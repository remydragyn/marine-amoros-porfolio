(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var app = require('./app/app');
var AppRouter = require('./app/routers/AppRouter');

app.appRouter = new AppRouter();
app.start();

},{"./app/app":19,"./app/routers/AppRouter":26}],2:[function(require,module,exports){
// MarionetteJS (Backbone.Marionette)
// ----------------------------------
// v2.4.2
//
// Copyright (c)2015 Derick Bailey, Muted Solutions, LLC.
// Distributed under MIT license
//
// http://marionettejs.com

(function(root, factory) {

  if (typeof define === 'function' && define.amd) {
    define(['backbone', 'underscore', 'backbone.wreqr', 'backbone.babysitter'], function(Backbone, _) {
      return (root.Marionette = root.Mn = factory(root, Backbone, _));
    });
  } else if (typeof exports !== 'undefined') {
    var Backbone = require('backbone');
    var _ = require('underscore');
    var Wreqr = require('backbone.wreqr');
    var BabySitter = require('backbone.babysitter');
    module.exports = factory(root, Backbone, _);
  } else {
    root.Marionette = root.Mn = factory(root, root.Backbone, root._);
  }

}(this, function(root, Backbone, _) {
  'use strict';

  var previousMarionette = root.Marionette;
  var previousMn = root.Mn;

  var Marionette = Backbone.Marionette = {};

  Marionette.VERSION = '2.4.2';

  Marionette.noConflict = function() {
    root.Marionette = previousMarionette;
    root.Mn = previousMn;
    return this;
  };

  // Get the Deferred creator for later use
  Marionette.Deferred = Backbone.$.Deferred;

  Marionette.FEATURES = {
  };
  
  Marionette.isEnabled = function(name) {
    return !!Marionette.FEATURES[name];
  };
  
  /* jshint unused: false *//* global console */
  
  // Helpers
  // -------
  
  // Marionette.extend
  // -----------------
  
  // Borrow the Backbone `extend` method so we can use it as needed
  Marionette.extend = Backbone.Model.extend;
  
  // Marionette.isNodeAttached
  // -------------------------
  
  // Determine if `el` is a child of the document
  Marionette.isNodeAttached = function(el) {
    return Backbone.$.contains(document.documentElement, el);
  };
  
  // Merge `keys` from `options` onto `this`
  Marionette.mergeOptions = function(options, keys) {
    if (!options) { return; }
    _.extend(this, _.pick(options, keys));
  };
  
  // Marionette.getOption
  // --------------------
  
  // Retrieve an object, function or other value from a target
  // object or its `options`, with `options` taking precedence.
  Marionette.getOption = function(target, optionName) {
    if (!target || !optionName) { return; }
    if (target.options && (target.options[optionName] !== undefined)) {
      return target.options[optionName];
    } else {
      return target[optionName];
    }
  };
  
  // Proxy `Marionette.getOption`
  Marionette.proxyGetOption = function(optionName) {
    return Marionette.getOption(this, optionName);
  };
  
  // Similar to `_.result`, this is a simple helper
  // If a function is provided we call it with context
  // otherwise just return the value. If the value is
  // undefined return a default value
  Marionette._getValue = function(value, context, params) {
    if (_.isFunction(value)) {
      value = params ? value.apply(context, params) : value.call(context);
    }
    return value;
  };
  
  // Marionette.normalizeMethods
  // ----------------------
  
  // Pass in a mapping of events => functions or function names
  // and return a mapping of events => functions
  Marionette.normalizeMethods = function(hash) {
    return _.reduce(hash, function(normalizedHash, method, name) {
      if (!_.isFunction(method)) {
        method = this[method];
      }
      if (method) {
        normalizedHash[name] = method;
      }
      return normalizedHash;
    }, {}, this);
  };
  
  // utility method for parsing @ui. syntax strings
  // into associated selector
  Marionette.normalizeUIString = function(uiString, ui) {
    return uiString.replace(/@ui\.[a-zA-Z_$0-9]*/g, function(r) {
      return ui[r.slice(4)];
    });
  };
  
  // allows for the use of the @ui. syntax within
  // a given key for triggers and events
  // swaps the @ui with the associated selector.
  // Returns a new, non-mutated, parsed events hash.
  Marionette.normalizeUIKeys = function(hash, ui) {
    return _.reduce(hash, function(memo, val, key) {
      var normalizedKey = Marionette.normalizeUIString(key, ui);
      memo[normalizedKey] = val;
      return memo;
    }, {});
  };
  
  // allows for the use of the @ui. syntax within
  // a given value for regions
  // swaps the @ui with the associated selector
  Marionette.normalizeUIValues = function(hash, ui, properties) {
    _.each(hash, function(val, key) {
      if (_.isString(val)) {
        hash[key] = Marionette.normalizeUIString(val, ui);
      } else if (_.isObject(val) && _.isArray(properties)) {
        _.extend(val, Marionette.normalizeUIValues(_.pick(val, properties), ui));
        /* Value is an object, and we got an array of embedded property names to normalize. */
        _.each(properties, function(property) {
          var propertyVal = val[property];
          if (_.isString(propertyVal)) {
            val[property] = Marionette.normalizeUIString(propertyVal, ui);
          }
        });
      }
    });
    return hash;
  };
  
  // Mix in methods from Underscore, for iteration, and other
  // collection related features.
  // Borrowing this code from Backbone.Collection:
  // http://backbonejs.org/docs/backbone.html#section-121
  Marionette.actAsCollection = function(object, listProperty) {
    var methods = ['forEach', 'each', 'map', 'find', 'detect', 'filter',
      'select', 'reject', 'every', 'all', 'some', 'any', 'include',
      'contains', 'invoke', 'toArray', 'first', 'initial', 'rest',
      'last', 'without', 'isEmpty', 'pluck'];
  
    _.each(methods, function(method) {
      object[method] = function() {
        var list = _.values(_.result(this, listProperty));
        var args = [list].concat(_.toArray(arguments));
        return _[method].apply(_, args);
      };
    });
  };
  
  var deprecate = Marionette.deprecate = function(message, test) {
    if (_.isObject(message)) {
      message = (
        message.prev + ' is going to be removed in the future. ' +
        'Please use ' + message.next + ' instead.' +
        (message.url ? ' See: ' + message.url : '')
      );
    }
  
    if ((test === undefined || !test) && !deprecate._cache[message]) {
      deprecate._warn('Deprecation warning: ' + message);
      deprecate._cache[message] = true;
    }
  };
  
  deprecate._warn = typeof console !== 'undefined' && (console.warn || console.log) || function() {};
  deprecate._cache = {};
  
  /* jshint maxstatements: 14, maxcomplexity: 7 */
  
  // Trigger Method
  // --------------
  
  Marionette._triggerMethod = (function() {
    // split the event name on the ":"
    var splitter = /(^|:)(\w)/gi;
  
    // take the event section ("section1:section2:section3")
    // and turn it in to uppercase name
    function getEventName(match, prefix, eventName) {
      return eventName.toUpperCase();
    }
  
    return function(context, event, args) {
      var noEventArg = arguments.length < 3;
      if (noEventArg) {
        args = event;
        event = args[0];
      }
  
      // get the method name from the event name
      var methodName = 'on' + event.replace(splitter, getEventName);
      var method = context[methodName];
      var result;
  
      // call the onMethodName if it exists
      if (_.isFunction(method)) {
        // pass all args, except the event name
        result = method.apply(context, noEventArg ? _.rest(args) : args);
      }
  
      // trigger the event, if a trigger method exists
      if (_.isFunction(context.trigger)) {
        if (noEventArg + args.length > 1) {
          context.trigger.apply(context, noEventArg ? args : [event].concat(_.drop(args, 0)));
        } else {
          context.trigger(event);
        }
      }
  
      return result;
    };
  })();
  
  // Trigger an event and/or a corresponding method name. Examples:
  //
  // `this.triggerMethod("foo")` will trigger the "foo" event and
  // call the "onFoo" method.
  //
  // `this.triggerMethod("foo:bar")` will trigger the "foo:bar" event and
  // call the "onFooBar" method.
  Marionette.triggerMethod = function(event) {
    return Marionette._triggerMethod(this, arguments);
  };
  
  // triggerMethodOn invokes triggerMethod on a specific context
  //
  // e.g. `Marionette.triggerMethodOn(view, 'show')`
  // will trigger a "show" event or invoke onShow the view.
  Marionette.triggerMethodOn = function(context) {
    var fnc = _.isFunction(context.triggerMethod) ?
                  context.triggerMethod :
                  Marionette.triggerMethod;
  
    return fnc.apply(context, _.rest(arguments));
  };
  
  // DOM Refresh
  // -----------
  
  // Monitor a view's state, and after it has been rendered and shown
  // in the DOM, trigger a "dom:refresh" event every time it is
  // re-rendered.
  
  Marionette.MonitorDOMRefresh = function(view) {
  
    // track when the view has been shown in the DOM,
    // using a Marionette.Region (or by other means of triggering "show")
    function handleShow() {
      view._isShown = true;
      triggerDOMRefresh();
    }
  
    // track when the view has been rendered
    function handleRender() {
      view._isRendered = true;
      triggerDOMRefresh();
    }
  
    // Trigger the "dom:refresh" event and corresponding "onDomRefresh" method
    function triggerDOMRefresh() {
      if (view._isShown && view._isRendered && Marionette.isNodeAttached(view.el)) {
        if (_.isFunction(view.triggerMethod)) {
          view.triggerMethod('dom:refresh');
        }
      }
    }
  
    view.on({
      show: handleShow,
      render: handleRender
    });
  };
  
  /* jshint maxparams: 5 */
  
  // Bind Entity Events & Unbind Entity Events
  // -----------------------------------------
  //
  // These methods are used to bind/unbind a backbone "entity" (e.g. collection/model)
  // to methods on a target object.
  //
  // The first parameter, `target`, must have the Backbone.Events module mixed in.
  //
  // The second parameter is the `entity` (Backbone.Model, Backbone.Collection or
  // any object that has Backbone.Events mixed in) to bind the events from.
  //
  // The third parameter is a hash of { "event:name": "eventHandler" }
  // configuration. Multiple handlers can be separated by a space. A
  // function can be supplied instead of a string handler name.
  
  (function(Marionette) {
    'use strict';
  
    // Bind the event to handlers specified as a string of
    // handler names on the target object
    function bindFromStrings(target, entity, evt, methods) {
      var methodNames = methods.split(/\s+/);
  
      _.each(methodNames, function(methodName) {
  
        var method = target[methodName];
        if (!method) {
          throw new Marionette.Error('Method "' + methodName +
            '" was configured as an event handler, but does not exist.');
        }
  
        target.listenTo(entity, evt, method);
      });
    }
  
    // Bind the event to a supplied callback function
    function bindToFunction(target, entity, evt, method) {
      target.listenTo(entity, evt, method);
    }
  
    // Bind the event to handlers specified as a string of
    // handler names on the target object
    function unbindFromStrings(target, entity, evt, methods) {
      var methodNames = methods.split(/\s+/);
  
      _.each(methodNames, function(methodName) {
        var method = target[methodName];
        target.stopListening(entity, evt, method);
      });
    }
  
    // Bind the event to a supplied callback function
    function unbindToFunction(target, entity, evt, method) {
      target.stopListening(entity, evt, method);
    }
  
    // generic looping function
    function iterateEvents(target, entity, bindings, functionCallback, stringCallback) {
      if (!entity || !bindings) { return; }
  
      // type-check bindings
      if (!_.isObject(bindings)) {
        throw new Marionette.Error({
          message: 'Bindings must be an object or function.',
          url: 'marionette.functions.html#marionettebindentityevents'
        });
      }
  
      // allow the bindings to be a function
      bindings = Marionette._getValue(bindings, target);
  
      // iterate the bindings and bind them
      _.each(bindings, function(methods, evt) {
  
        // allow for a function as the handler,
        // or a list of event names as a string
        if (_.isFunction(methods)) {
          functionCallback(target, entity, evt, methods);
        } else {
          stringCallback(target, entity, evt, methods);
        }
  
      });
    }
  
    // Export Public API
    Marionette.bindEntityEvents = function(target, entity, bindings) {
      iterateEvents(target, entity, bindings, bindToFunction, bindFromStrings);
    };
  
    Marionette.unbindEntityEvents = function(target, entity, bindings) {
      iterateEvents(target, entity, bindings, unbindToFunction, unbindFromStrings);
    };
  
    // Proxy `bindEntityEvents`
    Marionette.proxyBindEntityEvents = function(entity, bindings) {
      return Marionette.bindEntityEvents(this, entity, bindings);
    };
  
    // Proxy `unbindEntityEvents`
    Marionette.proxyUnbindEntityEvents = function(entity, bindings) {
      return Marionette.unbindEntityEvents(this, entity, bindings);
    };
  })(Marionette);
  

  // Error
  // -----
  
  var errorProps = ['description', 'fileName', 'lineNumber', 'name', 'message', 'number'];
  
  Marionette.Error = Marionette.extend.call(Error, {
    urlRoot: 'http://marionettejs.com/docs/v' + Marionette.VERSION + '/',
  
    constructor: function(message, options) {
      if (_.isObject(message)) {
        options = message;
        message = options.message;
      } else if (!options) {
        options = {};
      }
  
      var error = Error.call(this, message);
      _.extend(this, _.pick(error, errorProps), _.pick(options, errorProps));
  
      this.captureStackTrace();
  
      if (options.url) {
        this.url = this.urlRoot + options.url;
      }
    },
  
    captureStackTrace: function() {
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, Marionette.Error);
      }
    },
  
    toString: function() {
      return this.name + ': ' + this.message + (this.url ? ' See: ' + this.url : '');
    }
  });
  
  Marionette.Error.extend = Marionette.extend;
  
  // Callbacks
  // ---------
  
  // A simple way of managing a collection of callbacks
  // and executing them at a later point in time, using jQuery's
  // `Deferred` object.
  Marionette.Callbacks = function() {
    this._deferred = Marionette.Deferred();
    this._callbacks = [];
  };
  
  _.extend(Marionette.Callbacks.prototype, {
  
    // Add a callback to be executed. Callbacks added here are
    // guaranteed to execute, even if they are added after the
    // `run` method is called.
    add: function(callback, contextOverride) {
      var promise = _.result(this._deferred, 'promise');
  
      this._callbacks.push({cb: callback, ctx: contextOverride});
  
      promise.then(function(args) {
        if (contextOverride) { args.context = contextOverride; }
        callback.call(args.context, args.options);
      });
    },
  
    // Run all registered callbacks with the context specified.
    // Additional callbacks can be added after this has been run
    // and they will still be executed.
    run: function(options, context) {
      this._deferred.resolve({
        options: options,
        context: context
      });
    },
  
    // Resets the list of callbacks to be run, allowing the same list
    // to be run multiple times - whenever the `run` method is called.
    reset: function() {
      var callbacks = this._callbacks;
      this._deferred = Marionette.Deferred();
      this._callbacks = [];
  
      _.each(callbacks, function(cb) {
        this.add(cb.cb, cb.ctx);
      }, this);
    }
  });
  
  // Controller
  // ----------
  
  // A multi-purpose object to use as a controller for
  // modules and routers, and as a mediator for workflow
  // and coordination of other objects, views, and more.
  Marionette.Controller = function(options) {
    this.options = options || {};
  
    if (_.isFunction(this.initialize)) {
      this.initialize(this.options);
    }
  };
  
  Marionette.Controller.extend = Marionette.extend;
  
  // Controller Methods
  // --------------
  
  // Ensure it can trigger events with Backbone.Events
  _.extend(Marionette.Controller.prototype, Backbone.Events, {
    destroy: function() {
      Marionette._triggerMethod(this, 'before:destroy', arguments);
      Marionette._triggerMethod(this, 'destroy', arguments);
  
      this.stopListening();
      this.off();
      return this;
    },
  
    // import the `triggerMethod` to trigger events with corresponding
    // methods if the method exists
    triggerMethod: Marionette.triggerMethod,
  
    // A handy way to merge options onto the instance
    mergeOptions: Marionette.mergeOptions,
  
    // Proxy `getOption` to enable getting options from this or this.options by name.
    getOption: Marionette.proxyGetOption
  
  });
  
  // Object
  // ------
  
  // A Base Class that other Classes should descend from.
  // Object borrows many conventions and utilities from Backbone.
  Marionette.Object = function(options) {
    this.options = _.extend({}, _.result(this, 'options'), options);
  
    this.initialize.apply(this, arguments);
  };
  
  Marionette.Object.extend = Marionette.extend;
  
  // Object Methods
  // --------------
  
  // Ensure it can trigger events with Backbone.Events
  _.extend(Marionette.Object.prototype, Backbone.Events, {
  
    //this is a noop method intended to be overridden by classes that extend from this base
    initialize: function() {},
  
    destroy: function() {
      this.triggerMethod('before:destroy');
      this.triggerMethod('destroy');
      this.stopListening();
  
      return this;
    },
  
    // Import the `triggerMethod` to trigger events with corresponding
    // methods if the method exists
    triggerMethod: Marionette.triggerMethod,
  
    // A handy way to merge options onto the instance
    mergeOptions: Marionette.mergeOptions,
  
    // Proxy `getOption` to enable getting options from this or this.options by name.
    getOption: Marionette.proxyGetOption,
  
    // Proxy `bindEntityEvents` to enable binding view's events from another entity.
    bindEntityEvents: Marionette.proxyBindEntityEvents,
  
    // Proxy `unbindEntityEvents` to enable unbinding view's events from another entity.
    unbindEntityEvents: Marionette.proxyUnbindEntityEvents
  });
  
  /* jshint maxcomplexity: 16, maxstatements: 45, maxlen: 120 */
  
  // Region
  // ------
  
  // Manage the visual regions of your composite application. See
  // http://lostechies.com/derickbailey/2011/12/12/composite-js-apps-regions-and-region-managers/
  
  Marionette.Region = Marionette.Object.extend({
    constructor: function(options) {
  
      // set options temporarily so that we can get `el`.
      // options will be overriden by Object.constructor
      this.options = options || {};
      this.el = this.getOption('el');
  
      // Handle when this.el is passed in as a $ wrapped element.
      this.el = this.el instanceof Backbone.$ ? this.el[0] : this.el;
  
      if (!this.el) {
        throw new Marionette.Error({
          name: 'NoElError',
          message: 'An "el" must be specified for a region.'
        });
      }
  
      this.$el = this.getEl(this.el);
      Marionette.Object.call(this, options);
    },
  
    // Displays a backbone view instance inside of the region.
    // Handles calling the `render` method for you. Reads content
    // directly from the `el` attribute. Also calls an optional
    // `onShow` and `onDestroy` method on your view, just after showing
    // or just before destroying the view, respectively.
    // The `preventDestroy` option can be used to prevent a view from
    // the old view being destroyed on show.
    // The `forceShow` option can be used to force a view to be
    // re-rendered if it's already shown in the region.
    show: function(view, options) {
      if (!this._ensureElement()) {
        return;
      }
  
      this._ensureViewIsIntact(view);
  
      var showOptions     = options || {};
      var isDifferentView = view !== this.currentView;
      var preventDestroy  = !!showOptions.preventDestroy;
      var forceShow       = !!showOptions.forceShow;
  
      // We are only changing the view if there is a current view to change to begin with
      var isChangingView = !!this.currentView;
  
      // Only destroy the current view if we don't want to `preventDestroy` and if
      // the view given in the first argument is different than `currentView`
      var _shouldDestroyView = isDifferentView && !preventDestroy;
  
      // Only show the view given in the first argument if it is different than
      // the current view or if we want to re-show the view. Note that if
      // `_shouldDestroyView` is true, then `_shouldShowView` is also necessarily true.
      var _shouldShowView = isDifferentView || forceShow;
  
      if (isChangingView) {
        this.triggerMethod('before:swapOut', this.currentView, this, options);
      }
  
      if (this.currentView) {
        delete this.currentView._parent;
      }
  
      if (_shouldDestroyView) {
        this.empty();
  
      // A `destroy` event is attached to the clean up manually removed views.
      // We need to detach this event when a new view is going to be shown as it
      // is no longer relevant.
      } else if (isChangingView && _shouldShowView) {
        this.currentView.off('destroy', this.empty, this);
      }
  
      if (_shouldShowView) {
  
        // We need to listen for if a view is destroyed
        // in a way other than through the region.
        // If this happens we need to remove the reference
        // to the currentView since once a view has been destroyed
        // we can not reuse it.
        view.once('destroy', this.empty, this);
        view.render();
  
        view._parent = this;
  
        if (isChangingView) {
          this.triggerMethod('before:swap', view, this, options);
        }
  
        this.triggerMethod('before:show', view, this, options);
        Marionette.triggerMethodOn(view, 'before:show', view, this, options);
  
        if (isChangingView) {
          this.triggerMethod('swapOut', this.currentView, this, options);
        }
  
        // An array of views that we're about to display
        var attachedRegion = Marionette.isNodeAttached(this.el);
  
        // The views that we're about to attach to the document
        // It's important that we prevent _getNestedViews from being executed unnecessarily
        // as it's a potentially-slow method
        var displayedViews = [];
  
        var attachOptions = _.extend({
          triggerBeforeAttach: this.triggerBeforeAttach,
          triggerAttach: this.triggerAttach
        }, showOptions);
  
        if (attachedRegion && attachOptions.triggerBeforeAttach) {
          displayedViews = this._displayedViews(view);
          this._triggerAttach(displayedViews, 'before:');
        }
  
        this.attachHtml(view);
        this.currentView = view;
  
        if (attachedRegion && attachOptions.triggerAttach) {
          displayedViews = this._displayedViews(view);
          this._triggerAttach(displayedViews);
        }
  
        if (isChangingView) {
          this.triggerMethod('swap', view, this, options);
        }
  
        this.triggerMethod('show', view, this, options);
        Marionette.triggerMethodOn(view, 'show', view, this, options);
  
        return this;
      }
  
      return this;
    },
  
    triggerBeforeAttach: true,
    triggerAttach: true,
  
    _triggerAttach: function(views, prefix) {
      var eventName = (prefix || '') + 'attach';
      _.each(views, function(view) {
        Marionette.triggerMethodOn(view, eventName, view, this);
      }, this);
    },
  
    _displayedViews: function(view) {
      return _.union([view], _.result(view, '_getNestedViews') || []);
    },
  
    _ensureElement: function() {
      if (!_.isObject(this.el)) {
        this.$el = this.getEl(this.el);
        this.el = this.$el[0];
      }
  
      if (!this.$el || this.$el.length === 0) {
        if (this.getOption('allowMissingEl')) {
          return false;
        } else {
          throw new Marionette.Error('An "el" ' + this.$el.selector + ' must exist in DOM');
        }
      }
      return true;
    },
  
    _ensureViewIsIntact: function(view) {
      if (!view) {
        throw new Marionette.Error({
          name: 'ViewNotValid',
          message: 'The view passed is undefined and therefore invalid. You must pass a view instance to show.'
        });
      }
  
      if (view.isDestroyed) {
        throw new Marionette.Error({
          name: 'ViewDestroyedError',
          message: 'View (cid: "' + view.cid + '") has already been destroyed and cannot be used.'
        });
      }
    },
  
    // Override this method to change how the region finds the DOM
    // element that it manages. Return a jQuery selector object scoped
    // to a provided parent el or the document if none exists.
    getEl: function(el) {
      return Backbone.$(el, Marionette._getValue(this.options.parentEl, this));
    },
  
    // Override this method to change how the new view is
    // appended to the `$el` that the region is managing
    attachHtml: function(view) {
      this.$el.contents().detach();
  
      this.el.appendChild(view.el);
    },
  
    // Destroy the current view, if there is one. If there is no
    // current view, it does nothing and returns immediately.
    empty: function(options) {
      var view = this.currentView;
  
      var preventDestroy = Marionette._getValue(options, 'preventDestroy', this);
      // If there is no view in the region
      // we should not remove anything
      if (!view) { return; }
  
      view.off('destroy', this.empty, this);
      this.triggerMethod('before:empty', view);
      if (!preventDestroy) {
        this._destroyView();
      }
      this.triggerMethod('empty', view);
  
      // Remove region pointer to the currentView
      delete this.currentView;
  
      if (preventDestroy) {
        this.$el.contents().detach();
      }
  
      return this;
    },
  
    // call 'destroy' or 'remove', depending on which is found
    // on the view (if showing a raw Backbone view or a Marionette View)
    _destroyView: function() {
      var view = this.currentView;
  
      if (view.destroy && !view.isDestroyed) {
        view.destroy();
      } else if (view.remove) {
        view.remove();
  
        // appending isDestroyed to raw Backbone View allows regions
        // to throw a ViewDestroyedError for this view
        view.isDestroyed = true;
      }
    },
  
    // Attach an existing view to the region. This
    // will not call `render` or `onShow` for the new view,
    // and will not replace the current HTML for the `el`
    // of the region.
    attachView: function(view) {
      this.currentView = view;
      return this;
    },
  
    // Checks whether a view is currently present within
    // the region. Returns `true` if there is and `false` if
    // no view is present.
    hasView: function() {
      return !!this.currentView;
    },
  
    // Reset the region by destroying any existing view and
    // clearing out the cached `$el`. The next time a view
    // is shown via this region, the region will re-query the
    // DOM for the region's `el`.
    reset: function() {
      this.empty();
  
      if (this.$el) {
        this.el = this.$el.selector;
      }
  
      delete this.$el;
      return this;
    }
  
  },
  
  // Static Methods
  {
  
    // Build an instance of a region by passing in a configuration object
    // and a default region class to use if none is specified in the config.
    //
    // The config object should either be a string as a jQuery DOM selector,
    // a Region class directly, or an object literal that specifies a selector,
    // a custom regionClass, and any options to be supplied to the region:
    //
    // ```js
    // {
    //   selector: "#foo",
    //   regionClass: MyCustomRegion,
    //   allowMissingEl: false
    // }
    // ```
    //
    buildRegion: function(regionConfig, DefaultRegionClass) {
      if (_.isString(regionConfig)) {
        return this._buildRegionFromSelector(regionConfig, DefaultRegionClass);
      }
  
      if (regionConfig.selector || regionConfig.el || regionConfig.regionClass) {
        return this._buildRegionFromObject(regionConfig, DefaultRegionClass);
      }
  
      if (_.isFunction(regionConfig)) {
        return this._buildRegionFromRegionClass(regionConfig);
      }
  
      throw new Marionette.Error({
        message: 'Improper region configuration type.',
        url: 'marionette.region.html#region-configuration-types'
      });
    },
  
    // Build the region from a string selector like '#foo-region'
    _buildRegionFromSelector: function(selector, DefaultRegionClass) {
      return new DefaultRegionClass({el: selector});
    },
  
    // Build the region from a configuration object
    // ```js
    // { selector: '#foo', regionClass: FooRegion, allowMissingEl: false }
    // ```
    _buildRegionFromObject: function(regionConfig, DefaultRegionClass) {
      var RegionClass = regionConfig.regionClass || DefaultRegionClass;
      var options = _.omit(regionConfig, 'selector', 'regionClass');
  
      if (regionConfig.selector && !options.el) {
        options.el = regionConfig.selector;
      }
  
      return new RegionClass(options);
    },
  
    // Build the region directly from a given `RegionClass`
    _buildRegionFromRegionClass: function(RegionClass) {
      return new RegionClass();
    }
  });
  
  // Region Manager
  // --------------
  
  // Manage one or more related `Marionette.Region` objects.
  Marionette.RegionManager = Marionette.Controller.extend({
    constructor: function(options) {
      this._regions = {};
      this.length = 0;
  
      Marionette.Controller.call(this, options);
  
      this.addRegions(this.getOption('regions'));
    },
  
    // Add multiple regions using an object literal or a
    // function that returns an object literal, where
    // each key becomes the region name, and each value is
    // the region definition.
    addRegions: function(regionDefinitions, defaults) {
      regionDefinitions = Marionette._getValue(regionDefinitions, this, arguments);
  
      return _.reduce(regionDefinitions, function(regions, definition, name) {
        if (_.isString(definition)) {
          definition = {selector: definition};
        }
        if (definition.selector) {
          definition = _.defaults({}, definition, defaults);
        }
  
        regions[name] = this.addRegion(name, definition);
        return regions;
      }, {}, this);
    },
  
    // Add an individual region to the region manager,
    // and return the region instance
    addRegion: function(name, definition) {
      var region;
  
      if (definition instanceof Marionette.Region) {
        region = definition;
      } else {
        region = Marionette.Region.buildRegion(definition, Marionette.Region);
      }
  
      this.triggerMethod('before:add:region', name, region);
  
      region._parent = this;
      this._store(name, region);
  
      this.triggerMethod('add:region', name, region);
      return region;
    },
  
    // Get a region by name
    get: function(name) {
      return this._regions[name];
    },
  
    // Gets all the regions contained within
    // the `regionManager` instance.
    getRegions: function() {
      return _.clone(this._regions);
    },
  
    // Remove a region by name
    removeRegion: function(name) {
      var region = this._regions[name];
      this._remove(name, region);
  
      return region;
    },
  
    // Empty all regions in the region manager, and
    // remove them
    removeRegions: function() {
      var regions = this.getRegions();
      _.each(this._regions, function(region, name) {
        this._remove(name, region);
      }, this);
  
      return regions;
    },
  
    // Empty all regions in the region manager, but
    // leave them attached
    emptyRegions: function() {
      var regions = this.getRegions();
      _.invoke(regions, 'empty');
      return regions;
    },
  
    // Destroy all regions and shut down the region
    // manager entirely
    destroy: function() {
      this.removeRegions();
      return Marionette.Controller.prototype.destroy.apply(this, arguments);
    },
  
    // internal method to store regions
    _store: function(name, region) {
      if (!this._regions[name]) {
        this.length++;
      }
  
      this._regions[name] = region;
    },
  
    // internal method to remove a region
    _remove: function(name, region) {
      this.triggerMethod('before:remove:region', name, region);
      region.empty();
      region.stopListening();
  
      delete region._parent;
      delete this._regions[name];
      this.length--;
      this.triggerMethod('remove:region', name, region);
    }
  });
  
  Marionette.actAsCollection(Marionette.RegionManager.prototype, '_regions');
  

  // Template Cache
  // --------------
  
  // Manage templates stored in `<script>` blocks,
  // caching them for faster access.
  Marionette.TemplateCache = function(templateId) {
    this.templateId = templateId;
  };
  
  // TemplateCache object-level methods. Manage the template
  // caches from these method calls instead of creating
  // your own TemplateCache instances
  _.extend(Marionette.TemplateCache, {
    templateCaches: {},
  
    // Get the specified template by id. Either
    // retrieves the cached version, or loads it
    // from the DOM.
    get: function(templateId, options) {
      var cachedTemplate = this.templateCaches[templateId];
  
      if (!cachedTemplate) {
        cachedTemplate = new Marionette.TemplateCache(templateId);
        this.templateCaches[templateId] = cachedTemplate;
      }
  
      return cachedTemplate.load(options);
    },
  
    // Clear templates from the cache. If no arguments
    // are specified, clears all templates:
    // `clear()`
    //
    // If arguments are specified, clears each of the
    // specified templates from the cache:
    // `clear("#t1", "#t2", "...")`
    clear: function() {
      var i;
      var args = _.toArray(arguments);
      var length = args.length;
  
      if (length > 0) {
        for (i = 0; i < length; i++) {
          delete this.templateCaches[args[i]];
        }
      } else {
        this.templateCaches = {};
      }
    }
  });
  
  // TemplateCache instance methods, allowing each
  // template cache object to manage its own state
  // and know whether or not it has been loaded
  _.extend(Marionette.TemplateCache.prototype, {
  
    // Internal method to load the template
    load: function(options) {
      // Guard clause to prevent loading this template more than once
      if (this.compiledTemplate) {
        return this.compiledTemplate;
      }
  
      // Load the template and compile it
      var template = this.loadTemplate(this.templateId, options);
      this.compiledTemplate = this.compileTemplate(template, options);
  
      return this.compiledTemplate;
    },
  
    // Load a template from the DOM, by default. Override
    // this method to provide your own template retrieval
    // For asynchronous loading with AMD/RequireJS, consider
    // using a template-loader plugin as described here:
    // https://github.com/marionettejs/backbone.marionette/wiki/Using-marionette-with-requirejs
    loadTemplate: function(templateId, options) {
      var template = Backbone.$(templateId).html();
  
      if (!template || template.length === 0) {
        throw new Marionette.Error({
          name: 'NoTemplateError',
          message: 'Could not find template: "' + templateId + '"'
        });
      }
  
      return template;
    },
  
    // Pre-compile the template before caching it. Override
    // this method if you do not need to pre-compile a template
    // (JST / RequireJS for example) or if you want to change
    // the template engine used (Handebars, etc).
    compileTemplate: function(rawTemplate, options) {
      return _.template(rawTemplate, options);
    }
  });
  
  // Renderer
  // --------
  
  // Render a template with data by passing in the template
  // selector and the data to render.
  Marionette.Renderer = {
  
    // Render a template with data. The `template` parameter is
    // passed to the `TemplateCache` object to retrieve the
    // template function. Override this method to provide your own
    // custom rendering and template handling for all of Marionette.
    render: function(template, data) {
      if (!template) {
        throw new Marionette.Error({
          name: 'TemplateNotFoundError',
          message: 'Cannot render the template since its false, null or undefined.'
        });
      }
  
      var templateFunc = _.isFunction(template) ? template : Marionette.TemplateCache.get(template);
  
      return templateFunc(data);
    }
  };
  

  /* jshint maxlen: 114, nonew: false */
  // View
  // ----
  
  // The core view class that other Marionette views extend from.
  Marionette.View = Backbone.View.extend({
    isDestroyed: false,
  
    constructor: function(options) {
      _.bindAll(this, 'render');
  
      options = Marionette._getValue(options, this);
  
      // this exposes view options to the view initializer
      // this is a backfill since backbone removed the assignment
      // of this.options
      // at some point however this may be removed
      this.options = _.extend({}, _.result(this, 'options'), options);
  
      this._behaviors = Marionette.Behaviors(this);
  
      Backbone.View.call(this, this.options);
  
      Marionette.MonitorDOMRefresh(this);
    },
  
    // Get the template for this view
    // instance. You can set a `template` attribute in the view
    // definition or pass a `template: "whatever"` parameter in
    // to the constructor options.
    getTemplate: function() {
      return this.getOption('template');
    },
  
    // Serialize a model by returning its attributes. Clones
    // the attributes to allow modification.
    serializeModel: function(model) {
      return model.toJSON.apply(model, _.rest(arguments));
    },
  
    // Mix in template helper methods. Looks for a
    // `templateHelpers` attribute, which can either be an
    // object literal, or a function that returns an object
    // literal. All methods and attributes from this object
    // are copies to the object passed in.
    mixinTemplateHelpers: function(target) {
      target = target || {};
      var templateHelpers = this.getOption('templateHelpers');
      templateHelpers = Marionette._getValue(templateHelpers, this);
      return _.extend(target, templateHelpers);
    },
  
    // normalize the keys of passed hash with the views `ui` selectors.
    // `{"@ui.foo": "bar"}`
    normalizeUIKeys: function(hash) {
      var uiBindings = _.result(this, '_uiBindings');
      return Marionette.normalizeUIKeys(hash, uiBindings || _.result(this, 'ui'));
    },
  
    // normalize the values of passed hash with the views `ui` selectors.
    // `{foo: "@ui.bar"}`
    normalizeUIValues: function(hash, properties) {
      var ui = _.result(this, 'ui');
      var uiBindings = _.result(this, '_uiBindings');
      return Marionette.normalizeUIValues(hash, uiBindings || ui, properties);
    },
  
    // Configure `triggers` to forward DOM events to view
    // events. `triggers: {"click .foo": "do:foo"}`
    configureTriggers: function() {
      if (!this.triggers) { return; }
  
      // Allow `triggers` to be configured as a function
      var triggers = this.normalizeUIKeys(_.result(this, 'triggers'));
  
      // Configure the triggers, prevent default
      // action and stop propagation of DOM events
      return _.reduce(triggers, function(events, value, key) {
        events[key] = this._buildViewTrigger(value);
        return events;
      }, {}, this);
    },
  
    // Overriding Backbone.View's delegateEvents to handle
    // the `triggers`, `modelEvents`, and `collectionEvents` configuration
    delegateEvents: function(events) {
      this._delegateDOMEvents(events);
      this.bindEntityEvents(this.model, this.getOption('modelEvents'));
      this.bindEntityEvents(this.collection, this.getOption('collectionEvents'));
  
      _.each(this._behaviors, function(behavior) {
        behavior.bindEntityEvents(this.model, behavior.getOption('modelEvents'));
        behavior.bindEntityEvents(this.collection, behavior.getOption('collectionEvents'));
      }, this);
  
      return this;
    },
  
    // internal method to delegate DOM events and triggers
    _delegateDOMEvents: function(eventsArg) {
      var events = Marionette._getValue(eventsArg || this.events, this);
  
      // normalize ui keys
      events = this.normalizeUIKeys(events);
      if (_.isUndefined(eventsArg)) {this.events = events;}
  
      var combinedEvents = {};
  
      // look up if this view has behavior events
      var behaviorEvents = _.result(this, 'behaviorEvents') || {};
      var triggers = this.configureTriggers();
      var behaviorTriggers = _.result(this, 'behaviorTriggers') || {};
  
      // behavior events will be overriden by view events and or triggers
      _.extend(combinedEvents, behaviorEvents, events, triggers, behaviorTriggers);
  
      Backbone.View.prototype.delegateEvents.call(this, combinedEvents);
    },
  
    // Overriding Backbone.View's undelegateEvents to handle unbinding
    // the `triggers`, `modelEvents`, and `collectionEvents` config
    undelegateEvents: function() {
      Backbone.View.prototype.undelegateEvents.apply(this, arguments);
  
      this.unbindEntityEvents(this.model, this.getOption('modelEvents'));
      this.unbindEntityEvents(this.collection, this.getOption('collectionEvents'));
  
      _.each(this._behaviors, function(behavior) {
        behavior.unbindEntityEvents(this.model, behavior.getOption('modelEvents'));
        behavior.unbindEntityEvents(this.collection, behavior.getOption('collectionEvents'));
      }, this);
  
      return this;
    },
  
    // Internal helper method to verify whether the view hasn't been destroyed
    _ensureViewIsIntact: function() {
      if (this.isDestroyed) {
        throw new Marionette.Error({
          name: 'ViewDestroyedError',
          message: 'View (cid: "' + this.cid + '") has already been destroyed and cannot be used.'
        });
      }
    },
  
    // Default `destroy` implementation, for removing a view from the
    // DOM and unbinding it. Regions will call this method
    // for you. You can specify an `onDestroy` method in your view to
    // add custom code that is called after the view is destroyed.
    destroy: function() {
      if (this.isDestroyed) { return this; }
  
      var args = _.toArray(arguments);
  
      this.triggerMethod.apply(this, ['before:destroy'].concat(args));
  
      // mark as destroyed before doing the actual destroy, to
      // prevent infinite loops within "destroy" event handlers
      // that are trying to destroy other views
      this.isDestroyed = true;
      this.triggerMethod.apply(this, ['destroy'].concat(args));
  
      // unbind UI elements
      this.unbindUIElements();
  
      this.isRendered = false;
  
      // remove the view from the DOM
      this.remove();
  
      // Call destroy on each behavior after
      // destroying the view.
      // This unbinds event listeners
      // that behaviors have registered for.
      _.invoke(this._behaviors, 'destroy', args);
  
      return this;
    },
  
    bindUIElements: function() {
      this._bindUIElements();
      _.invoke(this._behaviors, this._bindUIElements);
    },
  
    // This method binds the elements specified in the "ui" hash inside the view's code with
    // the associated jQuery selectors.
    _bindUIElements: function() {
      if (!this.ui) { return; }
  
      // store the ui hash in _uiBindings so they can be reset later
      // and so re-rendering the view will be able to find the bindings
      if (!this._uiBindings) {
        this._uiBindings = this.ui;
      }
  
      // get the bindings result, as a function or otherwise
      var bindings = _.result(this, '_uiBindings');
  
      // empty the ui so we don't have anything to start with
      this.ui = {};
  
      // bind each of the selectors
      _.each(bindings, function(selector, key) {
        this.ui[key] = this.$(selector);
      }, this);
    },
  
    // This method unbinds the elements specified in the "ui" hash
    unbindUIElements: function() {
      this._unbindUIElements();
      _.invoke(this._behaviors, this._unbindUIElements);
    },
  
    _unbindUIElements: function() {
      if (!this.ui || !this._uiBindings) { return; }
  
      // delete all of the existing ui bindings
      _.each(this.ui, function($el, name) {
        delete this.ui[name];
      }, this);
  
      // reset the ui element to the original bindings configuration
      this.ui = this._uiBindings;
      delete this._uiBindings;
    },
  
    // Internal method to create an event handler for a given `triggerDef` like
    // 'click:foo'
    _buildViewTrigger: function(triggerDef) {
      var hasOptions = _.isObject(triggerDef);
  
      var options = _.defaults({}, (hasOptions ? triggerDef : {}), {
        preventDefault: true,
        stopPropagation: true
      });
  
      var eventName = hasOptions ? options.event : triggerDef;
  
      return function(e) {
        if (e) {
          if (e.preventDefault && options.preventDefault) {
            e.preventDefault();
          }
  
          if (e.stopPropagation && options.stopPropagation) {
            e.stopPropagation();
          }
        }
  
        var args = {
          view: this,
          model: this.model,
          collection: this.collection
        };
  
        this.triggerMethod(eventName, args);
      };
    },
  
    setElement: function() {
      var ret = Backbone.View.prototype.setElement.apply(this, arguments);
  
      // proxy behavior $el to the view's $el.
      // This is needed because a view's $el proxy
      // is not set until after setElement is called.
      _.invoke(this._behaviors, 'proxyViewProperties', this);
  
      return ret;
    },
  
    // import the `triggerMethod` to trigger events with corresponding
    // methods if the method exists
    triggerMethod: function() {
      var ret = Marionette._triggerMethod(this, arguments);
  
      this._triggerEventOnBehaviors(arguments);
      this._triggerEventOnParentLayout(arguments[0], _.rest(arguments));
  
      return ret;
    },
  
    _triggerEventOnBehaviors: function(args) {
      var triggerMethod = Marionette._triggerMethod;
      var behaviors = this._behaviors;
      // Use good ol' for as this is a very hot function
      for (var i = 0, length = behaviors && behaviors.length; i < length; i++) {
        triggerMethod(behaviors[i], args);
      }
    },
  
    _triggerEventOnParentLayout: function(eventName, args) {
      var layoutView = this._parentLayoutView();
      if (!layoutView) {
        return;
      }
  
      // invoke triggerMethod on parent view
      var eventPrefix = Marionette.getOption(layoutView, 'childViewEventPrefix');
      var prefixedEventName = eventPrefix + ':' + eventName;
  
      Marionette._triggerMethod(layoutView, [prefixedEventName, this].concat(args));
  
      // call the parent view's childEvents handler
      var childEvents = Marionette.getOption(layoutView, 'childEvents');
      var normalizedChildEvents = layoutView.normalizeMethods(childEvents);
  
      if (!!normalizedChildEvents && _.isFunction(normalizedChildEvents[eventName])) {
        normalizedChildEvents[eventName].apply(layoutView, [this].concat(args));
      }
    },
  
    // This method returns any views that are immediate
    // children of this view
    _getImmediateChildren: function() {
      return [];
    },
  
    // Returns an array of every nested view within this view
    _getNestedViews: function() {
      var children = this._getImmediateChildren();
  
      if (!children.length) { return children; }
  
      return _.reduce(children, function(memo, view) {
        if (!view._getNestedViews) { return memo; }
        return memo.concat(view._getNestedViews());
      }, children);
    },
  
    // Internal utility for building an ancestor
    // view tree list.
    _getAncestors: function() {
      var ancestors = [];
      var parent  = this._parent;
  
      while (parent) {
        ancestors.push(parent);
        parent = parent._parent;
      }
  
      return ancestors;
    },
  
    // Returns the containing parent view.
    _parentLayoutView: function() {
      var ancestors = this._getAncestors();
      return _.find(ancestors, function(parent) {
        return parent instanceof Marionette.LayoutView;
      });
    },
  
    // Imports the "normalizeMethods" to transform hashes of
    // events=>function references/names to a hash of events=>function references
    normalizeMethods: Marionette.normalizeMethods,
  
    // A handy way to merge passed-in options onto the instance
    mergeOptions: Marionette.mergeOptions,
  
    // Proxy `getOption` to enable getting options from this or this.options by name.
    getOption: Marionette.proxyGetOption,
  
    // Proxy `bindEntityEvents` to enable binding view's events from another entity.
    bindEntityEvents: Marionette.proxyBindEntityEvents,
  
    // Proxy `unbindEntityEvents` to enable unbinding view's events from another entity.
    unbindEntityEvents: Marionette.proxyUnbindEntityEvents
  });
  
  // Item View
  // ---------
  
  // A single item view implementation that contains code for rendering
  // with underscore.js templates, serializing the view's model or collection,
  // and calling several methods on extended views, such as `onRender`.
  Marionette.ItemView = Marionette.View.extend({
  
    // Setting up the inheritance chain which allows changes to
    // Marionette.View.prototype.constructor which allows overriding
    constructor: function() {
      Marionette.View.apply(this, arguments);
    },
  
    // Serialize the model or collection for the view. If a model is
    // found, the view's `serializeModel` is called. If a collection is found,
    // each model in the collection is serialized by calling
    // the view's `serializeCollection` and put into an `items` array in
    // the resulting data. If both are found, defaults to the model.
    // You can override the `serializeData` method in your own view definition,
    // to provide custom serialization for your view's data.
    serializeData: function() {
      if (!this.model && !this.collection) {
        return {};
      }
  
      var args = [this.model || this.collection];
      if (arguments.length) {
        args.push.apply(args, arguments);
      }
  
      if (this.model) {
        return this.serializeModel.apply(this, args);
      } else {
        return {
          items: this.serializeCollection.apply(this, args)
        };
      }
    },
  
    // Serialize a collection by serializing each of its models.
    serializeCollection: function(collection) {
      return collection.toJSON.apply(collection, _.rest(arguments));
    },
  
    // Render the view, defaulting to underscore.js templates.
    // You can override this in your view definition to provide
    // a very specific rendering for your view. In general, though,
    // you should override the `Marionette.Renderer` object to
    // change how Marionette renders views.
    render: function() {
      this._ensureViewIsIntact();
  
      this.triggerMethod('before:render', this);
  
      this._renderTemplate();
      this.isRendered = true;
      this.bindUIElements();
  
      this.triggerMethod('render', this);
  
      return this;
    },
  
    // Internal method to render the template with the serialized data
    // and template helpers via the `Marionette.Renderer` object.
    // Throws an `UndefinedTemplateError` error if the template is
    // any falsely value but literal `false`.
    _renderTemplate: function() {
      var template = this.getTemplate();
  
      // Allow template-less item views
      if (template === false) {
        return;
      }
  
      if (!template) {
        throw new Marionette.Error({
          name: 'UndefinedTemplateError',
          message: 'Cannot render the template since it is null or undefined.'
        });
      }
  
      // Add in entity data and template helpers
      var data = this.mixinTemplateHelpers(this.serializeData());
  
      // Render and add to el
      var html = Marionette.Renderer.render(template, data, this);
      this.attachElContent(html);
  
      return this;
    },
  
    // Attaches the content of a given view.
    // This method can be overridden to optimize rendering,
    // or to render in a non standard way.
    //
    // For example, using `innerHTML` instead of `$el.html`
    //
    // ```js
    // attachElContent: function(html) {
    //   this.el.innerHTML = html;
    //   return this;
    // }
    // ```
    attachElContent: function(html) {
      this.$el.html(html);
  
      return this;
    }
  });
  
  /* jshint maxstatements: 20, maxcomplexity: 7 */
  
  // Collection View
  // ---------------
  
  // A view that iterates over a Backbone.Collection
  // and renders an individual child view for each model.
  Marionette.CollectionView = Marionette.View.extend({
  
    // used as the prefix for child view events
    // that are forwarded through the collectionview
    childViewEventPrefix: 'childview',
  
    // flag for maintaining the sorted order of the collection
    sort: true,
  
    // constructor
    // option to pass `{sort: false}` to prevent the `CollectionView` from
    // maintaining the sorted order of the collection.
    // This will fallback onto appending childView's to the end.
    //
    // option to pass `{comparator: compFunction()}` to allow the `CollectionView`
    // to use a custom sort order for the collection.
    constructor: function(options) {
      this.once('render', this._initialEvents);
      this._initChildViewStorage();
  
      Marionette.View.apply(this, arguments);
  
      this.on({
        'before:show':   this._onBeforeShowCalled,
        'show':          this._onShowCalled,
        'before:attach': this._onBeforeAttachCalled,
        'attach':        this._onAttachCalled
      });
      this.initRenderBuffer();
    },
  
    // Instead of inserting elements one by one into the page,
    // it's much more performant to insert elements into a document
    // fragment and then insert that document fragment into the page
    initRenderBuffer: function() {
      this._bufferedChildren = [];
    },
  
    startBuffering: function() {
      this.initRenderBuffer();
      this.isBuffering = true;
    },
  
    endBuffering: function() {
      // Only trigger attach if already shown and attached, otherwise Region#show() handles this.
      var canTriggerAttach = this._isShown && Marionette.isNodeAttached(this.el);
      var nestedViews;
  
      this.isBuffering = false;
  
      if (this._isShown) {
        this._triggerMethodMany(this._bufferedChildren, this, 'before:show');
      }
      if (canTriggerAttach && this._triggerBeforeAttach) {
        nestedViews = this._getNestedViews();
        this._triggerMethodMany(nestedViews, this, 'before:attach');
      }
  
      this.attachBuffer(this, this._createBuffer());
  
      if (canTriggerAttach && this._triggerAttach) {
        nestedViews = this._getNestedViews();
        this._triggerMethodMany(nestedViews, this, 'attach');
      }
      if (this._isShown) {
        this._triggerMethodMany(this._bufferedChildren, this, 'show');
      }
      this.initRenderBuffer();
    },
  
    _triggerMethodMany: function(targets, source, eventName) {
      var args = _.drop(arguments, 3);
  
      _.each(targets, function(target) {
        Marionette.triggerMethodOn.apply(target, [target, eventName, target, source].concat(args));
      });
    },
  
    // Configured the initial events that the collection view
    // binds to.
    _initialEvents: function() {
      if (this.collection) {
        this.listenTo(this.collection, 'add', this._onCollectionAdd);
        this.listenTo(this.collection, 'remove', this._onCollectionRemove);
        this.listenTo(this.collection, 'reset', this.render);
  
        if (this.getOption('sort')) {
          this.listenTo(this.collection, 'sort', this._sortViews);
        }
      }
    },
  
    // Handle a child added to the collection
    _onCollectionAdd: function(child, collection, opts) {
      var index;
      if (opts.at !== undefined) {
        index = opts.at;
      } else {
        index = _.indexOf(this._filteredSortedModels(), child);
      }
  
      if (this._shouldAddChild(child, index)) {
        this.destroyEmptyView();
        var ChildView = this.getChildView(child);
        this.addChild(child, ChildView, index);
      }
    },
  
    // get the child view by model it holds, and remove it
    _onCollectionRemove: function(model) {
      var view = this.children.findByModel(model);
      this.removeChildView(view);
      this.checkEmpty();
    },
  
    _onBeforeShowCalled: function() {
      // Reset attach event flags at the top of the Region#show() event lifecycle; if the Region's
      // show() options permit onBeforeAttach/onAttach events, these flags will be set true again.
      this._triggerBeforeAttach = this._triggerAttach = false;
      this.children.each(function(childView) {
        Marionette.triggerMethodOn(childView, 'before:show', childView);
      });
    },
  
    _onShowCalled: function() {
      this.children.each(function(childView) {
        Marionette.triggerMethodOn(childView, 'show', childView);
      });
    },
  
    // If during Region#show() onBeforeAttach was fired, continue firing it for child views
    _onBeforeAttachCalled: function() {
      this._triggerBeforeAttach = true;
    },
  
    // If during Region#show() onAttach was fired, continue firing it for child views
    _onAttachCalled: function() {
      this._triggerAttach = true;
    },
  
    // Render children views. Override this method to
    // provide your own implementation of a render function for
    // the collection view.
    render: function() {
      this._ensureViewIsIntact();
      this.triggerMethod('before:render', this);
      this._renderChildren();
      this.isRendered = true;
      this.triggerMethod('render', this);
      return this;
    },
  
    // Reorder DOM after sorting. When your element's rendering
    // do not use their index, you can pass reorderOnSort: true
    // to only reorder the DOM after a sort instead of rendering
    // all the collectionView
    reorder: function() {
      var children = this.children;
      var models = this._filteredSortedModels();
      var modelsChanged = _.find(models, function(model) {
        return !children.findByModel(model);
      });
  
      // If the models we're displaying have changed due to filtering
      // We need to add and/or remove child views
      // So render as normal
      if (modelsChanged) {
        this.render();
      } else {
        // get the DOM nodes in the same order as the models
        var els = _.map(models, function(model, index) {
          var view = children.findByModel(model);
          view._index = index;
          return view.el;
        });
  
        // since append moves elements that are already in the DOM,
        // appending the elements will effectively reorder them
        this.triggerMethod('before:reorder');
        this._appendReorderedChildren(els);
        this.triggerMethod('reorder');
      }
    },
  
    // Render view after sorting. Override this method to
    // change how the view renders after a `sort` on the collection.
    // An example of this would be to only `renderChildren` in a `CompositeView`
    // rather than the full view.
    resortView: function() {
      if (Marionette.getOption(this, 'reorderOnSort')) {
        this.reorder();
      } else {
        this.render();
      }
    },
  
    // Internal method. This checks for any changes in the order of the collection.
    // If the index of any view doesn't match, it will render.
    _sortViews: function() {
      var models = this._filteredSortedModels();
  
      // check for any changes in sort order of views
      var orderChanged = _.find(models, function(item, index) {
        var view = this.children.findByModel(item);
        return !view || view._index !== index;
      }, this);
  
      if (orderChanged) {
        this.resortView();
      }
    },
  
    // Internal reference to what index a `emptyView` is.
    _emptyViewIndex: -1,
  
    // Internal method. Separated so that CompositeView can append to the childViewContainer
    // if necessary
    _appendReorderedChildren: function(children) {
      this.$el.append(children);
    },
  
    // Internal method. Separated so that CompositeView can have
    // more control over events being triggered, around the rendering
    // process
    _renderChildren: function() {
      this.destroyEmptyView();
      this.destroyChildren({checkEmpty: false});
  
      if (this.isEmpty(this.collection)) {
        this.showEmptyView();
      } else {
        this.triggerMethod('before:render:collection', this);
        this.startBuffering();
        this.showCollection();
        this.endBuffering();
        this.triggerMethod('render:collection', this);
  
        // If we have shown children and none have passed the filter, show the empty view
        if (this.children.isEmpty()) {
          this.showEmptyView();
        }
      }
    },
  
    // Internal method to loop through collection and show each child view.
    showCollection: function() {
      var ChildView;
  
      var models = this._filteredSortedModels();
  
      _.each(models, function(child, index) {
        ChildView = this.getChildView(child);
        this.addChild(child, ChildView, index);
      }, this);
    },
  
    // Allow the collection to be sorted by a custom view comparator
    _filteredSortedModels: function() {
      var models;
      var viewComparator = this.getViewComparator();
  
      if (viewComparator) {
        if (_.isString(viewComparator) || viewComparator.length === 1) {
          models = this.collection.sortBy(viewComparator, this);
        } else {
          models = _.clone(this.collection.models).sort(_.bind(viewComparator, this));
        }
      } else {
        models = this.collection.models;
      }
  
      // Filter after sorting in case the filter uses the index
      if (this.getOption('filter')) {
        models = _.filter(models, function(model, index) {
          return this._shouldAddChild(model, index);
        }, this);
      }
  
      return models;
    },
  
    // Internal method to show an empty view in place of
    // a collection of child views, when the collection is empty
    showEmptyView: function() {
      var EmptyView = this.getEmptyView();
  
      if (EmptyView && !this._showingEmptyView) {
        this.triggerMethod('before:render:empty');
  
        this._showingEmptyView = true;
        var model = new Backbone.Model();
        this.addEmptyView(model, EmptyView);
  
        this.triggerMethod('render:empty');
      }
    },
  
    // Internal method to destroy an existing emptyView instance
    // if one exists. Called when a collection view has been
    // rendered empty, and then a child is added to the collection.
    destroyEmptyView: function() {
      if (this._showingEmptyView) {
        this.triggerMethod('before:remove:empty');
  
        this.destroyChildren();
        delete this._showingEmptyView;
  
        this.triggerMethod('remove:empty');
      }
    },
  
    // Retrieve the empty view class
    getEmptyView: function() {
      return this.getOption('emptyView');
    },
  
    // Render and show the emptyView. Similar to addChild method
    // but "add:child" events are not fired, and the event from
    // emptyView are not forwarded
    addEmptyView: function(child, EmptyView) {
      // Only trigger attach if already shown, attached, and not buffering, otherwise endBuffer() or
      // Region#show() handles this.
      var canTriggerAttach = this._isShown && !this.isBuffering && Marionette.isNodeAttached(this.el);
      var nestedViews;
  
      // get the emptyViewOptions, falling back to childViewOptions
      var emptyViewOptions = this.getOption('emptyViewOptions') ||
                            this.getOption('childViewOptions');
  
      if (_.isFunction(emptyViewOptions)) {
        emptyViewOptions = emptyViewOptions.call(this, child, this._emptyViewIndex);
      }
  
      // build the empty view
      var view = this.buildChildView(child, EmptyView, emptyViewOptions);
  
      view._parent = this;
  
      // Proxy emptyView events
      this.proxyChildEvents(view);
  
      // trigger the 'before:show' event on `view` if the collection view has already been shown
      if (this._isShown) {
        Marionette.triggerMethodOn(view, 'before:show', view);
      }
  
      // Store the `emptyView` like a `childView` so we can properly
      // remove and/or close it later
      this.children.add(view);
  
      // Trigger `before:attach` following `render` to avoid adding logic and event triggers
      // to public method `renderChildView()`.
      if (canTriggerAttach && this._triggerBeforeAttach) {
        nestedViews = [view].concat(view._getNestedViews());
        view.once('render', function() {
          this._triggerMethodMany(nestedViews, this, 'before:attach');
        }, this);
      }
  
      // Render it and show it
      this.renderChildView(view, this._emptyViewIndex);
  
      // Trigger `attach`
      if (canTriggerAttach && this._triggerAttach) {
        nestedViews = [view].concat(view._getNestedViews());
        this._triggerMethodMany(nestedViews, this, 'attach');
      }
      // call the 'show' method if the collection view has already been shown
      if (this._isShown) {
        Marionette.triggerMethodOn(view, 'show', view);
      }
    },
  
    // Retrieve the `childView` class, either from `this.options.childView`
    // or from the `childView` in the object definition. The "options"
    // takes precedence.
    // This method receives the model that will be passed to the instance
    // created from this `childView`. Overriding methods may use the child
    // to determine what `childView` class to return.
    getChildView: function(child) {
      var childView = this.getOption('childView');
  
      if (!childView) {
        throw new Marionette.Error({
          name: 'NoChildViewError',
          message: 'A "childView" must be specified'
        });
      }
  
      return childView;
    },
  
    // Render the child's view and add it to the
    // HTML for the collection view at a given index.
    // This will also update the indices of later views in the collection
    // in order to keep the children in sync with the collection.
    addChild: function(child, ChildView, index) {
      var childViewOptions = this.getOption('childViewOptions');
      childViewOptions = Marionette._getValue(childViewOptions, this, [child, index]);
  
      var view = this.buildChildView(child, ChildView, childViewOptions);
  
      // increment indices of views after this one
      this._updateIndices(view, true, index);
  
      this.triggerMethod('before:add:child', view);
      this._addChildView(view, index);
      this.triggerMethod('add:child', view);
  
      view._parent = this;
  
      return view;
    },
  
    // Internal method. This decrements or increments the indices of views after the
    // added/removed view to keep in sync with the collection.
    _updateIndices: function(view, increment, index) {
      if (!this.getOption('sort')) {
        return;
      }
  
      if (increment) {
        // assign the index to the view
        view._index = index;
      }
  
      // update the indexes of views after this one
      this.children.each(function(laterView) {
        if (laterView._index >= view._index) {
          laterView._index += increment ? 1 : -1;
        }
      });
    },
  
    // Internal Method. Add the view to children and render it at
    // the given index.
    _addChildView: function(view, index) {
      // Only trigger attach if already shown, attached, and not buffering, otherwise endBuffer() or
      // Region#show() handles this.
      var canTriggerAttach = this._isShown && !this.isBuffering && Marionette.isNodeAttached(this.el);
      var nestedViews;
  
      // set up the child view event forwarding
      this.proxyChildEvents(view);
  
      // trigger the 'before:show' event on `view` if the collection view has already been shown
      if (this._isShown && !this.isBuffering) {
        Marionette.triggerMethodOn(view, 'before:show', view);
      }
  
      // Store the child view itself so we can properly remove and/or destroy it later
      this.children.add(view);
  
      // Trigger `before:attach` following `render` to avoid adding logic and event triggers
      // to public method `renderChildView()`.
      if (canTriggerAttach && this._triggerBeforeAttach) {
        nestedViews = [view].concat(view._getNestedViews());
        view.once('render', function() {
          this._triggerMethodMany(nestedViews, this, 'before:attach');
        }, this);
      }
  
      this.renderChildView(view, index);
  
      // Trigger `attach`
      if (canTriggerAttach && this._triggerAttach) {
        nestedViews = [view].concat(view._getNestedViews());
        this._triggerMethodMany(nestedViews, this, 'attach');
      }
      // Trigger `show`
      if (this._isShown && !this.isBuffering) {
        Marionette.triggerMethodOn(view, 'show', view);
      }
    },
  
    // render the child view
    renderChildView: function(view, index) {
      view.render();
      this.attachHtml(this, view, index);
      return view;
    },
  
    // Build a `childView` for a model in the collection.
    buildChildView: function(child, ChildViewClass, childViewOptions) {
      var options = _.extend({model: child}, childViewOptions);
      return new ChildViewClass(options);
    },
  
    // Remove the child view and destroy it.
    // This function also updates the indices of
    // later views in the collection in order to keep
    // the children in sync with the collection.
    removeChildView: function(view) {
  
      if (view) {
        this.triggerMethod('before:remove:child', view);
  
        // call 'destroy' or 'remove', depending on which is found
        if (view.destroy) {
          view.destroy();
        } else if (view.remove) {
          view.remove();
        }
  
        delete view._parent;
        this.stopListening(view);
        this.children.remove(view);
        this.triggerMethod('remove:child', view);
  
        // decrement the index of views after this one
        this._updateIndices(view, false);
      }
  
      return view;
    },
  
    // check if the collection is empty
    isEmpty: function() {
      return !this.collection || this.collection.length === 0;
    },
  
    // If empty, show the empty view
    checkEmpty: function() {
      if (this.isEmpty(this.collection)) {
        this.showEmptyView();
      }
    },
  
    // You might need to override this if you've overridden attachHtml
    attachBuffer: function(collectionView, buffer) {
      collectionView.$el.append(buffer);
    },
  
    // Create a fragment buffer from the currently buffered children
    _createBuffer: function() {
      var elBuffer = document.createDocumentFragment();
      _.each(this._bufferedChildren, function(b) {
        elBuffer.appendChild(b.el);
      });
      return elBuffer;
    },
  
    // Append the HTML to the collection's `el`.
    // Override this method to do something other
    // than `.append`.
    attachHtml: function(collectionView, childView, index) {
      if (collectionView.isBuffering) {
        // buffering happens on reset events and initial renders
        // in order to reduce the number of inserts into the
        // document, which are expensive.
        collectionView._bufferedChildren.splice(index, 0, childView);
      } else {
        // If we've already rendered the main collection, append
        // the new child into the correct order if we need to. Otherwise
        // append to the end.
        if (!collectionView._insertBefore(childView, index)) {
          collectionView._insertAfter(childView);
        }
      }
    },
  
    // Internal method. Check whether we need to insert the view into
    // the correct position.
    _insertBefore: function(childView, index) {
      var currentView;
      var findPosition = this.getOption('sort') && (index < this.children.length - 1);
      if (findPosition) {
        // Find the view after this one
        currentView = this.children.find(function(view) {
          return view._index === index + 1;
        });
      }
  
      if (currentView) {
        currentView.$el.before(childView.el);
        return true;
      }
  
      return false;
    },
  
    // Internal method. Append a view to the end of the $el
    _insertAfter: function(childView) {
      this.$el.append(childView.el);
    },
  
    // Internal method to set up the `children` object for
    // storing all of the child views
    _initChildViewStorage: function() {
      this.children = new Backbone.ChildViewContainer();
    },
  
    // Handle cleanup and other destroying needs for the collection of views
    destroy: function() {
      if (this.isDestroyed) { return this; }
  
      this.triggerMethod('before:destroy:collection');
      this.destroyChildren({checkEmpty: false});
      this.triggerMethod('destroy:collection');
  
      return Marionette.View.prototype.destroy.apply(this, arguments);
    },
  
    // Destroy the child views that this collection view
    // is holding on to, if any
    destroyChildren: function(options) {
      var destroyOptions = options || {};
      var shouldCheckEmpty = true;
      var childViews = this.children.map(_.identity);
  
      if (!_.isUndefined(destroyOptions.checkEmpty)) {
        shouldCheckEmpty = destroyOptions.checkEmpty;
      }
  
      this.children.each(this.removeChildView, this);
  
      if (shouldCheckEmpty) {
        this.checkEmpty();
      }
      return childViews;
    },
  
    // Return true if the given child should be shown
    // Return false otherwise
    // The filter will be passed (child, index, collection)
    // Where
    //  'child' is the given model
    //  'index' is the index of that model in the collection
    //  'collection' is the collection referenced by this CollectionView
    _shouldAddChild: function(child, index) {
      var filter = this.getOption('filter');
      return !_.isFunction(filter) || filter.call(this, child, index, this.collection);
    },
  
    // Set up the child view event forwarding. Uses a "childview:"
    // prefix in front of all forwarded events.
    proxyChildEvents: function(view) {
      var prefix = this.getOption('childViewEventPrefix');
  
      // Forward all child view events through the parent,
      // prepending "childview:" to the event name
      this.listenTo(view, 'all', function() {
        var args = _.toArray(arguments);
        var rootEvent = args[0];
        var childEvents = this.normalizeMethods(_.result(this, 'childEvents'));
  
        args[0] = prefix + ':' + rootEvent;
        args.splice(1, 0, view);
  
        // call collectionView childEvent if defined
        if (typeof childEvents !== 'undefined' && _.isFunction(childEvents[rootEvent])) {
          childEvents[rootEvent].apply(this, args.slice(1));
        }
  
        this.triggerMethod.apply(this, args);
      });
    },
  
    _getImmediateChildren: function() {
      return _.values(this.children._views);
    },
  
    getViewComparator: function() {
      return this.getOption('viewComparator');
    }
  });
  
  /* jshint maxstatements: 17, maxlen: 117 */
  
  // Composite View
  // --------------
  
  // Used for rendering a branch-leaf, hierarchical structure.
  // Extends directly from CollectionView and also renders an
  // a child view as `modelView`, for the top leaf
  Marionette.CompositeView = Marionette.CollectionView.extend({
  
    // Setting up the inheritance chain which allows changes to
    // Marionette.CollectionView.prototype.constructor which allows overriding
    // option to pass '{sort: false}' to prevent the CompositeView from
    // maintaining the sorted order of the collection.
    // This will fallback onto appending childView's to the end.
    constructor: function() {
      Marionette.CollectionView.apply(this, arguments);
    },
  
    // Configured the initial events that the composite view
    // binds to. Override this method to prevent the initial
    // events, or to add your own initial events.
    _initialEvents: function() {
  
      // Bind only after composite view is rendered to avoid adding child views
      // to nonexistent childViewContainer
  
      if (this.collection) {
        this.listenTo(this.collection, 'add', this._onCollectionAdd);
        this.listenTo(this.collection, 'remove', this._onCollectionRemove);
        this.listenTo(this.collection, 'reset', this._renderChildren);
  
        if (this.getOption('sort')) {
          this.listenTo(this.collection, 'sort', this._sortViews);
        }
      }
    },
  
    // Retrieve the `childView` to be used when rendering each of
    // the items in the collection. The default is to return
    // `this.childView` or Marionette.CompositeView if no `childView`
    // has been defined
    getChildView: function(child) {
      var childView = this.getOption('childView') || this.constructor;
  
      return childView;
    },
  
    // Serialize the model for the view.
    // You can override the `serializeData` method in your own view
    // definition, to provide custom serialization for your view's data.
    serializeData: function() {
      var data = {};
  
      if (this.model) {
        data = _.partial(this.serializeModel, this.model).apply(this, arguments);
      }
  
      return data;
    },
  
    // Renders the model and the collection.
    render: function() {
      this._ensureViewIsIntact();
      this._isRendering = true;
      this.resetChildViewContainer();
  
      this.triggerMethod('before:render', this);
  
      this._renderTemplate();
      this._renderChildren();
  
      this._isRendering = false;
      this.isRendered = true;
      this.triggerMethod('render', this);
      return this;
    },
  
    _renderChildren: function() {
      if (this.isRendered || this._isRendering) {
        Marionette.CollectionView.prototype._renderChildren.call(this);
      }
    },
  
    // Render the root template that the children
    // views are appended to
    _renderTemplate: function() {
      var data = {};
      data = this.serializeData();
      data = this.mixinTemplateHelpers(data);
  
      this.triggerMethod('before:render:template');
  
      var template = this.getTemplate();
      var html = Marionette.Renderer.render(template, data, this);
      this.attachElContent(html);
  
      // the ui bindings is done here and not at the end of render since they
      // will not be available until after the model is rendered, but should be
      // available before the collection is rendered.
      this.bindUIElements();
      this.triggerMethod('render:template');
    },
  
    // Attaches the content of the root.
    // This method can be overridden to optimize rendering,
    // or to render in a non standard way.
    //
    // For example, using `innerHTML` instead of `$el.html`
    //
    // ```js
    // attachElContent: function(html) {
    //   this.el.innerHTML = html;
    //   return this;
    // }
    // ```
    attachElContent: function(html) {
      this.$el.html(html);
  
      return this;
    },
  
    // You might need to override this if you've overridden attachHtml
    attachBuffer: function(compositeView, buffer) {
      var $container = this.getChildViewContainer(compositeView);
      $container.append(buffer);
    },
  
    // Internal method. Append a view to the end of the $el.
    // Overidden from CollectionView to ensure view is appended to
    // childViewContainer
    _insertAfter: function(childView) {
      var $container = this.getChildViewContainer(this, childView);
      $container.append(childView.el);
    },
  
    // Internal method. Append reordered childView'.
    // Overidden from CollectionView to ensure reordered views
    // are appended to childViewContainer
    _appendReorderedChildren: function(children) {
      var $container = this.getChildViewContainer(this);
      $container.append(children);
    },
  
    // Internal method to ensure an `$childViewContainer` exists, for the
    // `attachHtml` method to use.
    getChildViewContainer: function(containerView, childView) {
      if (!!containerView.$childViewContainer) {
        return containerView.$childViewContainer;
      }
  
      var container;
      var childViewContainer = Marionette.getOption(containerView, 'childViewContainer');
      if (childViewContainer) {
  
        var selector = Marionette._getValue(childViewContainer, containerView);
  
        if (selector.charAt(0) === '@' && containerView.ui) {
          container = containerView.ui[selector.substr(4)];
        } else {
          container = containerView.$(selector);
        }
  
        if (container.length <= 0) {
          throw new Marionette.Error({
            name: 'ChildViewContainerMissingError',
            message: 'The specified "childViewContainer" was not found: ' + containerView.childViewContainer
          });
        }
  
      } else {
        container = containerView.$el;
      }
  
      containerView.$childViewContainer = container;
      return container;
    },
  
    // Internal method to reset the `$childViewContainer` on render
    resetChildViewContainer: function() {
      if (this.$childViewContainer) {
        this.$childViewContainer = undefined;
      }
    }
  });
  
  // Layout View
  // -----------
  
  // Used for managing application layoutViews, nested layoutViews and
  // multiple regions within an application or sub-application.
  //
  // A specialized view class that renders an area of HTML and then
  // attaches `Region` instances to the specified `regions`.
  // Used for composite view management and sub-application areas.
  Marionette.LayoutView = Marionette.ItemView.extend({
    regionClass: Marionette.Region,
  
    options: {
      destroyImmediate: false
    },
  
    // used as the prefix for child view events
    // that are forwarded through the layoutview
    childViewEventPrefix: 'childview',
  
    // Ensure the regions are available when the `initialize` method
    // is called.
    constructor: function(options) {
      options = options || {};
  
      this._firstRender = true;
      this._initializeRegions(options);
  
      Marionette.ItemView.call(this, options);
    },
  
    // LayoutView's render will use the existing region objects the
    // first time it is called. Subsequent calls will destroy the
    // views that the regions are showing and then reset the `el`
    // for the regions to the newly rendered DOM elements.
    render: function() {
      this._ensureViewIsIntact();
  
      if (this._firstRender) {
        // if this is the first render, don't do anything to
        // reset the regions
        this._firstRender = false;
      } else {
        // If this is not the first render call, then we need to
        // re-initialize the `el` for each region
        this._reInitializeRegions();
      }
  
      return Marionette.ItemView.prototype.render.apply(this, arguments);
    },
  
    // Handle destroying regions, and then destroy the view itself.
    destroy: function() {
      if (this.isDestroyed) { return this; }
      // #2134: remove parent element before destroying the child views, so
      // removing the child views doesn't retrigger repaints
      if (this.getOption('destroyImmediate') === true) {
        this.$el.remove();
      }
      this.regionManager.destroy();
      return Marionette.ItemView.prototype.destroy.apply(this, arguments);
    },
  
    showChildView: function(regionName, view) {
      return this.getRegion(regionName).show(view);
    },
  
    getChildView: function(regionName) {
      return this.getRegion(regionName).currentView;
    },
  
    // Add a single region, by name, to the layoutView
    addRegion: function(name, definition) {
      var regions = {};
      regions[name] = definition;
      return this._buildRegions(regions)[name];
    },
  
    // Add multiple regions as a {name: definition, name2: def2} object literal
    addRegions: function(regions) {
      this.regions = _.extend({}, this.regions, regions);
      return this._buildRegions(regions);
    },
  
    // Remove a single region from the LayoutView, by name
    removeRegion: function(name) {
      delete this.regions[name];
      return this.regionManager.removeRegion(name);
    },
  
    // Provides alternative access to regions
    // Accepts the region name
    // getRegion('main')
    getRegion: function(region) {
      return this.regionManager.get(region);
    },
  
    // Get all regions
    getRegions: function() {
      return this.regionManager.getRegions();
    },
  
    // internal method to build regions
    _buildRegions: function(regions) {
      var defaults = {
        regionClass: this.getOption('regionClass'),
        parentEl: _.partial(_.result, this, 'el')
      };
  
      return this.regionManager.addRegions(regions, defaults);
    },
  
    // Internal method to initialize the regions that have been defined in a
    // `regions` attribute on this layoutView.
    _initializeRegions: function(options) {
      var regions;
      this._initRegionManager();
  
      regions = Marionette._getValue(this.regions, this, [options]) || {};
  
      // Enable users to define `regions` as instance options.
      var regionOptions = this.getOption.call(options, 'regions');
  
      // enable region options to be a function
      regionOptions = Marionette._getValue(regionOptions, this, [options]);
  
      _.extend(regions, regionOptions);
  
      // Normalize region selectors hash to allow
      // a user to use the @ui. syntax.
      regions = this.normalizeUIValues(regions, ['selector', 'el']);
  
      this.addRegions(regions);
    },
  
    // Internal method to re-initialize all of the regions by updating the `el` that
    // they point to
    _reInitializeRegions: function() {
      this.regionManager.invoke('reset');
    },
  
    // Enable easy overriding of the default `RegionManager`
    // for customized region interactions and business specific
    // view logic for better control over single regions.
    getRegionManager: function() {
      return new Marionette.RegionManager();
    },
  
    // Internal method to initialize the region manager
    // and all regions in it
    _initRegionManager: function() {
      this.regionManager = this.getRegionManager();
      this.regionManager._parent = this;
  
      this.listenTo(this.regionManager, 'before:add:region', function(name) {
        this.triggerMethod('before:add:region', name);
      });
  
      this.listenTo(this.regionManager, 'add:region', function(name, region) {
        this[name] = region;
        this.triggerMethod('add:region', name, region);
      });
  
      this.listenTo(this.regionManager, 'before:remove:region', function(name) {
        this.triggerMethod('before:remove:region', name);
      });
  
      this.listenTo(this.regionManager, 'remove:region', function(name, region) {
        delete this[name];
        this.triggerMethod('remove:region', name, region);
      });
    },
  
    _getImmediateChildren: function() {
      return _.chain(this.regionManager.getRegions())
        .pluck('currentView')
        .compact()
        .value();
    }
  });
  

  // Behavior
  // --------
  
  // A Behavior is an isolated set of DOM /
  // user interactions that can be mixed into any View.
  // Behaviors allow you to blackbox View specific interactions
  // into portable logical chunks, keeping your views simple and your code DRY.
  
  Marionette.Behavior = Marionette.Object.extend({
    constructor: function(options, view) {
      // Setup reference to the view.
      // this comes in handle when a behavior
      // wants to directly talk up the chain
      // to the view.
      this.view = view;
      this.defaults = _.result(this, 'defaults') || {};
      this.options  = _.extend({}, this.defaults, options);
      // Construct an internal UI hash using
      // the views UI hash and then the behaviors UI hash.
      // This allows the user to use UI hash elements
      // defined in the parent view as well as those
      // defined in the given behavior.
      this.ui = _.extend({}, _.result(view, 'ui'), _.result(this, 'ui'));
  
      Marionette.Object.apply(this, arguments);
    },
  
    // proxy behavior $ method to the view
    // this is useful for doing jquery DOM lookups
    // scoped to behaviors view.
    $: function() {
      return this.view.$.apply(this.view, arguments);
    },
  
    // Stops the behavior from listening to events.
    // Overrides Object#destroy to prevent additional events from being triggered.
    destroy: function() {
      this.stopListening();
  
      return this;
    },
  
    proxyViewProperties: function(view) {
      this.$el = view.$el;
      this.el = view.el;
    }
  });
  
  /* jshint maxlen: 143 */
  // Behaviors
  // ---------
  
  // Behaviors is a utility class that takes care of
  // gluing your behavior instances to their given View.
  // The most important part of this class is that you
  // **MUST** override the class level behaviorsLookup
  // method for things to work properly.
  
  Marionette.Behaviors = (function(Marionette, _) {
    // Borrow event splitter from Backbone
    var delegateEventSplitter = /^(\S+)\s*(.*)$/;
  
    function Behaviors(view, behaviors) {
  
      if (!_.isObject(view.behaviors)) {
        return {};
      }
  
      // Behaviors defined on a view can be a flat object literal
      // or it can be a function that returns an object.
      behaviors = Behaviors.parseBehaviors(view, behaviors || _.result(view, 'behaviors'));
  
      // Wraps several of the view's methods
      // calling the methods first on each behavior
      // and then eventually calling the method on the view.
      Behaviors.wrap(view, behaviors, _.keys(methods));
      return behaviors;
    }
  
    var methods = {
      behaviorTriggers: function(behaviorTriggers, behaviors) {
        var triggerBuilder = new BehaviorTriggersBuilder(this, behaviors);
        return triggerBuilder.buildBehaviorTriggers();
      },
  
      behaviorEvents: function(behaviorEvents, behaviors) {
        var _behaviorsEvents = {};
  
        _.each(behaviors, function(b, i) {
          var _events = {};
          var behaviorEvents = _.clone(_.result(b, 'events')) || {};
  
          // Normalize behavior events hash to allow
          // a user to use the @ui. syntax.
          behaviorEvents = Marionette.normalizeUIKeys(behaviorEvents, getBehaviorsUI(b));
  
          var j = 0;
          _.each(behaviorEvents, function(behaviour, key) {
            var match     = key.match(delegateEventSplitter);
  
            // Set event name to be namespaced using the view cid,
            // the behavior index, and the behavior event index
            // to generate a non colliding event namespace
            // http://api.jquery.com/event.namespace/
            var eventName = match[1] + '.' + [this.cid, i, j++, ' '].join('');
            var selector  = match[2];
  
            var eventKey  = eventName + selector;
            var handler   = _.isFunction(behaviour) ? behaviour : b[behaviour];
  
            _events[eventKey] = _.bind(handler, b);
          }, this);
  
          _behaviorsEvents = _.extend(_behaviorsEvents, _events);
        }, this);
  
        return _behaviorsEvents;
      }
    };
  
    _.extend(Behaviors, {
  
      // Placeholder method to be extended by the user.
      // The method should define the object that stores the behaviors.
      // i.e.
      //
      // ```js
      // Marionette.Behaviors.behaviorsLookup: function() {
      //   return App.Behaviors
      // }
      // ```
      behaviorsLookup: function() {
        throw new Marionette.Error({
          message: 'You must define where your behaviors are stored.',
          url: 'marionette.behaviors.html#behaviorslookup'
        });
      },
  
      // Takes care of getting the behavior class
      // given options and a key.
      // If a user passes in options.behaviorClass
      // default to using that. Otherwise delegate
      // the lookup to the users `behaviorsLookup` implementation.
      getBehaviorClass: function(options, key) {
        if (options.behaviorClass) {
          return options.behaviorClass;
        }
  
        // Get behavior class can be either a flat object or a method
        return Marionette._getValue(Behaviors.behaviorsLookup, this, [options, key])[key];
      },
  
      // Iterate over the behaviors object, for each behavior
      // instantiate it and get its grouped behaviors.
      parseBehaviors: function(view, behaviors) {
        return _.chain(behaviors).map(function(options, key) {
          var BehaviorClass = Behaviors.getBehaviorClass(options, key);
  
          var behavior = new BehaviorClass(options, view);
          var nestedBehaviors = Behaviors.parseBehaviors(view, _.result(behavior, 'behaviors'));
  
          return [behavior].concat(nestedBehaviors);
        }).flatten().value();
      },
  
      // Wrap view internal methods so that they delegate to behaviors. For example,
      // `onDestroy` should trigger destroy on all of the behaviors and then destroy itself.
      // i.e.
      //
      // `view.delegateEvents = _.partial(methods.delegateEvents, view.delegateEvents, behaviors);`
      wrap: function(view, behaviors, methodNames) {
        _.each(methodNames, function(methodName) {
          view[methodName] = _.partial(methods[methodName], view[methodName], behaviors);
        });
      }
    });
  
    // Class to build handlers for `triggers` on behaviors
    // for views
    function BehaviorTriggersBuilder(view, behaviors) {
      this._view      = view;
      this._behaviors = behaviors;
      this._triggers  = {};
    }
  
    _.extend(BehaviorTriggersBuilder.prototype, {
      // Main method to build the triggers hash with event keys and handlers
      buildBehaviorTriggers: function() {
        _.each(this._behaviors, this._buildTriggerHandlersForBehavior, this);
        return this._triggers;
      },
  
      // Internal method to build all trigger handlers for a given behavior
      _buildTriggerHandlersForBehavior: function(behavior, i) {
        var triggersHash = _.clone(_.result(behavior, 'triggers')) || {};
  
        triggersHash = Marionette.normalizeUIKeys(triggersHash, getBehaviorsUI(behavior));
  
        _.each(triggersHash, _.bind(this._setHandlerForBehavior, this, behavior, i));
      },
  
      // Internal method to create and assign the trigger handler for a given
      // behavior
      _setHandlerForBehavior: function(behavior, i, eventName, trigger) {
        // Unique identifier for the `this._triggers` hash
        var triggerKey = trigger.replace(/^\S+/, function(triggerName) {
          return triggerName + '.' + 'behaviortriggers' + i;
        });
  
        this._triggers[triggerKey] = this._view._buildViewTrigger(eventName);
      }
    });
  
    function getBehaviorsUI(behavior) {
      return behavior._uiBindings || behavior.ui;
    }
  
    return Behaviors;
  
  })(Marionette, _);
  

  // App Router
  // ----------
  
  // Reduce the boilerplate code of handling route events
  // and then calling a single method on another object.
  // Have your routers configured to call the method on
  // your object, directly.
  //
  // Configure an AppRouter with `appRoutes`.
  //
  // App routers can only take one `controller` object.
  // It is recommended that you divide your controller
  // objects in to smaller pieces of related functionality
  // and have multiple routers / controllers, instead of
  // just one giant router and controller.
  //
  // You can also add standard routes to an AppRouter.
  
  Marionette.AppRouter = Backbone.Router.extend({
  
    constructor: function(options) {
      this.options = options || {};
  
      Backbone.Router.apply(this, arguments);
  
      var appRoutes = this.getOption('appRoutes');
      var controller = this._getController();
      this.processAppRoutes(controller, appRoutes);
      this.on('route', this._processOnRoute, this);
    },
  
    // Similar to route method on a Backbone Router but
    // method is called on the controller
    appRoute: function(route, methodName) {
      var controller = this._getController();
      this._addAppRoute(controller, route, methodName);
    },
  
    // process the route event and trigger the onRoute
    // method call, if it exists
    _processOnRoute: function(routeName, routeArgs) {
      // make sure an onRoute before trying to call it
      if (_.isFunction(this.onRoute)) {
        // find the path that matches the current route
        var routePath = _.invert(this.getOption('appRoutes'))[routeName];
        this.onRoute(routeName, routePath, routeArgs);
      }
    },
  
    // Internal method to process the `appRoutes` for the
    // router, and turn them in to routes that trigger the
    // specified method on the specified `controller`.
    processAppRoutes: function(controller, appRoutes) {
      if (!appRoutes) { return; }
  
      var routeNames = _.keys(appRoutes).reverse(); // Backbone requires reverted order of routes
  
      _.each(routeNames, function(route) {
        this._addAppRoute(controller, route, appRoutes[route]);
      }, this);
    },
  
    _getController: function() {
      return this.getOption('controller');
    },
  
    _addAppRoute: function(controller, route, methodName) {
      var method = controller[methodName];
  
      if (!method) {
        throw new Marionette.Error('Method "' + methodName + '" was not found on the controller');
      }
  
      this.route(route, methodName, _.bind(method, controller));
    },
  
    mergeOptions: Marionette.mergeOptions,
  
    // Proxy `getOption` to enable getting options from this or this.options by name.
    getOption: Marionette.proxyGetOption,
  
    triggerMethod: Marionette.triggerMethod,
  
    bindEntityEvents: Marionette.proxyBindEntityEvents,
  
    unbindEntityEvents: Marionette.proxyUnbindEntityEvents
  });
  
  // Application
  // -----------
  
  // Contain and manage the composite application as a whole.
  // Stores and starts up `Region` objects, includes an
  // event aggregator as `app.vent`
  Marionette.Application = Marionette.Object.extend({
    constructor: function(options) {
      this._initializeRegions(options);
      this._initCallbacks = new Marionette.Callbacks();
      this.submodules = {};
      _.extend(this, options);
      this._initChannel();
      Marionette.Object.call(this, options);
    },
  
    // Command execution, facilitated by Backbone.Wreqr.Commands
    execute: function() {
      this.commands.execute.apply(this.commands, arguments);
    },
  
    // Request/response, facilitated by Backbone.Wreqr.RequestResponse
    request: function() {
      return this.reqres.request.apply(this.reqres, arguments);
    },
  
    // Add an initializer that is either run at when the `start`
    // method is called, or run immediately if added after `start`
    // has already been called.
    addInitializer: function(initializer) {
      this._initCallbacks.add(initializer);
    },
  
    // kick off all of the application's processes.
    // initializes all of the regions that have been added
    // to the app, and runs all of the initializer functions
    start: function(options) {
      this.triggerMethod('before:start', options);
      this._initCallbacks.run(options, this);
      this.triggerMethod('start', options);
    },
  
    // Add regions to your app.
    // Accepts a hash of named strings or Region objects
    // addRegions({something: "#someRegion"})
    // addRegions({something: Region.extend({el: "#someRegion"}) });
    addRegions: function(regions) {
      return this._regionManager.addRegions(regions);
    },
  
    // Empty all regions in the app, without removing them
    emptyRegions: function() {
      return this._regionManager.emptyRegions();
    },
  
    // Removes a region from your app, by name
    // Accepts the regions name
    // removeRegion('myRegion')
    removeRegion: function(region) {
      return this._regionManager.removeRegion(region);
    },
  
    // Provides alternative access to regions
    // Accepts the region name
    // getRegion('main')
    getRegion: function(region) {
      return this._regionManager.get(region);
    },
  
    // Get all the regions from the region manager
    getRegions: function() {
      return this._regionManager.getRegions();
    },
  
    // Create a module, attached to the application
    module: function(moduleNames, moduleDefinition) {
  
      // Overwrite the module class if the user specifies one
      var ModuleClass = Marionette.Module.getClass(moduleDefinition);
  
      var args = _.toArray(arguments);
      args.unshift(this);
  
      // see the Marionette.Module object for more information
      return ModuleClass.create.apply(ModuleClass, args);
    },
  
    // Enable easy overriding of the default `RegionManager`
    // for customized region interactions and business-specific
    // view logic for better control over single regions.
    getRegionManager: function() {
      return new Marionette.RegionManager();
    },
  
    // Internal method to initialize the regions that have been defined in a
    // `regions` attribute on the application instance
    _initializeRegions: function(options) {
      var regions = _.isFunction(this.regions) ? this.regions(options) : this.regions || {};
  
      this._initRegionManager();
  
      // Enable users to define `regions` in instance options.
      var optionRegions = Marionette.getOption(options, 'regions');
  
      // Enable region options to be a function
      if (_.isFunction(optionRegions)) {
        optionRegions = optionRegions.call(this, options);
      }
  
      // Overwrite current regions with those passed in options
      _.extend(regions, optionRegions);
  
      this.addRegions(regions);
  
      return this;
    },
  
    // Internal method to set up the region manager
    _initRegionManager: function() {
      this._regionManager = this.getRegionManager();
      this._regionManager._parent = this;
  
      this.listenTo(this._regionManager, 'before:add:region', function() {
        Marionette._triggerMethod(this, 'before:add:region', arguments);
      });
  
      this.listenTo(this._regionManager, 'add:region', function(name, region) {
        this[name] = region;
        Marionette._triggerMethod(this, 'add:region', arguments);
      });
  
      this.listenTo(this._regionManager, 'before:remove:region', function() {
        Marionette._triggerMethod(this, 'before:remove:region', arguments);
      });
  
      this.listenTo(this._regionManager, 'remove:region', function(name) {
        delete this[name];
        Marionette._triggerMethod(this, 'remove:region', arguments);
      });
    },
  
    // Internal method to setup the Wreqr.radio channel
    _initChannel: function() {
      this.channelName = _.result(this, 'channelName') || 'global';
      this.channel = _.result(this, 'channel') || Backbone.Wreqr.radio.channel(this.channelName);
      this.vent = _.result(this, 'vent') || this.channel.vent;
      this.commands = _.result(this, 'commands') || this.channel.commands;
      this.reqres = _.result(this, 'reqres') || this.channel.reqres;
    }
  });
  
  /* jshint maxparams: 9 */
  
  // Module
  // ------
  
  // A simple module system, used to create privacy and encapsulation in
  // Marionette applications
  Marionette.Module = function(moduleName, app, options) {
    this.moduleName = moduleName;
    this.options = _.extend({}, this.options, options);
    // Allow for a user to overide the initialize
    // for a given module instance.
    this.initialize = options.initialize || this.initialize;
  
    // Set up an internal store for sub-modules.
    this.submodules = {};
  
    this._setupInitializersAndFinalizers();
  
    // Set an internal reference to the app
    // within a module.
    this.app = app;
  
    if (_.isFunction(this.initialize)) {
      this.initialize(moduleName, app, this.options);
    }
  };
  
  Marionette.Module.extend = Marionette.extend;
  
  // Extend the Module prototype with events / listenTo, so that the module
  // can be used as an event aggregator or pub/sub.
  _.extend(Marionette.Module.prototype, Backbone.Events, {
  
    // By default modules start with their parents.
    startWithParent: true,
  
    // Initialize is an empty function by default. Override it with your own
    // initialization logic when extending Marionette.Module.
    initialize: function() {},
  
    // Initializer for a specific module. Initializers are run when the
    // module's `start` method is called.
    addInitializer: function(callback) {
      this._initializerCallbacks.add(callback);
    },
  
    // Finalizers are run when a module is stopped. They are used to teardown
    // and finalize any variables, references, events and other code that the
    // module had set up.
    addFinalizer: function(callback) {
      this._finalizerCallbacks.add(callback);
    },
  
    // Start the module, and run all of its initializers
    start: function(options) {
      // Prevent re-starting a module that is already started
      if (this._isInitialized) { return; }
  
      // start the sub-modules (depth-first hierarchy)
      _.each(this.submodules, function(mod) {
        // check to see if we should start the sub-module with this parent
        if (mod.startWithParent) {
          mod.start(options);
        }
      });
  
      // run the callbacks to "start" the current module
      this.triggerMethod('before:start', options);
  
      this._initializerCallbacks.run(options, this);
      this._isInitialized = true;
  
      this.triggerMethod('start', options);
    },
  
    // Stop this module by running its finalizers and then stop all of
    // the sub-modules for this module
    stop: function() {
      // if we are not initialized, don't bother finalizing
      if (!this._isInitialized) { return; }
      this._isInitialized = false;
  
      this.triggerMethod('before:stop');
  
      // stop the sub-modules; depth-first, to make sure the
      // sub-modules are stopped / finalized before parents
      _.invoke(this.submodules, 'stop');
  
      // run the finalizers
      this._finalizerCallbacks.run(undefined, this);
  
      // reset the initializers and finalizers
      this._initializerCallbacks.reset();
      this._finalizerCallbacks.reset();
  
      this.triggerMethod('stop');
    },
  
    // Configure the module with a definition function and any custom args
    // that are to be passed in to the definition function
    addDefinition: function(moduleDefinition, customArgs) {
      this._runModuleDefinition(moduleDefinition, customArgs);
    },
  
    // Internal method: run the module definition function with the correct
    // arguments
    _runModuleDefinition: function(definition, customArgs) {
      // If there is no definition short circut the method.
      if (!definition) { return; }
  
      // build the correct list of arguments for the module definition
      var args = _.flatten([
        this,
        this.app,
        Backbone,
        Marionette,
        Backbone.$, _,
        customArgs
      ]);
  
      definition.apply(this, args);
    },
  
    // Internal method: set up new copies of initializers and finalizers.
    // Calling this method will wipe out all existing initializers and
    // finalizers.
    _setupInitializersAndFinalizers: function() {
      this._initializerCallbacks = new Marionette.Callbacks();
      this._finalizerCallbacks = new Marionette.Callbacks();
    },
  
    // import the `triggerMethod` to trigger events with corresponding
    // methods if the method exists
    triggerMethod: Marionette.triggerMethod
  });
  
  // Class methods to create modules
  _.extend(Marionette.Module, {
  
    // Create a module, hanging off the app parameter as the parent object.
    create: function(app, moduleNames, moduleDefinition) {
      var module = app;
  
      // get the custom args passed in after the module definition and
      // get rid of the module name and definition function
      var customArgs = _.drop(arguments, 3);
  
      // Split the module names and get the number of submodules.
      // i.e. an example module name of `Doge.Wow.Amaze` would
      // then have the potential for 3 module definitions.
      moduleNames = moduleNames.split('.');
      var length = moduleNames.length;
  
      // store the module definition for the last module in the chain
      var moduleDefinitions = [];
      moduleDefinitions[length - 1] = moduleDefinition;
  
      // Loop through all the parts of the module definition
      _.each(moduleNames, function(moduleName, i) {
        var parentModule = module;
        module = this._getModule(parentModule, moduleName, app, moduleDefinition);
        this._addModuleDefinition(parentModule, module, moduleDefinitions[i], customArgs);
      }, this);
  
      // Return the last module in the definition chain
      return module;
    },
  
    _getModule: function(parentModule, moduleName, app, def, args) {
      var options = _.extend({}, def);
      var ModuleClass = this.getClass(def);
  
      // Get an existing module of this name if we have one
      var module = parentModule[moduleName];
  
      if (!module) {
        // Create a new module if we don't have one
        module = new ModuleClass(moduleName, app, options);
        parentModule[moduleName] = module;
        // store the module on the parent
        parentModule.submodules[moduleName] = module;
      }
  
      return module;
    },
  
    // ## Module Classes
    //
    // Module classes can be used as an alternative to the define pattern.
    // The extend function of a Module is identical to the extend functions
    // on other Backbone and Marionette classes.
    // This allows module lifecyle events like `onStart` and `onStop` to be called directly.
    getClass: function(moduleDefinition) {
      var ModuleClass = Marionette.Module;
  
      if (!moduleDefinition) {
        return ModuleClass;
      }
  
      // If all of the module's functionality is defined inside its class,
      // then the class can be passed in directly. `MyApp.module("Foo", FooModule)`.
      if (moduleDefinition.prototype instanceof ModuleClass) {
        return moduleDefinition;
      }
  
      return moduleDefinition.moduleClass || ModuleClass;
    },
  
    // Add the module definition and add a startWithParent initializer function.
    // This is complicated because module definitions are heavily overloaded
    // and support an anonymous function, module class, or options object
    _addModuleDefinition: function(parentModule, module, def, args) {
      var fn = this._getDefine(def);
      var startWithParent = this._getStartWithParent(def, module);
  
      if (fn) {
        module.addDefinition(fn, args);
      }
  
      this._addStartWithParent(parentModule, module, startWithParent);
    },
  
    _getStartWithParent: function(def, module) {
      var swp;
  
      if (_.isFunction(def) && (def.prototype instanceof Marionette.Module)) {
        swp = module.constructor.prototype.startWithParent;
        return _.isUndefined(swp) ? true : swp;
      }
  
      if (_.isObject(def)) {
        swp = def.startWithParent;
        return _.isUndefined(swp) ? true : swp;
      }
  
      return true;
    },
  
    _getDefine: function(def) {
      if (_.isFunction(def) && !(def.prototype instanceof Marionette.Module)) {
        return def;
      }
  
      if (_.isObject(def)) {
        return def.define;
      }
  
      return null;
    },
  
    _addStartWithParent: function(parentModule, module, startWithParent) {
      module.startWithParent = module.startWithParent && startWithParent;
  
      if (!module.startWithParent || !!module.startWithParentIsConfigured) {
        return;
      }
  
      module.startWithParentIsConfigured = true;
  
      parentModule.addInitializer(function(options) {
        if (module.startWithParent) {
          module.start(options);
        }
      });
    }
  });
  

  return Marionette;
}));

},{"backbone":6,"backbone.babysitter":3,"backbone.wreqr":4,"underscore":18}],3:[function(require,module,exports){
// Backbone.BabySitter
// -------------------
// v0.1.8
//
// Copyright (c)2015 Derick Bailey, Muted Solutions, LLC.
// Distributed under MIT license
//
// http://github.com/marionettejs/backbone.babysitter

(function(root, factory) {

  if (typeof define === 'function' && define.amd) {
    define(['backbone', 'underscore'], function(Backbone, _) {
      return factory(Backbone, _);
    });
  } else if (typeof exports !== 'undefined') {
    var Backbone = require('backbone');
    var _ = require('underscore');
    module.exports = factory(Backbone, _);
  } else {
    factory(root.Backbone, root._);
  }

}(this, function(Backbone, _) {
  'use strict';

  var previousChildViewContainer = Backbone.ChildViewContainer;

  // BabySitter.ChildViewContainer
  // -----------------------------
  //
  // Provide a container to store, retrieve and
  // shut down child views.
  
  Backbone.ChildViewContainer = (function (Backbone, _) {
  
    // Container Constructor
    // ---------------------
  
    var Container = function(views){
      this._views = {};
      this._indexByModel = {};
      this._indexByCustom = {};
      this._updateLength();
  
      _.each(views, this.add, this);
    };
  
    // Container Methods
    // -----------------
  
    _.extend(Container.prototype, {
  
      // Add a view to this container. Stores the view
      // by `cid` and makes it searchable by the model
      // cid (and model itself). Optionally specify
      // a custom key to store an retrieve the view.
      add: function(view, customIndex){
        var viewCid = view.cid;
  
        // store the view
        this._views[viewCid] = view;
  
        // index it by model
        if (view.model){
          this._indexByModel[view.model.cid] = viewCid;
        }
  
        // index by custom
        if (customIndex){
          this._indexByCustom[customIndex] = viewCid;
        }
  
        this._updateLength();
        return this;
      },
  
      // Find a view by the model that was attached to
      // it. Uses the model's `cid` to find it.
      findByModel: function(model){
        return this.findByModelCid(model.cid);
      },
  
      // Find a view by the `cid` of the model that was attached to
      // it. Uses the model's `cid` to find the view `cid` and
      // retrieve the view using it.
      findByModelCid: function(modelCid){
        var viewCid = this._indexByModel[modelCid];
        return this.findByCid(viewCid);
      },
  
      // Find a view by a custom indexer.
      findByCustom: function(index){
        var viewCid = this._indexByCustom[index];
        return this.findByCid(viewCid);
      },
  
      // Find by index. This is not guaranteed to be a
      // stable index.
      findByIndex: function(index){
        return _.values(this._views)[index];
      },
  
      // retrieve a view by its `cid` directly
      findByCid: function(cid){
        return this._views[cid];
      },
  
      // Remove a view
      remove: function(view){
        var viewCid = view.cid;
  
        // delete model index
        if (view.model){
          delete this._indexByModel[view.model.cid];
        }
  
        // delete custom index
        _.any(this._indexByCustom, function(cid, key) {
          if (cid === viewCid) {
            delete this._indexByCustom[key];
            return true;
          }
        }, this);
  
        // remove the view from the container
        delete this._views[viewCid];
  
        // update the length
        this._updateLength();
        return this;
      },
  
      // Call a method on every view in the container,
      // passing parameters to the call method one at a
      // time, like `function.call`.
      call: function(method){
        this.apply(method, _.tail(arguments));
      },
  
      // Apply a method on every view in the container,
      // passing parameters to the call method one at a
      // time, like `function.apply`.
      apply: function(method, args){
        _.each(this._views, function(view){
          if (_.isFunction(view[method])){
            view[method].apply(view, args || []);
          }
        });
      },
  
      // Update the `.length` attribute on this container
      _updateLength: function(){
        this.length = _.size(this._views);
      }
    });
  
    // Borrowing this code from Backbone.Collection:
    // http://backbonejs.org/docs/backbone.html#section-106
    //
    // Mix in methods from Underscore, for iteration, and other
    // collection related features.
    var methods = ['forEach', 'each', 'map', 'find', 'detect', 'filter',
      'select', 'reject', 'every', 'all', 'some', 'any', 'include',
      'contains', 'invoke', 'toArray', 'first', 'initial', 'rest',
      'last', 'without', 'isEmpty', 'pluck', 'reduce'];
  
    _.each(methods, function(method) {
      Container.prototype[method] = function() {
        var views = _.values(this._views);
        var args = [views].concat(_.toArray(arguments));
        return _[method].apply(_, args);
      };
    });
  
    // return the public API
    return Container;
  })(Backbone, _);
  

  Backbone.ChildViewContainer.VERSION = '0.1.8';

  Backbone.ChildViewContainer.noConflict = function () {
    Backbone.ChildViewContainer = previousChildViewContainer;
    return this;
  };

  return Backbone.ChildViewContainer;

}));

},{"backbone":6,"underscore":18}],4:[function(require,module,exports){
// Backbone.Wreqr (Backbone.Marionette)
// ----------------------------------
// v1.3.3
//
// Copyright (c)2015 Derick Bailey, Muted Solutions, LLC.
// Distributed under MIT license
//
// http://github.com/marionettejs/backbone.wreqr


(function(root, factory) {

  if (typeof define === 'function' && define.amd) {
    define(['backbone', 'underscore'], function(Backbone, _) {
      return factory(Backbone, _);
    });
  } else if (typeof exports !== 'undefined') {
    var Backbone = require('backbone');
    var _ = require('underscore');
    module.exports = factory(Backbone, _);
  } else {
    factory(root.Backbone, root._);
  }

}(this, function(Backbone, _) {
  "use strict";

  var previousWreqr = Backbone.Wreqr;

  var Wreqr = Backbone.Wreqr = {};

  Backbone.Wreqr.VERSION = '1.3.3';

  Backbone.Wreqr.noConflict = function () {
    Backbone.Wreqr = previousWreqr;
    return this;
  };

  // Handlers
  // --------
  // A registry of functions to call, given a name
  
  Wreqr.Handlers = (function(Backbone, _){
    "use strict";
    
    // Constructor
    // -----------
  
    var Handlers = function(options){
      this.options = options;
      this._wreqrHandlers = {};
      
      if (_.isFunction(this.initialize)){
        this.initialize(options);
      }
    };
  
    Handlers.extend = Backbone.Model.extend;
  
    // Instance Members
    // ----------------
  
    _.extend(Handlers.prototype, Backbone.Events, {
  
      // Add multiple handlers using an object literal configuration
      setHandlers: function(handlers){
        _.each(handlers, function(handler, name){
          var context = null;
  
          if (_.isObject(handler) && !_.isFunction(handler)){
            context = handler.context;
            handler = handler.callback;
          }
  
          this.setHandler(name, handler, context);
        }, this);
      },
  
      // Add a handler for the given name, with an
      // optional context to run the handler within
      setHandler: function(name, handler, context){
        var config = {
          callback: handler,
          context: context
        };
  
        this._wreqrHandlers[name] = config;
  
        this.trigger("handler:add", name, handler, context);
      },
  
      // Determine whether or not a handler is registered
      hasHandler: function(name){
        return !! this._wreqrHandlers[name];
      },
  
      // Get the currently registered handler for
      // the specified name. Throws an exception if
      // no handler is found.
      getHandler: function(name){
        var config = this._wreqrHandlers[name];
  
        if (!config){
          return;
        }
  
        return function(){
          return config.callback.apply(config.context, arguments);
        };
      },
  
      // Remove a handler for the specified name
      removeHandler: function(name){
        delete this._wreqrHandlers[name];
      },
  
      // Remove all handlers from this registry
      removeAllHandlers: function(){
        this._wreqrHandlers = {};
      }
    });
  
    return Handlers;
  })(Backbone, _);
  
  // Wreqr.CommandStorage
  // --------------------
  //
  // Store and retrieve commands for execution.
  Wreqr.CommandStorage = (function(){
    "use strict";
  
    // Constructor function
    var CommandStorage = function(options){
      this.options = options;
      this._commands = {};
  
      if (_.isFunction(this.initialize)){
        this.initialize(options);
      }
    };
  
    // Instance methods
    _.extend(CommandStorage.prototype, Backbone.Events, {
  
      // Get an object literal by command name, that contains
      // the `commandName` and the `instances` of all commands
      // represented as an array of arguments to process
      getCommands: function(commandName){
        var commands = this._commands[commandName];
  
        // we don't have it, so add it
        if (!commands){
  
          // build the configuration
          commands = {
            command: commandName, 
            instances: []
          };
  
          // store it
          this._commands[commandName] = commands;
        }
  
        return commands;
      },
  
      // Add a command by name, to the storage and store the
      // args for the command
      addCommand: function(commandName, args){
        var command = this.getCommands(commandName);
        command.instances.push(args);
      },
  
      // Clear all commands for the given `commandName`
      clearCommands: function(commandName){
        var command = this.getCommands(commandName);
        command.instances = [];
      }
    });
  
    return CommandStorage;
  })();
  
  // Wreqr.Commands
  // --------------
  //
  // A simple command pattern implementation. Register a command
  // handler and execute it.
  Wreqr.Commands = (function(Wreqr, _){
    "use strict";
  
    return Wreqr.Handlers.extend({
      // default storage type
      storageType: Wreqr.CommandStorage,
  
      constructor: function(options){
        this.options = options || {};
  
        this._initializeStorage(this.options);
        this.on("handler:add", this._executeCommands, this);
  
        Wreqr.Handlers.prototype.constructor.apply(this, arguments);
      },
  
      // Execute a named command with the supplied args
      execute: function(name){
        name = arguments[0];
        var args = _.rest(arguments);
  
        if (this.hasHandler(name)){
          this.getHandler(name).apply(this, args);
        } else {
          this.storage.addCommand(name, args);
        }
  
      },
  
      // Internal method to handle bulk execution of stored commands
      _executeCommands: function(name, handler, context){
        var command = this.storage.getCommands(name);
  
        // loop through and execute all the stored command instances
        _.each(command.instances, function(args){
          handler.apply(context, args);
        });
  
        this.storage.clearCommands(name);
      },
  
      // Internal method to initialize storage either from the type's
      // `storageType` or the instance `options.storageType`.
      _initializeStorage: function(options){
        var storage;
  
        var StorageType = options.storageType || this.storageType;
        if (_.isFunction(StorageType)){
          storage = new StorageType();
        } else {
          storage = StorageType;
        }
  
        this.storage = storage;
      }
    });
  
  })(Wreqr, _);
  
  // Wreqr.RequestResponse
  // ---------------------
  //
  // A simple request/response implementation. Register a
  // request handler, and return a response from it
  Wreqr.RequestResponse = (function(Wreqr, _){
    "use strict";
  
    return Wreqr.Handlers.extend({
      request: function(name){
        if (this.hasHandler(name)) {
          return this.getHandler(name).apply(this, _.rest(arguments));
        }
      }
    });
  
  })(Wreqr, _);
  
  // Event Aggregator
  // ----------------
  // A pub-sub object that can be used to decouple various parts
  // of an application through event-driven architecture.
  
  Wreqr.EventAggregator = (function(Backbone, _){
    "use strict";
    var EA = function(){};
  
    // Copy the `extend` function used by Backbone's classes
    EA.extend = Backbone.Model.extend;
  
    // Copy the basic Backbone.Events on to the event aggregator
    _.extend(EA.prototype, Backbone.Events);
  
    return EA;
  })(Backbone, _);
  
  // Wreqr.Channel
  // --------------
  //
  // An object that wraps the three messaging systems:
  // EventAggregator, RequestResponse, Commands
  Wreqr.Channel = (function(Wreqr){
    "use strict";
  
    var Channel = function(channelName) {
      this.vent        = new Backbone.Wreqr.EventAggregator();
      this.reqres      = new Backbone.Wreqr.RequestResponse();
      this.commands    = new Backbone.Wreqr.Commands();
      this.channelName = channelName;
    };
  
    _.extend(Channel.prototype, {
  
      // Remove all handlers from the messaging systems of this channel
      reset: function() {
        this.vent.off();
        this.vent.stopListening();
        this.reqres.removeAllHandlers();
        this.commands.removeAllHandlers();
        return this;
      },
  
      // Connect a hash of events; one for each messaging system
      connectEvents: function(hash, context) {
        this._connect('vent', hash, context);
        return this;
      },
  
      connectCommands: function(hash, context) {
        this._connect('commands', hash, context);
        return this;
      },
  
      connectRequests: function(hash, context) {
        this._connect('reqres', hash, context);
        return this;
      },
  
      // Attach the handlers to a given message system `type`
      _connect: function(type, hash, context) {
        if (!hash) {
          return;
        }
  
        context = context || this;
        var method = (type === 'vent') ? 'on' : 'setHandler';
  
        _.each(hash, function(fn, eventName) {
          this[type][method](eventName, _.bind(fn, context));
        }, this);
      }
    });
  
  
    return Channel;
  })(Wreqr);
  
  // Wreqr.Radio
  // --------------
  //
  // An object that lets you communicate with many channels.
  Wreqr.radio = (function(Wreqr, _){
    "use strict";
  
    var Radio = function() {
      this._channels = {};
      this.vent = {};
      this.commands = {};
      this.reqres = {};
      this._proxyMethods();
    };
  
    _.extend(Radio.prototype, {
  
      channel: function(channelName) {
        if (!channelName) {
          throw new Error('Channel must receive a name');
        }
  
        return this._getChannel( channelName );
      },
  
      _getChannel: function(channelName) {
        var channel = this._channels[channelName];
  
        if(!channel) {
          channel = new Wreqr.Channel(channelName);
          this._channels[channelName] = channel;
        }
  
        return channel;
      },
  
      _proxyMethods: function() {
        _.each(['vent', 'commands', 'reqres'], function(system) {
          _.each( messageSystems[system], function(method) {
            this[system][method] = proxyMethod(this, system, method);
          }, this);
        }, this);
      }
    });
  
  
    var messageSystems = {
      vent: [
        'on',
        'off',
        'trigger',
        'once',
        'stopListening',
        'listenTo',
        'listenToOnce'
      ],
  
      commands: [
        'execute',
        'setHandler',
        'setHandlers',
        'removeHandler',
        'removeAllHandlers'
      ],
  
      reqres: [
        'request',
        'setHandler',
        'setHandlers',
        'removeHandler',
        'removeAllHandlers'
      ]
    };
  
    var proxyMethod = function(radio, system, method) {
      return function(channelName) {
        var messageSystem = radio._getChannel(channelName)[system];
  
        return messageSystem[method].apply(messageSystem, _.rest(arguments));
      };
    };
  
    return new Radio();
  
  })(Wreqr, _);
  

  return Backbone.Wreqr;

}));

},{"backbone":6,"underscore":18}],5:[function(require,module,exports){
// Backbone.Radio v0.9.1
(function (global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory(require("underscore"), require("backbone")) : typeof define === "function" && define.amd ? define(["underscore", "backbone"], factory) : global.Backbone.Radio = factory(global._, global.Backbone);
})(this, function (_, Backbone) {
  "use strict";

  var previousRadio = Backbone.Radio;

  var Radio = Backbone.Radio = {};

  Radio.VERSION = "0.9.1";

  // This allows you to run multiple instances of Radio on the same
  // webapp. After loading the new version, call `noConflict()` to
  // get a reference to it. At the same time the old version will be
  // returned to Backbone.Radio.
  Radio.noConflict = function () {
    Backbone.Radio = previousRadio;
    return this;
  };

  // Whether or not we're in DEBUG mode or not. DEBUG mode helps you
  // get around the issues of lack of warnings when events are mis-typed.
  Radio.DEBUG = false;

  // Format debug text.
  Radio._debugText = function (warning, eventName, channelName) {
    return warning + (channelName ? " on the " + channelName + " channel" : "") + ": \"" + eventName + "\"";
  };

  // This is the method that's called when an unregistered event was called.
  // By default, it logs warning to the console. By overriding this you could
  // make it throw an Error, for instance. This would make firing a nonexistent event
  // have the same consequence as firing a nonexistent method on an Object.
  Radio.debugLog = function (warning, eventName, channelName) {
    if (Radio.DEBUG && console && console.warn) {
      console.warn(Radio._debugText(warning, eventName, channelName));
    }
  };

  var eventSplitter = /\s+/;

  // An internal method used to handle Radio's method overloading for Requests and
  // Commands. It's borrowed from Backbone.Events. It differs from Backbone's overload
  // API (which is used in Backbone.Events) in that it doesn't support space-separated
  // event names.
  Radio._eventsApi = function (obj, action, name, rest) {
    if (!name) {
      return false;
    }

    var results = {};

    // Handle event maps.
    if (typeof name === "object") {
      for (var key in name) {
        var result = obj[action].apply(obj, [key, name[key]].concat(rest));
        eventSplitter.test(key) ? _.extend(results, result) : results[key] = result;
      }
      return results;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        results[names[i]] = obj[action].apply(obj, [names[i]].concat(rest));
      }
      return results;
    }

    return false;
  };

  // An optimized way to execute callbacks.
  Radio._callHandler = function (callback, context, args) {
    var a1 = args[0],
        a2 = args[1],
        a3 = args[2];
    switch (args.length) {
      case 0:
        return callback.call(context);
      case 1:
        return callback.call(context, a1);
      case 2:
        return callback.call(context, a1, a2);
      case 3:
        return callback.call(context, a1, a2, a3);
      default:
        return callback.apply(context, args);
    }
  };

  // A helper used by `off` methods to the handler from the store
  function removeHandler(store, name, callback, context) {
    var event = store[name];
    if ((!callback || (callback === event.callback || callback === event.callback._callback)) && (!context || context === event.context)) {
      delete store[name];
      return true;
    }
  }

  function removeHandlers(store, name, callback, context) {
    store || (store = {});
    var names = name ? [name] : _.keys(store);
    var matched = false;

    for (var i = 0, length = names.length; i < length; i++) {
      name = names[i];

      // If there's no event by this name, log it and continue
      // with the loop
      if (!store[name]) {
        continue;
      }

      if (removeHandler(store, name, callback, context)) {
        matched = true;
      }
    }

    return matched;
  }

  /*
   * tune-in
   * -------
   * Get console logs of a channel's activity
   *
   */

  var _logs = {};

  // This is to produce an identical function in both tuneIn and tuneOut,
  // so that Backbone.Events unregisters it.
  function _partial(channelName) {
    return _logs[channelName] || (_logs[channelName] = _.partial(Radio.log, channelName));
  }

  _.extend(Radio, {

    // Log information about the channel and event
    log: function log(channelName, eventName) {
      var args = _.rest(arguments, 2);
      console.log("[" + channelName + "] \"" + eventName + "\"", args);
    },

    // Logs all events on this channel to the console. It sets an
    // internal value on the channel telling it we're listening,
    // then sets a listener on the Backbone.Events
    tuneIn: function tuneIn(channelName) {
      var channel = Radio.channel(channelName);
      channel._tunedIn = true;
      channel.on("all", _partial(channelName));
      return this;
    },

    // Stop logging all of the activities on this channel to the console
    tuneOut: function tuneOut(channelName) {
      var channel = Radio.channel(channelName);
      channel._tunedIn = false;
      channel.off("all", _partial(channelName));
      delete _logs[channelName];
      return this;
    }
  });

  /*
   * Backbone.Radio.Commands
   * -----------------------
   * A messaging system for sending orders.
   *
   */

  Radio.Commands = {

    // Issue a command
    command: function command(name) {
      var args = _.rest(arguments);
      if (Radio._eventsApi(this, "command", name, args)) {
        return this;
      }
      var channelName = this.channelName;
      var commands = this._commands;

      // Check if we should log the command, and if so, do it
      if (channelName && this._tunedIn) {
        Radio.log.apply(this, [channelName, name].concat(args));
      }

      // If the command isn't handled, log it in DEBUG mode and exit
      if (commands && (commands[name] || commands["default"])) {
        var handler = commands[name] || commands["default"];
        args = commands[name] ? args : arguments;
        Radio._callHandler(handler.callback, handler.context, args);
      } else {
        Radio.debugLog("An unhandled command was fired", name, channelName);
      }

      return this;
    },

    // Register a handler for a command.
    comply: function comply(name, callback, context) {
      if (Radio._eventsApi(this, "comply", name, [callback, context])) {
        return this;
      }
      this._commands || (this._commands = {});

      if (this._commands[name]) {
        Radio.debugLog("A command was overwritten", name, this.channelName);
      }

      this._commands[name] = {
        callback: callback,
        context: context || this
      };

      return this;
    },

    // Register a handler for a command that happens just once.
    complyOnce: function complyOnce(name, callback, context) {
      if (Radio._eventsApi(this, "complyOnce", name, [callback, context])) {
        return this;
      }
      var self = this;

      var once = _.once(function () {
        self.stopComplying(name);
        return callback.apply(this, arguments);
      });

      return this.comply(name, once, context);
    },

    // Remove handler(s)
    stopComplying: function stopComplying(name, callback, context) {
      if (Radio._eventsApi(this, "stopComplying", name)) {
        return this;
      }

      // Remove everything if there are no arguments passed
      if (!name && !callback && !context) {
        delete this._commands;
      } else if (!removeHandlers(this._commands, name, callback, context)) {
        Radio.debugLog("Attempted to remove the unregistered command", name, this.channelName);
      }

      return this;
    }
  };

  /*
   * Backbone.Radio.Requests
   * -----------------------
   * A messaging system for requesting data.
   *
   */

  function makeCallback(callback) {
    return _.isFunction(callback) ? callback : function () {
      return callback;
    };
  }

  Radio.Requests = {

    // Make a request
    request: function request(name) {
      var args = _.rest(arguments);
      var results = Radio._eventsApi(this, "request", name, args);
      if (results) {
        return results;
      }
      var channelName = this.channelName;
      var requests = this._requests;

      // Check if we should log the request, and if so, do it
      if (channelName && this._tunedIn) {
        Radio.log.apply(this, [channelName, name].concat(args));
      }

      // If the request isn't handled, log it in DEBUG mode and exit
      if (requests && (requests[name] || requests["default"])) {
        var handler = requests[name] || requests["default"];
        args = requests[name] ? args : arguments;
        return Radio._callHandler(handler.callback, handler.context, args);
      } else {
        Radio.debugLog("An unhandled request was fired", name, channelName);
      }
    },

    // Set up a handler for a request
    reply: function reply(name, callback, context) {
      if (Radio._eventsApi(this, "reply", name, [callback, context])) {
        return this;
      }

      this._requests || (this._requests = {});

      if (this._requests[name]) {
        Radio.debugLog("A request was overwritten", name, this.channelName);
      }

      this._requests[name] = {
        callback: makeCallback(callback),
        context: context || this
      };

      return this;
    },

    // Set up a handler that can only be requested once
    replyOnce: function replyOnce(name, callback, context) {
      if (Radio._eventsApi(this, "replyOnce", name, [callback, context])) {
        return this;
      }

      var self = this;

      var once = _.once(function () {
        self.stopReplying(name);
        return makeCallback(callback).apply(this, arguments);
      });

      return this.reply(name, once, context);
    },

    // Remove handler(s)
    stopReplying: function stopReplying(name, callback, context) {
      if (Radio._eventsApi(this, "stopReplying", name)) {
        return this;
      }

      // Remove everything if there are no arguments passed
      if (!name && !callback && !context) {
        delete this._requests;
      } else if (!removeHandlers(this._requests, name, callback, context)) {
        Radio.debugLog("Attempted to remove the unregistered request", name, this.channelName);
      }

      return this;
    }
  };

  /*
   * Backbone.Radio.channel
   * ----------------------
   * Get a reference to a channel by name.
   *
   */

  Radio._channels = {};

  Radio.channel = function (channelName) {
    if (!channelName) {
      throw new Error("You must provide a name for the channel.");
    }

    if (Radio._channels[channelName]) {
      return Radio._channels[channelName];
    } else {
      return Radio._channels[channelName] = new Radio.Channel(channelName);
    }
  };

  /*
   * Backbone.Radio.Channel
   * ----------------------
   * A Channel is an object that extends from Backbone.Events,
   * Radio.Commands, and Radio.Requests.
   *
   */

  Radio.Channel = function (channelName) {
    this.channelName = channelName;
  };

  _.extend(Radio.Channel.prototype, Backbone.Events, Radio.Commands, Radio.Requests, {

    // Remove all handlers from the messaging systems of this channel
    reset: function reset() {
      this.off();
      this.stopListening();
      this.stopComplying();
      this.stopReplying();
      return this;
    }
  });

  /*
   * Top-level API
   * -------------
   * Supplies the 'top-level API' for working with Channels directly
   * from Backbone.Radio.
   *
   */

  var channel,
      args,
      systems = [Backbone.Events, Radio.Commands, Radio.Requests];

  _.each(systems, function (system) {
    _.each(system, function (method, methodName) {
      Radio[methodName] = function (channelName) {
        args = _.rest(arguments);
        channel = this.channel(channelName);
        return channel[methodName].apply(channel, args);
      };
    });
  });

  Radio.reset = function (channelName) {
    var channels = !channelName ? this._channels : [this._channels[channelName]];
    _.invoke(channels, "reset");
  };

  var backbone_radio = Radio;

  return backbone_radio;
});
//# sourceMappingURL=./backbone.radio.js.map
},{"backbone":6,"underscore":18}],6:[function(require,module,exports){
(function (global){
//     Backbone.js 1.2.1

//     (c) 2010-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(factory) {

  // Establish the root object, `window` (`self`) in the browser, or `global` on the server.
  // We use `self` instead of `window` for `WebWorker` support.
  var root = (typeof self == 'object' && self.self == self && self) ||
            (typeof global == 'object' && global.global == global && global);

  // Set up Backbone appropriately for the environment. Start with AMD.
  if (typeof define === 'function' && define.amd) {
    define(['underscore', 'jquery', 'exports'], function(_, $, exports) {
      // Export global even in AMD case in case this script is loaded with
      // others that may still expect a global Backbone.
      root.Backbone = factory(root, exports, _, $);
    });

  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
  } else if (typeof exports !== 'undefined') {
    var _ = require('underscore'), $;
    try { $ = require('jquery'); } catch(e) {}
    factory(root, exports, _, $);

  // Finally, as a browser global.
  } else {
    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
  }

}(function(root, Backbone, _, $) {

  // Initial Setup
  // -------------

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create a local reference to a common array method we'll want to use later.
  var slice = [].slice;

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.2.1';

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = $;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... this will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Proxy Underscore methods to a Backbone class' prototype using a
  // particular attribute as the data argument
  var addMethod = function(length, method, attribute) {
    switch (length) {
      case 1: return function() {
        return _[method](this[attribute]);
      };
      case 2: return function(value) {
        return _[method](this[attribute], value);
      };
      case 3: return function(iteratee, context) {
        return _[method](this[attribute], iteratee, context);
      };
      case 4: return function(iteratee, defaultVal, context) {
        return _[method](this[attribute], iteratee, defaultVal, context);
      };
      default: return function() {
        var args = slice.call(arguments);
        args.unshift(this[attribute]);
        return _[method].apply(_, args);
      };
    }
  };
  var addUnderscoreMethods = function(Class, methods, attribute) {
    _.each(methods, function(length, method) {
      if (_[method]) Class.prototype[method] = addMethod(length, method, attribute);
    });
  };

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {};

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Iterates over the standard `event, callback` (as well as the fancy multiple
  // space-separated events `"change blur", callback` and jQuery-style event
  // maps `{event: callback}`), reducing them by manipulating `memo`.
  // Passes a normalized single event name and callback, as well as any
  // optional `opts`.
  var eventsApi = function(iteratee, memo, name, callback, opts) {
    var i = 0, names;
    if (name && typeof name === 'object') {
      // Handle event maps.
      if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;
      for (names = _.keys(name); i < names.length ; i++) {
        memo = iteratee(memo, names[i], name[names[i]], opts);
      }
    } else if (name && eventSplitter.test(name)) {
      // Handle space separated event names.
      for (names = name.split(eventSplitter); i < names.length; i++) {
        memo = iteratee(memo, names[i], callback, opts);
      }
    } else {
      memo = iteratee(memo, name, callback, opts);
    }
    return memo;
  };

  // Bind an event to a `callback` function. Passing `"all"` will bind
  // the callback to all events fired.
  Events.on = function(name, callback, context) {
    return internalOn(this, name, callback, context);
  };

  // An internal use `on` function, used to guard the `listening` argument from
  // the public API.
  var internalOn = function(obj, name, callback, context, listening) {
    obj._events = eventsApi(onApi, obj._events || {}, name, callback, {
        context: context,
        ctx: obj,
        listening: listening
    });

    if (listening) {
      var listeners = obj._listeners || (obj._listeners = {});
      listeners[listening.id] = listening;
    }

    return obj;
  };

  // Inversion-of-control versions of `on`. Tell *this* object to listen to
  // an event in another object... keeping track of what it's listening to.
  Events.listenTo =  function(obj, name, callback) {
    if (!obj) return this;
    var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
    var listeningTo = this._listeningTo || (this._listeningTo = {});
    var listening = listeningTo[id];

    // This object is not listening to any other events on `obj` yet.
    // Setup the necessary references to track the listening callbacks.
    if (!listening) {
      var thisId = this._listenId || (this._listenId = _.uniqueId('l'));
      listening = listeningTo[id] = {obj: obj, objId: id, id: thisId, listeningTo: listeningTo, count: 0};
    }

    // Bind callbacks on obj, and keep track of them on listening.
    internalOn(obj, name, callback, this, listening);
    return this;
  };

  // The reducing API that adds a callback to the `events` object.
  var onApi = function(events, name, callback, options) {
    if (callback) {
      var handlers = events[name] || (events[name] = []);
      var context = options.context, ctx = options.ctx, listening = options.listening;
      if (listening) listening.count++;

      handlers.push({ callback: callback, context: context, ctx: context || ctx, listening: listening });
    }
    return events;
  };

  // Remove one or many callbacks. If `context` is null, removes all
  // callbacks with that function. If `callback` is null, removes all
  // callbacks for the event. If `name` is null, removes all bound
  // callbacks for all events.
  Events.off =  function(name, callback, context) {
    if (!this._events) return this;
    this._events = eventsApi(offApi, this._events, name, callback, {
        context: context,
        listeners: this._listeners
    });
    return this;
  };

  // Tell this object to stop listening to either specific events ... or
  // to every object it's currently listening to.
  Events.stopListening =  function(obj, name, callback) {
    var listeningTo = this._listeningTo;
    if (!listeningTo) return this;

    var ids = obj ? [obj._listenId] : _.keys(listeningTo);

    for (var i = 0; i < ids.length; i++) {
      var listening = listeningTo[ids[i]];

      // If listening doesn't exist, this object is not currently
      // listening to obj. Break out early.
      if (!listening) break;

      listening.obj.off(name, callback, this);
    }
    if (_.isEmpty(listeningTo)) this._listeningTo = void 0;

    return this;
  };

  // The reducing API that removes a callback from the `events` object.
  var offApi = function(events, name, callback, options) {
    // No events to consider.
    if (!events) return;

    var i = 0, listening;
    var context = options.context, listeners = options.listeners;

    // Delete all events listeners and "drop" events.
    if (!name && !callback && !context) {
      var ids = _.keys(listeners);
      for (; i < ids.length; i++) {
        listening = listeners[ids[i]];
        delete listeners[listening.id];
        delete listening.listeningTo[listening.objId];
      }
      return;
    }

    var names = name ? [name] : _.keys(events);
    for (; i < names.length; i++) {
      name = names[i];
      var handlers = events[name];

      // Bail out if there are no events stored.
      if (!handlers) break;

      // Replace events if there are any remaining.  Otherwise, clean up.
      var remaining = [];
      for (var j = 0; j < handlers.length; j++) {
        var handler = handlers[j];
        if (
          callback && callback !== handler.callback &&
            callback !== handler.callback._callback ||
              context && context !== handler.context
        ) {
          remaining.push(handler);
        } else {
          listening = handler.listening;
          if (listening && --listening.count === 0) {
            delete listeners[listening.id];
            delete listening.listeningTo[listening.objId];
          }
        }
      }

      // Update tail event if the list has any events.  Otherwise, clean up.
      if (remaining.length) {
        events[name] = remaining;
      } else {
        delete events[name];
      }
    }
    if (_.size(events)) return events;
  };

  // Bind an event to only be triggered a single time. After the first time
  // the callback is invoked, it will be removed. When multiple events are
  // passed in using the space-separated syntax, the event will fire once for every
  // event you passed in, not once for a combination of all events
  Events.once =  function(name, callback, context) {
    // Map the event into a `{event: once}` object.
    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.off, this));
    return this.on(events, void 0, context);
  };

  // Inversion-of-control versions of `once`.
  Events.listenToOnce =  function(obj, name, callback) {
    // Map the event into a `{event: once}` object.
    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.stopListening, this, obj));
    return this.listenTo(obj, events);
  };

  // Reduces the event callbacks into a map of `{event: onceWrapper}`.
  // `offer` unbinds the `onceWrapper` after it has been called.
  var onceMap = function(map, name, callback, offer) {
    if (callback) {
      var once = map[name] = _.once(function() {
        offer(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
    }
    return map;
  };

  // Trigger one or many events, firing all bound callbacks. Callbacks are
  // passed the same arguments as `trigger` is, apart from the event name
  // (unless you're listening on `"all"`, which will cause your callback to
  // receive the true name of the event as the first argument).
  Events.trigger =  function(name) {
    if (!this._events) return this;

    var length = Math.max(0, arguments.length - 1);
    var args = Array(length);
    for (var i = 0; i < length; i++) args[i] = arguments[i + 1];

    eventsApi(triggerApi, this._events, name, void 0, args);
    return this;
  };

  // Handles triggering the appropriate event callbacks.
  var triggerApi = function(objEvents, name, cb, args) {
    if (objEvents) {
      var events = objEvents[name];
      var allEvents = objEvents.all;
      if (events && allEvents) allEvents = allEvents.slice();
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, [name].concat(args));
    }
    return objEvents;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
    }
  };

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId(this.cidPrefix);
    this.attributes = {};
    if (options.collection) this.collection = options.collection;
    if (options.parse) attrs = this.parse(attrs, options) || {};
    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // The prefix is used to create the client id which is used to identify models locally.
    // You may want to override this if you're experiencing name clashes with model ids.
    cidPrefix: 'c',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Special-cased proxy to underscore's `_.matches` method.
    matches: function(attrs) {
      return !!_.iteratee(attrs, this)(this.attributes);
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      var attrs;
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      var unset      = options.unset;
      var silent     = options.silent;
      var changes    = [];
      var changing   = this._changing;
      this._changing = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }

      var current = this.attributes;
      var changed = this.changed;
      var prev    = this._previousAttributes;

      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

      // For each `set` attribute, update or delete the current value.
      for (var attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          changed[attr] = val;
        } else {
          delete changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = options;
        for (var i = 0; i < changes.length; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          options = this._pending;
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      var changed = {};
      for (var attr in diff) {
        var val = diff[attr];
        if (_.isEqual(old[attr], val)) continue;
        changed[attr] = val;
      }
      return _.size(changed) ? changed : false;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server, merging the response with the model's
    // local attributes. Any changed attributes will trigger a "change" event.
    fetch: function(options) {
      options = _.extend({parse: true}, options);
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
        if (!model.set(serverAttrs, options)) return false;
        if (success) success.call(options.context, model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      // Handle both `"key", value` and `{key: value}` -style arguments.
      var attrs;
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options = _.extend({validate: true, parse: true}, options);
      var wait = options.wait;

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the model will be valid when the attributes, if any, are set.
      if (attrs && !wait) {
        if (!this.set(attrs, options)) return false;
      } else {
        if (!this._validate(attrs, options)) return false;
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      var model = this;
      var success = options.success;
      var attributes = this.attributes;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
        if (wait) serverAttrs = _.extend({}, attrs, serverAttrs);
        if (serverAttrs && !model.set(serverAttrs, options)) return false;
        if (success) success.call(options.context, model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      // Set temporary attributes if `{wait: true}` to properly find new ids.
      if (attrs && wait) this.attributes = _.extend({}, attributes, attrs);

      var method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch' && !options.attrs) options.attrs = attrs;
      var xhr = this.sync(method, this, options);

      // Restore attributes.
      this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;
      var wait = options.wait;

      var destroy = function() {
        model.stopListening();
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (wait) destroy();
        if (success) success.call(options.context, model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      var xhr = false;
      if (this.isNew()) {
        _.defer(options.success);
      } else {
        wrapError(this, options);
        xhr = this.sync('delete', this, options);
      }
      if (!wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base =
        _.result(this, 'urlRoot') ||
        _.result(this.collection, 'url') ||
        urlError();
      if (this.isNew()) return base;
      var id = this.get(this.idAttribute);
      return base.replace(/[^\/]$/, '$&/') + encodeURIComponent(id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return !this.has(this.idAttribute);
    },

    // Check if the model is currently in a valid state.
    isValid: function(options) {
      return this._validate({}, _.defaults({validate: true}, options));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
      return false;
    }

  });

  // Underscore methods that we want to implement on the Model.
  var modelMethods = { keys: 1, values: 1, pairs: 1, invert: 1, pick: 0,
      omit: 0, chain: 1, isEmpty: 1 };

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  addUnderscoreMethods(Model, modelMethods, 'attributes');

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analogous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, remove: false};

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model) { return model.toJSON(options); });
    },

    // Proxy `Backbone.sync` by default.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set.
    add: function(models, options) {
      return this.set(models, _.extend({merge: false}, options, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      options = _.extend({}, options);
      var singular = !_.isArray(models);
      models = singular ? [models] : _.clone(models);
      var removed = this._removeModels(models, options);
      if (!options.silent && removed) this.trigger('update', this, options);
      return singular ? removed[0] : removed;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      options = _.defaults({}, options, setOptions);
      if (options.parse && !this._isModel(models)) models = this.parse(models, options);
      var singular = !_.isArray(models);
      models = singular ? (models ? [models] : []) : models.slice();
      var id, model, attrs, existing, sort;
      var at = options.at;
      if (at != null) at = +at;
      if (at < 0) at += this.length + 1;
      var sortable = this.comparator && (at == null) && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
      var toAdd = [], toRemove = [], modelMap = {};
      var add = options.add, merge = options.merge, remove = options.remove;
      var order = !sortable && add && remove ? [] : false;
      var orderChanged = false;

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      for (var i = 0; i < models.length; i++) {
        attrs = models[i];

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        if (existing = this.get(attrs)) {
          if (remove) modelMap[existing.cid] = true;
          if (merge && attrs !== existing) {
            attrs = this._isModel(attrs) ? attrs.attributes : attrs;
            if (options.parse) attrs = existing.parse(attrs, options);
            existing.set(attrs, options);
            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
          }
          models[i] = existing;

        // If this is a new, valid model, push it to the `toAdd` list.
        } else if (add) {
          model = models[i] = this._prepareModel(attrs, options);
          if (!model) continue;
          toAdd.push(model);
          this._addReference(model, options);
        }

        // Do not add multiple models with the same `id`.
        model = existing || model;
        if (!model) continue;
        id = this.modelId(model.attributes);
        if (order && (model.isNew() || !modelMap[id])) {
          order.push(model);

          // Check to see if this is actually a new model at this index.
          orderChanged = orderChanged || !this.models[i] || model.cid !== this.models[i].cid;
        }

        modelMap[id] = true;
      }

      // Remove nonexistent models if appropriate.
      if (remove) {
        for (var i = 0; i < this.length; i++) {
          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
        }
        if (toRemove.length) this._removeModels(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      if (toAdd.length || orderChanged) {
        if (sortable) sort = true;
        this.length += toAdd.length;
        if (at != null) {
          for (var i = 0; i < toAdd.length; i++) {
            this.models.splice(at + i, 0, toAdd[i]);
          }
        } else {
          if (order) this.models.length = 0;
          var orderedModels = order || toAdd;
          for (var i = 0; i < orderedModels.length; i++) {
            this.models.push(orderedModels[i]);
          }
        }
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      // Unless silenced, it's time to fire all appropriate add/sort events.
      if (!options.silent) {
        var addOpts = at != null ? _.clone(options) : options;
        for (var i = 0; i < toAdd.length; i++) {
          if (at != null) addOpts.index = at + i;
          (model = toAdd[i]).trigger('add', model, this, addOpts);
        }
        if (sort || orderChanged) this.trigger('sort', this, options);
        if (toAdd.length || toRemove.length) this.trigger('update', this, options);
      }

      // Return the added (or merged) model (or models).
      return singular ? models[0] : models;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options = options ? _.clone(options) : {};
      for (var i = 0; i < this.models.length; i++) {
        this._removeReference(this.models[i], options);
      }
      options.previousModels = this.models;
      this._reset();
      models = this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return models;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      return this.add(model, _.extend({at: this.length}, options));
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      return this.remove(model, options);
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      return this.add(model, _.extend({at: 0}, options));
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      return this.remove(model, options);
    },

    // Slice out a sub-array of models from the collection.
    slice: function() {
      return slice.apply(this.models, arguments);
    },

    // Get a model from the set by id.
    get: function(obj) {
      if (obj == null) return void 0;
      var id = this.modelId(this._isModel(obj) ? obj.attributes : obj);
      return this._byId[obj] || this._byId[id] || this._byId[obj.cid];
    },

    // Get the model at the given index.
    at: function(index) {
      if (index < 0) index += this.length;
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {
      var matches = _.matches(attrs);
      return this[first ? 'find' : 'filter'](function(model) {
        return matches(model.attributes);
      });
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      // Run sort based on type of `comparator`.
      if (_.isString(this.comparator) || this.comparator.length === 1) {
        this.models = this.sortBy(this.comparator, this);
      } else {
        this.models.sort(_.bind(this.comparator, this));
      }

      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.invoke(this.models, 'get', attr);
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = _.extend({parse: true}, options);
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success.call(options.context, collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      var wait = options.wait;
      model = this._prepareModel(model, options);
      if (!model) return false;
      if (!wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(model, resp, callbackOpts) {
        if (wait) collection.add(model, callbackOpts);
        if (success) success.call(callbackOpts.context, model, resp, callbackOpts);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function() {
      return new this.constructor(this.models, {
        model: this.model,
        comparator: this.comparator
      });
    },

    // Define how to uniquely identify models in the collection.
    modelId: function (attrs) {
      return attrs[this.model.prototype.idAttribute || 'id'];
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (this._isModel(attrs)) {
        if (!attrs.collection) attrs.collection = this;
        return attrs;
      }
      options = options ? _.clone(options) : {};
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model.validationError) return model;
      this.trigger('invalid', this, model.validationError, options);
      return false;
    },

    // Internal method called by both remove and set.
    // Returns removed models, or false if nothing is removed.
    _removeModels: function(models, options) {
      var removed = [];
      for (var i = 0; i < models.length; i++) {
        var model = this.get(models[i]);
        if (!model) continue;

        var index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;

        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }

        removed.push(model);
        this._removeReference(model, options);
      }
      return removed.length ? removed : false;
    },

    // Method for checking whether an object should be considered a model for
    // the purposes of adding to the collection.
    _isModel: function (model) {
      return model instanceof Model;
    },

    // Internal method to create a model's ties to a collection.
    _addReference: function(model, options) {
      this._byId[model.cid] = model;
      var id = this.modelId(model.attributes);
      if (id != null) this._byId[id] = model;
      model.on('all', this._onModelEvent, this);
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model, options) {
      delete this._byId[model.cid];
      var id = this.modelId(model.attributes);
      if (id != null) delete this._byId[id];
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event === 'add' || event === 'remove') && collection !== this) return;
      if (event === 'destroy') this.remove(model, options);
      if (event === 'change') {
        var prevId = this.modelId(model.previousAttributes());
        var id = this.modelId(model.attributes);
        if (prevId !== id) {
          if (prevId != null) delete this._byId[prevId];
          if (id != null) this._byId[id] = model;
        }
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var collectionMethods = { forEach: 3, each: 3, map: 3, collect: 3, reduce: 4,
      foldl: 4, inject: 4, reduceRight: 4, foldr: 4, find: 3, detect: 3, filter: 3,
      select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 2,
      contains: 2, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3,
      head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3,
      without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3,
      isEmpty: 1, chain: 1, sample: 3, partition: 3 };

  // Mix in each Underscore method as a proxy to `Collection#models`.
  addUnderscoreMethods(Collection, collectionMethods, 'models');

  // Underscore methods that take a property name as an argument.
  var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];

  // Use attributes instead of properties.
  _.each(attributeMethods, function(method) {
    if (!_[method]) return;
    Collection.prototype[method] = function(value, context) {
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _[method](this.models, iterator, context);
    };
  });

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    _.extend(this, _.pick(options, viewOptions));
    this._ensureElement();
    this.initialize.apply(this, arguments);
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be merged as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be preferred to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {
      this._removeElement();
      this.stopListening();
      return this;
    },

    // Remove this view's element from the document and all event listeners
    // attached to it. Exposed for subclasses using an alternative DOM
    // manipulation API.
    _removeElement: function() {
      this.$el.remove();
    },

    // Change the view's element (`this.el` property) and re-delegate the
    // view's events on the new element.
    setElement: function(element) {
      this.undelegateEvents();
      this._setElement(element);
      this.delegateEvents();
      return this;
    },

    // Creates the `this.el` and `this.$el` references for this view using the
    // given `el`. `el` can be a CSS selector or an HTML string, a jQuery
    // context or an element. Subclasses can override this to utilize an
    // alternative DOM manipulation API and are only required to set the
    // `this.el` property.
    _setElement: function(el) {
      this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);
      this.el = this.$el[0];
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save',
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    delegateEvents: function(events) {
      events || (events = _.result(this, 'events'));
      if (!events) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[method];
        if (!method) continue;
        var match = key.match(delegateEventSplitter);
        this.delegate(match[1], match[2], _.bind(method, this));
      }
      return this;
    },

    // Add a single event listener to the view's element (or a child element
    // using `selector`). This only works for delegate-able events: not `focus`,
    // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
    delegate: function(eventName, selector, listener) {
      this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);
      return this;
    },

    // Clears all callbacks previously bound to the view by `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      if (this.$el) this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // A finer-grained `undelegateEvents` for removing a single delegated event.
    // `selector` and `listener` are both optional.
    undelegate: function(eventName, selector, listener) {
      this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);
      return this;
    },

    // Produces a DOM element to be assigned to your view. Exposed for
    // subclasses using an alternative DOM manipulation API.
    _createElement: function(tagName) {
      return document.createElement(tagName);
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        this.setElement(this._createElement(_.result(this, 'tagName')));
        this._setAttributes(attrs);
      } else {
        this.setElement(_.result(this, 'el'));
      }
    },

    // Set attributes from a hash on this view's element.  Exposed for
    // subclasses using an alternative DOM manipulation API.
    _setAttributes: function(attributes) {
      this.$el.attr(attributes);
    }

  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // Pass along `textStatus` and `errorThrown` from jQuery.
    var error = options.error;
    options.error = function(xhr, textStatus, errorThrown) {
      options.textStatus = textStatus;
      options.errorThrown = errorThrown;
      if (error) error.call(options.context, xhr, textStatus, errorThrown);
    };

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {
        var args = router._extractParameters(route, fragment);
        if (router.execute(callback, args, name) !== false) {
          router.trigger.apply(router, ['route:' + name].concat(args));
          router.trigger('route', name, args);
          Backbone.history.trigger('route', router, name, args);
        }
      });
      return this;
    },

    // Execute a route handler with the provided parameters.  This is an
    // excellent place to do pre-route setup or post-route cleanup.
    execute: function(callback, args, name) {
      if (callback) callback.apply(this, args);
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(optionalParam, '(?:$1)?')
                   .replace(namedParam, function(match, optional) {
                     return optional ? match : '([^/?]+)';
                   })
                   .replace(splatParam, '([^?]*?)');
      return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function(param, i) {
        // Don't decode the search params.
        if (i === params.length - 1) return param || null;
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    _.bindAll(this, 'checkUrl');

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for stripping urls of hash.
  var pathStripper = /#.*$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Are we at the app root?
    atRoot: function() {
      var path = this.location.pathname.replace(/[^\/]$/, '$&/');
      return path === this.root && !this.getSearch();
    },

    // Does the pathname match the root?
    matchRoot: function() {
      var path = this.decodeFragment(this.location.pathname);
      var root = path.slice(0, this.root.length - 1) + '/';
      return root === this.root;
    },

    // Unicode characters in `location.pathname` are percent encoded so they're
    // decoded for comparison. `%25` should not be decoded since it may be part
    // of an encoded parameter.
    decodeFragment: function(fragment) {
      return decodeURI(fragment.replace(/%25/g, '%2525'));
    },

    // In IE6, the hash fragment and search params are incorrect if the
    // fragment contains `?`.
    getSearch: function() {
      var match = this.location.href.replace(/#.*/, '').match(/\?.+/);
      return match ? match[0] : '';
    },

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the pathname and search params, without the root.
    getPath: function() {
      var path = this.decodeFragment(
        this.location.pathname + this.getSearch()
      ).slice(this.root.length - 1);
      return path.charAt(0) === '/' ? path.slice(1) : path;
    },

    // Get the cross-browser normalized URL fragment from the path or hash.
    getFragment: function(fragment) {
      if (fragment == null) {
        if (this._usePushState || !this._wantsHashChange) {
          fragment = this.getPath();
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error('Backbone.history has already been started');
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._hasHashChange   = 'onhashchange' in window;
      this._useHashChange   = this._wantsHashChange && this._hasHashChange;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.history && this.history.pushState);
      this._usePushState    = this._wantsPushState && this._hasPushState;
      this.fragment         = this.getFragment();

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      // Transition from hashChange to pushState or vice versa if both are
      // requested.
      if (this._wantsHashChange && this._wantsPushState) {

        // If we've started off with a route from a `pushState`-enabled
        // browser, but we're currently in a browser that doesn't support it...
        if (!this._hasPushState && !this.atRoot()) {
          var root = this.root.slice(0, -1) || '/';
          this.location.replace(root + '#' + this.getPath());
          // Return immediately as browser will do redirect to new url
          return true;

        // Or if we've started out with a hash-based route, but we're currently
        // in a browser where it could be `pushState`-based instead...
        } else if (this._hasPushState && this.atRoot()) {
          this.navigate(this.getHash(), {replace: true});
        }

      }

      // Proxy an iframe to handle location events if the browser doesn't
      // support the `hashchange` event, HTML5 history, or the user wants
      // `hashChange` but not `pushState`.
      if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
        this.iframe = document.createElement('iframe');
        this.iframe.src = 'javascript:0';
        this.iframe.style.display = 'none';
        this.iframe.tabIndex = -1;
        var body = document.body;
        // Using `appendChild` will throw on IE < 9 if the document is not ready.
        var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
        iWindow.document.open();
        iWindow.document.close();
        iWindow.location.hash = '#' + this.fragment;
      }

      // Add a cross-platform `addEventListener` shim for older browsers.
      var addEventListener = window.addEventListener || function (eventName, listener) {
        return attachEvent('on' + eventName, listener);
      };

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._usePushState) {
        addEventListener('popstate', this.checkUrl, false);
      } else if (this._useHashChange && !this.iframe) {
        addEventListener('hashchange', this.checkUrl, false);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      // Add a cross-platform `removeEventListener` shim for older browsers.
      var removeEventListener = window.removeEventListener || function (eventName, listener) {
        return detachEvent('on' + eventName, listener);
      };

      // Remove window listeners.
      if (this._usePushState) {
        removeEventListener('popstate', this.checkUrl, false);
      } else if (this._useHashChange && !this.iframe) {
        removeEventListener('hashchange', this.checkUrl, false);
      }

      // Clean up the iframe if necessary.
      if (this.iframe) {
        document.body.removeChild(this.iframe);
        this.iframe = null;
      }

      // Some environments will throw when clearing an undefined interval.
      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();

      // If the user pressed the back button, the iframe's hash will have
      // changed and we should use that for comparison.
      if (current === this.fragment && this.iframe) {
        current = this.getHash(this.iframe.contentWindow);
      }

      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl();
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragment) {
      // If the root doesn't match, no routes can match either.
      if (!this.matchRoot()) return false;
      fragment = this.fragment = this.getFragment(fragment);
      return _.any(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: !!options};

      // Normalize the fragment.
      fragment = this.getFragment(fragment || '');

      // Don't include a trailing slash on the root.
      var root = this.root;
      if (fragment === '' || fragment.charAt(0) === '?') {
        root = root.slice(0, -1) || '/';
      }
      var url = root + fragment;

      // Strip the hash and decode for matching.
      fragment = this.decodeFragment(fragment.replace(pathStripper, ''));

      if (this.fragment === fragment) return;
      this.fragment = fragment;

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._usePushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && (fragment !== this.getHash(this.iframe.contentWindow))) {
          var iWindow = this.iframe.contentWindow;

          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if (!options.replace) {
            iWindow.document.open();
            iWindow.document.close();
          }

          this._updateHash(iWindow.location, fragment, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) return this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent` constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error.call(options.context, model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

  return Backbone;

}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9iYWNrYm9uZS9iYWNrYm9uZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiLy8gICAgIEJhY2tib25lLmpzIDEuMi4xXG5cbi8vICAgICAoYykgMjAxMC0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgQmFja2JvbmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4vLyAgICAgRm9yIGFsbCBkZXRhaWxzIGFuZCBkb2N1bWVudGF0aW9uOlxuLy8gICAgIGh0dHA6Ly9iYWNrYm9uZWpzLm9yZ1xuXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xuXG4gIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIChgc2VsZmApIGluIHRoZSBicm93c2VyLCBvciBgZ2xvYmFsYCBvbiB0aGUgc2VydmVyLlxuICAvLyBXZSB1c2UgYHNlbGZgIGluc3RlYWQgb2YgYHdpbmRvd2AgZm9yIGBXZWJXb3JrZXJgIHN1cHBvcnQuXG4gIHZhciByb290ID0gKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PSBzZWxmICYmIHNlbGYpIHx8XG4gICAgICAgICAgICAodHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwuZ2xvYmFsID09IGdsb2JhbCAmJiBnbG9iYWwpO1xuXG4gIC8vIFNldCB1cCBCYWNrYm9uZSBhcHByb3ByaWF0ZWx5IGZvciB0aGUgZW52aXJvbm1lbnQuIFN0YXJ0IHdpdGggQU1ELlxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsndW5kZXJzY29yZScsICdqcXVlcnknLCAnZXhwb3J0cyddLCBmdW5jdGlvbihfLCAkLCBleHBvcnRzKSB7XG4gICAgICAvLyBFeHBvcnQgZ2xvYmFsIGV2ZW4gaW4gQU1EIGNhc2UgaW4gY2FzZSB0aGlzIHNjcmlwdCBpcyBsb2FkZWQgd2l0aFxuICAgICAgLy8gb3RoZXJzIHRoYXQgbWF5IHN0aWxsIGV4cGVjdCBhIGdsb2JhbCBCYWNrYm9uZS5cbiAgICAgIHJvb3QuQmFja2JvbmUgPSBmYWN0b3J5KHJvb3QsIGV4cG9ydHMsIF8sICQpO1xuICAgIH0pO1xuXG4gIC8vIE5leHQgZm9yIE5vZGUuanMgb3IgQ29tbW9uSlMuIGpRdWVyeSBtYXkgbm90IGJlIG5lZWRlZCBhcyBhIG1vZHVsZS5cbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKSwgJDtcbiAgICB0cnkgeyAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7IH0gY2F0Y2goZSkge31cbiAgICBmYWN0b3J5KHJvb3QsIGV4cG9ydHMsIF8sICQpO1xuXG4gIC8vIEZpbmFsbHksIGFzIGEgYnJvd3NlciBnbG9iYWwuXG4gIH0gZWxzZSB7XG4gICAgcm9vdC5CYWNrYm9uZSA9IGZhY3Rvcnkocm9vdCwge30sIHJvb3QuXywgKHJvb3QualF1ZXJ5IHx8IHJvb3QuWmVwdG8gfHwgcm9vdC5lbmRlciB8fCByb290LiQpKTtcbiAgfVxuXG59KGZ1bmN0aW9uKHJvb3QsIEJhY2tib25lLCBfLCAkKSB7XG5cbiAgLy8gSW5pdGlhbCBTZXR1cFxuICAvLyAtLS0tLS0tLS0tLS0tXG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBCYWNrYm9uZWAgdmFyaWFibGUsIHNvIHRoYXQgaXQgY2FuIGJlXG4gIC8vIHJlc3RvcmVkIGxhdGVyIG9uLCBpZiBgbm9Db25mbGljdGAgaXMgdXNlZC5cbiAgdmFyIHByZXZpb3VzQmFja2JvbmUgPSByb290LkJhY2tib25lO1xuXG4gIC8vIENyZWF0ZSBhIGxvY2FsIHJlZmVyZW5jZSB0byBhIGNvbW1vbiBhcnJheSBtZXRob2Qgd2UnbGwgd2FudCB0byB1c2UgbGF0ZXIuXG4gIHZhciBzbGljZSA9IFtdLnNsaWNlO1xuXG4gIC8vIEN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgbGlicmFyeS4gS2VlcCBpbiBzeW5jIHdpdGggYHBhY2thZ2UuanNvbmAuXG4gIEJhY2tib25lLlZFUlNJT04gPSAnMS4yLjEnO1xuXG4gIC8vIEZvciBCYWNrYm9uZSdzIHB1cnBvc2VzLCBqUXVlcnksIFplcHRvLCBFbmRlciwgb3IgTXkgTGlicmFyeSAoa2lkZGluZykgb3duc1xuICAvLyB0aGUgYCRgIHZhcmlhYmxlLlxuICBCYWNrYm9uZS4kID0gJDtcblxuICAvLyBSdW5zIEJhY2tib25lLmpzIGluICpub0NvbmZsaWN0KiBtb2RlLCByZXR1cm5pbmcgdGhlIGBCYWNrYm9uZWAgdmFyaWFibGVcbiAgLy8gdG8gaXRzIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoaXMgQmFja2JvbmUgb2JqZWN0LlxuICBCYWNrYm9uZS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5CYWNrYm9uZSA9IHByZXZpb3VzQmFja2JvbmU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gVHVybiBvbiBgZW11bGF0ZUhUVFBgIHRvIHN1cHBvcnQgbGVnYWN5IEhUVFAgc2VydmVycy4gU2V0dGluZyB0aGlzIG9wdGlvblxuICAvLyB3aWxsIGZha2UgYFwiUEFUQ0hcImAsIGBcIlBVVFwiYCBhbmQgYFwiREVMRVRFXCJgIHJlcXVlc3RzIHZpYSB0aGUgYF9tZXRob2RgIHBhcmFtZXRlciBhbmRcbiAgLy8gc2V0IGEgYFgtSHR0cC1NZXRob2QtT3ZlcnJpZGVgIGhlYWRlci5cbiAgQmFja2JvbmUuZW11bGF0ZUhUVFAgPSBmYWxzZTtcblxuICAvLyBUdXJuIG9uIGBlbXVsYXRlSlNPTmAgdG8gc3VwcG9ydCBsZWdhY3kgc2VydmVycyB0aGF0IGNhbid0IGRlYWwgd2l0aCBkaXJlY3RcbiAgLy8gYGFwcGxpY2F0aW9uL2pzb25gIHJlcXVlc3RzIC4uLiB0aGlzIHdpbGwgZW5jb2RlIHRoZSBib2R5IGFzXG4gIC8vIGBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRgIGluc3RlYWQgYW5kIHdpbGwgc2VuZCB0aGUgbW9kZWwgaW4gYVxuICAvLyBmb3JtIHBhcmFtIG5hbWVkIGBtb2RlbGAuXG4gIEJhY2tib25lLmVtdWxhdGVKU09OID0gZmFsc2U7XG5cbiAgLy8gUHJveHkgVW5kZXJzY29yZSBtZXRob2RzIHRvIGEgQmFja2JvbmUgY2xhc3MnIHByb3RvdHlwZSB1c2luZyBhXG4gIC8vIHBhcnRpY3VsYXIgYXR0cmlidXRlIGFzIHRoZSBkYXRhIGFyZ3VtZW50XG4gIHZhciBhZGRNZXRob2QgPSBmdW5jdGlvbihsZW5ndGgsIG1ldGhvZCwgYXR0cmlidXRlKSB7XG4gICAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX1ttZXRob2RdKHRoaXNbYXR0cmlidXRlXSk7XG4gICAgICB9O1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9bbWV0aG9kXSh0aGlzW2F0dHJpYnV0ZV0sIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gX1ttZXRob2RdKHRoaXNbYXR0cmlidXRlXSwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGl0ZXJhdGVlLCBkZWZhdWx0VmFsLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBfW21ldGhvZF0odGhpc1thdHRyaWJ1dGVdLCBpdGVyYXRlZSwgZGVmYXVsdFZhbCwgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgZGVmYXVsdDogcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgYXJncy51bnNoaWZ0KHRoaXNbYXR0cmlidXRlXSk7XG4gICAgICAgIHJldHVybiBfW21ldGhvZF0uYXBwbHkoXywgYXJncyk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgdmFyIGFkZFVuZGVyc2NvcmVNZXRob2RzID0gZnVuY3Rpb24oQ2xhc3MsIG1ldGhvZHMsIGF0dHJpYnV0ZSkge1xuICAgIF8uZWFjaChtZXRob2RzLCBmdW5jdGlvbihsZW5ndGgsIG1ldGhvZCkge1xuICAgICAgaWYgKF9bbWV0aG9kXSkgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBhZGRNZXRob2QobGVuZ3RoLCBtZXRob2QsIGF0dHJpYnV0ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQmFja2JvbmUuRXZlbnRzXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEEgbW9kdWxlIHRoYXQgY2FuIGJlIG1peGVkIGluIHRvICphbnkgb2JqZWN0KiBpbiBvcmRlciB0byBwcm92aWRlIGl0IHdpdGhcbiAgLy8gY3VzdG9tIGV2ZW50cy4gWW91IG1heSBiaW5kIHdpdGggYG9uYCBvciByZW1vdmUgd2l0aCBgb2ZmYCBjYWxsYmFja1xuICAvLyBmdW5jdGlvbnMgdG8gYW4gZXZlbnQ7IGB0cmlnZ2VyYC1pbmcgYW4gZXZlbnQgZmlyZXMgYWxsIGNhbGxiYWNrcyBpblxuICAvLyBzdWNjZXNzaW9uLlxuICAvL1xuICAvLyAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAvLyAgICAgXy5leHRlbmQob2JqZWN0LCBCYWNrYm9uZS5FdmVudHMpO1xuICAvLyAgICAgb2JqZWN0Lm9uKCdleHBhbmQnLCBmdW5jdGlvbigpeyBhbGVydCgnZXhwYW5kZWQnKTsgfSk7XG4gIC8vICAgICBvYmplY3QudHJpZ2dlcignZXhwYW5kJyk7XG4gIC8vXG4gIHZhciBFdmVudHMgPSBCYWNrYm9uZS5FdmVudHMgPSB7fTtcblxuICAvLyBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byBzcGxpdCBldmVudCBzdHJpbmdzLlxuICB2YXIgZXZlbnRTcGxpdHRlciA9IC9cXHMrLztcblxuICAvLyBJdGVyYXRlcyBvdmVyIHRoZSBzdGFuZGFyZCBgZXZlbnQsIGNhbGxiYWNrYCAoYXMgd2VsbCBhcyB0aGUgZmFuY3kgbXVsdGlwbGVcbiAgLy8gc3BhY2Utc2VwYXJhdGVkIGV2ZW50cyBgXCJjaGFuZ2UgYmx1clwiLCBjYWxsYmFja2AgYW5kIGpRdWVyeS1zdHlsZSBldmVudFxuICAvLyBtYXBzIGB7ZXZlbnQ6IGNhbGxiYWNrfWApLCByZWR1Y2luZyB0aGVtIGJ5IG1hbmlwdWxhdGluZyBgbWVtb2AuXG4gIC8vIFBhc3NlcyBhIG5vcm1hbGl6ZWQgc2luZ2xlIGV2ZW50IG5hbWUgYW5kIGNhbGxiYWNrLCBhcyB3ZWxsIGFzIGFueVxuICAvLyBvcHRpb25hbCBgb3B0c2AuXG4gIHZhciBldmVudHNBcGkgPSBmdW5jdGlvbihpdGVyYXRlZSwgbWVtbywgbmFtZSwgY2FsbGJhY2ssIG9wdHMpIHtcbiAgICB2YXIgaSA9IDAsIG5hbWVzO1xuICAgIGlmIChuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gSGFuZGxlIGV2ZW50IG1hcHMuXG4gICAgICBpZiAoY2FsbGJhY2sgIT09IHZvaWQgMCAmJiAnY29udGV4dCcgaW4gb3B0cyAmJiBvcHRzLmNvbnRleHQgPT09IHZvaWQgMCkgb3B0cy5jb250ZXh0ID0gY2FsbGJhY2s7XG4gICAgICBmb3IgKG5hbWVzID0gXy5rZXlzKG5hbWUpOyBpIDwgbmFtZXMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBuYW1lc1tpXSwgbmFtZVtuYW1lc1tpXV0sIG9wdHMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmFtZSAmJiBldmVudFNwbGl0dGVyLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIEhhbmRsZSBzcGFjZSBzZXBhcmF0ZWQgZXZlbnQgbmFtZXMuXG4gICAgICBmb3IgKG5hbWVzID0gbmFtZS5zcGxpdChldmVudFNwbGl0dGVyKTsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBuYW1lc1tpXSwgY2FsbGJhY2ssIG9wdHMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZW1vID0gaXRlcmF0ZWUobWVtbywgbmFtZSwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIH1cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcblxuICAvLyBCaW5kIGFuIGV2ZW50IHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi4gUGFzc2luZyBgXCJhbGxcImAgd2lsbCBiaW5kXG4gIC8vIHRoZSBjYWxsYmFjayB0byBhbGwgZXZlbnRzIGZpcmVkLlxuICBFdmVudHMub24gPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIHJldHVybiBpbnRlcm5hbE9uKHRoaXMsIG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCB1c2UgYG9uYCBmdW5jdGlvbiwgdXNlZCB0byBndWFyZCB0aGUgYGxpc3RlbmluZ2AgYXJndW1lbnQgZnJvbVxuICAvLyB0aGUgcHVibGljIEFQSS5cbiAgdmFyIGludGVybmFsT24gPSBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0LCBsaXN0ZW5pbmcpIHtcbiAgICBvYmouX2V2ZW50cyA9IGV2ZW50c0FwaShvbkFwaSwgb2JqLl9ldmVudHMgfHwge30sIG5hbWUsIGNhbGxiYWNrLCB7XG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIGN0eDogb2JqLFxuICAgICAgICBsaXN0ZW5pbmc6IGxpc3RlbmluZ1xuICAgIH0pO1xuXG4gICAgaWYgKGxpc3RlbmluZykge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IG9iai5fbGlzdGVuZXJzIHx8IChvYmouX2xpc3RlbmVycyA9IHt9KTtcbiAgICAgIGxpc3RlbmVyc1tsaXN0ZW5pbmcuaWRdID0gbGlzdGVuaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gSW52ZXJzaW9uLW9mLWNvbnRyb2wgdmVyc2lvbnMgb2YgYG9uYC4gVGVsbCAqdGhpcyogb2JqZWN0IHRvIGxpc3RlbiB0b1xuICAvLyBhbiBldmVudCBpbiBhbm90aGVyIG9iamVjdC4uLiBrZWVwaW5nIHRyYWNrIG9mIHdoYXQgaXQncyBsaXN0ZW5pbmcgdG8uXG4gIEV2ZW50cy5saXN0ZW5UbyA9ICBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiB0aGlzO1xuICAgIHZhciBpZCA9IG9iai5fbGlzdGVuSWQgfHwgKG9iai5fbGlzdGVuSWQgPSBfLnVuaXF1ZUlkKCdsJykpO1xuICAgIHZhciBsaXN0ZW5pbmdUbyA9IHRoaXMuX2xpc3RlbmluZ1RvIHx8ICh0aGlzLl9saXN0ZW5pbmdUbyA9IHt9KTtcbiAgICB2YXIgbGlzdGVuaW5nID0gbGlzdGVuaW5nVG9baWRdO1xuXG4gICAgLy8gVGhpcyBvYmplY3QgaXMgbm90IGxpc3RlbmluZyB0byBhbnkgb3RoZXIgZXZlbnRzIG9uIGBvYmpgIHlldC5cbiAgICAvLyBTZXR1cCB0aGUgbmVjZXNzYXJ5IHJlZmVyZW5jZXMgdG8gdHJhY2sgdGhlIGxpc3RlbmluZyBjYWxsYmFja3MuXG4gICAgaWYgKCFsaXN0ZW5pbmcpIHtcbiAgICAgIHZhciB0aGlzSWQgPSB0aGlzLl9saXN0ZW5JZCB8fCAodGhpcy5fbGlzdGVuSWQgPSBfLnVuaXF1ZUlkKCdsJykpO1xuICAgICAgbGlzdGVuaW5nID0gbGlzdGVuaW5nVG9baWRdID0ge29iajogb2JqLCBvYmpJZDogaWQsIGlkOiB0aGlzSWQsIGxpc3RlbmluZ1RvOiBsaXN0ZW5pbmdUbywgY291bnQ6IDB9O1xuICAgIH1cblxuICAgIC8vIEJpbmQgY2FsbGJhY2tzIG9uIG9iaiwgYW5kIGtlZXAgdHJhY2sgb2YgdGhlbSBvbiBsaXN0ZW5pbmcuXG4gICAgaW50ZXJuYWxPbihvYmosIG5hbWUsIGNhbGxiYWNrLCB0aGlzLCBsaXN0ZW5pbmcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFRoZSByZWR1Y2luZyBBUEkgdGhhdCBhZGRzIGEgY2FsbGJhY2sgdG8gdGhlIGBldmVudHNgIG9iamVjdC5cbiAgdmFyIG9uQXBpID0gZnVuY3Rpb24oZXZlbnRzLCBuYW1lLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdIHx8IChldmVudHNbbmFtZV0gPSBbXSk7XG4gICAgICB2YXIgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dCwgY3R4ID0gb3B0aW9ucy5jdHgsIGxpc3RlbmluZyA9IG9wdGlvbnMubGlzdGVuaW5nO1xuICAgICAgaWYgKGxpc3RlbmluZykgbGlzdGVuaW5nLmNvdW50Kys7XG5cbiAgICAgIGhhbmRsZXJzLnB1c2goeyBjYWxsYmFjazogY2FsbGJhY2ssIGNvbnRleHQ6IGNvbnRleHQsIGN0eDogY29udGV4dCB8fCBjdHgsIGxpc3RlbmluZzogbGlzdGVuaW5nIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9O1xuXG4gIC8vIFJlbW92ZSBvbmUgb3IgbWFueSBjYWxsYmFja3MuIElmIGBjb250ZXh0YCBpcyBudWxsLCByZW1vdmVzIGFsbFxuICAvLyBjYWxsYmFja3Mgd2l0aCB0aGF0IGZ1bmN0aW9uLiBJZiBgY2FsbGJhY2tgIGlzIG51bGwsIHJlbW92ZXMgYWxsXG4gIC8vIGNhbGxiYWNrcyBmb3IgdGhlIGV2ZW50LiBJZiBgbmFtZWAgaXMgbnVsbCwgcmVtb3ZlcyBhbGwgYm91bmRcbiAgLy8gY2FsbGJhY2tzIGZvciBhbGwgZXZlbnRzLlxuICBFdmVudHMub2ZmID0gIGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiB0aGlzO1xuICAgIHRoaXMuX2V2ZW50cyA9IGV2ZW50c0FwaShvZmZBcGksIHRoaXMuX2V2ZW50cywgbmFtZSwgY2FsbGJhY2ssIHtcbiAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgbGlzdGVuZXJzOiB0aGlzLl9saXN0ZW5lcnNcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBUZWxsIHRoaXMgb2JqZWN0IHRvIHN0b3AgbGlzdGVuaW5nIHRvIGVpdGhlciBzcGVjaWZpYyBldmVudHMgLi4uIG9yXG4gIC8vIHRvIGV2ZXJ5IG9iamVjdCBpdCdzIGN1cnJlbnRseSBsaXN0ZW5pbmcgdG8uXG4gIEV2ZW50cy5zdG9wTGlzdGVuaW5nID0gIGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgbGlzdGVuaW5nVG8gPSB0aGlzLl9saXN0ZW5pbmdUbztcbiAgICBpZiAoIWxpc3RlbmluZ1RvKSByZXR1cm4gdGhpcztcblxuICAgIHZhciBpZHMgPSBvYmogPyBbb2JqLl9saXN0ZW5JZF0gOiBfLmtleXMobGlzdGVuaW5nVG8pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaXN0ZW5pbmcgPSBsaXN0ZW5pbmdUb1tpZHNbaV1dO1xuXG4gICAgICAvLyBJZiBsaXN0ZW5pbmcgZG9lc24ndCBleGlzdCwgdGhpcyBvYmplY3QgaXMgbm90IGN1cnJlbnRseVxuICAgICAgLy8gbGlzdGVuaW5nIHRvIG9iai4gQnJlYWsgb3V0IGVhcmx5LlxuICAgICAgaWYgKCFsaXN0ZW5pbmcpIGJyZWFrO1xuXG4gICAgICBsaXN0ZW5pbmcub2JqLm9mZihuYW1lLCBjYWxsYmFjaywgdGhpcyk7XG4gICAgfVxuICAgIGlmIChfLmlzRW1wdHkobGlzdGVuaW5nVG8pKSB0aGlzLl9saXN0ZW5pbmdUbyA9IHZvaWQgMDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFRoZSByZWR1Y2luZyBBUEkgdGhhdCByZW1vdmVzIGEgY2FsbGJhY2sgZnJvbSB0aGUgYGV2ZW50c2Agb2JqZWN0LlxuICB2YXIgb2ZmQXBpID0gZnVuY3Rpb24oZXZlbnRzLCBuYW1lLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIC8vIE5vIGV2ZW50cyB0byBjb25zaWRlci5cbiAgICBpZiAoIWV2ZW50cykgcmV0dXJuO1xuXG4gICAgdmFyIGkgPSAwLCBsaXN0ZW5pbmc7XG4gICAgdmFyIGNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQsIGxpc3RlbmVycyA9IG9wdGlvbnMubGlzdGVuZXJzO1xuXG4gICAgLy8gRGVsZXRlIGFsbCBldmVudHMgbGlzdGVuZXJzIGFuZCBcImRyb3BcIiBldmVudHMuXG4gICAgaWYgKCFuYW1lICYmICFjYWxsYmFjayAmJiAhY29udGV4dCkge1xuICAgICAgdmFyIGlkcyA9IF8ua2V5cyhsaXN0ZW5lcnMpO1xuICAgICAgZm9yICg7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGlzdGVuaW5nID0gbGlzdGVuZXJzW2lkc1tpXV07XG4gICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbbGlzdGVuaW5nLmlkXTtcbiAgICAgICAgZGVsZXRlIGxpc3RlbmluZy5saXN0ZW5pbmdUb1tsaXN0ZW5pbmcub2JqSWRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuYW1lcyA9IG5hbWUgPyBbbmFtZV0gOiBfLmtleXMoZXZlbnRzKTtcbiAgICBmb3IgKDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG5cbiAgICAgIC8vIEJhaWwgb3V0IGlmIHRoZXJlIGFyZSBubyBldmVudHMgc3RvcmVkLlxuICAgICAgaWYgKCFoYW5kbGVycykgYnJlYWs7XG5cbiAgICAgIC8vIFJlcGxhY2UgZXZlbnRzIGlmIHRoZXJlIGFyZSBhbnkgcmVtYWluaW5nLiAgT3RoZXJ3aXNlLCBjbGVhbiB1cC5cbiAgICAgIHZhciByZW1haW5pbmcgPSBbXTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVyc1tqXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrICE9PSBoYW5kbGVyLmNhbGxiYWNrICYmXG4gICAgICAgICAgICBjYWxsYmFjayAhPT0gaGFuZGxlci5jYWxsYmFjay5fY2FsbGJhY2sgfHxcbiAgICAgICAgICAgICAgY29udGV4dCAmJiBjb250ZXh0ICE9PSBoYW5kbGVyLmNvbnRleHRcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmVtYWluaW5nLnB1c2goaGFuZGxlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGlzdGVuaW5nID0gaGFuZGxlci5saXN0ZW5pbmc7XG4gICAgICAgICAgaWYgKGxpc3RlbmluZyAmJiAtLWxpc3RlbmluZy5jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1tsaXN0ZW5pbmcuaWRdO1xuICAgICAgICAgICAgZGVsZXRlIGxpc3RlbmluZy5saXN0ZW5pbmdUb1tsaXN0ZW5pbmcub2JqSWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdGFpbCBldmVudCBpZiB0aGUgbGlzdCBoYXMgYW55IGV2ZW50cy4gIE90aGVyd2lzZSwgY2xlYW4gdXAuXG4gICAgICBpZiAocmVtYWluaW5nLmxlbmd0aCkge1xuICAgICAgICBldmVudHNbbmFtZV0gPSByZW1haW5pbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgZXZlbnRzW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoXy5zaXplKGV2ZW50cykpIHJldHVybiBldmVudHM7XG4gIH07XG5cbiAgLy8gQmluZCBhbiBldmVudCB0byBvbmx5IGJlIHRyaWdnZXJlZCBhIHNpbmdsZSB0aW1lLiBBZnRlciB0aGUgZmlyc3QgdGltZVxuICAvLyB0aGUgY2FsbGJhY2sgaXMgaW52b2tlZCwgaXQgd2lsbCBiZSByZW1vdmVkLiBXaGVuIG11bHRpcGxlIGV2ZW50cyBhcmVcbiAgLy8gcGFzc2VkIGluIHVzaW5nIHRoZSBzcGFjZS1zZXBhcmF0ZWQgc3ludGF4LCB0aGUgZXZlbnQgd2lsbCBmaXJlIG9uY2UgZm9yIGV2ZXJ5XG4gIC8vIGV2ZW50IHlvdSBwYXNzZWQgaW4sIG5vdCBvbmNlIGZvciBhIGNvbWJpbmF0aW9uIG9mIGFsbCBldmVudHNcbiAgRXZlbnRzLm9uY2UgPSAgZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAvLyBNYXAgdGhlIGV2ZW50IGludG8gYSBge2V2ZW50OiBvbmNlfWAgb2JqZWN0LlxuICAgIHZhciBldmVudHMgPSBldmVudHNBcGkob25jZU1hcCwge30sIG5hbWUsIGNhbGxiYWNrLCBfLmJpbmQodGhpcy5vZmYsIHRoaXMpKTtcbiAgICByZXR1cm4gdGhpcy5vbihldmVudHMsIHZvaWQgMCwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gSW52ZXJzaW9uLW9mLWNvbnRyb2wgdmVyc2lvbnMgb2YgYG9uY2VgLlxuICBFdmVudHMubGlzdGVuVG9PbmNlID0gIGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAvLyBNYXAgdGhlIGV2ZW50IGludG8gYSBge2V2ZW50OiBvbmNlfWAgb2JqZWN0LlxuICAgIHZhciBldmVudHMgPSBldmVudHNBcGkob25jZU1hcCwge30sIG5hbWUsIGNhbGxiYWNrLCBfLmJpbmQodGhpcy5zdG9wTGlzdGVuaW5nLCB0aGlzLCBvYmopKTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5UbyhvYmosIGV2ZW50cyk7XG4gIH07XG5cbiAgLy8gUmVkdWNlcyB0aGUgZXZlbnQgY2FsbGJhY2tzIGludG8gYSBtYXAgb2YgYHtldmVudDogb25jZVdyYXBwZXJ9YC5cbiAgLy8gYG9mZmVyYCB1bmJpbmRzIHRoZSBgb25jZVdyYXBwZXJgIGFmdGVyIGl0IGhhcyBiZWVuIGNhbGxlZC5cbiAgdmFyIG9uY2VNYXAgPSBmdW5jdGlvbihtYXAsIG5hbWUsIGNhbGxiYWNrLCBvZmZlcikge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdmFyIG9uY2UgPSBtYXBbbmFtZV0gPSBfLm9uY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgIG9mZmVyKG5hbWUsIG9uY2UpO1xuICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgICBvbmNlLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9O1xuXG4gIC8vIFRyaWdnZXIgb25lIG9yIG1hbnkgZXZlbnRzLCBmaXJpbmcgYWxsIGJvdW5kIGNhbGxiYWNrcy4gQ2FsbGJhY2tzIGFyZVxuICAvLyBwYXNzZWQgdGhlIHNhbWUgYXJndW1lbnRzIGFzIGB0cmlnZ2VyYCBpcywgYXBhcnQgZnJvbSB0aGUgZXZlbnQgbmFtZVxuICAvLyAodW5sZXNzIHlvdSdyZSBsaXN0ZW5pbmcgb24gYFwiYWxsXCJgLCB3aGljaCB3aWxsIGNhdXNlIHlvdXIgY2FsbGJhY2sgdG9cbiAgLy8gcmVjZWl2ZSB0aGUgdHJ1ZSBuYW1lIG9mIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgYXJndW1lbnQpLlxuICBFdmVudHMudHJpZ2dlciA9ICBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiB0aGlzO1xuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KDAsIGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG5cbiAgICBldmVudHNBcGkodHJpZ2dlckFwaSwgdGhpcy5fZXZlbnRzLCBuYW1lLCB2b2lkIDAsIGFyZ3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEhhbmRsZXMgdHJpZ2dlcmluZyB0aGUgYXBwcm9wcmlhdGUgZXZlbnQgY2FsbGJhY2tzLlxuICB2YXIgdHJpZ2dlckFwaSA9IGZ1bmN0aW9uKG9iakV2ZW50cywgbmFtZSwgY2IsIGFyZ3MpIHtcbiAgICBpZiAob2JqRXZlbnRzKSB7XG4gICAgICB2YXIgZXZlbnRzID0gb2JqRXZlbnRzW25hbWVdO1xuICAgICAgdmFyIGFsbEV2ZW50cyA9IG9iakV2ZW50cy5hbGw7XG4gICAgICBpZiAoZXZlbnRzICYmIGFsbEV2ZW50cykgYWxsRXZlbnRzID0gYWxsRXZlbnRzLnNsaWNlKCk7XG4gICAgICBpZiAoZXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGV2ZW50cywgYXJncyk7XG4gICAgICBpZiAoYWxsRXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGFsbEV2ZW50cywgW25hbWVdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmpFdmVudHM7XG4gIH07XG5cbiAgLy8gQSBkaWZmaWN1bHQtdG8tYmVsaWV2ZSwgYnV0IG9wdGltaXplZCBpbnRlcm5hbCBkaXNwYXRjaCBmdW5jdGlvbiBmb3JcbiAgLy8gdHJpZ2dlcmluZyBldmVudHMuIFRyaWVzIHRvIGtlZXAgdGhlIHVzdWFsIGNhc2VzIHNwZWVkeSAobW9zdCBpbnRlcm5hbFxuICAvLyBCYWNrYm9uZSBldmVudHMgaGF2ZSAzIGFyZ3VtZW50cykuXG4gIHZhciB0cmlnZ2VyRXZlbnRzID0gZnVuY3Rpb24oZXZlbnRzLCBhcmdzKSB7XG4gICAgdmFyIGV2LCBpID0gLTEsIGwgPSBldmVudHMubGVuZ3RoLCBhMSA9IGFyZ3NbMF0sIGEyID0gYXJnc1sxXSwgYTMgPSBhcmdzWzJdO1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgpOyByZXR1cm47XG4gICAgICBjYXNlIDE6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSk7IHJldHVybjtcbiAgICAgIGNhc2UgMjogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExLCBhMik7IHJldHVybjtcbiAgICAgIGNhc2UgMzogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExLCBhMiwgYTMpOyByZXR1cm47XG4gICAgICBkZWZhdWx0OiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5hcHBseShldi5jdHgsIGFyZ3MpOyByZXR1cm47XG4gICAgfVxuICB9O1xuXG4gIC8vIEFsaWFzZXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBFdmVudHMuYmluZCAgID0gRXZlbnRzLm9uO1xuICBFdmVudHMudW5iaW5kID0gRXZlbnRzLm9mZjtcblxuICAvLyBBbGxvdyB0aGUgYEJhY2tib25lYCBvYmplY3QgdG8gc2VydmUgYXMgYSBnbG9iYWwgZXZlbnQgYnVzLCBmb3IgZm9sa3Mgd2hvXG4gIC8vIHdhbnQgZ2xvYmFsIFwicHVic3ViXCIgaW4gYSBjb252ZW5pZW50IHBsYWNlLlxuICBfLmV4dGVuZChCYWNrYm9uZSwgRXZlbnRzKTtcblxuICAvLyBCYWNrYm9uZS5Nb2RlbFxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEJhY2tib25lICoqTW9kZWxzKiogYXJlIHRoZSBiYXNpYyBkYXRhIG9iamVjdCBpbiB0aGUgZnJhbWV3b3JrIC0tXG4gIC8vIGZyZXF1ZW50bHkgcmVwcmVzZW50aW5nIGEgcm93IGluIGEgdGFibGUgaW4gYSBkYXRhYmFzZSBvbiB5b3VyIHNlcnZlci5cbiAgLy8gQSBkaXNjcmV0ZSBjaHVuayBvZiBkYXRhIGFuZCBhIGJ1bmNoIG9mIHVzZWZ1bCwgcmVsYXRlZCBtZXRob2RzIGZvclxuICAvLyBwZXJmb3JtaW5nIGNvbXB1dGF0aW9ucyBhbmQgdHJhbnNmb3JtYXRpb25zIG9uIHRoYXQgZGF0YS5cblxuICAvLyBDcmVhdGUgYSBuZXcgbW9kZWwgd2l0aCB0aGUgc3BlY2lmaWVkIGF0dHJpYnV0ZXMuIEEgY2xpZW50IGlkIChgY2lkYClcbiAgLy8gaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYW5kIGFzc2lnbmVkIGZvciB5b3UuXG4gIHZhciBNb2RlbCA9IEJhY2tib25lLk1vZGVsID0gZnVuY3Rpb24oYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIHZhciBhdHRycyA9IGF0dHJpYnV0ZXMgfHwge307XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICB0aGlzLmNpZCA9IF8udW5pcXVlSWQodGhpcy5jaWRQcmVmaXgpO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIGlmIChvcHRpb25zLmNvbGxlY3Rpb24pIHRoaXMuY29sbGVjdGlvbiA9IG9wdGlvbnMuY29sbGVjdGlvbjtcbiAgICBpZiAob3B0aW9ucy5wYXJzZSkgYXR0cnMgPSB0aGlzLnBhcnNlKGF0dHJzLCBvcHRpb25zKSB8fCB7fTtcbiAgICBhdHRycyA9IF8uZGVmYXVsdHMoe30sIGF0dHJzLCBfLnJlc3VsdCh0aGlzLCAnZGVmYXVsdHMnKSk7XG4gICAgdGhpcy5zZXQoYXR0cnMsIG9wdGlvbnMpO1xuICAgIHRoaXMuY2hhbmdlZCA9IHt9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIEF0dGFjaCBhbGwgaW5oZXJpdGFibGUgbWV0aG9kcyB0byB0aGUgTW9kZWwgcHJvdG90eXBlLlxuICBfLmV4dGVuZChNb2RlbC5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgLy8gQSBoYXNoIG9mIGF0dHJpYnV0ZXMgd2hvc2UgY3VycmVudCBhbmQgcHJldmlvdXMgdmFsdWUgZGlmZmVyLlxuICAgIGNoYW5nZWQ6IG51bGwsXG5cbiAgICAvLyBUaGUgdmFsdWUgcmV0dXJuZWQgZHVyaW5nIHRoZSBsYXN0IGZhaWxlZCB2YWxpZGF0aW9uLlxuICAgIHZhbGlkYXRpb25FcnJvcjogbnVsbCxcblxuICAgIC8vIFRoZSBkZWZhdWx0IG5hbWUgZm9yIHRoZSBKU09OIGBpZGAgYXR0cmlidXRlIGlzIGBcImlkXCJgLiBNb25nb0RCIGFuZFxuICAgIC8vIENvdWNoREIgdXNlcnMgbWF5IHdhbnQgdG8gc2V0IHRoaXMgdG8gYFwiX2lkXCJgLlxuICAgIGlkQXR0cmlidXRlOiAnaWQnLFxuXG4gICAgLy8gVGhlIHByZWZpeCBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgY2xpZW50IGlkIHdoaWNoIGlzIHVzZWQgdG8gaWRlbnRpZnkgbW9kZWxzIGxvY2FsbHkuXG4gICAgLy8gWW91IG1heSB3YW50IHRvIG92ZXJyaWRlIHRoaXMgaWYgeW91J3JlIGV4cGVyaWVuY2luZyBuYW1lIGNsYXNoZXMgd2l0aCBtb2RlbCBpZHMuXG4gICAgY2lkUHJlZml4OiAnYycsXG5cbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBtb2RlbCdzIGBhdHRyaWJ1dGVzYCBvYmplY3QuXG4gICAgdG9KU09OOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gXy5jbG9uZSh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBQcm94eSBgQmFja2JvbmUuc3luY2AgYnkgZGVmYXVsdCAtLSBidXQgb3ZlcnJpZGUgdGhpcyBpZiB5b3UgbmVlZFxuICAgIC8vIGN1c3RvbSBzeW5jaW5nIHNlbWFudGljcyBmb3IgKnRoaXMqIHBhcnRpY3VsYXIgbW9kZWwuXG4gICAgc3luYzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQmFja2JvbmUuc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cbiAgICBnZXQ6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbYXR0cl07XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgSFRNTC1lc2NhcGVkIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cbiAgICBlc2NhcGU6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiBfLmVzY2FwZSh0aGlzLmdldChhdHRyKSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBhdHRyaWJ1dGUgY29udGFpbnMgYSB2YWx1ZSB0aGF0IGlzIG5vdCBudWxsXG4gICAgLy8gb3IgdW5kZWZpbmVkLlxuICAgIGhhczogZnVuY3Rpb24oYXR0cikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KGF0dHIpICE9IG51bGw7XG4gICAgfSxcblxuICAgIC8vIFNwZWNpYWwtY2FzZWQgcHJveHkgdG8gdW5kZXJzY29yZSdzIGBfLm1hdGNoZXNgIG1ldGhvZC5cbiAgICBtYXRjaGVzOiBmdW5jdGlvbihhdHRycykge1xuICAgICAgcmV0dXJuICEhXy5pdGVyYXRlZShhdHRycywgdGhpcykodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IGEgaGFzaCBvZiBtb2RlbCBhdHRyaWJ1dGVzIG9uIHRoZSBvYmplY3QsIGZpcmluZyBgXCJjaGFuZ2VcImAuIFRoaXMgaXNcbiAgICAvLyB0aGUgY29yZSBwcmltaXRpdmUgb3BlcmF0aW9uIG9mIGEgbW9kZWwsIHVwZGF0aW5nIHRoZSBkYXRhIGFuZCBub3RpZnlpbmdcbiAgICAvLyBhbnlvbmUgd2hvIG5lZWRzIHRvIGtub3cgYWJvdXQgdGhlIGNoYW5nZSBpbiBzdGF0ZS4gVGhlIGhlYXJ0IG9mIHRoZSBiZWFzdC5cbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsLCBvcHRpb25zKSB7XG4gICAgICBpZiAoa2V5ID09IG51bGwpIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBIYW5kbGUgYm90aCBgXCJrZXlcIiwgdmFsdWVgIGFuZCBge2tleTogdmFsdWV9YCAtc3R5bGUgYXJndW1lbnRzLlxuICAgICAgdmFyIGF0dHJzO1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGF0dHJzID0ga2V5O1xuICAgICAgICBvcHRpb25zID0gdmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKGF0dHJzID0ge30pW2tleV0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG5cbiAgICAgIC8vIFJ1biB2YWxpZGF0aW9uLlxuICAgICAgaWYgKCF0aGlzLl92YWxpZGF0ZShhdHRycywgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gRXh0cmFjdCBhdHRyaWJ1dGVzIGFuZCBvcHRpb25zLlxuICAgICAgdmFyIHVuc2V0ICAgICAgPSBvcHRpb25zLnVuc2V0O1xuICAgICAgdmFyIHNpbGVudCAgICAgPSBvcHRpb25zLnNpbGVudDtcbiAgICAgIHZhciBjaGFuZ2VzICAgID0gW107XG4gICAgICB2YXIgY2hhbmdpbmcgICA9IHRoaXMuX2NoYW5naW5nO1xuICAgICAgdGhpcy5fY2hhbmdpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIWNoYW5naW5nKSB7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcyA9IF8uY2xvbmUodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkID0ge307XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgdmFyIGNoYW5nZWQgPSB0aGlzLmNoYW5nZWQ7XG4gICAgICB2YXIgcHJldiAgICA9IHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcztcblxuICAgICAgLy8gQ2hlY2sgZm9yIGNoYW5nZXMgb2YgYGlkYC5cbiAgICAgIGlmICh0aGlzLmlkQXR0cmlidXRlIGluIGF0dHJzKSB0aGlzLmlkID0gYXR0cnNbdGhpcy5pZEF0dHJpYnV0ZV07XG5cbiAgICAgIC8vIEZvciBlYWNoIGBzZXRgIGF0dHJpYnV0ZSwgdXBkYXRlIG9yIGRlbGV0ZSB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgIGZvciAodmFyIGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgICAgdmFsID0gYXR0cnNbYXR0cl07XG4gICAgICAgIGlmICghXy5pc0VxdWFsKGN1cnJlbnRbYXR0cl0sIHZhbCkpIGNoYW5nZXMucHVzaChhdHRyKTtcbiAgICAgICAgaWYgKCFfLmlzRXF1YWwocHJldlthdHRyXSwgdmFsKSkge1xuICAgICAgICAgIGNoYW5nZWRbYXR0cl0gPSB2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGNoYW5nZWRbYXR0cl07XG4gICAgICAgIH1cbiAgICAgICAgdW5zZXQgPyBkZWxldGUgY3VycmVudFthdHRyXSA6IGN1cnJlbnRbYXR0cl0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIC8vIFRyaWdnZXIgYWxsIHJlbGV2YW50IGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMubGVuZ3RoKSB0aGlzLl9wZW5kaW5nID0gb3B0aW9ucztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2U6JyArIGNoYW5nZXNbaV0sIHRoaXMsIGN1cnJlbnRbY2hhbmdlc1tpXV0sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFlvdSBtaWdodCBiZSB3b25kZXJpbmcgd2h5IHRoZXJlJ3MgYSBgd2hpbGVgIGxvb3AgaGVyZS4gQ2hhbmdlcyBjYW5cbiAgICAgIC8vIGJlIHJlY3Vyc2l2ZWx5IG5lc3RlZCB3aXRoaW4gYFwiY2hhbmdlXCJgIGV2ZW50cy5cbiAgICAgIGlmIChjaGFuZ2luZykgcmV0dXJuIHRoaXM7XG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICB3aGlsZSAodGhpcy5fcGVuZGluZykge1xuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLl9wZW5kaW5nO1xuICAgICAgICAgIHRoaXMuX3BlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9wZW5kaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9jaGFuZ2luZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBhbiBhdHRyaWJ1dGUgZnJvbSB0aGUgbW9kZWwsIGZpcmluZyBgXCJjaGFuZ2VcImAuIGB1bnNldGAgaXMgYSBub29wXG4gICAgLy8gaWYgdGhlIGF0dHJpYnV0ZSBkb2Vzbid0IGV4aXN0LlxuICAgIHVuc2V0OiBmdW5jdGlvbihhdHRyLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoYXR0ciwgdm9pZCAwLCBfLmV4dGVuZCh7fSwgb3B0aW9ucywge3Vuc2V0OiB0cnVlfSkpO1xuICAgIH0sXG5cbiAgICAvLyBDbGVhciBhbGwgYXR0cmlidXRlcyBvbiB0aGUgbW9kZWwsIGZpcmluZyBgXCJjaGFuZ2VcImAuXG4gICAgY2xlYXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBhdHRycyA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuYXR0cmlidXRlcykgYXR0cnNba2V5XSA9IHZvaWQgMDtcbiAgICAgIHJldHVybiB0aGlzLnNldChhdHRycywgXy5leHRlbmQoe30sIG9wdGlvbnMsIHt1bnNldDogdHJ1ZX0pKTtcbiAgICB9LFxuXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBtb2RlbCBoYXMgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBgXCJjaGFuZ2VcImAgZXZlbnQuXG4gICAgLy8gSWYgeW91IHNwZWNpZnkgYW4gYXR0cmlidXRlIG5hbWUsIGRldGVybWluZSBpZiB0aGF0IGF0dHJpYnV0ZSBoYXMgY2hhbmdlZC5cbiAgICBoYXNDaGFuZ2VkOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICBpZiAoYXR0ciA9PSBudWxsKSByZXR1cm4gIV8uaXNFbXB0eSh0aGlzLmNoYW5nZWQpO1xuICAgICAgcmV0dXJuIF8uaGFzKHRoaXMuY2hhbmdlZCwgYXR0cik7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIGF0dHJpYnV0ZXMgdGhhdCBoYXZlIGNoYW5nZWQsIG9yXG4gICAgLy8gZmFsc2UgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZWQgYXR0cmlidXRlcy4gVXNlZnVsIGZvciBkZXRlcm1pbmluZyB3aGF0XG4gICAgLy8gcGFydHMgb2YgYSB2aWV3IG5lZWQgdG8gYmUgdXBkYXRlZCBhbmQvb3Igd2hhdCBhdHRyaWJ1dGVzIG5lZWQgdG8gYmVcbiAgICAvLyBwZXJzaXN0ZWQgdG8gdGhlIHNlcnZlci4gVW5zZXQgYXR0cmlidXRlcyB3aWxsIGJlIHNldCB0byB1bmRlZmluZWQuXG4gICAgLy8gWW91IGNhbiBhbHNvIHBhc3MgYW4gYXR0cmlidXRlcyBvYmplY3QgdG8gZGlmZiBhZ2FpbnN0IHRoZSBtb2RlbCxcbiAgICAvLyBkZXRlcm1pbmluZyBpZiB0aGVyZSAqd291bGQgYmUqIGEgY2hhbmdlLlxuICAgIGNoYW5nZWRBdHRyaWJ1dGVzOiBmdW5jdGlvbihkaWZmKSB7XG4gICAgICBpZiAoIWRpZmYpIHJldHVybiB0aGlzLmhhc0NoYW5nZWQoKSA/IF8uY2xvbmUodGhpcy5jaGFuZ2VkKSA6IGZhbHNlO1xuICAgICAgdmFyIG9sZCA9IHRoaXMuX2NoYW5naW5nID8gdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzIDogdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgdmFyIGNoYW5nZWQgPSB7fTtcbiAgICAgIGZvciAodmFyIGF0dHIgaW4gZGlmZikge1xuICAgICAgICB2YXIgdmFsID0gZGlmZlthdHRyXTtcbiAgICAgICAgaWYgKF8uaXNFcXVhbChvbGRbYXR0cl0sIHZhbCkpIGNvbnRpbnVlO1xuICAgICAgICBjaGFuZ2VkW2F0dHJdID0gdmFsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF8uc2l6ZShjaGFuZ2VkKSA/IGNoYW5nZWQgOiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBwcmV2aW91cyB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUsIHJlY29yZGVkIGF0IHRoZSB0aW1lIHRoZSBsYXN0XG4gICAgLy8gYFwiY2hhbmdlXCJgIGV2ZW50IHdhcyBmaXJlZC5cbiAgICBwcmV2aW91czogZnVuY3Rpb24oYXR0cikge1xuICAgICAgaWYgKGF0dHIgPT0gbnVsbCB8fCAhdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXNbYXR0cl07XG4gICAgfSxcblxuICAgIC8vIEdldCBhbGwgb2YgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIG1vZGVsIGF0IHRoZSB0aW1lIG9mIHRoZSBwcmV2aW91c1xuICAgIC8vIGBcImNoYW5nZVwiYCBldmVudC5cbiAgICBwcmV2aW91c0F0dHJpYnV0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF8uY2xvbmUodGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzKTtcbiAgICB9LFxuXG4gICAgLy8gRmV0Y2ggdGhlIG1vZGVsIGZyb20gdGhlIHNlcnZlciwgbWVyZ2luZyB0aGUgcmVzcG9uc2Ugd2l0aCB0aGUgbW9kZWwnc1xuICAgIC8vIGxvY2FsIGF0dHJpYnV0ZXMuIEFueSBjaGFuZ2VkIGF0dHJpYnV0ZXMgd2lsbCB0cmlnZ2VyIGEgXCJjaGFuZ2VcIiBldmVudC5cbiAgICBmZXRjaDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHtwYXJzZTogdHJ1ZX0sIG9wdGlvbnMpO1xuICAgICAgdmFyIG1vZGVsID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICB2YXIgc2VydmVyQXR0cnMgPSBvcHRpb25zLnBhcnNlID8gbW9kZWwucGFyc2UocmVzcCwgb3B0aW9ucykgOiByZXNwO1xuICAgICAgICBpZiAoIW1vZGVsLnNldChzZXJ2ZXJBdHRycywgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MuY2FsbChvcHRpb25zLmNvbnRleHQsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgbW9kZWwudHJpZ2dlcignc3luYycsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIH07XG4gICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy5zeW5jKCdyZWFkJywgdGhpcywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8vIFNldCBhIGhhc2ggb2YgbW9kZWwgYXR0cmlidXRlcywgYW5kIHN5bmMgdGhlIG1vZGVsIHRvIHRoZSBzZXJ2ZXIuXG4gICAgLy8gSWYgdGhlIHNlcnZlciByZXR1cm5zIGFuIGF0dHJpYnV0ZXMgaGFzaCB0aGF0IGRpZmZlcnMsIHRoZSBtb2RlbCdzXG4gICAgLy8gc3RhdGUgd2lsbCBiZSBgc2V0YCBhZ2Fpbi5cbiAgICBzYXZlOiBmdW5jdGlvbihrZXksIHZhbCwgb3B0aW9ucykge1xuICAgICAgLy8gSGFuZGxlIGJvdGggYFwia2V5XCIsIHZhbHVlYCBhbmQgYHtrZXk6IHZhbHVlfWAgLXN0eWxlIGFyZ3VtZW50cy5cbiAgICAgIHZhciBhdHRycztcbiAgICAgIGlmIChrZXkgPT0gbnVsbCB8fCB0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhdHRycyA9IGtleTtcbiAgICAgICAgb3B0aW9ucyA9IHZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIChhdHRycyA9IHt9KVtrZXldID0gdmFsO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zID0gXy5leHRlbmQoe3ZhbGlkYXRlOiB0cnVlLCBwYXJzZTogdHJ1ZX0sIG9wdGlvbnMpO1xuICAgICAgdmFyIHdhaXQgPSBvcHRpb25zLndhaXQ7XG5cbiAgICAgIC8vIElmIHdlJ3JlIG5vdCB3YWl0aW5nIGFuZCBhdHRyaWJ1dGVzIGV4aXN0LCBzYXZlIGFjdHMgYXNcbiAgICAgIC8vIGBzZXQoYXR0cikuc2F2ZShudWxsLCBvcHRzKWAgd2l0aCB2YWxpZGF0aW9uLiBPdGhlcndpc2UsIGNoZWNrIGlmXG4gICAgICAvLyB0aGUgbW9kZWwgd2lsbCBiZSB2YWxpZCB3aGVuIHRoZSBhdHRyaWJ1dGVzLCBpZiBhbnksIGFyZSBzZXQuXG4gICAgICBpZiAoYXR0cnMgJiYgIXdhaXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNldChhdHRycywgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5fdmFsaWRhdGUoYXR0cnMsIG9wdGlvbnMpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIEFmdGVyIGEgc3VjY2Vzc2Z1bCBzZXJ2ZXItc2lkZSBzYXZlLCB0aGUgY2xpZW50IGlzIChvcHRpb25hbGx5KVxuICAgICAgLy8gdXBkYXRlZCB3aXRoIHRoZSBzZXJ2ZXItc2lkZSBzdGF0ZS5cbiAgICAgIHZhciBtb2RlbCA9IHRoaXM7XG4gICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICAvLyBFbnN1cmUgYXR0cmlidXRlcyBhcmUgcmVzdG9yZWQgZHVyaW5nIHN5bmNocm9ub3VzIHNhdmVzLlxuICAgICAgICBtb2RlbC5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgdmFyIHNlcnZlckF0dHJzID0gb3B0aW9ucy5wYXJzZSA/IG1vZGVsLnBhcnNlKHJlc3AsIG9wdGlvbnMpIDogcmVzcDtcbiAgICAgICAgaWYgKHdhaXQpIHNlcnZlckF0dHJzID0gXy5leHRlbmQoe30sIGF0dHJzLCBzZXJ2ZXJBdHRycyk7XG4gICAgICAgIGlmIChzZXJ2ZXJBdHRycyAmJiAhbW9kZWwuc2V0KHNlcnZlckF0dHJzLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcy5jYWxsKG9wdGlvbnMuY29udGV4dCwgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICBtb2RlbC50cmlnZ2VyKCdzeW5jJywgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICAgIHdyYXBFcnJvcih0aGlzLCBvcHRpb25zKTtcblxuICAgICAgLy8gU2V0IHRlbXBvcmFyeSBhdHRyaWJ1dGVzIGlmIGB7d2FpdDogdHJ1ZX1gIHRvIHByb3Blcmx5IGZpbmQgbmV3IGlkcy5cbiAgICAgIGlmIChhdHRycyAmJiB3YWl0KSB0aGlzLmF0dHJpYnV0ZXMgPSBfLmV4dGVuZCh7fSwgYXR0cmlidXRlcywgYXR0cnMpO1xuXG4gICAgICB2YXIgbWV0aG9kID0gdGhpcy5pc05ldygpID8gJ2NyZWF0ZScgOiAob3B0aW9ucy5wYXRjaCA/ICdwYXRjaCcgOiAndXBkYXRlJyk7XG4gICAgICBpZiAobWV0aG9kID09PSAncGF0Y2gnICYmICFvcHRpb25zLmF0dHJzKSBvcHRpb25zLmF0dHJzID0gYXR0cnM7XG4gICAgICB2YXIgeGhyID0gdGhpcy5zeW5jKG1ldGhvZCwgdGhpcywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIFJlc3RvcmUgYXR0cmlidXRlcy5cbiAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG5cbiAgICAgIHJldHVybiB4aHI7XG4gICAgfSxcblxuICAgIC8vIERlc3Ryb3kgdGhpcyBtb2RlbCBvbiB0aGUgc2VydmVyIGlmIGl0IHdhcyBhbHJlYWR5IHBlcnNpc3RlZC5cbiAgICAvLyBPcHRpbWlzdGljYWxseSByZW1vdmVzIHRoZSBtb2RlbCBmcm9tIGl0cyBjb2xsZWN0aW9uLCBpZiBpdCBoYXMgb25lLlxuICAgIC8vIElmIGB3YWl0OiB0cnVlYCBpcyBwYXNzZWQsIHdhaXRzIGZvciB0aGUgc2VydmVyIHRvIHJlc3BvbmQgYmVmb3JlIHJlbW92YWwuXG4gICAgZGVzdHJveTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICB2YXIgd2FpdCA9IG9wdGlvbnMud2FpdDtcblxuICAgICAgdmFyIGRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbW9kZWwuc3RvcExpc3RlbmluZygpO1xuICAgICAgICBtb2RlbC50cmlnZ2VyKCdkZXN0cm95JywgbW9kZWwsIG1vZGVsLmNvbGxlY3Rpb24sIG9wdGlvbnMpO1xuICAgICAgfTtcblxuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICBpZiAod2FpdCkgZGVzdHJveSgpO1xuICAgICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcy5jYWxsKG9wdGlvbnMuY29udGV4dCwgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIW1vZGVsLmlzTmV3KCkpIG1vZGVsLnRyaWdnZXIoJ3N5bmMnLCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgeGhyID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5pc05ldygpKSB7XG4gICAgICAgIF8uZGVmZXIob3B0aW9ucy5zdWNjZXNzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyYXBFcnJvcih0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgeGhyID0gdGhpcy5zeW5jKCdkZWxldGUnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICghd2FpdCkgZGVzdHJveSgpO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9LFxuXG4gICAgLy8gRGVmYXVsdCBVUkwgZm9yIHRoZSBtb2RlbCdzIHJlcHJlc2VudGF0aW9uIG9uIHRoZSBzZXJ2ZXIgLS0gaWYgeW91J3JlXG4gICAgLy8gdXNpbmcgQmFja2JvbmUncyByZXN0ZnVsIG1ldGhvZHMsIG92ZXJyaWRlIHRoaXMgdG8gY2hhbmdlIHRoZSBlbmRwb2ludFxuICAgIC8vIHRoYXQgd2lsbCBiZSBjYWxsZWQuXG4gICAgdXJsOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiYXNlID1cbiAgICAgICAgXy5yZXN1bHQodGhpcywgJ3VybFJvb3QnKSB8fFxuICAgICAgICBfLnJlc3VsdCh0aGlzLmNvbGxlY3Rpb24sICd1cmwnKSB8fFxuICAgICAgICB1cmxFcnJvcigpO1xuICAgICAgaWYgKHRoaXMuaXNOZXcoKSkgcmV0dXJuIGJhc2U7XG4gICAgICB2YXIgaWQgPSB0aGlzLmdldCh0aGlzLmlkQXR0cmlidXRlKTtcbiAgICAgIHJldHVybiBiYXNlLnJlcGxhY2UoL1teXFwvXSQvLCAnJCYvJykgKyBlbmNvZGVVUklDb21wb25lbnQoaWQpO1xuICAgIH0sXG5cbiAgICAvLyAqKnBhcnNlKiogY29udmVydHMgYSByZXNwb25zZSBpbnRvIHRoZSBoYXNoIG9mIGF0dHJpYnV0ZXMgdG8gYmUgYHNldGAgb25cbiAgICAvLyB0aGUgbW9kZWwuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGlzIGp1c3QgdG8gcGFzcyB0aGUgcmVzcG9uc2UgYWxvbmcuXG4gICAgcGFyc2U6IGZ1bmN0aW9uKHJlc3AsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiByZXNwO1xuICAgIH0sXG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgbW9kZWwgd2l0aCBpZGVudGljYWwgYXR0cmlidXRlcyB0byB0aGlzIG9uZS5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICB9LFxuXG4gICAgLy8gQSBtb2RlbCBpcyBuZXcgaWYgaXQgaGFzIG5ldmVyIGJlZW4gc2F2ZWQgdG8gdGhlIHNlcnZlciwgYW5kIGxhY2tzIGFuIGlkLlxuICAgIGlzTmV3OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhdGhpcy5oYXModGhpcy5pZEF0dHJpYnV0ZSk7XG4gICAgfSxcblxuICAgIC8vIENoZWNrIGlmIHRoZSBtb2RlbCBpcyBjdXJyZW50bHkgaW4gYSB2YWxpZCBzdGF0ZS5cbiAgICBpc1ZhbGlkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsaWRhdGUoe30sIF8uZGVmYXVsdHMoe3ZhbGlkYXRlOiB0cnVlfSwgb3B0aW9ucykpO1xuICAgIH0sXG5cbiAgICAvLyBSdW4gdmFsaWRhdGlvbiBhZ2FpbnN0IHRoZSBuZXh0IGNvbXBsZXRlIHNldCBvZiBtb2RlbCBhdHRyaWJ1dGVzLFxuICAgIC8vIHJldHVybmluZyBgdHJ1ZWAgaWYgYWxsIGlzIHdlbGwuIE90aGVyd2lzZSwgZmlyZSBhbiBgXCJpbnZhbGlkXCJgIGV2ZW50LlxuICAgIF92YWxpZGF0ZTogZnVuY3Rpb24oYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucy52YWxpZGF0ZSB8fCAhdGhpcy52YWxpZGF0ZSkgcmV0dXJuIHRydWU7XG4gICAgICBhdHRycyA9IF8uZXh0ZW5kKHt9LCB0aGlzLmF0dHJpYnV0ZXMsIGF0dHJzKTtcbiAgICAgIHZhciBlcnJvciA9IHRoaXMudmFsaWRhdGlvbkVycm9yID0gdGhpcy52YWxpZGF0ZShhdHRycywgb3B0aW9ucykgfHwgbnVsbDtcbiAgICAgIGlmICghZXJyb3IpIHJldHVybiB0cnVlO1xuICAgICAgdGhpcy50cmlnZ2VyKCdpbnZhbGlkJywgdGhpcywgZXJyb3IsIF8uZXh0ZW5kKG9wdGlvbnMsIHt2YWxpZGF0aW9uRXJyb3I6IGVycm9yfSkpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBVbmRlcnNjb3JlIG1ldGhvZHMgdGhhdCB3ZSB3YW50IHRvIGltcGxlbWVudCBvbiB0aGUgTW9kZWwuXG4gIHZhciBtb2RlbE1ldGhvZHMgPSB7IGtleXM6IDEsIHZhbHVlczogMSwgcGFpcnM6IDEsIGludmVydDogMSwgcGljazogMCxcbiAgICAgIG9taXQ6IDAsIGNoYWluOiAxLCBpc0VtcHR5OiAxIH07XG5cbiAgLy8gTWl4IGluIGVhY2ggVW5kZXJzY29yZSBtZXRob2QgYXMgYSBwcm94eSB0byBgTW9kZWwjYXR0cmlidXRlc2AuXG4gIGFkZFVuZGVyc2NvcmVNZXRob2RzKE1vZGVsLCBtb2RlbE1ldGhvZHMsICdhdHRyaWJ1dGVzJyk7XG5cbiAgLy8gQmFja2JvbmUuQ29sbGVjdGlvblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gSWYgbW9kZWxzIHRlbmQgdG8gcmVwcmVzZW50IGEgc2luZ2xlIHJvdyBvZiBkYXRhLCBhIEJhY2tib25lIENvbGxlY3Rpb24gaXNcbiAgLy8gbW9yZSBhbmFsb2dvdXMgdG8gYSB0YWJsZSBmdWxsIG9mIGRhdGEgLi4uIG9yIGEgc21hbGwgc2xpY2Ugb3IgcGFnZSBvZiB0aGF0XG4gIC8vIHRhYmxlLCBvciBhIGNvbGxlY3Rpb24gb2Ygcm93cyB0aGF0IGJlbG9uZyB0b2dldGhlciBmb3IgYSBwYXJ0aWN1bGFyIHJlYXNvblxuICAvLyAtLSBhbGwgb2YgdGhlIG1lc3NhZ2VzIGluIHRoaXMgcGFydGljdWxhciBmb2xkZXIsIGFsbCBvZiB0aGUgZG9jdW1lbnRzXG4gIC8vIGJlbG9uZ2luZyB0byB0aGlzIHBhcnRpY3VsYXIgYXV0aG9yLCBhbmQgc28gb24uIENvbGxlY3Rpb25zIG1haW50YWluXG4gIC8vIGluZGV4ZXMgb2YgdGhlaXIgbW9kZWxzLCBib3RoIGluIG9yZGVyLCBhbmQgZm9yIGxvb2t1cCBieSBgaWRgLlxuXG4gIC8vIENyZWF0ZSBhIG5ldyAqKkNvbGxlY3Rpb24qKiwgcGVyaGFwcyB0byBjb250YWluIGEgc3BlY2lmaWMgdHlwZSBvZiBgbW9kZWxgLlxuICAvLyBJZiBhIGBjb21wYXJhdG9yYCBpcyBzcGVjaWZpZWQsIHRoZSBDb2xsZWN0aW9uIHdpbGwgbWFpbnRhaW5cbiAgLy8gaXRzIG1vZGVscyBpbiBzb3J0IG9yZGVyLCBhcyB0aGV5J3JlIGFkZGVkIGFuZCByZW1vdmVkLlxuICB2YXIgQ29sbGVjdGlvbiA9IEJhY2tib25lLkNvbGxlY3Rpb24gPSBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIGlmIChvcHRpb25zLm1vZGVsKSB0aGlzLm1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICBpZiAob3B0aW9ucy5jb21wYXJhdG9yICE9PSB2b2lkIDApIHRoaXMuY29tcGFyYXRvciA9IG9wdGlvbnMuY29tcGFyYXRvcjtcbiAgICB0aGlzLl9yZXNldCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChtb2RlbHMpIHRoaXMucmVzZXQobW9kZWxzLCBfLmV4dGVuZCh7c2lsZW50OiB0cnVlfSwgb3B0aW9ucykpO1xuICB9O1xuXG4gIC8vIERlZmF1bHQgb3B0aW9ucyBmb3IgYENvbGxlY3Rpb24jc2V0YC5cbiAgdmFyIHNldE9wdGlvbnMgPSB7YWRkOiB0cnVlLCByZW1vdmU6IHRydWUsIG1lcmdlOiB0cnVlfTtcbiAgdmFyIGFkZE9wdGlvbnMgPSB7YWRkOiB0cnVlLCByZW1vdmU6IGZhbHNlfTtcblxuICAvLyBEZWZpbmUgdGhlIENvbGxlY3Rpb24ncyBpbmhlcml0YWJsZSBtZXRob2RzLlxuICBfLmV4dGVuZChDb2xsZWN0aW9uLnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBUaGUgZGVmYXVsdCBtb2RlbCBmb3IgYSBjb2xsZWN0aW9uIGlzIGp1c3QgYSAqKkJhY2tib25lLk1vZGVsKiouXG4gICAgLy8gVGhpcyBzaG91bGQgYmUgb3ZlcnJpZGRlbiBpbiBtb3N0IGNhc2VzLlxuICAgIG1vZGVsOiBNb2RlbCxcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vIFRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgQ29sbGVjdGlvbiBpcyBhbiBhcnJheSBvZiB0aGVcbiAgICAvLyBtb2RlbHMnIGF0dHJpYnV0ZXMuXG4gICAgdG9KU09OOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24obW9kZWwpIHsgcmV0dXJuIG1vZGVsLnRvSlNPTihvcHRpb25zKTsgfSk7XG4gICAgfSxcblxuICAgIC8vIFByb3h5IGBCYWNrYm9uZS5zeW5jYCBieSBkZWZhdWx0LlxuICAgIHN5bmM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEJhY2tib25lLnN5bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgbW9kZWwsIG9yIGxpc3Qgb2YgbW9kZWxzIHRvIHRoZSBzZXQuXG4gICAgYWRkOiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldChtb2RlbHMsIF8uZXh0ZW5kKHttZXJnZTogZmFsc2V9LCBvcHRpb25zLCBhZGRPcHRpb25zKSk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBhIG1vZGVsLCBvciBhIGxpc3Qgb2YgbW9kZWxzIGZyb20gdGhlIHNldC5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgICAgIHZhciBzaW5ndWxhciA9ICFfLmlzQXJyYXkobW9kZWxzKTtcbiAgICAgIG1vZGVscyA9IHNpbmd1bGFyID8gW21vZGVsc10gOiBfLmNsb25lKG1vZGVscyk7XG4gICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMuX3JlbW92ZU1vZGVscyhtb2RlbHMsIG9wdGlvbnMpO1xuICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCAmJiByZW1vdmVkKSB0aGlzLnRyaWdnZXIoJ3VwZGF0ZScsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHNpbmd1bGFyID8gcmVtb3ZlZFswXSA6IHJlbW92ZWQ7XG4gICAgfSxcblxuICAgIC8vIFVwZGF0ZSBhIGNvbGxlY3Rpb24gYnkgYHNldGAtaW5nIGEgbmV3IGxpc3Qgb2YgbW9kZWxzLCBhZGRpbmcgbmV3IG9uZXMsXG4gICAgLy8gcmVtb3ZpbmcgbW9kZWxzIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LCBhbmQgbWVyZ2luZyBtb2RlbHMgdGhhdFxuICAgIC8vIGFscmVhZHkgZXhpc3QgaW4gdGhlIGNvbGxlY3Rpb24sIGFzIG5lY2Vzc2FyeS4gU2ltaWxhciB0byAqKk1vZGVsI3NldCoqLFxuICAgIC8vIHRoZSBjb3JlIG9wZXJhdGlvbiBmb3IgdXBkYXRpbmcgdGhlIGRhdGEgY29udGFpbmVkIGJ5IHRoZSBjb2xsZWN0aW9uLlxuICAgIHNldDogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gXy5kZWZhdWx0cyh7fSwgb3B0aW9ucywgc2V0T3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5wYXJzZSAmJiAhdGhpcy5faXNNb2RlbChtb2RlbHMpKSBtb2RlbHMgPSB0aGlzLnBhcnNlKG1vZGVscywgb3B0aW9ucyk7XG4gICAgICB2YXIgc2luZ3VsYXIgPSAhXy5pc0FycmF5KG1vZGVscyk7XG4gICAgICBtb2RlbHMgPSBzaW5ndWxhciA/IChtb2RlbHMgPyBbbW9kZWxzXSA6IFtdKSA6IG1vZGVscy5zbGljZSgpO1xuICAgICAgdmFyIGlkLCBtb2RlbCwgYXR0cnMsIGV4aXN0aW5nLCBzb3J0O1xuICAgICAgdmFyIGF0ID0gb3B0aW9ucy5hdDtcbiAgICAgIGlmIChhdCAhPSBudWxsKSBhdCA9ICthdDtcbiAgICAgIGlmIChhdCA8IDApIGF0ICs9IHRoaXMubGVuZ3RoICsgMTtcbiAgICAgIHZhciBzb3J0YWJsZSA9IHRoaXMuY29tcGFyYXRvciAmJiAoYXQgPT0gbnVsbCkgJiYgb3B0aW9ucy5zb3J0ICE9PSBmYWxzZTtcbiAgICAgIHZhciBzb3J0QXR0ciA9IF8uaXNTdHJpbmcodGhpcy5jb21wYXJhdG9yKSA/IHRoaXMuY29tcGFyYXRvciA6IG51bGw7XG4gICAgICB2YXIgdG9BZGQgPSBbXSwgdG9SZW1vdmUgPSBbXSwgbW9kZWxNYXAgPSB7fTtcbiAgICAgIHZhciBhZGQgPSBvcHRpb25zLmFkZCwgbWVyZ2UgPSBvcHRpb25zLm1lcmdlLCByZW1vdmUgPSBvcHRpb25zLnJlbW92ZTtcbiAgICAgIHZhciBvcmRlciA9ICFzb3J0YWJsZSAmJiBhZGQgJiYgcmVtb3ZlID8gW10gOiBmYWxzZTtcbiAgICAgIHZhciBvcmRlckNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgLy8gVHVybiBiYXJlIG9iamVjdHMgaW50byBtb2RlbCByZWZlcmVuY2VzLCBhbmQgcHJldmVudCBpbnZhbGlkIG1vZGVsc1xuICAgICAgLy8gZnJvbSBiZWluZyBhZGRlZC5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW9kZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGF0dHJzID0gbW9kZWxzW2ldO1xuXG4gICAgICAgIC8vIElmIGEgZHVwbGljYXRlIGlzIGZvdW5kLCBwcmV2ZW50IGl0IGZyb20gYmVpbmcgYWRkZWQgYW5kXG4gICAgICAgIC8vIG9wdGlvbmFsbHkgbWVyZ2UgaXQgaW50byB0aGUgZXhpc3RpbmcgbW9kZWwuXG4gICAgICAgIGlmIChleGlzdGluZyA9IHRoaXMuZ2V0KGF0dHJzKSkge1xuICAgICAgICAgIGlmIChyZW1vdmUpIG1vZGVsTWFwW2V4aXN0aW5nLmNpZF0gPSB0cnVlO1xuICAgICAgICAgIGlmIChtZXJnZSAmJiBhdHRycyAhPT0gZXhpc3RpbmcpIHtcbiAgICAgICAgICAgIGF0dHJzID0gdGhpcy5faXNNb2RlbChhdHRycykgPyBhdHRycy5hdHRyaWJ1dGVzIDogYXR0cnM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYXJzZSkgYXR0cnMgPSBleGlzdGluZy5wYXJzZShhdHRycywgb3B0aW9ucyk7XG4gICAgICAgICAgICBleGlzdGluZy5zZXQoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHNvcnRhYmxlICYmICFzb3J0ICYmIGV4aXN0aW5nLmhhc0NoYW5nZWQoc29ydEF0dHIpKSBzb3J0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbW9kZWxzW2ldID0gZXhpc3Rpbmc7XG5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG5ldywgdmFsaWQgbW9kZWwsIHB1c2ggaXQgdG8gdGhlIGB0b0FkZGAgbGlzdC5cbiAgICAgICAgfSBlbHNlIGlmIChhZGQpIHtcbiAgICAgICAgICBtb2RlbCA9IG1vZGVsc1tpXSA9IHRoaXMuX3ByZXBhcmVNb2RlbChhdHRycywgb3B0aW9ucyk7XG4gICAgICAgICAgaWYgKCFtb2RlbCkgY29udGludWU7XG4gICAgICAgICAgdG9BZGQucHVzaChtb2RlbCk7XG4gICAgICAgICAgdGhpcy5fYWRkUmVmZXJlbmNlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvIG5vdCBhZGQgbXVsdGlwbGUgbW9kZWxzIHdpdGggdGhlIHNhbWUgYGlkYC5cbiAgICAgICAgbW9kZWwgPSBleGlzdGluZyB8fCBtb2RlbDtcbiAgICAgICAgaWYgKCFtb2RlbCkgY29udGludWU7XG4gICAgICAgIGlkID0gdGhpcy5tb2RlbElkKG1vZGVsLmF0dHJpYnV0ZXMpO1xuICAgICAgICBpZiAob3JkZXIgJiYgKG1vZGVsLmlzTmV3KCkgfHwgIW1vZGVsTWFwW2lkXSkpIHtcbiAgICAgICAgICBvcmRlci5wdXNoKG1vZGVsKTtcblxuICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGlzIGlzIGFjdHVhbGx5IGEgbmV3IG1vZGVsIGF0IHRoaXMgaW5kZXguXG4gICAgICAgICAgb3JkZXJDaGFuZ2VkID0gb3JkZXJDaGFuZ2VkIHx8ICF0aGlzLm1vZGVsc1tpXSB8fCBtb2RlbC5jaWQgIT09IHRoaXMubW9kZWxzW2ldLmNpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vZGVsTWFwW2lkXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBub25leGlzdGVudCBtb2RlbHMgaWYgYXBwcm9wcmlhdGUuXG4gICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICghbW9kZWxNYXBbKG1vZGVsID0gdGhpcy5tb2RlbHNbaV0pLmNpZF0pIHRvUmVtb3ZlLnB1c2gobW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b1JlbW92ZS5sZW5ndGgpIHRoaXMuX3JlbW92ZU1vZGVscyh0b1JlbW92ZSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlZSBpZiBzb3J0aW5nIGlzIG5lZWRlZCwgdXBkYXRlIGBsZW5ndGhgIGFuZCBzcGxpY2UgaW4gbmV3IG1vZGVscy5cbiAgICAgIGlmICh0b0FkZC5sZW5ndGggfHwgb3JkZXJDaGFuZ2VkKSB7XG4gICAgICAgIGlmIChzb3J0YWJsZSkgc29ydCA9IHRydWU7XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IHRvQWRkLmxlbmd0aDtcbiAgICAgICAgaWYgKGF0ICE9IG51bGwpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvQWRkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVscy5zcGxpY2UoYXQgKyBpLCAwLCB0b0FkZFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChvcmRlcikgdGhpcy5tb2RlbHMubGVuZ3RoID0gMDtcbiAgICAgICAgICB2YXIgb3JkZXJlZE1vZGVscyA9IG9yZGVyIHx8IHRvQWRkO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXJlZE1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5tb2RlbHMucHVzaChvcmRlcmVkTW9kZWxzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU2lsZW50bHkgc29ydCB0aGUgY29sbGVjdGlvbiBpZiBhcHByb3ByaWF0ZS5cbiAgICAgIGlmIChzb3J0KSB0aGlzLnNvcnQoe3NpbGVudDogdHJ1ZX0pO1xuXG4gICAgICAvLyBVbmxlc3Mgc2lsZW5jZWQsIGl0J3MgdGltZSB0byBmaXJlIGFsbCBhcHByb3ByaWF0ZSBhZGQvc29ydCBldmVudHMuXG4gICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgIHZhciBhZGRPcHRzID0gYXQgIT0gbnVsbCA/IF8uY2xvbmUob3B0aW9ucykgOiBvcHRpb25zO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvQWRkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGF0ICE9IG51bGwpIGFkZE9wdHMuaW5kZXggPSBhdCArIGk7XG4gICAgICAgICAgKG1vZGVsID0gdG9BZGRbaV0pLnRyaWdnZXIoJ2FkZCcsIG1vZGVsLCB0aGlzLCBhZGRPcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc29ydCB8fCBvcmRlckNoYW5nZWQpIHRoaXMudHJpZ2dlcignc29ydCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAodG9BZGQubGVuZ3RoIHx8IHRvUmVtb3ZlLmxlbmd0aCkgdGhpcy50cmlnZ2VyKCd1cGRhdGUnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIHRoZSBhZGRlZCAob3IgbWVyZ2VkKSBtb2RlbCAob3IgbW9kZWxzKS5cbiAgICAgIHJldHVybiBzaW5ndWxhciA/IG1vZGVsc1swXSA6IG1vZGVscztcbiAgICB9LFxuXG4gICAgLy8gV2hlbiB5b3UgaGF2ZSBtb3JlIGl0ZW1zIHRoYW4geW91IHdhbnQgdG8gYWRkIG9yIHJlbW92ZSBpbmRpdmlkdWFsbHksXG4gICAgLy8geW91IGNhbiByZXNldCB0aGUgZW50aXJlIHNldCB3aXRoIGEgbmV3IGxpc3Qgb2YgbW9kZWxzLCB3aXRob3V0IGZpcmluZ1xuICAgIC8vIGFueSBncmFudWxhciBgYWRkYCBvciBgcmVtb3ZlYCBldmVudHMuIEZpcmVzIGByZXNldGAgd2hlbiBmaW5pc2hlZC5cbiAgICAvLyBVc2VmdWwgZm9yIGJ1bGsgb3BlcmF0aW9ucyBhbmQgb3B0aW1pemF0aW9ucy5cbiAgICByZXNldDogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tb2RlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlUmVmZXJlbmNlKHRoaXMubW9kZWxzW2ldLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMucHJldmlvdXNNb2RlbHMgPSB0aGlzLm1vZGVscztcbiAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICBtb2RlbHMgPSB0aGlzLmFkZChtb2RlbHMsIF8uZXh0ZW5kKHtzaWxlbnQ6IHRydWV9LCBvcHRpb25zKSk7XG4gICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB0aGlzLnRyaWdnZXIoJ3Jlc2V0JywgdGhpcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gbW9kZWxzO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBtb2RlbCB0byB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHB1c2g6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGQobW9kZWwsIF8uZXh0ZW5kKHthdDogdGhpcy5sZW5ndGh9LCBvcHRpb25zKSk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBhIG1vZGVsIGZyb20gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICBwb3A6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMuYXQodGhpcy5sZW5ndGggLSAxKTtcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIG1vZGVsIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgdW5zaGlmdDogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZChtb2RlbCwgXy5leHRlbmQoe2F0OiAwfSwgb3B0aW9ucykpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYSBtb2RlbCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgc2hpZnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMuYXQoMCk7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmUobW9kZWwsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyBTbGljZSBvdXQgYSBzdWItYXJyYXkgb2YgbW9kZWxzIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgc2xpY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNsaWNlLmFwcGx5KHRoaXMubW9kZWxzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYSBtb2RlbCBmcm9tIHRoZSBzZXQgYnkgaWQuXG4gICAgZ2V0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgIHZhciBpZCA9IHRoaXMubW9kZWxJZCh0aGlzLl9pc01vZGVsKG9iaikgPyBvYmouYXR0cmlidXRlcyA6IG9iaik7XG4gICAgICByZXR1cm4gdGhpcy5fYnlJZFtvYmpdIHx8IHRoaXMuX2J5SWRbaWRdIHx8IHRoaXMuX2J5SWRbb2JqLmNpZF07XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgbW9kZWwgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgIGF0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaWYgKGluZGV4IDwgMCkgaW5kZXggKz0gdGhpcy5sZW5ndGg7XG4gICAgICByZXR1cm4gdGhpcy5tb2RlbHNbaW5kZXhdO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gbW9kZWxzIHdpdGggbWF0Y2hpbmcgYXR0cmlidXRlcy4gVXNlZnVsIGZvciBzaW1wbGUgY2FzZXMgb2ZcbiAgICAvLyBgZmlsdGVyYC5cbiAgICB3aGVyZTogZnVuY3Rpb24oYXR0cnMsIGZpcnN0KSB7XG4gICAgICB2YXIgbWF0Y2hlcyA9IF8ubWF0Y2hlcyhhdHRycyk7XG4gICAgICByZXR1cm4gdGhpc1tmaXJzdCA/ICdmaW5kJyA6ICdmaWx0ZXInXShmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlcyhtb2RlbC5hdHRyaWJ1dGVzKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gdGhlIGZpcnN0IG1vZGVsIHdpdGggbWF0Y2hpbmcgYXR0cmlidXRlcy4gVXNlZnVsIGZvciBzaW1wbGUgY2FzZXNcbiAgICAvLyBvZiBgZmluZGAuXG4gICAgZmluZFdoZXJlOiBmdW5jdGlvbihhdHRycykge1xuICAgICAgcmV0dXJuIHRoaXMud2hlcmUoYXR0cnMsIHRydWUpO1xuICAgIH0sXG5cbiAgICAvLyBGb3JjZSB0aGUgY29sbGVjdGlvbiB0byByZS1zb3J0IGl0c2VsZi4gWW91IGRvbid0IG5lZWQgdG8gY2FsbCB0aGlzIHVuZGVyXG4gICAgLy8gbm9ybWFsIGNpcmN1bXN0YW5jZXMsIGFzIHRoZSBzZXQgd2lsbCBtYWludGFpbiBzb3J0IG9yZGVyIGFzIGVhY2ggaXRlbVxuICAgIC8vIGlzIGFkZGVkLlxuICAgIHNvcnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5jb21wYXJhdG9yKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzb3J0IGEgc2V0IHdpdGhvdXQgYSBjb21wYXJhdG9yJyk7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuXG4gICAgICAvLyBSdW4gc29ydCBiYXNlZCBvbiB0eXBlIG9mIGBjb21wYXJhdG9yYC5cbiAgICAgIGlmIChfLmlzU3RyaW5nKHRoaXMuY29tcGFyYXRvcikgfHwgdGhpcy5jb21wYXJhdG9yLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGlzLm1vZGVscyA9IHRoaXMuc29ydEJ5KHRoaXMuY29tcGFyYXRvciwgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1vZGVscy5zb3J0KF8uYmluZCh0aGlzLmNvbXBhcmF0b3IsIHRoaXMpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCkgdGhpcy50cmlnZ2VyKCdzb3J0JywgdGhpcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUGx1Y2sgYW4gYXR0cmlidXRlIGZyb20gZWFjaCBtb2RlbCBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICBwbHVjazogZnVuY3Rpb24oYXR0cikge1xuICAgICAgcmV0dXJuIF8uaW52b2tlKHRoaXMubW9kZWxzLCAnZ2V0JywgYXR0cik7XG4gICAgfSxcblxuICAgIC8vIEZldGNoIHRoZSBkZWZhdWx0IHNldCBvZiBtb2RlbHMgZm9yIHRoaXMgY29sbGVjdGlvbiwgcmVzZXR0aW5nIHRoZVxuICAgIC8vIGNvbGxlY3Rpb24gd2hlbiB0aGV5IGFycml2ZS4gSWYgYHJlc2V0OiB0cnVlYCBpcyBwYXNzZWQsIHRoZSByZXNwb25zZVxuICAgIC8vIGRhdGEgd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB0aGUgYHJlc2V0YCBtZXRob2QgaW5zdGVhZCBvZiBgc2V0YC5cbiAgICBmZXRjaDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHtwYXJzZTogdHJ1ZX0sIG9wdGlvbnMpO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvcHRpb25zLnJlc2V0ID8gJ3Jlc2V0JyA6ICdzZXQnO1xuICAgICAgICBjb2xsZWN0aW9uW21ldGhvZF0ocmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzLmNhbGwob3B0aW9ucy5jb250ZXh0LCBjb2xsZWN0aW9uLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgY29sbGVjdGlvbi50cmlnZ2VyKCdzeW5jJywgY29sbGVjdGlvbiwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICB9O1xuICAgICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuc3luYygncmVhZCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgYSBtb2RlbCBpbiB0aGlzIGNvbGxlY3Rpb24uIEFkZCB0aGUgbW9kZWwgdG8gdGhlXG4gICAgLy8gY29sbGVjdGlvbiBpbW1lZGlhdGVseSwgdW5sZXNzIGB3YWl0OiB0cnVlYCBpcyBwYXNzZWQsIGluIHdoaWNoIGNhc2Ugd2VcbiAgICAvLyB3YWl0IGZvciB0aGUgc2VydmVyIHRvIGFncmVlLlxuICAgIGNyZWF0ZTogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgdmFyIHdhaXQgPSBvcHRpb25zLndhaXQ7XG4gICAgICBtb2RlbCA9IHRoaXMuX3ByZXBhcmVNb2RlbChtb2RlbCwgb3B0aW9ucyk7XG4gICAgICBpZiAoIW1vZGVsKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoIXdhaXQpIHRoaXMuYWRkKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24obW9kZWwsIHJlc3AsIGNhbGxiYWNrT3B0cykge1xuICAgICAgICBpZiAod2FpdCkgY29sbGVjdGlvbi5hZGQobW9kZWwsIGNhbGxiYWNrT3B0cyk7XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzLmNhbGwoY2FsbGJhY2tPcHRzLmNvbnRleHQsIG1vZGVsLCByZXNwLCBjYWxsYmFja09wdHMpO1xuICAgICAgfTtcbiAgICAgIG1vZGVsLnNhdmUobnVsbCwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSxcblxuICAgIC8vICoqcGFyc2UqKiBjb252ZXJ0cyBhIHJlc3BvbnNlIGludG8gYSBsaXN0IG9mIG1vZGVscyB0byBiZSBhZGRlZCB0byB0aGVcbiAgICAvLyBjb2xsZWN0aW9uLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyBqdXN0IHRvIHBhc3MgaXQgdGhyb3VnaC5cbiAgICBwYXJzZTogZnVuY3Rpb24ocmVzcCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHJlc3A7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBjb2xsZWN0aW9uIHdpdGggYW4gaWRlbnRpY2FsIGxpc3Qgb2YgbW9kZWxzIGFzIHRoaXMgb25lLlxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLm1vZGVscywge1xuICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgY29tcGFyYXRvcjogdGhpcy5jb21wYXJhdG9yXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gRGVmaW5lIGhvdyB0byB1bmlxdWVseSBpZGVudGlmeSBtb2RlbHMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgbW9kZWxJZDogZnVuY3Rpb24gKGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnNbdGhpcy5tb2RlbC5wcm90b3R5cGUuaWRBdHRyaWJ1dGUgfHwgJ2lkJ107XG4gICAgfSxcblxuICAgIC8vIFByaXZhdGUgbWV0aG9kIHRvIHJlc2V0IGFsbCBpbnRlcm5hbCBzdGF0ZS4gQ2FsbGVkIHdoZW4gdGhlIGNvbGxlY3Rpb25cbiAgICAvLyBpcyBmaXJzdCBpbml0aWFsaXplZCBvciByZXNldC5cbiAgICBfcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5tb2RlbHMgPSBbXTtcbiAgICAgIHRoaXMuX2J5SWQgID0ge307XG4gICAgfSxcblxuICAgIC8vIFByZXBhcmUgYSBoYXNoIG9mIGF0dHJpYnV0ZXMgKG9yIG90aGVyIG1vZGVsKSB0byBiZSBhZGRlZCB0byB0aGlzXG4gICAgLy8gY29sbGVjdGlvbi5cbiAgICBfcHJlcGFyZU1vZGVsOiBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuX2lzTW9kZWwoYXR0cnMpKSB7XG4gICAgICAgIGlmICghYXR0cnMuY29sbGVjdGlvbikgYXR0cnMuY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBhdHRycztcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgb3B0aW9ucy5jb2xsZWN0aW9uID0gdGhpcztcbiAgICAgIHZhciBtb2RlbCA9IG5ldyB0aGlzLm1vZGVsKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgIGlmICghbW9kZWwudmFsaWRhdGlvbkVycm9yKSByZXR1cm4gbW9kZWw7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2ludmFsaWQnLCB0aGlzLCBtb2RlbC52YWxpZGF0aW9uRXJyb3IsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgY2FsbGVkIGJ5IGJvdGggcmVtb3ZlIGFuZCBzZXQuXG4gICAgLy8gUmV0dXJucyByZW1vdmVkIG1vZGVscywgb3IgZmFsc2UgaWYgbm90aGluZyBpcyByZW1vdmVkLlxuICAgIF9yZW1vdmVNb2RlbHM6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW9kZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMuZ2V0KG1vZGVsc1tpXSk7XG4gICAgICAgIGlmICghbW9kZWwpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXhPZihtb2RlbCk7XG4gICAgICAgIHRoaXMubW9kZWxzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHRoaXMubGVuZ3RoLS07XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgIG9wdGlvbnMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICBtb2RlbC50cmlnZ2VyKCdyZW1vdmUnLCBtb2RlbCwgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZW1vdmVkLnB1c2gobW9kZWwpO1xuICAgICAgICB0aGlzLl9yZW1vdmVSZWZlcmVuY2UobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlbW92ZWQubGVuZ3RoID8gcmVtb3ZlZCA6IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBNZXRob2QgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgbW9kZWwgZm9yXG4gICAgLy8gdGhlIHB1cnBvc2VzIG9mIGFkZGluZyB0byB0aGUgY29sbGVjdGlvbi5cbiAgICBfaXNNb2RlbDogZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICByZXR1cm4gbW9kZWwgaW5zdGFuY2VvZiBNb2RlbDtcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIGNyZWF0ZSBhIG1vZGVsJ3MgdGllcyB0byBhIGNvbGxlY3Rpb24uXG4gICAgX2FkZFJlZmVyZW5jZTogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2J5SWRbbW9kZWwuY2lkXSA9IG1vZGVsO1xuICAgICAgdmFyIGlkID0gdGhpcy5tb2RlbElkKG1vZGVsLmF0dHJpYnV0ZXMpO1xuICAgICAgaWYgKGlkICE9IG51bGwpIHRoaXMuX2J5SWRbaWRdID0gbW9kZWw7XG4gICAgICBtb2RlbC5vbignYWxsJywgdGhpcy5fb25Nb2RlbEV2ZW50LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIHNldmVyIGEgbW9kZWwncyB0aWVzIHRvIGEgY29sbGVjdGlvbi5cbiAgICBfcmVtb3ZlUmVmZXJlbmNlOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgZGVsZXRlIHRoaXMuX2J5SWRbbW9kZWwuY2lkXTtcbiAgICAgIHZhciBpZCA9IHRoaXMubW9kZWxJZChtb2RlbC5hdHRyaWJ1dGVzKTtcbiAgICAgIGlmIChpZCAhPSBudWxsKSBkZWxldGUgdGhpcy5fYnlJZFtpZF07XG4gICAgICBpZiAodGhpcyA9PT0gbW9kZWwuY29sbGVjdGlvbikgZGVsZXRlIG1vZGVsLmNvbGxlY3Rpb247XG4gICAgICBtb2RlbC5vZmYoJ2FsbCcsIHRoaXMuX29uTW9kZWxFdmVudCwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCBjYWxsZWQgZXZlcnkgdGltZSBhIG1vZGVsIGluIHRoZSBzZXQgZmlyZXMgYW4gZXZlbnQuXG4gICAgLy8gU2V0cyBuZWVkIHRvIHVwZGF0ZSB0aGVpciBpbmRleGVzIHdoZW4gbW9kZWxzIGNoYW5nZSBpZHMuIEFsbCBvdGhlclxuICAgIC8vIGV2ZW50cyBzaW1wbHkgcHJveHkgdGhyb3VnaC4gXCJhZGRcIiBhbmQgXCJyZW1vdmVcIiBldmVudHMgdGhhdCBvcmlnaW5hdGVcbiAgICAvLyBpbiBvdGhlciBjb2xsZWN0aW9ucyBhcmUgaWdub3JlZC5cbiAgICBfb25Nb2RlbEV2ZW50OiBmdW5jdGlvbihldmVudCwgbW9kZWwsIGNvbGxlY3Rpb24sIG9wdGlvbnMpIHtcbiAgICAgIGlmICgoZXZlbnQgPT09ICdhZGQnIHx8IGV2ZW50ID09PSAncmVtb3ZlJykgJiYgY29sbGVjdGlvbiAhPT0gdGhpcykgcmV0dXJuO1xuICAgICAgaWYgKGV2ZW50ID09PSAnZGVzdHJveScpIHRoaXMucmVtb3ZlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIGlmIChldmVudCA9PT0gJ2NoYW5nZScpIHtcbiAgICAgICAgdmFyIHByZXZJZCA9IHRoaXMubW9kZWxJZChtb2RlbC5wcmV2aW91c0F0dHJpYnV0ZXMoKSk7XG4gICAgICAgIHZhciBpZCA9IHRoaXMubW9kZWxJZChtb2RlbC5hdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKHByZXZJZCAhPT0gaWQpIHtcbiAgICAgICAgICBpZiAocHJldklkICE9IG51bGwpIGRlbGV0ZSB0aGlzLl9ieUlkW3ByZXZJZF07XG4gICAgICAgICAgaWYgKGlkICE9IG51bGwpIHRoaXMuX2J5SWRbaWRdID0gbW9kZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBVbmRlcnNjb3JlIG1ldGhvZHMgdGhhdCB3ZSB3YW50IHRvIGltcGxlbWVudCBvbiB0aGUgQ29sbGVjdGlvbi5cbiAgLy8gOTAlIG9mIHRoZSBjb3JlIHVzZWZ1bG5lc3Mgb2YgQmFja2JvbmUgQ29sbGVjdGlvbnMgaXMgYWN0dWFsbHkgaW1wbGVtZW50ZWRcbiAgLy8gcmlnaHQgaGVyZTpcbiAgdmFyIGNvbGxlY3Rpb25NZXRob2RzID0geyBmb3JFYWNoOiAzLCBlYWNoOiAzLCBtYXA6IDMsIGNvbGxlY3Q6IDMsIHJlZHVjZTogNCxcbiAgICAgIGZvbGRsOiA0LCBpbmplY3Q6IDQsIHJlZHVjZVJpZ2h0OiA0LCBmb2xkcjogNCwgZmluZDogMywgZGV0ZWN0OiAzLCBmaWx0ZXI6IDMsXG4gICAgICBzZWxlY3Q6IDMsIHJlamVjdDogMywgZXZlcnk6IDMsIGFsbDogMywgc29tZTogMywgYW55OiAzLCBpbmNsdWRlOiAyLFxuICAgICAgY29udGFpbnM6IDIsIGludm9rZTogMCwgbWF4OiAzLCBtaW46IDMsIHRvQXJyYXk6IDEsIHNpemU6IDEsIGZpcnN0OiAzLFxuICAgICAgaGVhZDogMywgdGFrZTogMywgaW5pdGlhbDogMywgcmVzdDogMywgdGFpbDogMywgZHJvcDogMywgbGFzdDogMyxcbiAgICAgIHdpdGhvdXQ6IDAsIGRpZmZlcmVuY2U6IDAsIGluZGV4T2Y6IDMsIHNodWZmbGU6IDEsIGxhc3RJbmRleE9mOiAzLFxuICAgICAgaXNFbXB0eTogMSwgY2hhaW46IDEsIHNhbXBsZTogMywgcGFydGl0aW9uOiAzIH07XG5cbiAgLy8gTWl4IGluIGVhY2ggVW5kZXJzY29yZSBtZXRob2QgYXMgYSBwcm94eSB0byBgQ29sbGVjdGlvbiNtb2RlbHNgLlxuICBhZGRVbmRlcnNjb3JlTWV0aG9kcyhDb2xsZWN0aW9uLCBjb2xsZWN0aW9uTWV0aG9kcywgJ21vZGVscycpO1xuXG4gIC8vIFVuZGVyc2NvcmUgbWV0aG9kcyB0aGF0IHRha2UgYSBwcm9wZXJ0eSBuYW1lIGFzIGFuIGFyZ3VtZW50LlxuICB2YXIgYXR0cmlidXRlTWV0aG9kcyA9IFsnZ3JvdXBCeScsICdjb3VudEJ5JywgJ3NvcnRCeScsICdpbmRleEJ5J107XG5cbiAgLy8gVXNlIGF0dHJpYnV0ZXMgaW5zdGVhZCBvZiBwcm9wZXJ0aWVzLlxuICBfLmVhY2goYXR0cmlidXRlTWV0aG9kcywgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgaWYgKCFfW21ldGhvZF0pIHJldHVybjtcbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZSA6IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgIHJldHVybiBtb2RlbC5nZXQodmFsdWUpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfW21ldGhvZF0odGhpcy5tb2RlbHMsIGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBCYWNrYm9uZS5WaWV3XG4gIC8vIC0tLS0tLS0tLS0tLS1cblxuICAvLyBCYWNrYm9uZSBWaWV3cyBhcmUgYWxtb3N0IG1vcmUgY29udmVudGlvbiB0aGFuIHRoZXkgYXJlIGFjdHVhbCBjb2RlLiBBIFZpZXdcbiAgLy8gaXMgc2ltcGx5IGEgSmF2YVNjcmlwdCBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgbG9naWNhbCBjaHVuayBvZiBVSSBpbiB0aGVcbiAgLy8gRE9NLiBUaGlzIG1pZ2h0IGJlIGEgc2luZ2xlIGl0ZW0sIGFuIGVudGlyZSBsaXN0LCBhIHNpZGViYXIgb3IgcGFuZWwsIG9yXG4gIC8vIGV2ZW4gdGhlIHN1cnJvdW5kaW5nIGZyYW1lIHdoaWNoIHdyYXBzIHlvdXIgd2hvbGUgYXBwLiBEZWZpbmluZyBhIGNodW5rIG9mXG4gIC8vIFVJIGFzIGEgKipWaWV3KiogYWxsb3dzIHlvdSB0byBkZWZpbmUgeW91ciBET00gZXZlbnRzIGRlY2xhcmF0aXZlbHksIHdpdGhvdXRcbiAgLy8gaGF2aW5nIHRvIHdvcnJ5IGFib3V0IHJlbmRlciBvcmRlciAuLi4gYW5kIG1ha2VzIGl0IGVhc3kgZm9yIHRoZSB2aWV3IHRvXG4gIC8vIHJlYWN0IHRvIHNwZWNpZmljIGNoYW5nZXMgaW4gdGhlIHN0YXRlIG9mIHlvdXIgbW9kZWxzLlxuXG4gIC8vIENyZWF0aW5nIGEgQmFja2JvbmUuVmlldyBjcmVhdGVzIGl0cyBpbml0aWFsIGVsZW1lbnQgb3V0c2lkZSBvZiB0aGUgRE9NLFxuICAvLyBpZiBhbiBleGlzdGluZyBlbGVtZW50IGlzIG5vdCBwcm92aWRlZC4uLlxuICB2YXIgVmlldyA9IEJhY2tib25lLlZpZXcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5jaWQgPSBfLnVuaXF1ZUlkKCd2aWV3Jyk7XG4gICAgXy5leHRlbmQodGhpcywgXy5waWNrKG9wdGlvbnMsIHZpZXdPcHRpb25zKSk7XG4gICAgdGhpcy5fZW5zdXJlRWxlbWVudCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIENhY2hlZCByZWdleCB0byBzcGxpdCBrZXlzIGZvciBgZGVsZWdhdGVgLlxuICB2YXIgZGVsZWdhdGVFdmVudFNwbGl0dGVyID0gL14oXFxTKylcXHMqKC4qKSQvO1xuXG4gIC8vIExpc3Qgb2YgdmlldyBvcHRpb25zIHRvIGJlIG1lcmdlZCBhcyBwcm9wZXJ0aWVzLlxuICB2YXIgdmlld09wdGlvbnMgPSBbJ21vZGVsJywgJ2NvbGxlY3Rpb24nLCAnZWwnLCAnaWQnLCAnYXR0cmlidXRlcycsICdjbGFzc05hbWUnLCAndGFnTmFtZScsICdldmVudHMnXTtcblxuICAvLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuVmlldyoqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKFZpZXcucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIFRoZSBkZWZhdWx0IGB0YWdOYW1lYCBvZiBhIFZpZXcncyBlbGVtZW50IGlzIGBcImRpdlwiYC5cbiAgICB0YWdOYW1lOiAnZGl2JyxcblxuICAgIC8vIGpRdWVyeSBkZWxlZ2F0ZSBmb3IgZWxlbWVudCBsb29rdXAsIHNjb3BlZCB0byBET00gZWxlbWVudHMgd2l0aGluIHRoZVxuICAgIC8vIGN1cnJlbnQgdmlldy4gVGhpcyBzaG91bGQgYmUgcHJlZmVycmVkIHRvIGdsb2JhbCBsb29rdXBzIHdoZXJlIHBvc3NpYmxlLlxuICAgICQ6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy4kZWwuZmluZChzZWxlY3Rvcik7XG4gICAgfSxcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vICoqcmVuZGVyKiogaXMgdGhlIGNvcmUgZnVuY3Rpb24gdGhhdCB5b3VyIHZpZXcgc2hvdWxkIG92ZXJyaWRlLCBpbiBvcmRlclxuICAgIC8vIHRvIHBvcHVsYXRlIGl0cyBlbGVtZW50IChgdGhpcy5lbGApLCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBIVE1MLiBUaGVcbiAgICAvLyBjb252ZW50aW9uIGlzIGZvciAqKnJlbmRlcioqIHRvIGFsd2F5cyByZXR1cm4gYHRoaXNgLlxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIHRoaXMgdmlldyBieSB0YWtpbmcgdGhlIGVsZW1lbnQgb3V0IG9mIHRoZSBET00sIGFuZCByZW1vdmluZyBhbnlcbiAgICAvLyBhcHBsaWNhYmxlIEJhY2tib25lLkV2ZW50cyBsaXN0ZW5lcnMuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUVsZW1lbnQoKTtcbiAgICAgIHRoaXMuc3RvcExpc3RlbmluZygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSB0aGlzIHZpZXcncyBlbGVtZW50IGZyb20gdGhlIGRvY3VtZW50IGFuZCBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgLy8gYXR0YWNoZWQgdG8gaXQuIEV4cG9zZWQgZm9yIHN1YmNsYXNzZXMgdXNpbmcgYW4gYWx0ZXJuYXRpdmUgRE9NXG4gICAgLy8gbWFuaXB1bGF0aW9uIEFQSS5cbiAgICBfcmVtb3ZlRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLiRlbC5yZW1vdmUoKTtcbiAgICB9LFxuXG4gICAgLy8gQ2hhbmdlIHRoZSB2aWV3J3MgZWxlbWVudCAoYHRoaXMuZWxgIHByb3BlcnR5KSBhbmQgcmUtZGVsZWdhdGUgdGhlXG4gICAgLy8gdmlldydzIGV2ZW50cyBvbiB0aGUgbmV3IGVsZW1lbnQuXG4gICAgc2V0RWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgdGhpcy51bmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICB0aGlzLl9zZXRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZXMgdGhlIGB0aGlzLmVsYCBhbmQgYHRoaXMuJGVsYCByZWZlcmVuY2VzIGZvciB0aGlzIHZpZXcgdXNpbmcgdGhlXG4gICAgLy8gZ2l2ZW4gYGVsYC4gYGVsYCBjYW4gYmUgYSBDU1Mgc2VsZWN0b3Igb3IgYW4gSFRNTCBzdHJpbmcsIGEgalF1ZXJ5XG4gICAgLy8gY29udGV4dCBvciBhbiBlbGVtZW50LiBTdWJjbGFzc2VzIGNhbiBvdmVycmlkZSB0aGlzIHRvIHV0aWxpemUgYW5cbiAgICAvLyBhbHRlcm5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIEFQSSBhbmQgYXJlIG9ubHkgcmVxdWlyZWQgdG8gc2V0IHRoZVxuICAgIC8vIGB0aGlzLmVsYCBwcm9wZXJ0eS5cbiAgICBfc2V0RWxlbWVudDogZnVuY3Rpb24oZWwpIHtcbiAgICAgIHRoaXMuJGVsID0gZWwgaW5zdGFuY2VvZiBCYWNrYm9uZS4kID8gZWwgOiBCYWNrYm9uZS4kKGVsKTtcbiAgICAgIHRoaXMuZWwgPSB0aGlzLiRlbFswXTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IGNhbGxiYWNrcywgd2hlcmUgYHRoaXMuZXZlbnRzYCBpcyBhIGhhc2ggb2ZcbiAgICAvL1xuICAgIC8vICp7XCJldmVudCBzZWxlY3RvclwiOiBcImNhbGxiYWNrXCJ9KlxuICAgIC8vXG4gICAgLy8gICAgIHtcbiAgICAvLyAgICAgICAnbW91c2Vkb3duIC50aXRsZSc6ICAnZWRpdCcsXG4gICAgLy8gICAgICAgJ2NsaWNrIC5idXR0b24nOiAgICAgJ3NhdmUnLFxuICAgIC8vICAgICAgICdjbGljayAub3Blbic6ICAgICAgIGZ1bmN0aW9uKGUpIHsgLi4uIH1cbiAgICAvLyAgICAgfVxuICAgIC8vXG4gICAgLy8gcGFpcnMuIENhbGxiYWNrcyB3aWxsIGJlIGJvdW5kIHRvIHRoZSB2aWV3LCB3aXRoIGB0aGlzYCBzZXQgcHJvcGVybHkuXG4gICAgLy8gVXNlcyBldmVudCBkZWxlZ2F0aW9uIGZvciBlZmZpY2llbmN5LlxuICAgIC8vIE9taXR0aW5nIHRoZSBzZWxlY3RvciBiaW5kcyB0aGUgZXZlbnQgdG8gYHRoaXMuZWxgLlxuICAgIGRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbihldmVudHMpIHtcbiAgICAgIGV2ZW50cyB8fCAoZXZlbnRzID0gXy5yZXN1bHQodGhpcywgJ2V2ZW50cycpKTtcbiAgICAgIGlmICghZXZlbnRzKSByZXR1cm4gdGhpcztcbiAgICAgIHRoaXMudW5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGV2ZW50cykge1xuICAgICAgICB2YXIgbWV0aG9kID0gZXZlbnRzW2tleV07XG4gICAgICAgIGlmICghXy5pc0Z1bmN0aW9uKG1ldGhvZCkpIG1ldGhvZCA9IHRoaXNbbWV0aG9kXTtcbiAgICAgICAgaWYgKCFtZXRob2QpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgbWF0Y2ggPSBrZXkubWF0Y2goZGVsZWdhdGVFdmVudFNwbGl0dGVyKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZShtYXRjaFsxXSwgbWF0Y2hbMl0sIF8uYmluZChtZXRob2QsIHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIHZpZXcncyBlbGVtZW50IChvciBhIGNoaWxkIGVsZW1lbnRcbiAgICAvLyB1c2luZyBgc2VsZWN0b3JgKS4gVGhpcyBvbmx5IHdvcmtzIGZvciBkZWxlZ2F0ZS1hYmxlIGV2ZW50czogbm90IGBmb2N1c2AsXG4gICAgLy8gYGJsdXJgLCBhbmQgbm90IGBjaGFuZ2VgLCBgc3VibWl0YCwgYW5kIGByZXNldGAgaW4gSW50ZXJuZXQgRXhwbG9yZXIuXG4gICAgZGVsZWdhdGU6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgc2VsZWN0b3IsIGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLiRlbC5vbihldmVudE5hbWUgKyAnLmRlbGVnYXRlRXZlbnRzJyArIHRoaXMuY2lkLCBzZWxlY3RvciwgbGlzdGVuZXIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENsZWFycyBhbGwgY2FsbGJhY2tzIHByZXZpb3VzbHkgYm91bmQgdG8gdGhlIHZpZXcgYnkgYGRlbGVnYXRlRXZlbnRzYC5cbiAgICAvLyBZb3UgdXN1YWxseSBkb24ndCBuZWVkIHRvIHVzZSB0aGlzLCBidXQgbWF5IHdpc2ggdG8gaWYgeW91IGhhdmUgbXVsdGlwbGVcbiAgICAvLyBCYWNrYm9uZSB2aWV3cyBhdHRhY2hlZCB0byB0aGUgc2FtZSBET00gZWxlbWVudC5cbiAgICB1bmRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLiRlbCkgdGhpcy4kZWwub2ZmKCcuZGVsZWdhdGVFdmVudHMnICsgdGhpcy5jaWQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEEgZmluZXItZ3JhaW5lZCBgdW5kZWxlZ2F0ZUV2ZW50c2AgZm9yIHJlbW92aW5nIGEgc2luZ2xlIGRlbGVnYXRlZCBldmVudC5cbiAgICAvLyBgc2VsZWN0b3JgIGFuZCBgbGlzdGVuZXJgIGFyZSBib3RoIG9wdGlvbmFsLlxuICAgIHVuZGVsZWdhdGU6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgc2VsZWN0b3IsIGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLiRlbC5vZmYoZXZlbnROYW1lICsgJy5kZWxlZ2F0ZUV2ZW50cycgKyB0aGlzLmNpZCwgc2VsZWN0b3IsIGxpc3RlbmVyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBQcm9kdWNlcyBhIERPTSBlbGVtZW50IHRvIGJlIGFzc2lnbmVkIHRvIHlvdXIgdmlldy4gRXhwb3NlZCBmb3JcbiAgICAvLyBzdWJjbGFzc2VzIHVzaW5nIGFuIGFsdGVybmF0aXZlIERPTSBtYW5pcHVsYXRpb24gQVBJLlxuICAgIF9jcmVhdGVFbGVtZW50OiBmdW5jdGlvbih0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICB9LFxuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIFZpZXcgaGFzIGEgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAgLy8gSWYgYHRoaXMuZWxgIGlzIGEgc3RyaW5nLCBwYXNzIGl0IHRocm91Z2ggYCQoKWAsIHRha2UgdGhlIGZpcnN0XG4gICAgLy8gbWF0Y2hpbmcgZWxlbWVudCwgYW5kIHJlLWFzc2lnbiBpdCB0byBgZWxgLiBPdGhlcndpc2UsIGNyZWF0ZVxuICAgIC8vIGFuIGVsZW1lbnQgZnJvbSB0aGUgYGlkYCwgYGNsYXNzTmFtZWAgYW5kIGB0YWdOYW1lYCBwcm9wZXJ0aWVzLlxuICAgIF9lbnN1cmVFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5lbCkge1xuICAgICAgICB2YXIgYXR0cnMgPSBfLmV4dGVuZCh7fSwgXy5yZXN1bHQodGhpcywgJ2F0dHJpYnV0ZXMnKSk7XG4gICAgICAgIGlmICh0aGlzLmlkKSBhdHRycy5pZCA9IF8ucmVzdWx0KHRoaXMsICdpZCcpO1xuICAgICAgICBpZiAodGhpcy5jbGFzc05hbWUpIGF0dHJzWydjbGFzcyddID0gXy5yZXN1bHQodGhpcywgJ2NsYXNzTmFtZScpO1xuICAgICAgICB0aGlzLnNldEVsZW1lbnQodGhpcy5fY3JlYXRlRWxlbWVudChfLnJlc3VsdCh0aGlzLCAndGFnTmFtZScpKSk7XG4gICAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZXMoYXR0cnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRFbGVtZW50KF8ucmVzdWx0KHRoaXMsICdlbCcpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gU2V0IGF0dHJpYnV0ZXMgZnJvbSBhIGhhc2ggb24gdGhpcyB2aWV3J3MgZWxlbWVudC4gIEV4cG9zZWQgZm9yXG4gICAgLy8gc3ViY2xhc3NlcyB1c2luZyBhbiBhbHRlcm5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIEFQSS5cbiAgICBfc2V0QXR0cmlidXRlczogZnVuY3Rpb24oYXR0cmlidXRlcykge1xuICAgICAgdGhpcy4kZWwuYXR0cihhdHRyaWJ1dGVzKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gQmFja2JvbmUuc3luY1xuICAvLyAtLS0tLS0tLS0tLS0tXG5cbiAgLy8gT3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBjaGFuZ2UgdGhlIG1hbm5lciBpbiB3aGljaCBCYWNrYm9uZSBwZXJzaXN0c1xuICAvLyBtb2RlbHMgdG8gdGhlIHNlcnZlci4gWW91IHdpbGwgYmUgcGFzc2VkIHRoZSB0eXBlIG9mIHJlcXVlc3QsIGFuZCB0aGVcbiAgLy8gbW9kZWwgaW4gcXVlc3Rpb24uIEJ5IGRlZmF1bHQsIG1ha2VzIGEgUkVTVGZ1bCBBamF4IHJlcXVlc3RcbiAgLy8gdG8gdGhlIG1vZGVsJ3MgYHVybCgpYC4gU29tZSBwb3NzaWJsZSBjdXN0b21pemF0aW9ucyBjb3VsZCBiZTpcbiAgLy9cbiAgLy8gKiBVc2UgYHNldFRpbWVvdXRgIHRvIGJhdGNoIHJhcGlkLWZpcmUgdXBkYXRlcyBpbnRvIGEgc2luZ2xlIHJlcXVlc3QuXG4gIC8vICogU2VuZCB1cCB0aGUgbW9kZWxzIGFzIFhNTCBpbnN0ZWFkIG9mIEpTT04uXG4gIC8vICogUGVyc2lzdCBtb2RlbHMgdmlhIFdlYlNvY2tldHMgaW5zdGVhZCBvZiBBamF4LlxuICAvL1xuICAvLyBUdXJuIG9uIGBCYWNrYm9uZS5lbXVsYXRlSFRUUGAgaW4gb3JkZXIgdG8gc2VuZCBgUFVUYCBhbmQgYERFTEVURWAgcmVxdWVzdHNcbiAgLy8gYXMgYFBPU1RgLCB3aXRoIGEgYF9tZXRob2RgIHBhcmFtZXRlciBjb250YWluaW5nIHRoZSB0cnVlIEhUVFAgbWV0aG9kLFxuICAvLyBhcyB3ZWxsIGFzIGFsbCByZXF1ZXN0cyB3aXRoIHRoZSBib2R5IGFzIGBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRgXG4gIC8vIGluc3RlYWQgb2YgYGFwcGxpY2F0aW9uL2pzb25gIHdpdGggdGhlIG1vZGVsIGluIGEgcGFyYW0gbmFtZWQgYG1vZGVsYC5cbiAgLy8gVXNlZnVsIHdoZW4gaW50ZXJmYWNpbmcgd2l0aCBzZXJ2ZXItc2lkZSBsYW5ndWFnZXMgbGlrZSAqKlBIUCoqIHRoYXQgbWFrZVxuICAvLyBpdCBkaWZmaWN1bHQgdG8gcmVhZCB0aGUgYm9keSBvZiBgUFVUYCByZXF1ZXN0cy5cbiAgQmFja2JvbmUuc3luYyA9IGZ1bmN0aW9uKG1ldGhvZCwgbW9kZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgdHlwZSA9IG1ldGhvZE1hcFttZXRob2RdO1xuXG4gICAgLy8gRGVmYXVsdCBvcHRpb25zLCB1bmxlc3Mgc3BlY2lmaWVkLlxuICAgIF8uZGVmYXVsdHMob3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KSwge1xuICAgICAgZW11bGF0ZUhUVFA6IEJhY2tib25lLmVtdWxhdGVIVFRQLFxuICAgICAgZW11bGF0ZUpTT046IEJhY2tib25lLmVtdWxhdGVKU09OXG4gICAgfSk7XG5cbiAgICAvLyBEZWZhdWx0IEpTT04tcmVxdWVzdCBvcHRpb25zLlxuICAgIHZhciBwYXJhbXMgPSB7dHlwZTogdHlwZSwgZGF0YVR5cGU6ICdqc29uJ307XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSBoYXZlIGEgVVJMLlxuICAgIGlmICghb3B0aW9ucy51cmwpIHtcbiAgICAgIHBhcmFtcy51cmwgPSBfLnJlc3VsdChtb2RlbCwgJ3VybCcpIHx8IHVybEVycm9yKCk7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgcmVxdWVzdCBkYXRhLlxuICAgIGlmIChvcHRpb25zLmRhdGEgPT0gbnVsbCAmJiBtb2RlbCAmJiAobWV0aG9kID09PSAnY3JlYXRlJyB8fCBtZXRob2QgPT09ICd1cGRhdGUnIHx8IG1ldGhvZCA9PT0gJ3BhdGNoJykpIHtcbiAgICAgIHBhcmFtcy5jb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgIHBhcmFtcy5kYXRhID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5hdHRycyB8fCBtb2RlbC50b0pTT04ob3B0aW9ucykpO1xuICAgIH1cblxuICAgIC8vIEZvciBvbGRlciBzZXJ2ZXJzLCBlbXVsYXRlIEpTT04gYnkgZW5jb2RpbmcgdGhlIHJlcXVlc3QgaW50byBhbiBIVE1MLWZvcm0uXG4gICAgaWYgKG9wdGlvbnMuZW11bGF0ZUpTT04pIHtcbiAgICAgIHBhcmFtcy5jb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgcGFyYW1zLmRhdGEgPSBwYXJhbXMuZGF0YSA/IHttb2RlbDogcGFyYW1zLmRhdGF9IDoge307XG4gICAgfVxuXG4gICAgLy8gRm9yIG9sZGVyIHNlcnZlcnMsIGVtdWxhdGUgSFRUUCBieSBtaW1pY2tpbmcgdGhlIEhUVFAgbWV0aG9kIHdpdGggYF9tZXRob2RgXG4gICAgLy8gQW5kIGFuIGBYLUhUVFAtTWV0aG9kLU92ZXJyaWRlYCBoZWFkZXIuXG4gICAgaWYgKG9wdGlvbnMuZW11bGF0ZUhUVFAgJiYgKHR5cGUgPT09ICdQVVQnIHx8IHR5cGUgPT09ICdERUxFVEUnIHx8IHR5cGUgPT09ICdQQVRDSCcpKSB7XG4gICAgICBwYXJhbXMudHlwZSA9ICdQT1NUJztcbiAgICAgIGlmIChvcHRpb25zLmVtdWxhdGVKU09OKSBwYXJhbXMuZGF0YS5fbWV0aG9kID0gdHlwZTtcbiAgICAgIHZhciBiZWZvcmVTZW5kID0gb3B0aW9ucy5iZWZvcmVTZW5kO1xuICAgICAgb3B0aW9ucy5iZWZvcmVTZW5kID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdYLUhUVFAtTWV0aG9kLU92ZXJyaWRlJywgdHlwZSk7XG4gICAgICAgIGlmIChiZWZvcmVTZW5kKSByZXR1cm4gYmVmb3JlU2VuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBEb24ndCBwcm9jZXNzIGRhdGEgb24gYSBub24tR0VUIHJlcXVlc3QuXG4gICAgaWYgKHBhcmFtcy50eXBlICE9PSAnR0VUJyAmJiAhb3B0aW9ucy5lbXVsYXRlSlNPTikge1xuICAgICAgcGFyYW1zLnByb2Nlc3NEYXRhID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gUGFzcyBhbG9uZyBgdGV4dFN0YXR1c2AgYW5kIGBlcnJvclRocm93bmAgZnJvbSBqUXVlcnkuXG4gICAgdmFyIGVycm9yID0gb3B0aW9ucy5lcnJvcjtcbiAgICBvcHRpb25zLmVycm9yID0gZnVuY3Rpb24oeGhyLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgb3B0aW9ucy50ZXh0U3RhdHVzID0gdGV4dFN0YXR1cztcbiAgICAgIG9wdGlvbnMuZXJyb3JUaHJvd24gPSBlcnJvclRocm93bjtcbiAgICAgIGlmIChlcnJvcikgZXJyb3IuY2FsbChvcHRpb25zLmNvbnRleHQsIHhociwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pO1xuICAgIH07XG5cbiAgICAvLyBNYWtlIHRoZSByZXF1ZXN0LCBhbGxvd2luZyB0aGUgdXNlciB0byBvdmVycmlkZSBhbnkgQWpheCBvcHRpb25zLlxuICAgIHZhciB4aHIgPSBvcHRpb25zLnhociA9IEJhY2tib25lLmFqYXgoXy5leHRlbmQocGFyYW1zLCBvcHRpb25zKSk7XG4gICAgbW9kZWwudHJpZ2dlcigncmVxdWVzdCcsIG1vZGVsLCB4aHIsIG9wdGlvbnMpO1xuICAgIHJldHVybiB4aHI7XG4gIH07XG5cbiAgLy8gTWFwIGZyb20gQ1JVRCB0byBIVFRQIGZvciBvdXIgZGVmYXVsdCBgQmFja2JvbmUuc3luY2AgaW1wbGVtZW50YXRpb24uXG4gIHZhciBtZXRob2RNYXAgPSB7XG4gICAgJ2NyZWF0ZSc6ICdQT1NUJyxcbiAgICAndXBkYXRlJzogJ1BVVCcsXG4gICAgJ3BhdGNoJzogICdQQVRDSCcsXG4gICAgJ2RlbGV0ZSc6ICdERUxFVEUnLFxuICAgICdyZWFkJzogICAnR0VUJ1xuICB9O1xuXG4gIC8vIFNldCB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgQmFja2JvbmUuYWpheGAgdG8gcHJveHkgdGhyb3VnaCB0byBgJGAuXG4gIC8vIE92ZXJyaWRlIHRoaXMgaWYgeW91J2QgbGlrZSB0byB1c2UgYSBkaWZmZXJlbnQgbGlicmFyeS5cbiAgQmFja2JvbmUuYWpheCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBCYWNrYm9uZS4kLmFqYXguYXBwbHkoQmFja2JvbmUuJCwgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBCYWNrYm9uZS5Sb3V0ZXJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUm91dGVycyBtYXAgZmF1eC1VUkxzIHRvIGFjdGlvbnMsIGFuZCBmaXJlIGV2ZW50cyB3aGVuIHJvdXRlcyBhcmVcbiAgLy8gbWF0Y2hlZC4gQ3JlYXRpbmcgYSBuZXcgb25lIHNldHMgaXRzIGByb3V0ZXNgIGhhc2gsIGlmIG5vdCBzZXQgc3RhdGljYWxseS5cbiAgdmFyIFJvdXRlciA9IEJhY2tib25lLlJvdXRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIGlmIChvcHRpb25zLnJvdXRlcykgdGhpcy5yb3V0ZXMgPSBvcHRpb25zLnJvdXRlcztcbiAgICB0aGlzLl9iaW5kUm91dGVzKCk7XG4gICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMgZm9yIG1hdGNoaW5nIG5hbWVkIHBhcmFtIHBhcnRzIGFuZCBzcGxhdHRlZFxuICAvLyBwYXJ0cyBvZiByb3V0ZSBzdHJpbmdzLlxuICB2YXIgb3B0aW9uYWxQYXJhbSA9IC9cXCgoLio/KVxcKS9nO1xuICB2YXIgbmFtZWRQYXJhbSAgICA9IC8oXFwoXFw/KT86XFx3Ky9nO1xuICB2YXIgc3BsYXRQYXJhbSAgICA9IC9cXCpcXHcrL2c7XG4gIHZhciBlc2NhcGVSZWdFeHAgID0gL1tcXC17fVxcW1xcXSs/LixcXFxcXFxeJHwjXFxzXS9nO1xuXG4gIC8vIFNldCB1cCBhbGwgaW5oZXJpdGFibGUgKipCYWNrYm9uZS5Sb3V0ZXIqKiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxuICBfLmV4dGVuZChSb3V0ZXIucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vIE1hbnVhbGx5IGJpbmQgYSBzaW5nbGUgbmFtZWQgcm91dGUgdG8gYSBjYWxsYmFjay4gRm9yIGV4YW1wbGU6XG4gICAgLy9cbiAgICAvLyAgICAgdGhpcy5yb3V0ZSgnc2VhcmNoLzpxdWVyeS9wOm51bScsICdzZWFyY2gnLCBmdW5jdGlvbihxdWVyeSwgbnVtKSB7XG4gICAgLy8gICAgICAgLi4uXG4gICAgLy8gICAgIH0pO1xuICAgIC8vXG4gICAgcm91dGU6IGZ1bmN0aW9uKHJvdXRlLCBuYW1lLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCFfLmlzUmVnRXhwKHJvdXRlKSkgcm91dGUgPSB0aGlzLl9yb3V0ZVRvUmVnRXhwKHJvdXRlKTtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24obmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuYW1lO1xuICAgICAgICBuYW1lID0gJyc7XG4gICAgICB9XG4gICAgICBpZiAoIWNhbGxiYWNrKSBjYWxsYmFjayA9IHRoaXNbbmFtZV07XG4gICAgICB2YXIgcm91dGVyID0gdGhpcztcbiAgICAgIEJhY2tib25lLmhpc3Rvcnkucm91dGUocm91dGUsIGZ1bmN0aW9uKGZyYWdtZW50KSB7XG4gICAgICAgIHZhciBhcmdzID0gcm91dGVyLl9leHRyYWN0UGFyYW1ldGVycyhyb3V0ZSwgZnJhZ21lbnQpO1xuICAgICAgICBpZiAocm91dGVyLmV4ZWN1dGUoY2FsbGJhY2ssIGFyZ3MsIG5hbWUpICE9PSBmYWxzZSkge1xuICAgICAgICAgIHJvdXRlci50cmlnZ2VyLmFwcGx5KHJvdXRlciwgWydyb3V0ZTonICsgbmFtZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICByb3V0ZXIudHJpZ2dlcigncm91dGUnLCBuYW1lLCBhcmdzKTtcbiAgICAgICAgICBCYWNrYm9uZS5oaXN0b3J5LnRyaWdnZXIoJ3JvdXRlJywgcm91dGVyLCBuYW1lLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gRXhlY3V0ZSBhIHJvdXRlIGhhbmRsZXIgd2l0aCB0aGUgcHJvdmlkZWQgcGFyYW1ldGVycy4gIFRoaXMgaXMgYW5cbiAgICAvLyBleGNlbGxlbnQgcGxhY2UgdG8gZG8gcHJlLXJvdXRlIHNldHVwIG9yIHBvc3Qtcm91dGUgY2xlYW51cC5cbiAgICBleGVjdXRlOiBmdW5jdGlvbihjYWxsYmFjaywgYXJncywgbmFtZSkge1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9LFxuXG4gICAgLy8gU2ltcGxlIHByb3h5IHRvIGBCYWNrYm9uZS5oaXN0b3J5YCB0byBzYXZlIGEgZnJhZ21lbnQgaW50byB0aGUgaGlzdG9yeS5cbiAgICBuYXZpZ2F0ZTogZnVuY3Rpb24oZnJhZ21lbnQsIG9wdGlvbnMpIHtcbiAgICAgIEJhY2tib25lLmhpc3RvcnkubmF2aWdhdGUoZnJhZ21lbnQsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEJpbmQgYWxsIGRlZmluZWQgcm91dGVzIHRvIGBCYWNrYm9uZS5oaXN0b3J5YC4gV2UgaGF2ZSB0byByZXZlcnNlIHRoZVxuICAgIC8vIG9yZGVyIG9mIHRoZSByb3V0ZXMgaGVyZSB0byBzdXBwb3J0IGJlaGF2aW9yIHdoZXJlIHRoZSBtb3N0IGdlbmVyYWxcbiAgICAvLyByb3V0ZXMgY2FuIGJlIGRlZmluZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgcm91dGUgbWFwLlxuICAgIF9iaW5kUm91dGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5yb3V0ZXMpIHJldHVybjtcbiAgICAgIHRoaXMucm91dGVzID0gXy5yZXN1bHQodGhpcywgJ3JvdXRlcycpO1xuICAgICAgdmFyIHJvdXRlLCByb3V0ZXMgPSBfLmtleXModGhpcy5yb3V0ZXMpO1xuICAgICAgd2hpbGUgKChyb3V0ZSA9IHJvdXRlcy5wb3AoKSkgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJvdXRlKHJvdXRlLCB0aGlzLnJvdXRlc1tyb3V0ZV0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgcm91dGUgc3RyaW5nIGludG8gYSByZWd1bGFyIGV4cHJlc3Npb24sIHN1aXRhYmxlIGZvciBtYXRjaGluZ1xuICAgIC8vIGFnYWluc3QgdGhlIGN1cnJlbnQgbG9jYXRpb24gaGFzaC5cbiAgICBfcm91dGVUb1JlZ0V4cDogZnVuY3Rpb24ocm91dGUpIHtcbiAgICAgIHJvdXRlID0gcm91dGUucmVwbGFjZShlc2NhcGVSZWdFeHAsICdcXFxcJCYnKVxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKG9wdGlvbmFsUGFyYW0sICcoPzokMSk/JylcbiAgICAgICAgICAgICAgICAgICAucmVwbGFjZShuYW1lZFBhcmFtLCBmdW5jdGlvbihtYXRjaCwgb3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25hbCA/IG1hdGNoIDogJyhbXi8/XSspJztcbiAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHNwbGF0UGFyYW0sICcoW14/XSo/KScpO1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcm91dGUgKyAnKD86XFxcXD8oW1xcXFxzXFxcXFNdKikpPyQnKTtcbiAgICB9LFxuXG4gICAgLy8gR2l2ZW4gYSByb3V0ZSwgYW5kIGEgVVJMIGZyYWdtZW50IHRoYXQgaXQgbWF0Y2hlcywgcmV0dXJuIHRoZSBhcnJheSBvZlxuICAgIC8vIGV4dHJhY3RlZCBkZWNvZGVkIHBhcmFtZXRlcnMuIEVtcHR5IG9yIHVubWF0Y2hlZCBwYXJhbWV0ZXJzIHdpbGwgYmVcbiAgICAvLyB0cmVhdGVkIGFzIGBudWxsYCB0byBub3JtYWxpemUgY3Jvc3MtYnJvd3NlciBiZWhhdmlvci5cbiAgICBfZXh0cmFjdFBhcmFtZXRlcnM6IGZ1bmN0aW9uKHJvdXRlLCBmcmFnbWVudCkge1xuICAgICAgdmFyIHBhcmFtcyA9IHJvdXRlLmV4ZWMoZnJhZ21lbnQpLnNsaWNlKDEpO1xuICAgICAgcmV0dXJuIF8ubWFwKHBhcmFtcywgZnVuY3Rpb24ocGFyYW0sIGkpIHtcbiAgICAgICAgLy8gRG9uJ3QgZGVjb2RlIHRoZSBzZWFyY2ggcGFyYW1zLlxuICAgICAgICBpZiAoaSA9PT0gcGFyYW1zLmxlbmd0aCAtIDEpIHJldHVybiBwYXJhbSB8fCBudWxsO1xuICAgICAgICByZXR1cm4gcGFyYW0gPyBkZWNvZGVVUklDb21wb25lbnQocGFyYW0pIDogbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBCYWNrYm9uZS5IaXN0b3J5XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBIYW5kbGVzIGNyb3NzLWJyb3dzZXIgaGlzdG9yeSBtYW5hZ2VtZW50LCBiYXNlZCBvbiBlaXRoZXJcbiAgLy8gW3B1c2hTdGF0ZV0oaHR0cDovL2RpdmVpbnRvaHRtbDUuaW5mby9oaXN0b3J5Lmh0bWwpIGFuZCByZWFsIFVSTHMsIG9yXG4gIC8vIFtvbmhhc2hjaGFuZ2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL3dpbmRvdy5vbmhhc2hjaGFuZ2UpXG4gIC8vIGFuZCBVUkwgZnJhZ21lbnRzLiBJZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBuZWl0aGVyIChvbGQgSUUsIG5hdGNoKSxcbiAgLy8gZmFsbHMgYmFjayB0byBwb2xsaW5nLlxuICB2YXIgSGlzdG9yeSA9IEJhY2tib25lLkhpc3RvcnkgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgXy5iaW5kQWxsKHRoaXMsICdjaGVja1VybCcpO1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgYEhpc3RvcnlgIGNhbiBiZSB1c2VkIG91dHNpZGUgb2YgdGhlIGJyb3dzZXIuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuICAgICAgdGhpcy5oaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gICAgfVxuICB9O1xuXG4gIC8vIENhY2hlZCByZWdleCBmb3Igc3RyaXBwaW5nIGEgbGVhZGluZyBoYXNoL3NsYXNoIGFuZCB0cmFpbGluZyBzcGFjZS5cbiAgdmFyIHJvdXRlU3RyaXBwZXIgPSAvXlsjXFwvXXxcXHMrJC9nO1xuXG4gIC8vIENhY2hlZCByZWdleCBmb3Igc3RyaXBwaW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMuXG4gIHZhciByb290U3RyaXBwZXIgPSAvXlxcLyt8XFwvKyQvZztcblxuICAvLyBDYWNoZWQgcmVnZXggZm9yIHN0cmlwcGluZyB1cmxzIG9mIGhhc2guXG4gIHZhciBwYXRoU3RyaXBwZXIgPSAvIy4qJC87XG5cbiAgLy8gSGFzIHRoZSBoaXN0b3J5IGhhbmRsaW5nIGFscmVhZHkgYmVlbiBzdGFydGVkP1xuICBIaXN0b3J5LnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAvLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuSGlzdG9yeSoqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKEhpc3RvcnkucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIFRoZSBkZWZhdWx0IGludGVydmFsIHRvIHBvbGwgZm9yIGhhc2ggY2hhbmdlcywgaWYgbmVjZXNzYXJ5LCBpc1xuICAgIC8vIHR3ZW50eSB0aW1lcyBhIHNlY29uZC5cbiAgICBpbnRlcnZhbDogNTAsXG5cbiAgICAvLyBBcmUgd2UgYXQgdGhlIGFwcCByb290P1xuICAgIGF0Um9vdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMubG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvW15cXC9dJC8sICckJi8nKTtcbiAgICAgIHJldHVybiBwYXRoID09PSB0aGlzLnJvb3QgJiYgIXRoaXMuZ2V0U2VhcmNoKCk7XG4gICAgfSxcblxuICAgIC8vIERvZXMgdGhlIHBhdGhuYW1lIG1hdGNoIHRoZSByb290P1xuICAgIG1hdGNoUm9vdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMuZGVjb2RlRnJhZ21lbnQodGhpcy5sb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgICB2YXIgcm9vdCA9IHBhdGguc2xpY2UoMCwgdGhpcy5yb290Lmxlbmd0aCAtIDEpICsgJy8nO1xuICAgICAgcmV0dXJuIHJvb3QgPT09IHRoaXMucm9vdDtcbiAgICB9LFxuXG4gICAgLy8gVW5pY29kZSBjaGFyYWN0ZXJzIGluIGBsb2NhdGlvbi5wYXRobmFtZWAgYXJlIHBlcmNlbnQgZW5jb2RlZCBzbyB0aGV5J3JlXG4gICAgLy8gZGVjb2RlZCBmb3IgY29tcGFyaXNvbi4gYCUyNWAgc2hvdWxkIG5vdCBiZSBkZWNvZGVkIHNpbmNlIGl0IG1heSBiZSBwYXJ0XG4gICAgLy8gb2YgYW4gZW5jb2RlZCBwYXJhbWV0ZXIuXG4gICAgZGVjb2RlRnJhZ21lbnQ6IGZ1bmN0aW9uKGZyYWdtZW50KSB7XG4gICAgICByZXR1cm4gZGVjb2RlVVJJKGZyYWdtZW50LnJlcGxhY2UoLyUyNS9nLCAnJTI1MjUnKSk7XG4gICAgfSxcblxuICAgIC8vIEluIElFNiwgdGhlIGhhc2ggZnJhZ21lbnQgYW5kIHNlYXJjaCBwYXJhbXMgYXJlIGluY29ycmVjdCBpZiB0aGVcbiAgICAvLyBmcmFnbWVudCBjb250YWlucyBgP2AuXG4gICAgZ2V0U2VhcmNoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXRjaCA9IHRoaXMubG9jYXRpb24uaHJlZi5yZXBsYWNlKC8jLiovLCAnJykubWF0Y2goL1xcPy4rLyk7XG4gICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFswXSA6ICcnO1xuICAgIH0sXG5cbiAgICAvLyBHZXRzIHRoZSB0cnVlIGhhc2ggdmFsdWUuIENhbm5vdCB1c2UgbG9jYXRpb24uaGFzaCBkaXJlY3RseSBkdWUgdG8gYnVnXG4gICAgLy8gaW4gRmlyZWZveCB3aGVyZSBsb2NhdGlvbi5oYXNoIHdpbGwgYWx3YXlzIGJlIGRlY29kZWQuXG4gICAgZ2V0SGFzaDogZnVuY3Rpb24od2luZG93KSB7XG4gICAgICB2YXIgbWF0Y2ggPSAod2luZG93IHx8IHRoaXMpLmxvY2F0aW9uLmhyZWYubWF0Y2goLyMoLiopJC8pO1xuICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJztcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBwYXRobmFtZSBhbmQgc2VhcmNoIHBhcmFtcywgd2l0aG91dCB0aGUgcm9vdC5cbiAgICBnZXRQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5kZWNvZGVGcmFnbWVudChcbiAgICAgICAgdGhpcy5sb2NhdGlvbi5wYXRobmFtZSArIHRoaXMuZ2V0U2VhcmNoKClcbiAgICAgICkuc2xpY2UodGhpcy5yb290Lmxlbmd0aCAtIDEpO1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoLnNsaWNlKDEpIDogcGF0aDtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBjcm9zcy1icm93c2VyIG5vcm1hbGl6ZWQgVVJMIGZyYWdtZW50IGZyb20gdGhlIHBhdGggb3IgaGFzaC5cbiAgICBnZXRGcmFnbWVudDogZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgICAgIGlmIChmcmFnbWVudCA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLl91c2VQdXNoU3RhdGUgfHwgIXRoaXMuX3dhbnRzSGFzaENoYW5nZSkge1xuICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZXRQYXRoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEhhc2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2Uocm91dGVTdHJpcHBlciwgJycpO1xuICAgIH0sXG5cbiAgICAvLyBTdGFydCB0aGUgaGFzaCBjaGFuZ2UgaGFuZGxpbmcsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlIGN1cnJlbnQgVVJMIG1hdGNoZXNcbiAgICAvLyBhbiBleGlzdGluZyByb3V0ZSwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgIHN0YXJ0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoSGlzdG9yeS5zdGFydGVkKSB0aHJvdyBuZXcgRXJyb3IoJ0JhY2tib25lLmhpc3RvcnkgaGFzIGFscmVhZHkgYmVlbiBzdGFydGVkJyk7XG4gICAgICBIaXN0b3J5LnN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgICAvLyBGaWd1cmUgb3V0IHRoZSBpbml0aWFsIGNvbmZpZ3VyYXRpb24uIERvIHdlIG5lZWQgYW4gaWZyYW1lP1xuICAgICAgLy8gSXMgcHVzaFN0YXRlIGRlc2lyZWQgLi4uIGlzIGl0IGF2YWlsYWJsZT9cbiAgICAgIHRoaXMub3B0aW9ucyAgICAgICAgICA9IF8uZXh0ZW5kKHtyb290OiAnLyd9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5yb290ICAgICAgICAgICAgID0gdGhpcy5vcHRpb25zLnJvb3Q7XG4gICAgICB0aGlzLl93YW50c0hhc2hDaGFuZ2UgPSB0aGlzLm9wdGlvbnMuaGFzaENoYW5nZSAhPT0gZmFsc2U7XG4gICAgICB0aGlzLl9oYXNIYXNoQ2hhbmdlICAgPSAnb25oYXNoY2hhbmdlJyBpbiB3aW5kb3c7XG4gICAgICB0aGlzLl91c2VIYXNoQ2hhbmdlICAgPSB0aGlzLl93YW50c0hhc2hDaGFuZ2UgJiYgdGhpcy5faGFzSGFzaENoYW5nZTtcbiAgICAgIHRoaXMuX3dhbnRzUHVzaFN0YXRlICA9ICEhdGhpcy5vcHRpb25zLnB1c2hTdGF0ZTtcbiAgICAgIHRoaXMuX2hhc1B1c2hTdGF0ZSAgICA9ICEhKHRoaXMuaGlzdG9yeSAmJiB0aGlzLmhpc3RvcnkucHVzaFN0YXRlKTtcbiAgICAgIHRoaXMuX3VzZVB1c2hTdGF0ZSAgICA9IHRoaXMuX3dhbnRzUHVzaFN0YXRlICYmIHRoaXMuX2hhc1B1c2hTdGF0ZTtcbiAgICAgIHRoaXMuZnJhZ21lbnQgICAgICAgICA9IHRoaXMuZ2V0RnJhZ21lbnQoKTtcblxuICAgICAgLy8gTm9ybWFsaXplIHJvb3QgdG8gYWx3YXlzIGluY2x1ZGUgYSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaC5cbiAgICAgIHRoaXMucm9vdCA9ICgnLycgKyB0aGlzLnJvb3QgKyAnLycpLnJlcGxhY2Uocm9vdFN0cmlwcGVyLCAnLycpO1xuXG4gICAgICAvLyBUcmFuc2l0aW9uIGZyb20gaGFzaENoYW5nZSB0byBwdXNoU3RhdGUgb3IgdmljZSB2ZXJzYSBpZiBib3RoIGFyZVxuICAgICAgLy8gcmVxdWVzdGVkLlxuICAgICAgaWYgKHRoaXMuX3dhbnRzSGFzaENoYW5nZSAmJiB0aGlzLl93YW50c1B1c2hTdGF0ZSkge1xuXG4gICAgICAgIC8vIElmIHdlJ3ZlIHN0YXJ0ZWQgb2ZmIHdpdGggYSByb3V0ZSBmcm9tIGEgYHB1c2hTdGF0ZWAtZW5hYmxlZFxuICAgICAgICAvLyBicm93c2VyLCBidXQgd2UncmUgY3VycmVudGx5IGluIGEgYnJvd3NlciB0aGF0IGRvZXNuJ3Qgc3VwcG9ydCBpdC4uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc1B1c2hTdGF0ZSAmJiAhdGhpcy5hdFJvb3QoKSkge1xuICAgICAgICAgIHZhciByb290ID0gdGhpcy5yb290LnNsaWNlKDAsIC0xKSB8fCAnLyc7XG4gICAgICAgICAgdGhpcy5sb2NhdGlvbi5yZXBsYWNlKHJvb3QgKyAnIycgKyB0aGlzLmdldFBhdGgoKSk7XG4gICAgICAgICAgLy8gUmV0dXJuIGltbWVkaWF0ZWx5IGFzIGJyb3dzZXIgd2lsbCBkbyByZWRpcmVjdCB0byBuZXcgdXJsXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgLy8gT3IgaWYgd2UndmUgc3RhcnRlZCBvdXQgd2l0aCBhIGhhc2gtYmFzZWQgcm91dGUsIGJ1dCB3ZSdyZSBjdXJyZW50bHlcbiAgICAgICAgLy8gaW4gYSBicm93c2VyIHdoZXJlIGl0IGNvdWxkIGJlIGBwdXNoU3RhdGVgLWJhc2VkIGluc3RlYWQuLi5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9oYXNQdXNoU3RhdGUgJiYgdGhpcy5hdFJvb3QoKSkge1xuICAgICAgICAgIHRoaXMubmF2aWdhdGUodGhpcy5nZXRIYXNoKCksIHtyZXBsYWNlOiB0cnVlfSk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICAvLyBQcm94eSBhbiBpZnJhbWUgdG8gaGFuZGxlIGxvY2F0aW9uIGV2ZW50cyBpZiB0aGUgYnJvd3NlciBkb2Vzbid0XG4gICAgICAvLyBzdXBwb3J0IHRoZSBgaGFzaGNoYW5nZWAgZXZlbnQsIEhUTUw1IGhpc3RvcnksIG9yIHRoZSB1c2VyIHdhbnRzXG4gICAgICAvLyBgaGFzaENoYW5nZWAgYnV0IG5vdCBgcHVzaFN0YXRlYC5cbiAgICAgIGlmICghdGhpcy5faGFzSGFzaENoYW5nZSAmJiB0aGlzLl93YW50c0hhc2hDaGFuZ2UgJiYgIXRoaXMuX3VzZVB1c2hTdGF0ZSkge1xuICAgICAgICB0aGlzLmlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICB0aGlzLmlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDowJztcbiAgICAgICAgdGhpcy5pZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5pZnJhbWUudGFiSW5kZXggPSAtMTtcbiAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICAvLyBVc2luZyBgYXBwZW5kQ2hpbGRgIHdpbGwgdGhyb3cgb24gSUUgPCA5IGlmIHRoZSBkb2N1bWVudCBpcyBub3QgcmVhZHkuXG4gICAgICAgIHZhciBpV2luZG93ID0gYm9keS5pbnNlcnRCZWZvcmUodGhpcy5pZnJhbWUsIGJvZHkuZmlyc3RDaGlsZCkuY29udGVudFdpbmRvdztcbiAgICAgICAgaVdpbmRvdy5kb2N1bWVudC5vcGVuKCk7XG4gICAgICAgIGlXaW5kb3cuZG9jdW1lbnQuY2xvc2UoKTtcbiAgICAgICAgaVdpbmRvdy5sb2NhdGlvbi5oYXNoID0gJyMnICsgdGhpcy5mcmFnbWVudDtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGEgY3Jvc3MtcGxhdGZvcm0gYGFkZEV2ZW50TGlzdGVuZXJgIHNoaW0gZm9yIG9sZGVyIGJyb3dzZXJzLlxuICAgICAgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgfTtcblxuICAgICAgLy8gRGVwZW5kaW5nIG9uIHdoZXRoZXIgd2UncmUgdXNpbmcgcHVzaFN0YXRlIG9yIGhhc2hlcywgYW5kIHdoZXRoZXJcbiAgICAgIC8vICdvbmhhc2hjaGFuZ2UnIGlzIHN1cHBvcnRlZCwgZGV0ZXJtaW5lIGhvdyB3ZSBjaGVjayB0aGUgVVJMIHN0YXRlLlxuICAgICAgaWYgKHRoaXMuX3VzZVB1c2hTdGF0ZSkge1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMuY2hlY2tVcmwsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fdXNlSGFzaENoYW5nZSAmJiAhdGhpcy5pZnJhbWUpIHtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIHRoaXMuY2hlY2tVcmwsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrVXJsSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLmNoZWNrVXJsLCB0aGlzLmludGVydmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2lsZW50KSByZXR1cm4gdGhpcy5sb2FkVXJsKCk7XG4gICAgfSxcblxuICAgIC8vIERpc2FibGUgQmFja2JvbmUuaGlzdG9yeSwgcGVyaGFwcyB0ZW1wb3JhcmlseS4gTm90IHVzZWZ1bCBpbiBhIHJlYWwgYXBwLFxuICAgIC8vIGJ1dCBwb3NzaWJseSB1c2VmdWwgZm9yIHVuaXQgdGVzdGluZyBSb3V0ZXJzLlxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gQWRkIGEgY3Jvc3MtcGxhdGZvcm0gYHJlbW92ZUV2ZW50TGlzdGVuZXJgIHNoaW0gZm9yIG9sZGVyIGJyb3dzZXJzLlxuICAgICAgdmFyIHJlbW92ZUV2ZW50TGlzdGVuZXIgPSB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciB8fCBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgfTtcblxuICAgICAgLy8gUmVtb3ZlIHdpbmRvdyBsaXN0ZW5lcnMuXG4gICAgICBpZiAodGhpcy5fdXNlUHVzaFN0YXRlKSB7XG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5jaGVja1VybCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl91c2VIYXNoQ2hhbmdlICYmICF0aGlzLmlmcmFtZSkge1xuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgdGhpcy5jaGVja1VybCwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhbiB1cCB0aGUgaWZyYW1lIGlmIG5lY2Vzc2FyeS5cbiAgICAgIGlmICh0aGlzLmlmcmFtZSkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMuaWZyYW1lKTtcbiAgICAgICAgdGhpcy5pZnJhbWUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBTb21lIGVudmlyb25tZW50cyB3aWxsIHRocm93IHdoZW4gY2xlYXJpbmcgYW4gdW5kZWZpbmVkIGludGVydmFsLlxuICAgICAgaWYgKHRoaXMuX2NoZWNrVXJsSW50ZXJ2YWwpIGNsZWFySW50ZXJ2YWwodGhpcy5fY2hlY2tVcmxJbnRlcnZhbCk7XG4gICAgICBIaXN0b3J5LnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgcm91dGUgdG8gYmUgdGVzdGVkIHdoZW4gdGhlIGZyYWdtZW50IGNoYW5nZXMuIFJvdXRlcyBhZGRlZCBsYXRlclxuICAgIC8vIG1heSBvdmVycmlkZSBwcmV2aW91cyByb3V0ZXMuXG4gICAgcm91dGU6IGZ1bmN0aW9uKHJvdXRlLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy5oYW5kbGVycy51bnNoaWZ0KHtyb3V0ZTogcm91dGUsIGNhbGxiYWNrOiBjYWxsYmFja30pO1xuICAgIH0sXG5cbiAgICAvLyBDaGVja3MgdGhlIGN1cnJlbnQgVVJMIHRvIHNlZSBpZiBpdCBoYXMgY2hhbmdlZCwgYW5kIGlmIGl0IGhhcyxcbiAgICAvLyBjYWxscyBgbG9hZFVybGAsIG5vcm1hbGl6aW5nIGFjcm9zcyB0aGUgaGlkZGVuIGlmcmFtZS5cbiAgICBjaGVja1VybDogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldEZyYWdtZW50KCk7XG5cbiAgICAgIC8vIElmIHRoZSB1c2VyIHByZXNzZWQgdGhlIGJhY2sgYnV0dG9uLCB0aGUgaWZyYW1lJ3MgaGFzaCB3aWxsIGhhdmVcbiAgICAgIC8vIGNoYW5nZWQgYW5kIHdlIHNob3VsZCB1c2UgdGhhdCBmb3IgY29tcGFyaXNvbi5cbiAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmZyYWdtZW50ICYmIHRoaXMuaWZyYW1lKSB7XG4gICAgICAgIGN1cnJlbnQgPSB0aGlzLmdldEhhc2godGhpcy5pZnJhbWUuY29udGVudFdpbmRvdyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmZyYWdtZW50KSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAodGhpcy5pZnJhbWUpIHRoaXMubmF2aWdhdGUoY3VycmVudCk7XG4gICAgICB0aGlzLmxvYWRVcmwoKTtcbiAgICB9LFxuXG4gICAgLy8gQXR0ZW1wdCB0byBsb2FkIHRoZSBjdXJyZW50IFVSTCBmcmFnbWVudC4gSWYgYSByb3V0ZSBzdWNjZWVkcyB3aXRoIGFcbiAgICAvLyBtYXRjaCwgcmV0dXJucyBgdHJ1ZWAuIElmIG5vIGRlZmluZWQgcm91dGVzIG1hdGNoZXMgdGhlIGZyYWdtZW50LFxuICAgIC8vIHJldHVybnMgYGZhbHNlYC5cbiAgICBsb2FkVXJsOiBmdW5jdGlvbihmcmFnbWVudCkge1xuICAgICAgLy8gSWYgdGhlIHJvb3QgZG9lc24ndCBtYXRjaCwgbm8gcm91dGVzIGNhbiBtYXRjaCBlaXRoZXIuXG4gICAgICBpZiAoIXRoaXMubWF0Y2hSb290KCkpIHJldHVybiBmYWxzZTtcbiAgICAgIGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudCA9IHRoaXMuZ2V0RnJhZ21lbnQoZnJhZ21lbnQpO1xuICAgICAgcmV0dXJuIF8uYW55KHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGhhbmRsZXIucm91dGUudGVzdChmcmFnbWVudCkpIHtcbiAgICAgICAgICBoYW5kbGVyLmNhbGxiYWNrKGZyYWdtZW50KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIFNhdmUgYSBmcmFnbWVudCBpbnRvIHRoZSBoYXNoIGhpc3RvcnksIG9yIHJlcGxhY2UgdGhlIFVSTCBzdGF0ZSBpZiB0aGVcbiAgICAvLyAncmVwbGFjZScgb3B0aW9uIGlzIHBhc3NlZC4gWW91IGFyZSByZXNwb25zaWJsZSBmb3IgcHJvcGVybHkgVVJMLWVuY29kaW5nXG4gICAgLy8gdGhlIGZyYWdtZW50IGluIGFkdmFuY2UuXG4gICAgLy9cbiAgICAvLyBUaGUgb3B0aW9ucyBvYmplY3QgY2FuIGNvbnRhaW4gYHRyaWdnZXI6IHRydWVgIGlmIHlvdSB3aXNoIHRvIGhhdmUgdGhlXG4gICAgLy8gcm91dGUgY2FsbGJhY2sgYmUgZmlyZWQgKG5vdCB1c3VhbGx5IGRlc2lyYWJsZSksIG9yIGByZXBsYWNlOiB0cnVlYCwgaWZcbiAgICAvLyB5b3Ugd2lzaCB0byBtb2RpZnkgdGhlIGN1cnJlbnQgVVJMIHdpdGhvdXQgYWRkaW5nIGFuIGVudHJ5IHRvIHRoZSBoaXN0b3J5LlxuICAgIG5hdmlnYXRlOiBmdW5jdGlvbihmcmFnbWVudCwgb3B0aW9ucykge1xuICAgICAgaWYgKCFIaXN0b3J5LnN0YXJ0ZWQpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zID09PSB0cnVlKSBvcHRpb25zID0ge3RyaWdnZXI6ICEhb3B0aW9uc307XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgZnJhZ21lbnQuXG4gICAgICBmcmFnbWVudCA9IHRoaXMuZ2V0RnJhZ21lbnQoZnJhZ21lbnQgfHwgJycpO1xuXG4gICAgICAvLyBEb24ndCBpbmNsdWRlIGEgdHJhaWxpbmcgc2xhc2ggb24gdGhlIHJvb3QuXG4gICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcbiAgICAgIGlmIChmcmFnbWVudCA9PT0gJycgfHwgZnJhZ21lbnQuY2hhckF0KDApID09PSAnPycpIHtcbiAgICAgICAgcm9vdCA9IHJvb3Quc2xpY2UoMCwgLTEpIHx8ICcvJztcbiAgICAgIH1cbiAgICAgIHZhciB1cmwgPSByb290ICsgZnJhZ21lbnQ7XG5cbiAgICAgIC8vIFN0cmlwIHRoZSBoYXNoIGFuZCBkZWNvZGUgZm9yIG1hdGNoaW5nLlxuICAgICAgZnJhZ21lbnQgPSB0aGlzLmRlY29kZUZyYWdtZW50KGZyYWdtZW50LnJlcGxhY2UocGF0aFN0cmlwcGVyLCAnJykpO1xuXG4gICAgICBpZiAodGhpcy5mcmFnbWVudCA9PT0gZnJhZ21lbnQpIHJldHVybjtcbiAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudDtcblxuICAgICAgLy8gSWYgcHVzaFN0YXRlIGlzIGF2YWlsYWJsZSwgd2UgdXNlIGl0IHRvIHNldCB0aGUgZnJhZ21lbnQgYXMgYSByZWFsIFVSTC5cbiAgICAgIGlmICh0aGlzLl91c2VQdXNoU3RhdGUpIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5W29wdGlvbnMucmVwbGFjZSA/ICdyZXBsYWNlU3RhdGUnIDogJ3B1c2hTdGF0ZSddKHt9LCBkb2N1bWVudC50aXRsZSwgdXJsKTtcblxuICAgICAgLy8gSWYgaGFzaCBjaGFuZ2VzIGhhdmVuJ3QgYmVlbiBleHBsaWNpdGx5IGRpc2FibGVkLCB1cGRhdGUgdGhlIGhhc2hcbiAgICAgIC8vIGZyYWdtZW50IHRvIHN0b3JlIGhpc3RvcnkuXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3dhbnRzSGFzaENoYW5nZSkge1xuICAgICAgICB0aGlzLl91cGRhdGVIYXNoKHRoaXMubG9jYXRpb24sIGZyYWdtZW50LCBvcHRpb25zLnJlcGxhY2UpO1xuICAgICAgICBpZiAodGhpcy5pZnJhbWUgJiYgKGZyYWdtZW50ICE9PSB0aGlzLmdldEhhc2godGhpcy5pZnJhbWUuY29udGVudFdpbmRvdykpKSB7XG4gICAgICAgICAgdmFyIGlXaW5kb3cgPSB0aGlzLmlmcmFtZS5jb250ZW50V2luZG93O1xuXG4gICAgICAgICAgLy8gT3BlbmluZyBhbmQgY2xvc2luZyB0aGUgaWZyYW1lIHRyaWNrcyBJRTcgYW5kIGVhcmxpZXIgdG8gcHVzaCBhXG4gICAgICAgICAgLy8gaGlzdG9yeSBlbnRyeSBvbiBoYXNoLXRhZyBjaGFuZ2UuICBXaGVuIHJlcGxhY2UgaXMgdHJ1ZSwgd2UgZG9uJ3RcbiAgICAgICAgICAvLyB3YW50IHRoaXMuXG4gICAgICAgICAgaWYgKCFvcHRpb25zLnJlcGxhY2UpIHtcbiAgICAgICAgICAgIGlXaW5kb3cuZG9jdW1lbnQub3BlbigpO1xuICAgICAgICAgICAgaVdpbmRvdy5kb2N1bWVudC5jbG9zZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3VwZGF0ZUhhc2goaVdpbmRvdy5sb2NhdGlvbiwgZnJhZ21lbnQsIG9wdGlvbnMucmVwbGFjZSk7XG4gICAgICAgIH1cblxuICAgICAgLy8gSWYgeW91J3ZlIHRvbGQgdXMgdGhhdCB5b3UgZXhwbGljaXRseSBkb24ndCB3YW50IGZhbGxiYWNrIGhhc2hjaGFuZ2UtXG4gICAgICAvLyBiYXNlZCBoaXN0b3J5LCB0aGVuIGBuYXZpZ2F0ZWAgYmVjb21lcyBhIHBhZ2UgcmVmcmVzaC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudHJpZ2dlcikgcmV0dXJuIHRoaXMubG9hZFVybChmcmFnbWVudCk7XG4gICAgfSxcblxuICAgIC8vIFVwZGF0ZSB0aGUgaGFzaCBsb2NhdGlvbiwgZWl0aGVyIHJlcGxhY2luZyB0aGUgY3VycmVudCBlbnRyeSwgb3IgYWRkaW5nXG4gICAgLy8gYSBuZXcgb25lIHRvIHRoZSBicm93c2VyIGhpc3RvcnkuXG4gICAgX3VwZGF0ZUhhc2g6IGZ1bmN0aW9uKGxvY2F0aW9uLCBmcmFnbWVudCwgcmVwbGFjZSkge1xuICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgdmFyIGhyZWYgPSBsb2NhdGlvbi5ocmVmLnJlcGxhY2UoLyhqYXZhc2NyaXB0OnwjKS4qJC8sICcnKTtcbiAgICAgICAgbG9jYXRpb24ucmVwbGFjZShocmVmICsgJyMnICsgZnJhZ21lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU29tZSBicm93c2VycyByZXF1aXJlIHRoYXQgYGhhc2hgIGNvbnRhaW5zIGEgbGVhZGluZyAjLlxuICAgICAgICBsb2NhdGlvbi5oYXNoID0gJyMnICsgZnJhZ21lbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIENyZWF0ZSB0aGUgZGVmYXVsdCBCYWNrYm9uZS5oaXN0b3J5LlxuICBCYWNrYm9uZS5oaXN0b3J5ID0gbmV3IEhpc3Rvcnk7XG5cbiAgLy8gSGVscGVyc1xuICAvLyAtLS0tLS0tXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvcnJlY3RseSBzZXQgdXAgdGhlIHByb3RvdHlwZSBjaGFpbiBmb3Igc3ViY2xhc3Nlcy5cbiAgLy8gU2ltaWxhciB0byBgZ29vZy5pbmhlcml0c2AsIGJ1dCB1c2VzIGEgaGFzaCBvZiBwcm90b3R5cGUgcHJvcGVydGllcyBhbmRcbiAgLy8gY2xhc3MgcHJvcGVydGllcyB0byBiZSBleHRlbmRlZC5cbiAgdmFyIGV4dGVuZCA9IGZ1bmN0aW9uKHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgdmFyIGNoaWxkO1xuXG4gICAgLy8gVGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgbmV3IHN1YmNsYXNzIGlzIGVpdGhlciBkZWZpbmVkIGJ5IHlvdVxuICAgIC8vICh0aGUgXCJjb25zdHJ1Y3RvclwiIHByb3BlcnR5IGluIHlvdXIgYGV4dGVuZGAgZGVmaW5pdGlvbiksIG9yIGRlZmF1bHRlZFxuICAgIC8vIGJ5IHVzIHRvIHNpbXBseSBjYWxsIHRoZSBwYXJlbnQgY29uc3RydWN0b3IuXG4gICAgaWYgKHByb3RvUHJvcHMgJiYgXy5oYXMocHJvdG9Qcm9wcywgJ2NvbnN0cnVjdG9yJykpIHtcbiAgICAgIGNoaWxkID0gcHJvdG9Qcm9wcy5jb25zdHJ1Y3RvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGQgPSBmdW5jdGlvbigpeyByZXR1cm4gcGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgfVxuXG4gICAgLy8gQWRkIHN0YXRpYyBwcm9wZXJ0aWVzIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgaWYgc3VwcGxpZWQuXG4gICAgXy5leHRlbmQoY2hpbGQsIHBhcmVudCwgc3RhdGljUHJvcHMpO1xuXG4gICAgLy8gU2V0IHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gaW5oZXJpdCBmcm9tIGBwYXJlbnRgLCB3aXRob3V0IGNhbGxpbmdcbiAgICAvLyBgcGFyZW50YCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICB2YXIgU3Vycm9nYXRlID0gZnVuY3Rpb24oKXsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9O1xuICAgIFN1cnJvZ2F0ZS5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBTdXJyb2dhdGU7XG5cbiAgICAvLyBBZGQgcHJvdG90eXBlIHByb3BlcnRpZXMgKGluc3RhbmNlIHByb3BlcnRpZXMpIHRvIHRoZSBzdWJjbGFzcyxcbiAgICAvLyBpZiBzdXBwbGllZC5cbiAgICBpZiAocHJvdG9Qcm9wcykgXy5leHRlbmQoY2hpbGQucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcblxuICAgIC8vIFNldCBhIGNvbnZlbmllbmNlIHByb3BlcnR5IGluIGNhc2UgdGhlIHBhcmVudCdzIHByb3RvdHlwZSBpcyBuZWVkZWRcbiAgICAvLyBsYXRlci5cbiAgICBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlO1xuXG4gICAgcmV0dXJuIGNoaWxkO1xuICB9O1xuXG4gIC8vIFNldCB1cCBpbmhlcml0YW5jZSBmb3IgdGhlIG1vZGVsLCBjb2xsZWN0aW9uLCByb3V0ZXIsIHZpZXcgYW5kIGhpc3RvcnkuXG4gIE1vZGVsLmV4dGVuZCA9IENvbGxlY3Rpb24uZXh0ZW5kID0gUm91dGVyLmV4dGVuZCA9IFZpZXcuZXh0ZW5kID0gSGlzdG9yeS5leHRlbmQgPSBleHRlbmQ7XG5cbiAgLy8gVGhyb3cgYW4gZXJyb3Igd2hlbiBhIFVSTCBpcyBuZWVkZWQsIGFuZCBub25lIGlzIHN1cHBsaWVkLlxuICB2YXIgdXJsRXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgXCJ1cmxcIiBwcm9wZXJ0eSBvciBmdW5jdGlvbiBtdXN0IGJlIHNwZWNpZmllZCcpO1xuICB9O1xuXG4gIC8vIFdyYXAgYW4gb3B0aW9uYWwgZXJyb3IgY2FsbGJhY2sgd2l0aCBhIGZhbGxiYWNrIGVycm9yIGV2ZW50LlxuICB2YXIgd3JhcEVycm9yID0gZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgZXJyb3IgPSBvcHRpb25zLmVycm9yO1xuICAgIG9wdGlvbnMuZXJyb3IgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICBpZiAoZXJyb3IpIGVycm9yLmNhbGwob3B0aW9ucy5jb250ZXh0LCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICBtb2RlbC50cmlnZ2VyKCdlcnJvcicsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBCYWNrYm9uZTtcblxufSkpO1xuIl19
},{"jquery":17,"underscore":18}],7:[function(require,module,exports){
;(function () {
	'use strict';

	/**
	 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
	 *
	 * @codingstandard ftlabs-jsv2
	 * @copyright The Financial Times Limited [All Rights Reserved]
	 * @license MIT License (see LICENSE.txt)
	 */

	/*jslint browser:true, node:true*/
	/*global define, Event, Node*/


	/**
	 * Instantiate fast-clicking listeners on the specified layer.
	 *
	 * @constructor
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	function FastClick(layer, options) {
		var oldOnClick;

		options = options || {};

		/**
		 * Whether a click is currently being tracked.
		 *
		 * @type boolean
		 */
		this.trackingClick = false;


		/**
		 * Timestamp for when click tracking started.
		 *
		 * @type number
		 */
		this.trackingClickStart = 0;


		/**
		 * The element being tracked for a click.
		 *
		 * @type EventTarget
		 */
		this.targetElement = null;


		/**
		 * X-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartX = 0;


		/**
		 * Y-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartY = 0;


		/**
		 * ID of the last touch, retrieved from Touch.identifier.
		 *
		 * @type number
		 */
		this.lastTouchIdentifier = 0;


		/**
		 * Touchmove boundary, beyond which a click will be cancelled.
		 *
		 * @type number
		 */
		this.touchBoundary = options.touchBoundary || 10;


		/**
		 * The FastClick layer.
		 *
		 * @type Element
		 */
		this.layer = layer;

		/**
		 * The minimum time between tap(touchstart and touchend) events
		 *
		 * @type number
		 */
		this.tapDelay = options.tapDelay || 200;

		/**
		 * The maximum time for a tap
		 *
		 * @type number
		 */
		this.tapTimeout = options.tapTimeout || 700;

		if (FastClick.notNeeded(layer)) {
			return;
		}

		// Some old versions of Android don't have Function.prototype.bind
		function bind(method, context) {
			return function() { return method.apply(context, arguments); };
		}


		var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
		var context = this;
		for (var i = 0, l = methods.length; i < l; i++) {
			context[methods[i]] = bind(context[methods[i]], context);
		}

		// Set up event handlers as required
		if (deviceIsAndroid) {
			layer.addEventListener('mouseover', this.onMouse, true);
			layer.addEventListener('mousedown', this.onMouse, true);
			layer.addEventListener('mouseup', this.onMouse, true);
		}

		layer.addEventListener('click', this.onClick, true);
		layer.addEventListener('touchstart', this.onTouchStart, false);
		layer.addEventListener('touchmove', this.onTouchMove, false);
		layer.addEventListener('touchend', this.onTouchEnd, false);
		layer.addEventListener('touchcancel', this.onTouchCancel, false);

		// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
		// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
		// layer when they are cancelled.
		if (!Event.prototype.stopImmediatePropagation) {
			layer.removeEventListener = function(type, callback, capture) {
				var rmv = Node.prototype.removeEventListener;
				if (type === 'click') {
					rmv.call(layer, type, callback.hijacked || callback, capture);
				} else {
					rmv.call(layer, type, callback, capture);
				}
			};

			layer.addEventListener = function(type, callback, capture) {
				var adv = Node.prototype.addEventListener;
				if (type === 'click') {
					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
						if (!event.propagationStopped) {
							callback(event);
						}
					}), capture);
				} else {
					adv.call(layer, type, callback, capture);
				}
			};
		}

		// If a handler is already declared in the element's onclick attribute, it will be fired before
		// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
		// adding it as listener.
		if (typeof layer.onclick === 'function') {

			// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
			// - the old one won't work if passed to addEventListener directly.
			oldOnClick = layer.onclick;
			layer.addEventListener('click', function(event) {
				oldOnClick(event);
			}, false);
			layer.onclick = null;
		}
	}

	/**
	* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
	*
	* @type boolean
	*/
	var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;

	/**
	 * Android requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;


	/**
	 * iOS requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;


	/**
	 * iOS 4 requires an exception for select elements.
	 *
	 * @type boolean
	 */
	var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


	/**
	 * iOS 6.0-7.* requires the target element to be manually derived
	 *
	 * @type boolean
	 */
	var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);

	/**
	 * BlackBerry requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

	/**
	 * Determine whether a given element requires a native click.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element needs a native click
	 */
	FastClick.prototype.needsClick = function(target) {
		switch (target.nodeName.toLowerCase()) {

		// Don't send a synthetic click to disabled inputs (issue #62)
		case 'button':
		case 'select':
		case 'textarea':
			if (target.disabled) {
				return true;
			}

			break;
		case 'input':

			// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
			if ((deviceIsIOS && target.type === 'file') || target.disabled) {
				return true;
			}

			break;
		case 'label':
		case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
		case 'video':
			return true;
		}

		return (/\bneedsclick\b/).test(target.className);
	};


	/**
	 * Determine whether a given element requires a call to focus to simulate click into element.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
	 */
	FastClick.prototype.needsFocus = function(target) {
		switch (target.nodeName.toLowerCase()) {
		case 'textarea':
			return true;
		case 'select':
			return !deviceIsAndroid;
		case 'input':
			switch (target.type) {
			case 'button':
			case 'checkbox':
			case 'file':
			case 'image':
			case 'radio':
			case 'submit':
				return false;
			}

			// No point in attempting to focus disabled inputs
			return !target.disabled && !target.readOnly;
		default:
			return (/\bneedsfocus\b/).test(target.className);
		}
	};


	/**
	 * Send a click event to the specified element.
	 *
	 * @param {EventTarget|Element} targetElement
	 * @param {Event} event
	 */
	FastClick.prototype.sendClick = function(targetElement, event) {
		var clickEvent, touch;

		// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
		if (document.activeElement && document.activeElement !== targetElement) {
			document.activeElement.blur();
		}

		touch = event.changedTouches[0];

		// Synthesise a click event, with an extra attribute so it can be tracked
		clickEvent = document.createEvent('MouseEvents');
		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
		clickEvent.forwardedTouchEvent = true;
		targetElement.dispatchEvent(clickEvent);
	};

	FastClick.prototype.determineEventType = function(targetElement) {

		//Issue #159: Android Chrome Select Box does not open with a synthetic click event
		if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
			return 'mousedown';
		}

		return 'click';
	};


	/**
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.focus = function(targetElement) {
		var length;

		// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
		if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
			length = targetElement.value.length;
			targetElement.setSelectionRange(length, length);
		} else {
			targetElement.focus();
		}
	};


	/**
	 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
	 *
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.updateScrollParent = function(targetElement) {
		var scrollParent, parentElement;

		scrollParent = targetElement.fastClickScrollParent;

		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
		// target element was moved to another parent.
		if (!scrollParent || !scrollParent.contains(targetElement)) {
			parentElement = targetElement;
			do {
				if (parentElement.scrollHeight > parentElement.offsetHeight) {
					scrollParent = parentElement;
					targetElement.fastClickScrollParent = parentElement;
					break;
				}

				parentElement = parentElement.parentElement;
			} while (parentElement);
		}

		// Always update the scroll top tracker if possible.
		if (scrollParent) {
			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
		}
	};


	/**
	 * @param {EventTarget} targetElement
	 * @returns {Element|EventTarget}
	 */
	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {

		// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
		if (eventTarget.nodeType === Node.TEXT_NODE) {
			return eventTarget.parentNode;
		}

		return eventTarget;
	};


	/**
	 * On touch start, record the position and scroll offset.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchStart = function(event) {
		var targetElement, touch, selection;

		// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
		if (event.targetTouches.length > 1) {
			return true;
		}

		targetElement = this.getTargetElementFromEventTarget(event.target);
		touch = event.targetTouches[0];

		if (deviceIsIOS) {

			// Only trusted events will deselect text on iOS (issue #49)
			selection = window.getSelection();
			if (selection.rangeCount && !selection.isCollapsed) {
				return true;
			}

			if (!deviceIsIOS4) {

				// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
				// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
				// with the same identifier as the touch event that previously triggered the click that triggered the alert.
				// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
				// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
				// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
				// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
				// random integers, it's safe to to continue if the identifier is 0 here.
				if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
					event.preventDefault();
					return false;
				}

				this.lastTouchIdentifier = touch.identifier;

				// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
				// 1) the user does a fling scroll on the scrollable layer
				// 2) the user stops the fling scroll with another tap
				// then the event.target of the last 'touchend' event will be the element that was under the user's finger
				// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
				// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
				this.updateScrollParent(targetElement);
			}
		}

		this.trackingClick = true;
		this.trackingClickStart = event.timeStamp;
		this.targetElement = targetElement;

		this.touchStartX = touch.pageX;
		this.touchStartY = touch.pageY;

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
			event.preventDefault();
		}

		return true;
	};


	/**
	 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.touchHasMoved = function(event) {
		var touch = event.changedTouches[0], boundary = this.touchBoundary;

		if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
			return true;
		}

		return false;
	};


	/**
	 * Update the last position.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchMove = function(event) {
		if (!this.trackingClick) {
			return true;
		}

		// If the touch has moved, cancel the click tracking
		if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
			this.trackingClick = false;
			this.targetElement = null;
		}

		return true;
	};


	/**
	 * Attempt to find the labelled control for the given label element.
	 *
	 * @param {EventTarget|HTMLLabelElement} labelElement
	 * @returns {Element|null}
	 */
	FastClick.prototype.findControl = function(labelElement) {

		// Fast path for newer browsers supporting the HTML5 control attribute
		if (labelElement.control !== undefined) {
			return labelElement.control;
		}

		// All browsers under test that support touch events also support the HTML5 htmlFor attribute
		if (labelElement.htmlFor) {
			return document.getElementById(labelElement.htmlFor);
		}

		// If no for attribute exists, attempt to retrieve the first labellable descendant element
		// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
		return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
	};


	/**
	 * On touch end, determine whether to send a click event at once.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchEnd = function(event) {
		var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

		if (!this.trackingClick) {
			return true;
		}

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
			this.cancelNextClick = true;
			return true;
		}

		if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
			return true;
		}

		// Reset to prevent wrong click cancel on input (issue #156).
		this.cancelNextClick = false;

		this.lastClickTime = event.timeStamp;

		trackingClickStart = this.trackingClickStart;
		this.trackingClick = false;
		this.trackingClickStart = 0;

		// On some iOS devices, the targetElement supplied with the event is invalid if the layer
		// is performing a transition or scroll, and has to be re-detected manually. Note that
		// for this to function correctly, it must be called *after* the event target is checked!
		// See issue #57; also filed as rdar://13048589 .
		if (deviceIsIOSWithBadTarget) {
			touch = event.changedTouches[0];

			// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
		}

		targetTagName = targetElement.tagName.toLowerCase();
		if (targetTagName === 'label') {
			forElement = this.findControl(targetElement);
			if (forElement) {
				this.focus(targetElement);
				if (deviceIsAndroid) {
					return false;
				}

				targetElement = forElement;
			}
		} else if (this.needsFocus(targetElement)) {

			// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
			// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
			if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
				this.targetElement = null;
				return false;
			}

			this.focus(targetElement);
			this.sendClick(targetElement, event);

			// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
			// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
			if (!deviceIsIOS || targetTagName !== 'select') {
				this.targetElement = null;
				event.preventDefault();
			}

			return false;
		}

		if (deviceIsIOS && !deviceIsIOS4) {

			// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
			// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
			scrollParent = targetElement.fastClickScrollParent;
			if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
				return true;
			}
		}

		// Prevent the actual click from going though - unless the target node is marked as requiring
		// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
		if (!this.needsClick(targetElement)) {
			event.preventDefault();
			this.sendClick(targetElement, event);
		}

		return false;
	};


	/**
	 * On touch cancel, stop tracking the click.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.onTouchCancel = function() {
		this.trackingClick = false;
		this.targetElement = null;
	};


	/**
	 * Determine mouse events which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onMouse = function(event) {

		// If a target element was never set (because a touch event was never fired) allow the event
		if (!this.targetElement) {
			return true;
		}

		if (event.forwardedTouchEvent) {
			return true;
		}

		// Programmatically generated events targeting a specific element should be permitted
		if (!event.cancelable) {
			return true;
		}

		// Derive and check the target element to see whether the mouse event needs to be permitted;
		// unless explicitly enabled, prevent non-touch click events from triggering actions,
		// to prevent ghost/doubleclicks.
		if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

			// Prevent any user-added listeners declared on FastClick element from being fired.
			if (event.stopImmediatePropagation) {
				event.stopImmediatePropagation();
			} else {

				// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
				event.propagationStopped = true;
			}

			// Cancel the event
			event.stopPropagation();
			event.preventDefault();

			return false;
		}

		// If the mouse event is permitted, return true for the action to go through.
		return true;
	};


	/**
	 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
	 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
	 * an actual click which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onClick = function(event) {
		var permitted;

		// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
		if (this.trackingClick) {
			this.targetElement = null;
			this.trackingClick = false;
			return true;
		}

		// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
		if (event.target.type === 'submit' && event.detail === 0) {
			return true;
		}

		permitted = this.onMouse(event);

		// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
		if (!permitted) {
			this.targetElement = null;
		}

		// If clicks are permitted, return true for the action to go through.
		return permitted;
	};


	/**
	 * Remove all FastClick's event listeners.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.destroy = function() {
		var layer = this.layer;

		if (deviceIsAndroid) {
			layer.removeEventListener('mouseover', this.onMouse, true);
			layer.removeEventListener('mousedown', this.onMouse, true);
			layer.removeEventListener('mouseup', this.onMouse, true);
		}

		layer.removeEventListener('click', this.onClick, true);
		layer.removeEventListener('touchstart', this.onTouchStart, false);
		layer.removeEventListener('touchmove', this.onTouchMove, false);
		layer.removeEventListener('touchend', this.onTouchEnd, false);
		layer.removeEventListener('touchcancel', this.onTouchCancel, false);
	};


	/**
	 * Check whether FastClick is needed.
	 *
	 * @param {Element} layer The layer to listen on
	 */
	FastClick.notNeeded = function(layer) {
		var metaViewport;
		var chromeVersion;
		var blackberryVersion;
		var firefoxVersion;

		// Devices that don't support touch don't need FastClick
		if (typeof window.ontouchstart === 'undefined') {
			return true;
		}

		// Chrome version - zero for other browsers
		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (chromeVersion) {

			if (deviceIsAndroid) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// Chrome 32 and above with width=device-width or less don't need FastClick
					if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}

			// Chrome desktop doesn't need FastClick (issue #15)
			} else {
				return true;
			}
		}

		if (deviceIsBlackBerry10) {
			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);

			// BlackBerry 10.3+ does not require Fastclick library.
			// https://github.com/ftlabs/fastclick/issues/251
			if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// user-scalable=no eliminates click delay.
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// width=device-width (or less than device-width) eliminates click delay.
					if (document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}
			}
		}

		// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
		if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		// Firefox version - zero for other browsers
		firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (firefoxVersion >= 27) {
			// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896

			metaViewport = document.querySelector('meta[name=viewport]');
			if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
				return true;
			}
		}

		// IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
		// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
		if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		return false;
	};


	/**
	 * Factory method for creating a FastClick object
	 *
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	FastClick.attach = function(layer, options) {
		return new FastClick(layer, options);
	};


	if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {

		// AMD. Register as an anonymous module.
		define(function() {
			return FastClick;
		});
	} else if (typeof module !== 'undefined' && module.exports) {
		module.exports = FastClick.attach;
		module.exports.FastClick = FastClick;
	} else {
		window.FastClick = FastClick;
	}
}());

},{}],8:[function(require,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

exports.__esModule = true;

var _import = require('./handlebars/base');

var base = _interopRequireWildcard(_import);

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)

var _SafeString = require('./handlebars/safe-string');

var _SafeString2 = _interopRequireWildcard(_SafeString);

var _Exception = require('./handlebars/exception');

var _Exception2 = _interopRequireWildcard(_Exception);

var _import2 = require('./handlebars/utils');

var Utils = _interopRequireWildcard(_import2);

var _import3 = require('./handlebars/runtime');

var runtime = _interopRequireWildcard(_import3);

var _noConflict = require('./handlebars/no-conflict');

var _noConflict2 = _interopRequireWildcard(_noConflict);

// For compatibility and usage outside of module systems, make the Handlebars object a namespace
function create() {
  var hb = new base.HandlebarsEnvironment();

  Utils.extend(hb, base);
  hb.SafeString = _SafeString2['default'];
  hb.Exception = _Exception2['default'];
  hb.Utils = Utils;
  hb.escapeExpression = Utils.escapeExpression;

  hb.VM = runtime;
  hb.template = function (spec) {
    return runtime.template(spec, hb);
  };

  return hb;
}

var inst = create();
inst.create = create;

_noConflict2['default'](inst);

inst['default'] = inst;

exports['default'] = inst;
module.exports = exports['default'];
},{"./handlebars/base":9,"./handlebars/exception":10,"./handlebars/no-conflict":11,"./handlebars/runtime":12,"./handlebars/safe-string":13,"./handlebars/utils":14}],9:[function(require,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

exports.__esModule = true;
exports.HandlebarsEnvironment = HandlebarsEnvironment;
exports.createFrame = createFrame;

var _import = require('./utils');

var Utils = _interopRequireWildcard(_import);

var _Exception = require('./exception');

var _Exception2 = _interopRequireWildcard(_Exception);

var VERSION = '3.0.1';
exports.VERSION = VERSION;
var COMPILER_REVISION = 6;

exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '== 1.x.x',
  5: '== 2.0.0-alpha.x',
  6: '>= 2.0.0-beta.1'
};

exports.REVISION_CHANGES = REVISION_CHANGES;
var isArray = Utils.isArray,
    isFunction = Utils.isFunction,
    toString = Utils.toString,
    objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials) {
  this.helpers = helpers || {};
  this.partials = partials || {};

  registerDefaultHelpers(this);
}

HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: logger,
  log: log,

  registerHelper: function registerHelper(name, fn) {
    if (toString.call(name) === objectType) {
      if (fn) {
        throw new _Exception2['default']('Arg not supported with multiple helpers');
      }
      Utils.extend(this.helpers, name);
    } else {
      this.helpers[name] = fn;
    }
  },
  unregisterHelper: function unregisterHelper(name) {
    delete this.helpers[name];
  },

  registerPartial: function registerPartial(name, partial) {
    if (toString.call(name) === objectType) {
      Utils.extend(this.partials, name);
    } else {
      if (typeof partial === 'undefined') {
        throw new _Exception2['default']('Attempting to register a partial as undefined');
      }
      this.partials[name] = partial;
    }
  },
  unregisterPartial: function unregisterPartial(name) {
    delete this.partials[name];
  }
};

function registerDefaultHelpers(instance) {
  instance.registerHelper('helperMissing', function () {
    if (arguments.length === 1) {
      // A missing field in a {{foo}} constuct.
      return undefined;
    } else {
      // Someone is actually trying to call something, blow up.
      throw new _Exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
    }
  });

  instance.registerHelper('blockHelperMissing', function (context, options) {
    var inverse = options.inverse,
        fn = options.fn;

    if (context === true) {
      return fn(this);
    } else if (context === false || context == null) {
      return inverse(this);
    } else if (isArray(context)) {
      if (context.length > 0) {
        if (options.ids) {
          options.ids = [options.name];
        }

        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      if (options.data && options.ids) {
        var data = createFrame(options.data);
        data.contextPath = Utils.appendContextPath(options.data.contextPath, options.name);
        options = { data: data };
      }

      return fn(context, options);
    }
  });

  instance.registerHelper('each', function (context, options) {
    if (!options) {
      throw new _Exception2['default']('Must pass iterator to #each');
    }

    var fn = options.fn,
        inverse = options.inverse,
        i = 0,
        ret = '',
        data = undefined,
        contextPath = undefined;

    if (options.data && options.ids) {
      contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
    }

    if (isFunction(context)) {
      context = context.call(this);
    }

    if (options.data) {
      data = createFrame(options.data);
    }

    function execIteration(field, index, last) {
      if (data) {
        data.key = field;
        data.index = index;
        data.first = index === 0;
        data.last = !!last;

        if (contextPath) {
          data.contextPath = contextPath + field;
        }
      }

      ret = ret + fn(context[field], {
        data: data,
        blockParams: Utils.blockParams([context[field], field], [contextPath + field, null])
      });
    }

    if (context && typeof context === 'object') {
      if (isArray(context)) {
        for (var j = context.length; i < j; i++) {
          execIteration(i, i, i === context.length - 1);
        }
      } else {
        var priorKey = undefined;

        for (var key in context) {
          if (context.hasOwnProperty(key)) {
            // We're running the iterations one step out of sync so we can detect
            // the last iteration without have to scan the object twice and create
            // an itermediate keys array.
            if (priorKey) {
              execIteration(priorKey, i - 1);
            }
            priorKey = key;
            i++;
          }
        }
        if (priorKey) {
          execIteration(priorKey, i - 1, true);
        }
      }
    }

    if (i === 0) {
      ret = inverse(this);
    }

    return ret;
  });

  instance.registerHelper('if', function (conditional, options) {
    if (isFunction(conditional)) {
      conditional = conditional.call(this);
    }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if (!options.hash.includeZero && !conditional || Utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function (conditional, options) {
    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
  });

  instance.registerHelper('with', function (context, options) {
    if (isFunction(context)) {
      context = context.call(this);
    }

    var fn = options.fn;

    if (!Utils.isEmpty(context)) {
      if (options.data && options.ids) {
        var data = createFrame(options.data);
        data.contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]);
        options = { data: data };
      }

      return fn(context, options);
    } else {
      return options.inverse(this);
    }
  });

  instance.registerHelper('log', function (message, options) {
    var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
    instance.log(level, message);
  });

  instance.registerHelper('lookup', function (obj, field) {
    return obj && obj[field];
  });
}

var logger = {
  methodMap: { 0: 'debug', 1: 'info', 2: 'warn', 3: 'error' },

  // State enum
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3,
  level: 1,

  // Can be overridden in the host environment
  log: function log(level, message) {
    if (typeof console !== 'undefined' && logger.level <= level) {
      var method = logger.methodMap[level];
      (console[method] || console.log).call(console, message); // eslint-disable-line no-console
    }
  }
};

exports.logger = logger;
var log = logger.log;

exports.log = log;

function createFrame(object) {
  var frame = Utils.extend({}, object);
  frame._parent = object;
  return frame;
}

/* [args, ]options */
},{"./exception":10,"./utils":14}],10:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var loc = node && node.loc,
      line = undefined,
      column = undefined;
  if (loc) {
    line = loc.start.line;
    column = loc.start.column;

    message += ' - ' + line + ':' + column;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, Exception);
  }

  if (loc) {
    this.lineNumber = line;
    this.column = column;
  }
}

Exception.prototype = new Error();

exports['default'] = Exception;
module.exports = exports['default'];
},{}],11:[function(require,module,exports){
(function (global){
'use strict';

exports.__esModule = true;
/*global window */

exports['default'] = function (Handlebars) {
  /* istanbul ignore next */
  var root = typeof global !== 'undefined' ? global : window,
      $Handlebars = root.Handlebars;
  /* istanbul ignore next */
  Handlebars.noConflict = function () {
    if (root.Handlebars === Handlebars) {
      root.Handlebars = $Handlebars;
    }
  };
};

module.exports = exports['default'];
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvbm8tY29uZmxpY3QuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuLypnbG9iYWwgd2luZG93ICovXG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGZ1bmN0aW9uIChIYW5kbGViYXJzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHZhciByb290ID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3csXG4gICAgICAkSGFuZGxlYmFycyA9IHJvb3QuSGFuZGxlYmFycztcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgSGFuZGxlYmFycy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChyb290LkhhbmRsZWJhcnMgPT09IEhhbmRsZWJhcnMpIHtcbiAgICAgIHJvb3QuSGFuZGxlYmFycyA9ICRIYW5kbGViYXJzO1xuICAgIH1cbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyJdfQ==
},{}],12:[function(require,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

exports.__esModule = true;
exports.checkRevision = checkRevision;

// TODO: Remove this line and break up compilePartial

exports.template = template;
exports.wrapProgram = wrapProgram;
exports.resolvePartial = resolvePartial;
exports.invokePartial = invokePartial;
exports.noop = noop;

var _import = require('./utils');

var Utils = _interopRequireWildcard(_import);

var _Exception = require('./exception');

var _Exception2 = _interopRequireWildcard(_Exception);

var _COMPILER_REVISION$REVISION_CHANGES$createFrame = require('./base');

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = _COMPILER_REVISION$REVISION_CHANGES$createFrame.COMPILER_REVISION;

  if (compilerRevision !== currentRevision) {
    if (compilerRevision < currentRevision) {
      var runtimeVersions = _COMPILER_REVISION$REVISION_CHANGES$createFrame.REVISION_CHANGES[currentRevision],
          compilerVersions = _COMPILER_REVISION$REVISION_CHANGES$createFrame.REVISION_CHANGES[compilerRevision];
      throw new _Exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new _Exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
    }
  }
}

function template(templateSpec, env) {
  /* istanbul ignore next */
  if (!env) {
    throw new _Exception2['default']('No environment passed to template');
  }
  if (!templateSpec || !templateSpec.main) {
    throw new _Exception2['default']('Unknown template object: ' + typeof templateSpec);
  }

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  env.VM.checkRevision(templateSpec.compiler);

  function invokePartialWrapper(partial, context, options) {
    if (options.hash) {
      context = Utils.extend({}, context, options.hash);
    }

    partial = env.VM.resolvePartial.call(this, partial, context, options);
    var result = env.VM.invokePartial.call(this, partial, context, options);

    if (result == null && env.compile) {
      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
      result = options.partials[options.name](context, options);
    }
    if (result != null) {
      if (options.indent) {
        var lines = result.split('\n');
        for (var i = 0, l = lines.length; i < l; i++) {
          if (!lines[i] && i + 1 === l) {
            break;
          }

          lines[i] = options.indent + lines[i];
        }
        result = lines.join('\n');
      }
      return result;
    } else {
      throw new _Exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
    }
  }

  // Just add water
  var container = {
    strict: function strict(obj, name) {
      if (!(name in obj)) {
        throw new _Exception2['default']('"' + name + '" not defined in ' + obj);
      }
      return obj[name];
    },
    lookup: function lookup(depths, name) {
      var len = depths.length;
      for (var i = 0; i < len; i++) {
        if (depths[i] && depths[i][name] != null) {
          return depths[i][name];
        }
      }
    },
    lambda: function lambda(current, context) {
      return typeof current === 'function' ? current.call(context) : current;
    },

    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,

    fn: function fn(i) {
      return templateSpec[i];
    },

    programs: [],
    program: function program(i, data, declaredBlockParams, blockParams, depths) {
      var programWrapper = this.programs[i],
          fn = this.fn(i);
      if (data || depths || blockParams || declaredBlockParams) {
        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
      }
      return programWrapper;
    },

    data: function data(value, depth) {
      while (value && depth--) {
        value = value._parent;
      }
      return value;
    },
    merge: function merge(param, common) {
      var obj = param || common;

      if (param && common && param !== common) {
        obj = Utils.extend({}, common, param);
      }

      return obj;
    },

    noop: env.VM.noop,
    compilerInfo: templateSpec.compiler
  };

  function ret(context) {
    var options = arguments[1] === undefined ? {} : arguments[1];

    var data = options.data;

    ret._setup(options);
    if (!options.partial && templateSpec.useData) {
      data = initData(context, data);
    }
    var depths = undefined,
        blockParams = templateSpec.useBlockParams ? [] : undefined;
    if (templateSpec.useDepths) {
      depths = options.depths ? [context].concat(options.depths) : [context];
    }

    return templateSpec.main.call(container, context, container.helpers, container.partials, data, blockParams, depths);
  }
  ret.isTop = true;

  ret._setup = function (options) {
    if (!options.partial) {
      container.helpers = container.merge(options.helpers, env.helpers);

      if (templateSpec.usePartial) {
        container.partials = container.merge(options.partials, env.partials);
      }
    } else {
      container.helpers = options.helpers;
      container.partials = options.partials;
    }
  };

  ret._child = function (i, data, blockParams, depths) {
    if (templateSpec.useBlockParams && !blockParams) {
      throw new _Exception2['default']('must pass block params');
    }
    if (templateSpec.useDepths && !depths) {
      throw new _Exception2['default']('must pass parent depths');
    }

    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
  };
  return ret;
}

function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
  function prog(context) {
    var options = arguments[1] === undefined ? {} : arguments[1];

    return fn.call(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), depths && [context].concat(depths));
  }
  prog.program = i;
  prog.depth = depths ? depths.length : 0;
  prog.blockParams = declaredBlockParams || 0;
  return prog;
}

function resolvePartial(partial, context, options) {
  if (!partial) {
    partial = options.partials[options.name];
  } else if (!partial.call && !options.name) {
    // This is a dynamic partial that returned a string
    options.name = partial;
    partial = options.partials[partial];
  }
  return partial;
}

function invokePartial(partial, context, options) {
  options.partial = true;

  if (partial === undefined) {
    throw new _Exception2['default']('The partial ' + options.name + ' could not be found');
  } else if (partial instanceof Function) {
    return partial(context, options);
  }
}

function noop() {
  return '';
}

function initData(context, data) {
  if (!data || !('root' in data)) {
    data = data ? _COMPILER_REVISION$REVISION_CHANGES$createFrame.createFrame(data) : {};
    data.root = context;
  }
  return data;
}
},{"./base":9,"./exception":10,"./utils":14}],13:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// Build out our basic SafeString type
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
  return '' + this.string;
};

exports['default'] = SafeString;
module.exports = exports['default'];
},{}],14:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.extend = extend;

// Older IE versions do not directly support indexOf so we must implement our own, sadly.
exports.indexOf = indexOf;
exports.escapeExpression = escapeExpression;
exports.isEmpty = isEmpty;
exports.blockParams = blockParams;
exports.appendContextPath = appendContextPath;
var escape = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  '\'': '&#x27;',
  '`': '&#x60;'
};

var badChars = /[&<>"'`]/g,
    possible = /[&<>"'`]/;

function escapeChar(chr) {
  return escape[chr];
}

function extend(obj /* , ...source */) {
  for (var i = 1; i < arguments.length; i++) {
    for (var key in arguments[i]) {
      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
        obj[key] = arguments[i][key];
      }
    }
  }

  return obj;
}

var toString = Object.prototype.toString;

exports.toString = toString;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
/*eslint-disable func-style, no-var */
var isFunction = function isFunction(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
/* istanbul ignore next */
if (isFunction(/x/)) {
  exports.isFunction = isFunction = function (value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
var isFunction;
exports.isFunction = isFunction;
/*eslint-enable func-style, no-var */

/* istanbul ignore next */
var isArray = Array.isArray || function (value) {
  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
};exports.isArray = isArray;

function indexOf(array, value) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
}

function escapeExpression(string) {
  if (typeof string !== 'string') {
    // don't escape SafeStrings, since they're already safe
    if (string && string.toHTML) {
      return string.toHTML();
    } else if (string == null) {
      return '';
    } else if (!string) {
      return string + '';
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = '' + string;
  }

  if (!possible.test(string)) {
    return string;
  }
  return string.replace(badChars, escapeChar);
}

function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}

function blockParams(params, ids) {
  params.path = ids;
  return params;
}

function appendContextPath(contextPath, id) {
  return (contextPath ? contextPath + '.' : '') + id;
}
},{}],15:[function(require,module,exports){
// Create a simple path alias to allow browserify to resolve
// the runtime on a supported path.
module.exports = require('./dist/cjs/handlebars.runtime')['default'];

},{"./dist/cjs/handlebars.runtime":8}],16:[function(require,module,exports){
module.exports = require("handlebars/runtime")["default"];

},{"handlebars/runtime":15}],17:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v2.1.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-04-28T16:01Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//

var arr = [];

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	version = "2.1.4",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
	},

	isPlainObject: function( obj ) {
		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.constructor &&
				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
			return false;
		}

		// If the function hasn't returned already, we're confident that
		// |obj| is a plain object, created by {} or constructed with new Object
		return true;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		// Support: Android<4.0, iOS<6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {
			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf("use strict") === 1 ) {
				script = document.createElement("script");
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {
			// Otherwise, avoid the DOM node creation, insertion
			// and removal by using an indirect global eval
				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE9-11+
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {

	// Support: iOS 8.2 (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.0-pre
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-16
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + characterEncoding + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];
	nodeType = context.nodeType;

	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	if ( !seed && documentIsHTML ) {

		// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
		if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType !== 1 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;
	parent = doc.defaultView;

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Support tests
	---------------------------------------------------------------------- */
	documentIsHTML = !isXML( doc );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\f]' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is no seed and only one group
	if ( match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if ( elem && elem.parentNode ) {
						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter(function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.unique( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// Add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// If we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
});

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed, false );
	window.removeEventListener( "load", completed, false );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// We once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[0], key ) : emptyGet;
};


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( owner ) {
	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};


function Data() {
	// Support: Android<4,
	// Old WebKit does not have Object.preventExtensions/freeze method,
	// return new empty object instead with no [[set]] accessor
	Object.defineProperty( this.cache = {}, 0, {
		get: function() {
			return {};
		}
	});

	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = {
	key: function( owner ) {
		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return the key for a frozen object.
		if ( !Data.accepts( owner ) ) {
			return 0;
		}

		var descriptor = {},
			// Check if the owner object already has a cache key
			unlock = owner[ this.expando ];

		// If not, create one
		if ( !unlock ) {
			unlock = Data.uid++;

			// Secure it in a non-enumerable, non-writable property
			try {
				descriptor[ this.expando ] = { value: unlock };
				Object.defineProperties( owner, descriptor );

			// Support: Android<4
			// Fallback to a less secure definition
			} catch ( e ) {
				descriptor[ this.expando ] = unlock;
				jQuery.extend( owner, descriptor );
			}
		}

		// Ensure the cache object
		if ( !this.cache[ unlock ] ) {
			this.cache[ unlock ] = {};
		}

		return unlock;
	},
	set: function( owner, data, value ) {
		var prop,
			// There may be an unlock assigned to this node,
			// if there is no entry for this "owner", create one inline
			// and set the unlock as though an owner entry had always existed
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {
			// Fresh assignments by object are shallow copied
			if ( jQuery.isEmptyObject( cache ) ) {
				jQuery.extend( this.cache[ unlock ], data );
			// Otherwise, copy the properties one-by-one to the cache object
			} else {
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		// Either a valid cache is found, or will be created.
		// New caches will be created and the unlock returned,
		// allowing direct access to the newly created
		// empty data object. A valid owner object must be provided.
		var cache = this.cache[ this.key( owner ) ];

		return key === undefined ?
			cache : cache[ key ];
	},
	access: function( owner, key, value ) {
		var stored;
		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				((key && typeof key === "string") && value === undefined) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase(key) );
		}

		// [*]When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		if ( key === undefined ) {
			this.cache[ unlock ] = {};

		} else {
			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );
				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;
			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}
	},
	hasData: function( owner ) {
		return !jQuery.isEmptyObject(
			this.cache[ owner[ this.expando ] ] || {}
		);
	},
	discard: function( owner ) {
		if ( owner[ this.expando ] ) {
			delete this.cache[ owner[ this.expando ] ];
		}
	}
};
var data_priv = new Data();

var data_user = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			data_user.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend({
	hasData: function( elem ) {
		return data_user.hasData( elem ) || data_priv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return data_user.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		data_user.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to data_priv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return data_priv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		data_priv.remove( elem, name );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = data_user.get( elem );

				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice(5) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					data_priv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				data_user.set( this, key );
			});
		}

		return access( this, function( value ) {
			var data,
				camelKey = jQuery.camelCase( key );

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {
				// Attempt to get data from the cache
				// with the key as-is
				data = data_user.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to get data from the cache
				// with the key camelized
				data = data_user.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each(function() {
				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = data_user.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				data_user.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf("-") !== -1 && data !== undefined ) {
					data_user.set( this, key, value );
				}
			});
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each(function() {
			data_user.remove( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = data_priv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = data_priv.access( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return data_priv.get( elem, key ) || data_priv.access( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				data_priv.remove( elem, [ type + "queue", key ] );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = data_priv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};

var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Safari<=5.1
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari<=5.1, Android<4.2
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<=11+
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
})();
var strundefined = typeof undefined;



support.focusinBubbles = "onfocusin" in window;


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.hasData( elem ) && data_priv.get( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;
			data_priv.remove( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome<28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle, false );
	}
};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&
				// Support: Android<4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && e.preventDefault ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && e.stopImmediatePropagation ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// Support: Firefox, Chrome, Safari
// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					data_priv.remove( doc, fix );

				} else {
					data_priv.access( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {

		// Support: IE9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

// Support: IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute("type");
	}

	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		data_priv.set(
			elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
		);
	}
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( data_priv.hasData( src ) ) {
		pdataOld = data_priv.access( src );
		pdataCur = data_priv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( data_user.hasData( src ) ) {
		udataOld = data_user.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		data_user.set( dest, udataCur );
	}
}

function getAll( context, tag ) {
	var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
			context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	},

	cleanData: function( elems ) {
		var data, elem, type, key,
			special = jQuery.event.special,
			i = 0;

		for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
			if ( jQuery.acceptData( elem ) ) {
				key = elem[ data_priv.expando ];

				if ( key && (data = data_priv.cache[ key ]) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}
					if ( data_priv.cache[ key ] ) {
						// Discard any remaining `private` data
						delete data_priv.cache[ key ];
					}
				}
			}
			// Discard any remaining `user` data
			delete data_user.cache[ elem[ data_user.expando ] ];
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each(function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				});
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							// Support: QtWebKit
							// jQuery.merge because push.apply(_, arraylike) throws
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var style,
		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

			// Use of this method is a temporary fix (more like optimization) until something better comes along,
			// since it was removed from specification and supported only in FF
			style.display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {
		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		if ( elem.ownerDocument.defaultView.opener ) {
			return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
		}

		return window.getComputedStyle( elem, null );
	};



function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];
	}

	if ( computed ) {

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: iOS < 6
		// A tribute to the "awesome hack by Dean Edwards"
		// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
		// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?
		// Support: IE
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {
				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	var pixelPositionVal, boxSizingReliableVal,
		docElem = document.documentElement,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	if ( !div.style ) {
		return;
	}

	// Support: IE9-11+
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
		"position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computePixelPositionAndBoxSizingReliable() {
		div.style.cssText =
			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
			"border:1px;padding:1px;width:4px;position:absolute";
		div.innerHTML = "";
		docElem.appendChild( container );

		var divStyle = window.getComputedStyle( div, null );
		pixelPositionVal = divStyle.top !== "1%";
		boxSizingReliableVal = divStyle.width === "4px";

		docElem.removeChild( container );
	}

	// Support: node.js jsdom
	// Don't assume that getComputedStyle is a property of the global object
	if ( window.getComputedStyle ) {
		jQuery.extend( support, {
			pixelPosition: function() {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computePixelPositionAndBoxSizingReliable();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computePixelPositionAndBoxSizingReliable();
				}
				return boxSizingReliableVal;
			},
			reliableMarginRight: function() {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =
					// Support: Firefox<29, Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
					"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				docElem.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

				docElem.removeChild( container );
				div.removeChild( marginDiv );

				return ret;
			}
		});
	}
})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
	// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[0].toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = data_priv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend({

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Support: IE9-11+
			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				style[ name ] = value;
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*.
					// Use string for doubling so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur(),
				// break the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = data_priv.get( elem, "fxshow" );

	// Handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// Ensure the complete handler is called before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// Height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always(function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		});
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = data_priv.access( elem, "fxshow", {} );
		}

		// Store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;

			data_priv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// Don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// Support: Android 2.3
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || data_priv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = data_priv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = data_priv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS<=5.1, Android<=4.2+
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE<=11+
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: Android<=2.3
	// Options inside disabled selects are incorrectly marked as disabled
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<=11+
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
})();


var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {
			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
});




var rfocusable = /^(?:input|select|textarea|button)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each(function() {
			delete this[ jQuery.propFix[ name ] || name ];
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
					elem.tabIndex :
					-1;
			}
		}
	}
});

if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = arguments.length === 0 || typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// Toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					data_priv.set( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// Handle most common string cases
					ret.replace(rreturn, "") :
					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					jQuery.trim( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE6-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
						optionSet = true;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		tmp = new DOMParser();
		xml = tmp.parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Document location
	ajaxLocation = window.location.href,

	// Segment location into parts
	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,
			// URL without anti-cache param
			cacheURL,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapAll( html.call(this, i) );
			});
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
};
jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


jQuery.ajaxSettings.xhr = function() {
	try {
		return new XMLHttpRequest();
	} catch( e ) {}
};

var xhrId = 0,
	xhrCallbacks = {},
	xhrSuccessStatus = {
		// file protocol always yields status code 0, assume 200
		0: 200,
		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
// See https://support.microsoft.com/kb/2856746 for more info
if ( window.attachEvent ) {
	window.attachEvent( "onunload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]();
		}
	});
}

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
	var callback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr(),
					id = ++xhrId;

				xhr.open( options.type, options.url, options.async, options.username, options.password );

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers["X-Requested-With"] ) {
					headers["X-Requested-With"] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							delete xhrCallbacks[ id ];
							callback = xhr.onload = xhr.onerror = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {
								complete(
									// file: protocol always yields status 0; see #8605, #14207
									xhr.status,
									xhr.statusText
								);
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,
									// Support: IE9
									// Accessing binary-data responseText throws an exception
									// (#11426)
									typeof xhr.responseText === "string" ? {
										text: xhr.responseText
									} : undefined,
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				xhr.onerror = callback("error");

				// Create the abort callback
				callback = xhrCallbacks[ id ] = callback("abort");

				try {
					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {
					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {
	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery("<script>").prop({
					async: true,
					charset: s.scriptCharset,
					src: s.url
				}).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};




var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// Support: BlackBerry 5, iOS 3 (original iPhone)
		// If we don't have gBCR, just use 0,0 rather than error
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : window.pageXOffset,
					top ? val : window.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Support: Safari<7+, Chrome<37+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));

},{}],18:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],19:[function(require,module,exports){
(function (global){
var $ = global.$ = global.jQuery = require('jquery');
var Backbone = require('backbone');
var _ = global._ = require('underscore');
Backbone.$ = $;
var Marionette = require('backbone.marionette');

app = new Marionette.Application();

app.addRegions({
    regionMain: '.region-main'
});

app.Behaviors = app.Behaviors || {};

Marionette.Behaviors.behaviorsLookup = function() {
    return app.Behaviors;
};

app.addInitializer(function() {

    Backbone.history.start({
        pushState: true,
        root: '/'
    });

});

window.app = app;
module.exports = app;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9qYXZhc2NyaXB0L2FwcC9hcHAuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsidmFyICQgPSBnbG9iYWwuJCA9IGdsb2JhbC5qUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgXyA9IGdsb2JhbC5fID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuQmFja2JvbmUuJCA9ICQ7XG52YXIgTWFyaW9uZXR0ZSA9IHJlcXVpcmUoJ2JhY2tib25lLm1hcmlvbmV0dGUnKTtcblxuYXBwID0gbmV3IE1hcmlvbmV0dGUuQXBwbGljYXRpb24oKTtcblxuYXBwLmFkZFJlZ2lvbnMoe1xuICAgIHJlZ2lvbk1haW46ICcucmVnaW9uLW1haW4nXG59KTtcblxuYXBwLkJlaGF2aW9ycyA9IGFwcC5CZWhhdmlvcnMgfHwge307XG5cbk1hcmlvbmV0dGUuQmVoYXZpb3JzLmJlaGF2aW9yc0xvb2t1cCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcHAuQmVoYXZpb3JzO1xufTtcblxuYXBwLmFkZEluaXRpYWxpemVyKGZ1bmN0aW9uKCkge1xuXG4gICAgQmFja2JvbmUuaGlzdG9yeS5zdGFydCh7XG4gICAgICAgIHB1c2hTdGF0ZTogdHJ1ZSxcbiAgICAgICAgcm9vdDogJy8nXG4gICAgfSk7XG5cbn0pO1xuXG53aW5kb3cuYXBwID0gYXBwO1xubW9kdWxlLmV4cG9ydHMgPSBhcHA7XG4iXX0=
},{"backbone":6,"backbone.marionette":2,"jquery":17,"underscore":18}],20:[function(require,module,exports){
var app = require('./../app');
var channels = require('./../channels');
var Marionette = require('backbone.marionette');
var TweenMax       = require('../../libs/TweenMax/TweenMax');
var TimelineLite   = require('../../libs/TweenMax/TimelineLite');

module.exports = app.Behaviors.Navigator = Marionette.Behavior.extend({

    ui: {
        links: '[data-navigate], a[href^="/"]',
        loader: '.loader-container',
        page: '.page',
        path: '.st0'
    },

    events: {
        'click @ui.links': 'onClickNavigate'
    },

    initialize: function() {
        // channels.loaderChannel.on('hideLoader', this.hideLoader, this);
    },

    onClickNavigate: function (e) {
        if ($(e.currentTarget).hasClass('no-capture')) {
            return;
        }
        e.preventDefault();
        var currentUrl = "/"+Backbone.history.getFragment();
        this.url = $(e.currentTarget).data('navigate') || $(e.currentTarget).attr('href');
        
        // if(currentUrl != this.url) {

        //     currentUrl = this.url;

        //     this.showLoader();
        //     return
        // }

        this.triggerNavigate();
    },

    triggerNavigate: function () {
        channels.globalChannel.trigger('navigate', {
            url: this.url,
            trigger: true
        });
    },

    // showLoader: function() {
    //     var $window = $(window);

    //     new TimelineLite({onComplete: _.bind(this.triggerNavigate, this)})
    //         .to(this.ui.path, 0, {'animation-iteration-count': 'infinite', 'stroke-dashoffset': ""})
    //         .to(this.ui.page, 0.8, {y: -50, alpha: 0})
    //         .to(this.ui.loader, 0.8, {y: 0, alpha: 1})
    //         .to($window, 0, {scrollTop:0 })
    // },

    // hideLoader: function() {
    //     new TimelineLite().delay(0.5)
    //         .to(this.ui.path, 1, {'animation-iteration-count': '1', 'stroke-dashoffset': 0})
    //         .to(this.ui.loader, 0.8, {y: 50, alpha: 0})
    //         .to(this.ui.page, 0.8, {y: 0, alpha: 1})
    // }

});

},{"../../libs/TweenMax/TimelineLite":37,"../../libs/TweenMax/TweenMax":39,"./../app":19,"./../channels":21,"backbone.marionette":2}],21:[function(require,module,exports){
Backbone = require('backbone');
Backbone.Radio = require('backbone.radio');

module.exports.globalChannel = Backbone.Radio.channel('global');
module.exports.userChannel = Backbone.Radio.channel('user');
module.exports.navChannel = Backbone.Radio.channel('nav');

},{"backbone":6,"backbone.radio":5}],22:[function(require,module,exports){
var WorkModel = require('./../models/WorkModel');

module.exports = Backbone.Collection.extend({
    model: WorkModel
})
},{"./../models/WorkModel":25}],23:[function(require,module,exports){
var app                = require('./../app');
var Backbone           = require('backbone');
var channels           = require('./../channels');
// Views
var GlobalView         = require('./../views/GlobalView');
var BaseView           = require('./../views/BaseView');
var IndexView          = require('./../views/IndexView');
var ProjectView          = require('./../views/ProjectView');

var WorkCollection = require('./../collections/WorkCollection');
var workModel       = require('./../models/WorkModel'); 
var workData       = require('./../datas/workData');

module.exports = Backbone.Marionette.Controller.extend({

    initialize: function () {

        // State checks
        app.onload = true;

        // Bootstrap it, gurrl
        this.bootstrap();

    },

    bootstrap: function () {
        this.globalView = new GlobalView();
        this.baseView = new BaseView();

        app.workCollection = new WorkCollection(workData);

        channels.globalChannel.on('navigate', this.navigate, this);

    },

    navigate: function (options) {

        // If navigate() is being called...
        // we must be past our initial page load
        // so we'll set onload to 'false'
        app.onload = false;

        var url = options.url;
        var trigger = options.trigger ? options.trigger : false;

        app.appRouter.navigate(url, {
            trigger: trigger
        });

    },

    /* View Routes
    =========================================== */

    index: function () {
        var indexView = new IndexView();
        app.regionMain.show(indexView);
    },

    project: function () {
        var projectView = new ProjectView();
        app.regionMain.show(projectView);
    },

    defaultHandler: function (route) {
        console.log('%cRoute /%s does not exist', 'color:white; background:gray; padding: 0 0.25em', route);
    }

});

},{"./../app":19,"./../channels":21,"./../collections/WorkCollection":22,"./../datas/workData":24,"./../models/WorkModel":25,"./../views/BaseView":28,"./../views/GlobalView":30,"./../views/IndexView":32,"./../views/ProjectView":34,"backbone":6}],24:[function(require,module,exports){
module.exports = [
    {
        active: true,
        title: 'Edie &amp Watson',
        slug: 'edie-watson',
        cover: '/images/projects/edie-watson/cover.jpg',
        subpart: {
            'web-design': 'Webdesign',
            'print': 'Print',
            'da-photo': 'DA photo',
        }
    },
    {
        title: 'Le Salon des Dames',
        slug: 'salon-des-dames',
        cover: '/images/projects/edie-watson/cover.jpg',
    },
    {
        title: 'San Marina',
        slug: 'san-marina',
        cover: '/images/projects/edie-watson/cover.jpg',
    },
    {
        title: 'Bénédicte Sachi-Saillard',
        slug: 'benedicte-sachi-saillard',
        cover: '/images/projects/edie-watson/cover.jpg',
    }
]
},{}],25:[function(require,module,exports){
var Backbone = require('backbone');

module.exports = Backbone.Model.extend({});

},{"backbone":6}],26:[function(require,module,exports){
var Marionette = require('backbone.marionette');
var AppController = require('./../controllers/AppController.js');

module.exports = Marionette.AppRouter.extend({

    appRoutes: {
        '(/)': 'index',
        'project/:slug(/)': 'project',
        '*default': 'defaultHandler'
    },

    controller: new AppController()

});

},{"./../controllers/AppController.js":23,"backbone.marionette":2}],27:[function(require,module,exports){
module.exports.FRAME_RATE = 24;
module.exports.SHOW_CLASS = 'show';
module.exports.INITING_CLASS = 'is-initing';
module.exports.READY_CLASS = 'is-ready';

},{}],28:[function(require,module,exports){
var Marionette = require('backbone.marionette');

module.exports = Marionette.ItemView.extend({

});

},{"backbone.marionette":2}],29:[function(require,module,exports){
var app           = require('./../app');
var channels      = require('./../channels');
var Marionette    = require('backbone.marionette');

var IndexItemView = require('./IndexItemView');
var template      = require('./../../templates/index-list.hbs');


module.exports = Marionette.CompositeView.extend({
    className: 'index-list-container',
    template: template,

    childView: IndexItemView,
    childViewContainer: ".index-list-js",

    ui: {
        indexArrow: '.index-arrow-js',
        indexList: '.index-list-js',
        indexItem: '.index-item-js',
    },

    events: {
        'click @ui.indexArrow': 'onClickIndexArrow',
    },


    initialize: function () {
        channels.navChannel.on('hoverSubItemNav', this.hoverSubItemNav, this);
    },

    onBeforeRender: function () {},

    onRender: function () {
    },

    onShow: function () {
        // binds view elements to ui hash
        this.bindUIElements();
        this.ui.indexItem.first().addClass('active').css('opacity', 1);
    },

    onClickIndexArrow: function (e) {
        var $arrow = $(e.currentTarget),
            $list = this.ui.indexList,
            $items = $list.children(),
            length = $items.length-1,
            currentIndex = $list.find('.active').index(),
            newIndex = currentIndex,
            direction = 'next';


        if ($arrow.hasClass('prev-arrow')) {
            direction = 'prev';
            newIndex = newIndex-1;
            if (newIndex < 0) {
                newIndex = length;
            }

        } else {
            newIndex = newIndex+1;
            if (newIndex > length) {
                newIndex = 0;
            }

        }

        channels.navChannel.trigger('clickIndexArrow', {
            index: newIndex
        });

        this.moveIndexItem(direction, newIndex, $items, $list);
    },

    hoverSubItemNav: function (options) {
        var $list = this.ui.indexList,
            $items = $list.children(),
            newIndex = options.index,
            direction = 'next';
        
        this.moveIndexItem(direction, newIndex, $items, $list);
    },

    moveIndexItem: function (direction, newIndex, $items, $list) {
        var newItem = $items[newIndex],
            $currentItem = $list.find('.active');

        var tl = new TimelineMax();

        tl.totalProgress(1, false);

        tl.to($items, 0.2, {alpha:0, display:'none', className: '-=active'})
          .fromTo(newItem, 0.2, {alpha: 0, display:'none', className: '+=active'}, {alpha:1, display:'block'})
        
    }

});

},{"./../../templates/index-list.hbs":41,"./../app":19,"./../channels":21,"./IndexItemView":31,"backbone.marionette":2}],30:[function(require,module,exports){
var Marionette = require('backbone.marionette');
var constants = require('./../utils/constants');
var attachFastClick = require('fastclick');

// View Behaviors
require('../behaviors/Navigator');

module.exports = Marionette.ItemView.extend({

    el: 'body',

    events: {
        'keyup': 'keyup'
    },

    behaviors: {
        Navigator: {}
    },

    initialize: function() {

        // Javascript is ready... go!
        this.$el.removeClass(constants.INITING_CLASS);

        // No click delay for iOS
        attachFastClick(document.body);

        // Force touch devices to respect :active styles in CSS
        document.addEventListener('touchstart', function() {}, true);

        // Page visibility detection
        this.listenForPageVisibility();

    },

    listenForPageVisibility: function() {

        var hidden, visibilityChange;

        if (typeof document.hidden !== 'undefined') {
            hidden = 'hidden';
            visibilityChange = 'visibilitychange';
        } else if (typeof document.mozHidden !== 'undefined') {
            hidden = 'mozHidden';
            visibilityChange = 'mozvisibilitychange';
        } else if (typeof document.msHidden !== 'undefined') {
            hidden = 'msHidden';
            visibilityChange = 'msvisibilitychange';
        } else if (typeof document.webkitHidden !== 'undefined') {
            hidden = 'webkitHidden';
            visibilityChange = 'webkitvisibilitychange';
        }

        function handleVisibilityChange() {
            // channels.globalChannel.trigger('app:visibility', !document[hidden]);
        }

        if (visibilityChange && typeof document.addEventListener !== 'undefined') {
            document.addEventListener(visibilityChange, handleVisibilityChange, false);
        }

    }

});

},{"../behaviors/Navigator":20,"./../utils/constants":27,"backbone.marionette":2,"fastclick":7}],31:[function(require,module,exports){
var app        = require('./../app');
var channels   = require('./../channels');
var Marionette = require('backbone.marionette');
var template   = require('./../../templates/index-item.hbs');


module.exports = Marionette.ItemView.extend({

    tagName: 'li',
    className: 'index-item index-item-js',
    
    template: template,

    templateHelpers: function() {return {}},

    ui: {},

    events: {},

    initialize: function () {},


    modelChanged: function () {}

});

},{"./../../templates/index-item.hbs":40,"./../app":19,"./../channels":21,"backbone.marionette":2}],32:[function(require,module,exports){
// var app           = require('app/app');
var channels      = require('./../channels');
var Marionette    = require('backbone.marionette');
var template      = require('./../../templates/index.hbs');


// VIEW
var NavView       = require('./NavView'); 
var ContentView   = require('./ContentView'); 
// var ProjectsListView  = require('views/ProjectsListView');

module.exports = Marionette.LayoutView.extend({

    className: 'page page-index',

    template: template,

    regions: {
        regionNav: '.region-nav',
        regionContent: '.region-content'
    },

    ui: {},

    events: {},

    initialize: function () {},

    onShow: function () {
        this.navView = new NavView();
        this.regionNav.show(this.navView);

        this.contentView = new ContentView({
            collection: app.workCollection,
        });
        this.regionContent.show(this.contentView);
    }

});

},{"./../../templates/index.hbs":42,"./../channels":21,"./ContentView":29,"./NavView":33,"backbone.marionette":2}],33:[function(require,module,exports){
var app        = require('./../app');
var channels   = require('./../channels');
var Marionette = require('backbone.marionette');
var template   = require('./../../templates/nav.hbs');

var WorkListView = require('./WorkListView');


module.exports = Marionette.LayoutView.extend({
    className: 'nav-wrapper wrapper',

    template: template,

    regions: {
        workList: '.work-list-js',
        aboutList: '.about-list-js'
    },

    events: {},

    initialize: function () {},

    onBeforeRender: function () {},

    onRender: function () {},

    onShow: function () {
        this.workListView = new WorkListView({
            collection: app.workCollection
        });
        this.workList.show(this.workListView);
    },

    onBeforeDestroy: function () {},

    onDestroy: function () {},

});

},{"./../../templates/nav.hbs":43,"./../app":19,"./../channels":21,"./WorkListView":36,"backbone.marionette":2}],34:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"./../../templates/index.hbs":42,"./../channels":21,"./ContentView":29,"./NavView":33,"backbone.marionette":2,"dup":32}],35:[function(require,module,exports){
var app        = require('./../app');
var channels   = require('./../channels');
var Marionette = require('backbone.marionette');
var template   = require('./../../templates/work-item.hbs');


module.exports = Marionette.ItemView.extend({

    tagName: 'li',
    className: 'sub-nav-item sub-nav-item-js',
    
    template: template,

    templateHelpers: function() {return {}},

    ui: {
        subPartName: '.sub-part-name-js'
    },

    events: {
        'mouseenter @ui.subPartName': 'onMouseEnterSubPartName'
    },

    initialize: function () {},

    onMouseEnterSubPartName: function () {
        var $el = this.$el;

        if ($el.hasClass('hover')) {
            return
        }

        $('.sub-nav-item-js').removeClass('hover');
        $el.addClass('hover');

        var index = $el.parent().children('.hover').index();

        channels.navChannel.trigger('hoverSubItemNav', {
            index: index
        });
    }

});

},{"./../../templates/work-item.hbs":44,"./../app":19,"./../channels":21,"backbone.marionette":2}],36:[function(require,module,exports){
var app        = require('./../app');
var channels   = require('./../channels');
var Marionette = require('backbone.marionette');

var WorkItemView = require('./WorkItemView');


module.exports = Marionette.CollectionView.extend({
    tagName: 'ul',
    childView: WorkItemView,

    childEvents: function () {return {}},

    ui: {
        subNavItem: '.sub-nav-item-js',
    },

    events: {},

    initialize: function () {
        channels.navChannel.on('clickIndexArrow', this.clickIndexArrow, this);
    },

    onShow: function () {
        // binds view elements to ui hash
        this.bindUIElements();

        this.ui.subNavItem.first().addClass('hover');
    },

    clickIndexArrow: function (options) {
        var $el = this.$el,
            index = options.index,
            $subNavItem = $el.children('.sub-nav-item-js');

        $subNavItem.removeClass('hover');

        $($subNavItem[index]).addClass('hover');
    }

    

});

},{"./../app":19,"./../channels":21,"./WorkItemView":35,"backbone.marionette":2}],37:[function(require,module,exports){
(function (global){
/*!
 * VERSION: 1.18.0
 * DATE: 2015-08-29
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2015, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */
var _gsScope="undefined"!=typeof module&&module.exports&&"undefined"!=typeof global?global:this||window;(_gsScope._gsQueue||(_gsScope._gsQueue=[])).push(function(){"use strict";_gsScope._gsDefine("TimelineLite",["core.Animation","core.SimpleTimeline","TweenLite"],function(t,e,i){var s=function(t){e.call(this,t),this._labels={},this.autoRemoveChildren=this.vars.autoRemoveChildren===!0,this.smoothChildTiming=this.vars.smoothChildTiming===!0,this._sortChildren=!0,this._onUpdate=this.vars.onUpdate;var i,s,r=this.vars;for(s in r)i=r[s],l(i)&&-1!==i.join("").indexOf("{self}")&&(r[s]=this._swapSelfInParams(i));l(r.tweens)&&this.add(r.tweens,0,r.align,r.stagger)},r=1e-10,n=i._internals,a=s._internals={},o=n.isSelector,l=n.isArray,h=n.lazyTweens,_=n.lazyRender,u=_gsScope._gsDefine.globals,f=function(t){var e,i={};for(e in t)i[e]=t[e];return i},c=function(t,e,i){var s,r,n=t.cycle;for(s in n)r=n[s],t[s]="function"==typeof r?r.call(e[i],i):r[i%r.length];delete t.cycle},p=a.pauseCallback=function(){},m=function(t){var e,i=[],s=t.length;for(e=0;e!==s;i.push(t[e++]));return i},d=s.prototype=new e;return s.version="1.18.0",d.constructor=s,d.kill()._gc=d._forcingPlayhead=d._hasPause=!1,d.to=function(t,e,s,r){var n=s.repeat&&u.TweenMax||i;return e?this.add(new n(t,e,s),r):this.set(t,s,r)},d.from=function(t,e,s,r){return this.add((s.repeat&&u.TweenMax||i).from(t,e,s),r)},d.fromTo=function(t,e,s,r,n){var a=r.repeat&&u.TweenMax||i;return e?this.add(a.fromTo(t,e,s,r),n):this.set(t,r,n)},d.staggerTo=function(t,e,r,n,a,l,h,_){var u,p,d=new s({onComplete:l,onCompleteParams:h,callbackScope:_,smoothChildTiming:this.smoothChildTiming}),g=r.cycle;for("string"==typeof t&&(t=i.selector(t)||t),t=t||[],o(t)&&(t=m(t)),n=n||0,0>n&&(t=m(t),t.reverse(),n*=-1),p=0;t.length>p;p++)u=f(r),u.startAt&&(u.startAt=f(u.startAt),u.startAt.cycle&&c(u.startAt,t,p)),g&&c(u,t,p),d.to(t[p],e,u,p*n);return this.add(d,a)},d.staggerFrom=function(t,e,i,s,r,n,a,o){return i.immediateRender=0!=i.immediateRender,i.runBackwards=!0,this.staggerTo(t,e,i,s,r,n,a,o)},d.staggerFromTo=function(t,e,i,s,r,n,a,o,l){return s.startAt=i,s.immediateRender=0!=s.immediateRender&&0!=i.immediateRender,this.staggerTo(t,e,s,r,n,a,o,l)},d.call=function(t,e,s,r){return this.add(i.delayedCall(0,t,e,s),r)},d.set=function(t,e,s){return s=this._parseTimeOrLabel(s,0,!0),null==e.immediateRender&&(e.immediateRender=s===this._time&&!this._paused),this.add(new i(t,0,e),s)},s.exportRoot=function(t,e){t=t||{},null==t.smoothChildTiming&&(t.smoothChildTiming=!0);var r,n,a=new s(t),o=a._timeline;for(null==e&&(e=!0),o._remove(a,!0),a._startTime=0,a._rawPrevTime=a._time=a._totalTime=o._time,r=o._first;r;)n=r._next,e&&r instanceof i&&r.target===r.vars.onComplete||a.add(r,r._startTime-r._delay),r=n;return o.add(a,0),a},d.add=function(r,n,a,o){var h,_,u,f,c,p;if("number"!=typeof n&&(n=this._parseTimeOrLabel(n,0,!0,r)),!(r instanceof t)){if(r instanceof Array||r&&r.push&&l(r)){for(a=a||"normal",o=o||0,h=n,_=r.length,u=0;_>u;u++)l(f=r[u])&&(f=new s({tweens:f})),this.add(f,h),"string"!=typeof f&&"function"!=typeof f&&("sequence"===a?h=f._startTime+f.totalDuration()/f._timeScale:"start"===a&&(f._startTime-=f.delay())),h+=o;return this._uncache(!0)}if("string"==typeof r)return this.addLabel(r,n);if("function"!=typeof r)throw"Cannot add "+r+" into the timeline; it is not a tween, timeline, function, or string.";r=i.delayedCall(0,r)}if(e.prototype.add.call(this,r,n),(this._gc||this._time===this._duration)&&!this._paused&&this._duration<this.duration())for(c=this,p=c.rawTime()>r._startTime;c._timeline;)p&&c._timeline.smoothChildTiming?c.totalTime(c._totalTime,!0):c._gc&&c._enabled(!0,!1),c=c._timeline;return this},d.remove=function(e){if(e instanceof t){this._remove(e,!1);var i=e._timeline=e.vars.useFrames?t._rootFramesTimeline:t._rootTimeline;return e._startTime=(e._paused?e._pauseTime:i._time)-(e._reversed?e.totalDuration()-e._totalTime:e._totalTime)/e._timeScale,this}if(e instanceof Array||e&&e.push&&l(e)){for(var s=e.length;--s>-1;)this.remove(e[s]);return this}return"string"==typeof e?this.removeLabel(e):this.kill(null,e)},d._remove=function(t,i){e.prototype._remove.call(this,t,i);var s=this._last;return s?this._time>s._startTime+s._totalDuration/s._timeScale&&(this._time=this.duration(),this._totalTime=this._totalDuration):this._time=this._totalTime=this._duration=this._totalDuration=0,this},d.append=function(t,e){return this.add(t,this._parseTimeOrLabel(null,e,!0,t))},d.insert=d.insertMultiple=function(t,e,i,s){return this.add(t,e||0,i,s)},d.appendMultiple=function(t,e,i,s){return this.add(t,this._parseTimeOrLabel(null,e,!0,t),i,s)},d.addLabel=function(t,e){return this._labels[t]=this._parseTimeOrLabel(e),this},d.addPause=function(t,e,s,r){var n=i.delayedCall(0,p,s,r||this);return n.vars.onComplete=n.vars.onReverseComplete=e,n.data="isPause",this._hasPause=!0,this.add(n,t)},d.removeLabel=function(t){return delete this._labels[t],this},d.getLabelTime=function(t){return null!=this._labels[t]?this._labels[t]:-1},d._parseTimeOrLabel=function(e,i,s,r){var n;if(r instanceof t&&r.timeline===this)this.remove(r);else if(r&&(r instanceof Array||r.push&&l(r)))for(n=r.length;--n>-1;)r[n]instanceof t&&r[n].timeline===this&&this.remove(r[n]);if("string"==typeof i)return this._parseTimeOrLabel(i,s&&"number"==typeof e&&null==this._labels[i]?e-this.duration():0,s);if(i=i||0,"string"!=typeof e||!isNaN(e)&&null==this._labels[e])null==e&&(e=this.duration());else{if(n=e.indexOf("="),-1===n)return null==this._labels[e]?s?this._labels[e]=this.duration()+i:i:this._labels[e]+i;i=parseInt(e.charAt(n-1)+"1",10)*Number(e.substr(n+1)),e=n>1?this._parseTimeOrLabel(e.substr(0,n-1),0,s):this.duration()}return Number(e)+i},d.seek=function(t,e){return this.totalTime("number"==typeof t?t:this._parseTimeOrLabel(t),e!==!1)},d.stop=function(){return this.paused(!0)},d.gotoAndPlay=function(t,e){return this.play(t,e)},d.gotoAndStop=function(t,e){return this.pause(t,e)},d.render=function(t,e,i){this._gc&&this._enabled(!0,!1);var s,n,a,o,l,u,f=this._dirty?this.totalDuration():this._totalDuration,c=this._time,p=this._startTime,m=this._timeScale,d=this._paused;if(t>=f)this._totalTime=this._time=f,this._reversed||this._hasPausedChild()||(n=!0,o="onComplete",l=!!this._timeline.autoRemoveChildren,0===this._duration&&(0===t||0>this._rawPrevTime||this._rawPrevTime===r)&&this._rawPrevTime!==t&&this._first&&(l=!0,this._rawPrevTime>r&&(o="onReverseComplete"))),this._rawPrevTime=this._duration||!e||t||this._rawPrevTime===t?t:r,t=f+1e-4;else if(1e-7>t)if(this._totalTime=this._time=0,(0!==c||0===this._duration&&this._rawPrevTime!==r&&(this._rawPrevTime>0||0>t&&this._rawPrevTime>=0))&&(o="onReverseComplete",n=this._reversed),0>t)this._active=!1,this._timeline.autoRemoveChildren&&this._reversed?(l=n=!0,o="onReverseComplete"):this._rawPrevTime>=0&&this._first&&(l=!0),this._rawPrevTime=t;else{if(this._rawPrevTime=this._duration||!e||t||this._rawPrevTime===t?t:r,0===t&&n)for(s=this._first;s&&0===s._startTime;)s._duration||(n=!1),s=s._next;t=0,this._initted||(l=!0)}else{if(this._hasPause&&!this._forcingPlayhead&&!e){if(t>=c)for(s=this._first;s&&t>=s._startTime&&!u;)s._duration||"isPause"!==s.data||s.ratio||0===s._startTime&&0===this._rawPrevTime||(u=s),s=s._next;else for(s=this._last;s&&s._startTime>=t&&!u;)s._duration||"isPause"===s.data&&s._rawPrevTime>0&&(u=s),s=s._prev;u&&(this._time=t=u._startTime,this._totalTime=t+this._cycle*(this._totalDuration+this._repeatDelay))}this._totalTime=this._time=this._rawPrevTime=t}if(this._time!==c&&this._first||i||l||u){if(this._initted||(this._initted=!0),this._active||!this._paused&&this._time!==c&&t>0&&(this._active=!0),0===c&&this.vars.onStart&&0!==this._time&&(e||this._callback("onStart")),this._time>=c)for(s=this._first;s&&(a=s._next,!this._paused||d);)(s._active||s._startTime<=this._time&&!s._paused&&!s._gc)&&(u===s&&this.pause(),s._reversed?s.render((s._dirty?s.totalDuration():s._totalDuration)-(t-s._startTime)*s._timeScale,e,i):s.render((t-s._startTime)*s._timeScale,e,i)),s=a;else for(s=this._last;s&&(a=s._prev,!this._paused||d);){if(s._active||c>=s._startTime&&!s._paused&&!s._gc){if(u===s){for(u=s._prev;u&&u.endTime()>this._time;)u.render(u._reversed?u.totalDuration()-(t-u._startTime)*u._timeScale:(t-u._startTime)*u._timeScale,e,i),u=u._prev;u=null,this.pause()}s._reversed?s.render((s._dirty?s.totalDuration():s._totalDuration)-(t-s._startTime)*s._timeScale,e,i):s.render((t-s._startTime)*s._timeScale,e,i)}s=a}this._onUpdate&&(e||(h.length&&_(),this._callback("onUpdate"))),o&&(this._gc||(p===this._startTime||m!==this._timeScale)&&(0===this._time||f>=this.totalDuration())&&(n&&(h.length&&_(),this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!e&&this.vars[o]&&this._callback(o)))}},d._hasPausedChild=function(){for(var t=this._first;t;){if(t._paused||t instanceof s&&t._hasPausedChild())return!0;t=t._next}return!1},d.getChildren=function(t,e,s,r){r=r||-9999999999;for(var n=[],a=this._first,o=0;a;)r>a._startTime||(a instanceof i?e!==!1&&(n[o++]=a):(s!==!1&&(n[o++]=a),t!==!1&&(n=n.concat(a.getChildren(!0,e,s)),o=n.length))),a=a._next;return n},d.getTweensOf=function(t,e){var s,r,n=this._gc,a=[],o=0;for(n&&this._enabled(!0,!0),s=i.getTweensOf(t),r=s.length;--r>-1;)(s[r].timeline===this||e&&this._contains(s[r]))&&(a[o++]=s[r]);return n&&this._enabled(!1,!0),a},d.recent=function(){return this._recent},d._contains=function(t){for(var e=t.timeline;e;){if(e===this)return!0;e=e.timeline}return!1},d.shiftChildren=function(t,e,i){i=i||0;for(var s,r=this._first,n=this._labels;r;)r._startTime>=i&&(r._startTime+=t),r=r._next;if(e)for(s in n)n[s]>=i&&(n[s]+=t);return this._uncache(!0)},d._kill=function(t,e){if(!t&&!e)return this._enabled(!1,!1);for(var i=e?this.getTweensOf(e):this.getChildren(!0,!0,!1),s=i.length,r=!1;--s>-1;)i[s]._kill(t,e)&&(r=!0);return r},d.clear=function(t){var e=this.getChildren(!1,!0,!0),i=e.length;for(this._time=this._totalTime=0;--i>-1;)e[i]._enabled(!1,!1);return t!==!1&&(this._labels={}),this._uncache(!0)},d.invalidate=function(){for(var e=this._first;e;)e.invalidate(),e=e._next;return t.prototype.invalidate.call(this)},d._enabled=function(t,i){if(t===this._gc)for(var s=this._first;s;)s._enabled(t,!0),s=s._next;return e.prototype._enabled.call(this,t,i)},d.totalTime=function(){this._forcingPlayhead=!0;var e=t.prototype.totalTime.apply(this,arguments);return this._forcingPlayhead=!1,e},d.duration=function(t){return arguments.length?(0!==this.duration()&&0!==t&&this.timeScale(this._duration/t),this):(this._dirty&&this.totalDuration(),this._duration)},d.totalDuration=function(t){if(!arguments.length){if(this._dirty){for(var e,i,s=0,r=this._last,n=999999999999;r;)e=r._prev,r._dirty&&r.totalDuration(),r._startTime>n&&this._sortChildren&&!r._paused?this.add(r,r._startTime-r._delay):n=r._startTime,0>r._startTime&&!r._paused&&(s-=r._startTime,this._timeline.smoothChildTiming&&(this._startTime+=r._startTime/this._timeScale),this.shiftChildren(-r._startTime,!1,-9999999999),n=0),i=r._startTime+r._totalDuration/r._timeScale,i>s&&(s=i),r=e;this._duration=this._totalDuration=s,this._dirty=!1}return this._totalDuration}return 0!==this.totalDuration()&&0!==t&&this.timeScale(this._totalDuration/t),this},d.paused=function(e){if(!e)for(var i=this._first,s=this._time;i;)i._startTime===s&&"isPause"===i.data&&(i._rawPrevTime=0),i=i._next;return t.prototype.paused.apply(this,arguments)},d.usesFrames=function(){for(var e=this._timeline;e._timeline;)e=e._timeline;return e===t._rootFramesTimeline},d.rawTime=function(){return this._paused?this._totalTime:(this._timeline.rawTime()-this._startTime)*this._timeScale},s},!0)}),_gsScope._gsDefine&&_gsScope._gsQueue.pop()(),function(t){"use strict";var e=function(){return(_gsScope.GreenSockGlobals||_gsScope)[t]};"function"==typeof define&&define.amd?define(["TweenLite"],e):"undefined"!=typeof module&&module.exports&&(require("./TweenLite.js"),module.exports=e())}("TimelineLite");
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9qYXZhc2NyaXB0L2xpYnMvVHdlZW5NYXgvVGltZWxpbmVMaXRlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVkVSU0lPTjogMS4xOC4wXG4gKiBEQVRFOiAyMDE1LTA4LTI5XG4gKiBVUERBVEVTIEFORCBET0NTIEFUOiBodHRwOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwOC0yMDE1LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIHdvcmsgaXMgc3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cDovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBzb2Z0d2FyZSBhZ3JlZW1lbnQgdGhhdCB3YXMgaXNzdWVkIHdpdGggeW91ciBtZW1iZXJzaGlwLlxuICogXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiAqL1xudmFyIF9nc1Njb3BlPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDp0aGlzfHx3aW5kb3c7KF9nc1Njb3BlLl9nc1F1ZXVlfHwoX2dzU2NvcGUuX2dzUXVldWU9W10pKS5wdXNoKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7X2dzU2NvcGUuX2dzRGVmaW5lKFwiVGltZWxpbmVMaXRlXCIsW1wiY29yZS5BbmltYXRpb25cIixcImNvcmUuU2ltcGxlVGltZWxpbmVcIixcIlR3ZWVuTGl0ZVwiXSxmdW5jdGlvbih0LGUsaSl7dmFyIHM9ZnVuY3Rpb24odCl7ZS5jYWxsKHRoaXMsdCksdGhpcy5fbGFiZWxzPXt9LHRoaXMuYXV0b1JlbW92ZUNoaWxkcmVuPXRoaXMudmFycy5hdXRvUmVtb3ZlQ2hpbGRyZW49PT0hMCx0aGlzLnNtb290aENoaWxkVGltaW5nPXRoaXMudmFycy5zbW9vdGhDaGlsZFRpbWluZz09PSEwLHRoaXMuX3NvcnRDaGlsZHJlbj0hMCx0aGlzLl9vblVwZGF0ZT10aGlzLnZhcnMub25VcGRhdGU7dmFyIGkscyxyPXRoaXMudmFycztmb3IocyBpbiByKWk9cltzXSxsKGkpJiYtMSE9PWkuam9pbihcIlwiKS5pbmRleE9mKFwie3NlbGZ9XCIpJiYocltzXT10aGlzLl9zd2FwU2VsZkluUGFyYW1zKGkpKTtsKHIudHdlZW5zKSYmdGhpcy5hZGQoci50d2VlbnMsMCxyLmFsaWduLHIuc3RhZ2dlcil9LHI9MWUtMTAsbj1pLl9pbnRlcm5hbHMsYT1zLl9pbnRlcm5hbHM9e30sbz1uLmlzU2VsZWN0b3IsbD1uLmlzQXJyYXksaD1uLmxhenlUd2VlbnMsXz1uLmxhenlSZW5kZXIsdT1fZ3NTY29wZS5fZ3NEZWZpbmUuZ2xvYmFscyxmPWZ1bmN0aW9uKHQpe3ZhciBlLGk9e307Zm9yKGUgaW4gdClpW2VdPXRbZV07cmV0dXJuIGl9LGM9ZnVuY3Rpb24odCxlLGkpe3ZhciBzLHIsbj10LmN5Y2xlO2ZvcihzIGluIG4pcj1uW3NdLHRbc109XCJmdW5jdGlvblwiPT10eXBlb2Ygcj9yLmNhbGwoZVtpXSxpKTpyW2klci5sZW5ndGhdO2RlbGV0ZSB0LmN5Y2xlfSxwPWEucGF1c2VDYWxsYmFjaz1mdW5jdGlvbigpe30sbT1mdW5jdGlvbih0KXt2YXIgZSxpPVtdLHM9dC5sZW5ndGg7Zm9yKGU9MDtlIT09cztpLnB1c2godFtlKytdKSk7cmV0dXJuIGl9LGQ9cy5wcm90b3R5cGU9bmV3IGU7cmV0dXJuIHMudmVyc2lvbj1cIjEuMTguMFwiLGQuY29uc3RydWN0b3I9cyxkLmtpbGwoKS5fZ2M9ZC5fZm9yY2luZ1BsYXloZWFkPWQuX2hhc1BhdXNlPSExLGQudG89ZnVuY3Rpb24odCxlLHMscil7dmFyIG49cy5yZXBlYXQmJnUuVHdlZW5NYXh8fGk7cmV0dXJuIGU/dGhpcy5hZGQobmV3IG4odCxlLHMpLHIpOnRoaXMuc2V0KHQscyxyKX0sZC5mcm9tPWZ1bmN0aW9uKHQsZSxzLHIpe3JldHVybiB0aGlzLmFkZCgocy5yZXBlYXQmJnUuVHdlZW5NYXh8fGkpLmZyb20odCxlLHMpLHIpfSxkLmZyb21Ubz1mdW5jdGlvbih0LGUscyxyLG4pe3ZhciBhPXIucmVwZWF0JiZ1LlR3ZWVuTWF4fHxpO3JldHVybiBlP3RoaXMuYWRkKGEuZnJvbVRvKHQsZSxzLHIpLG4pOnRoaXMuc2V0KHQscixuKX0sZC5zdGFnZ2VyVG89ZnVuY3Rpb24odCxlLHIsbixhLGwsaCxfKXt2YXIgdSxwLGQ9bmV3IHMoe29uQ29tcGxldGU6bCxvbkNvbXBsZXRlUGFyYW1zOmgsY2FsbGJhY2tTY29wZTpfLHNtb290aENoaWxkVGltaW5nOnRoaXMuc21vb3RoQ2hpbGRUaW1pbmd9KSxnPXIuY3ljbGU7Zm9yKFwic3RyaW5nXCI9PXR5cGVvZiB0JiYodD1pLnNlbGVjdG9yKHQpfHx0KSx0PXR8fFtdLG8odCkmJih0PW0odCkpLG49bnx8MCwwPm4mJih0PW0odCksdC5yZXZlcnNlKCksbio9LTEpLHA9MDt0Lmxlbmd0aD5wO3ArKyl1PWYociksdS5zdGFydEF0JiYodS5zdGFydEF0PWYodS5zdGFydEF0KSx1LnN0YXJ0QXQuY3ljbGUmJmModS5zdGFydEF0LHQscCkpLGcmJmModSx0LHApLGQudG8odFtwXSxlLHUscCpuKTtyZXR1cm4gdGhpcy5hZGQoZCxhKX0sZC5zdGFnZ2VyRnJvbT1mdW5jdGlvbih0LGUsaSxzLHIsbixhLG8pe3JldHVybiBpLmltbWVkaWF0ZVJlbmRlcj0wIT1pLmltbWVkaWF0ZVJlbmRlcixpLnJ1bkJhY2t3YXJkcz0hMCx0aGlzLnN0YWdnZXJUbyh0LGUsaSxzLHIsbixhLG8pfSxkLnN0YWdnZXJGcm9tVG89ZnVuY3Rpb24odCxlLGkscyxyLG4sYSxvLGwpe3JldHVybiBzLnN0YXJ0QXQ9aSxzLmltbWVkaWF0ZVJlbmRlcj0wIT1zLmltbWVkaWF0ZVJlbmRlciYmMCE9aS5pbW1lZGlhdGVSZW5kZXIsdGhpcy5zdGFnZ2VyVG8odCxlLHMscixuLGEsbyxsKX0sZC5jYWxsPWZ1bmN0aW9uKHQsZSxzLHIpe3JldHVybiB0aGlzLmFkZChpLmRlbGF5ZWRDYWxsKDAsdCxlLHMpLHIpfSxkLnNldD1mdW5jdGlvbih0LGUscyl7cmV0dXJuIHM9dGhpcy5fcGFyc2VUaW1lT3JMYWJlbChzLDAsITApLG51bGw9PWUuaW1tZWRpYXRlUmVuZGVyJiYoZS5pbW1lZGlhdGVSZW5kZXI9cz09PXRoaXMuX3RpbWUmJiF0aGlzLl9wYXVzZWQpLHRoaXMuYWRkKG5ldyBpKHQsMCxlKSxzKX0scy5leHBvcnRSb290PWZ1bmN0aW9uKHQsZSl7dD10fHx7fSxudWxsPT10LnNtb290aENoaWxkVGltaW5nJiYodC5zbW9vdGhDaGlsZFRpbWluZz0hMCk7dmFyIHIsbixhPW5ldyBzKHQpLG89YS5fdGltZWxpbmU7Zm9yKG51bGw9PWUmJihlPSEwKSxvLl9yZW1vdmUoYSwhMCksYS5fc3RhcnRUaW1lPTAsYS5fcmF3UHJldlRpbWU9YS5fdGltZT1hLl90b3RhbFRpbWU9by5fdGltZSxyPW8uX2ZpcnN0O3I7KW49ci5fbmV4dCxlJiZyIGluc3RhbmNlb2YgaSYmci50YXJnZXQ9PT1yLnZhcnMub25Db21wbGV0ZXx8YS5hZGQocixyLl9zdGFydFRpbWUtci5fZGVsYXkpLHI9bjtyZXR1cm4gby5hZGQoYSwwKSxhfSxkLmFkZD1mdW5jdGlvbihyLG4sYSxvKXt2YXIgaCxfLHUsZixjLHA7aWYoXCJudW1iZXJcIiE9dHlwZW9mIG4mJihuPXRoaXMuX3BhcnNlVGltZU9yTGFiZWwobiwwLCEwLHIpKSwhKHIgaW5zdGFuY2VvZiB0KSl7aWYociBpbnN0YW5jZW9mIEFycmF5fHxyJiZyLnB1c2gmJmwocikpe2ZvcihhPWF8fFwibm9ybWFsXCIsbz1vfHwwLGg9bixfPXIubGVuZ3RoLHU9MDtfPnU7dSsrKWwoZj1yW3VdKSYmKGY9bmV3IHMoe3R3ZWVuczpmfSkpLHRoaXMuYWRkKGYsaCksXCJzdHJpbmdcIiE9dHlwZW9mIGYmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGYmJihcInNlcXVlbmNlXCI9PT1hP2g9Zi5fc3RhcnRUaW1lK2YudG90YWxEdXJhdGlvbigpL2YuX3RpbWVTY2FsZTpcInN0YXJ0XCI9PT1hJiYoZi5fc3RhcnRUaW1lLT1mLmRlbGF5KCkpKSxoKz1vO3JldHVybiB0aGlzLl91bmNhY2hlKCEwKX1pZihcInN0cmluZ1wiPT10eXBlb2YgcilyZXR1cm4gdGhpcy5hZGRMYWJlbChyLG4pO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHIpdGhyb3dcIkNhbm5vdCBhZGQgXCIrcitcIiBpbnRvIHRoZSB0aW1lbGluZTsgaXQgaXMgbm90IGEgdHdlZW4sIHRpbWVsaW5lLCBmdW5jdGlvbiwgb3Igc3RyaW5nLlwiO3I9aS5kZWxheWVkQ2FsbCgwLHIpfWlmKGUucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMscixuKSwodGhpcy5fZ2N8fHRoaXMuX3RpbWU9PT10aGlzLl9kdXJhdGlvbikmJiF0aGlzLl9wYXVzZWQmJnRoaXMuX2R1cmF0aW9uPHRoaXMuZHVyYXRpb24oKSlmb3IoYz10aGlzLHA9Yy5yYXdUaW1lKCk+ci5fc3RhcnRUaW1lO2MuX3RpbWVsaW5lOylwJiZjLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZz9jLnRvdGFsVGltZShjLl90b3RhbFRpbWUsITApOmMuX2djJiZjLl9lbmFibGVkKCEwLCExKSxjPWMuX3RpbWVsaW5lO3JldHVybiB0aGlzfSxkLnJlbW92ZT1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgdCl7dGhpcy5fcmVtb3ZlKGUsITEpO3ZhciBpPWUuX3RpbWVsaW5lPWUudmFycy51c2VGcmFtZXM/dC5fcm9vdEZyYW1lc1RpbWVsaW5lOnQuX3Jvb3RUaW1lbGluZTtyZXR1cm4gZS5fc3RhcnRUaW1lPShlLl9wYXVzZWQ/ZS5fcGF1c2VUaW1lOmkuX3RpbWUpLShlLl9yZXZlcnNlZD9lLnRvdGFsRHVyYXRpb24oKS1lLl90b3RhbFRpbWU6ZS5fdG90YWxUaW1lKS9lLl90aW1lU2NhbGUsdGhpc31pZihlIGluc3RhbmNlb2YgQXJyYXl8fGUmJmUucHVzaCYmbChlKSl7Zm9yKHZhciBzPWUubGVuZ3RoOy0tcz4tMTspdGhpcy5yZW1vdmUoZVtzXSk7cmV0dXJuIHRoaXN9cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGU/dGhpcy5yZW1vdmVMYWJlbChlKTp0aGlzLmtpbGwobnVsbCxlKX0sZC5fcmVtb3ZlPWZ1bmN0aW9uKHQsaSl7ZS5wcm90b3R5cGUuX3JlbW92ZS5jYWxsKHRoaXMsdCxpKTt2YXIgcz10aGlzLl9sYXN0O3JldHVybiBzP3RoaXMuX3RpbWU+cy5fc3RhcnRUaW1lK3MuX3RvdGFsRHVyYXRpb24vcy5fdGltZVNjYWxlJiYodGhpcy5fdGltZT10aGlzLmR1cmF0aW9uKCksdGhpcy5fdG90YWxUaW1lPXRoaXMuX3RvdGFsRHVyYXRpb24pOnRoaXMuX3RpbWU9dGhpcy5fdG90YWxUaW1lPXRoaXMuX2R1cmF0aW9uPXRoaXMuX3RvdGFsRHVyYXRpb249MCx0aGlzfSxkLmFwcGVuZD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmFkZCh0LHRoaXMuX3BhcnNlVGltZU9yTGFiZWwobnVsbCxlLCEwLHQpKX0sZC5pbnNlcnQ9ZC5pbnNlcnRNdWx0aXBsZT1mdW5jdGlvbih0LGUsaSxzKXtyZXR1cm4gdGhpcy5hZGQodCxlfHwwLGkscyl9LGQuYXBwZW5kTXVsdGlwbGU9ZnVuY3Rpb24odCxlLGkscyl7cmV0dXJuIHRoaXMuYWRkKHQsdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChudWxsLGUsITAsdCksaSxzKX0sZC5hZGRMYWJlbD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl9sYWJlbHNbdF09dGhpcy5fcGFyc2VUaW1lT3JMYWJlbChlKSx0aGlzfSxkLmFkZFBhdXNlPWZ1bmN0aW9uKHQsZSxzLHIpe3ZhciBuPWkuZGVsYXllZENhbGwoMCxwLHMscnx8dGhpcyk7cmV0dXJuIG4udmFycy5vbkNvbXBsZXRlPW4udmFycy5vblJldmVyc2VDb21wbGV0ZT1lLG4uZGF0YT1cImlzUGF1c2VcIix0aGlzLl9oYXNQYXVzZT0hMCx0aGlzLmFkZChuLHQpfSxkLnJlbW92ZUxhYmVsPWZ1bmN0aW9uKHQpe3JldHVybiBkZWxldGUgdGhpcy5fbGFiZWxzW3RdLHRoaXN9LGQuZ2V0TGFiZWxUaW1lPWZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT10aGlzLl9sYWJlbHNbdF0/dGhpcy5fbGFiZWxzW3RdOi0xfSxkLl9wYXJzZVRpbWVPckxhYmVsPWZ1bmN0aW9uKGUsaSxzLHIpe3ZhciBuO2lmKHIgaW5zdGFuY2VvZiB0JiZyLnRpbWVsaW5lPT09dGhpcyl0aGlzLnJlbW92ZShyKTtlbHNlIGlmKHImJihyIGluc3RhbmNlb2YgQXJyYXl8fHIucHVzaCYmbChyKSkpZm9yKG49ci5sZW5ndGg7LS1uPi0xOylyW25daW5zdGFuY2VvZiB0JiZyW25dLnRpbWVsaW5lPT09dGhpcyYmdGhpcy5yZW1vdmUocltuXSk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGkpcmV0dXJuIHRoaXMuX3BhcnNlVGltZU9yTGFiZWwoaSxzJiZcIm51bWJlclwiPT10eXBlb2YgZSYmbnVsbD09dGhpcy5fbGFiZWxzW2ldP2UtdGhpcy5kdXJhdGlvbigpOjAscyk7aWYoaT1pfHwwLFwic3RyaW5nXCIhPXR5cGVvZiBlfHwhaXNOYU4oZSkmJm51bGw9PXRoaXMuX2xhYmVsc1tlXSludWxsPT1lJiYoZT10aGlzLmR1cmF0aW9uKCkpO2Vsc2V7aWYobj1lLmluZGV4T2YoXCI9XCIpLC0xPT09bilyZXR1cm4gbnVsbD09dGhpcy5fbGFiZWxzW2VdP3M/dGhpcy5fbGFiZWxzW2VdPXRoaXMuZHVyYXRpb24oKStpOmk6dGhpcy5fbGFiZWxzW2VdK2k7aT1wYXJzZUludChlLmNoYXJBdChuLTEpK1wiMVwiLDEwKSpOdW1iZXIoZS5zdWJzdHIobisxKSksZT1uPjE/dGhpcy5fcGFyc2VUaW1lT3JMYWJlbChlLnN1YnN0cigwLG4tMSksMCxzKTp0aGlzLmR1cmF0aW9uKCl9cmV0dXJuIE51bWJlcihlKStpfSxkLnNlZWs9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50b3RhbFRpbWUoXCJudW1iZXJcIj09dHlwZW9mIHQ/dDp0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHQpLGUhPT0hMSl9LGQuc3RvcD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhdXNlZCghMCl9LGQuZ290b0FuZFBsYXk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5wbGF5KHQsZSl9LGQuZ290b0FuZFN0b3A9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5wYXVzZSh0LGUpfSxkLnJlbmRlcj1mdW5jdGlvbih0LGUsaSl7dGhpcy5fZ2MmJnRoaXMuX2VuYWJsZWQoITAsITEpO3ZhciBzLG4sYSxvLGwsdSxmPXRoaXMuX2RpcnR5P3RoaXMudG90YWxEdXJhdGlvbigpOnRoaXMuX3RvdGFsRHVyYXRpb24sYz10aGlzLl90aW1lLHA9dGhpcy5fc3RhcnRUaW1lLG09dGhpcy5fdGltZVNjYWxlLGQ9dGhpcy5fcGF1c2VkO2lmKHQ+PWYpdGhpcy5fdG90YWxUaW1lPXRoaXMuX3RpbWU9Zix0aGlzLl9yZXZlcnNlZHx8dGhpcy5faGFzUGF1c2VkQ2hpbGQoKXx8KG49ITAsbz1cIm9uQ29tcGxldGVcIixsPSEhdGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuLDA9PT10aGlzLl9kdXJhdGlvbiYmKDA9PT10fHwwPnRoaXMuX3Jhd1ByZXZUaW1lfHx0aGlzLl9yYXdQcmV2VGltZT09PXIpJiZ0aGlzLl9yYXdQcmV2VGltZSE9PXQmJnRoaXMuX2ZpcnN0JiYobD0hMCx0aGlzLl9yYXdQcmV2VGltZT5yJiYobz1cIm9uUmV2ZXJzZUNvbXBsZXRlXCIpKSksdGhpcy5fcmF3UHJldlRpbWU9dGhpcy5fZHVyYXRpb258fCFlfHx0fHx0aGlzLl9yYXdQcmV2VGltZT09PXQ/dDpyLHQ9ZisxZS00O2Vsc2UgaWYoMWUtNz50KWlmKHRoaXMuX3RvdGFsVGltZT10aGlzLl90aW1lPTAsKDAhPT1jfHwwPT09dGhpcy5fZHVyYXRpb24mJnRoaXMuX3Jhd1ByZXZUaW1lIT09ciYmKHRoaXMuX3Jhd1ByZXZUaW1lPjB8fDA+dCYmdGhpcy5fcmF3UHJldlRpbWU+PTApKSYmKG89XCJvblJldmVyc2VDb21wbGV0ZVwiLG49dGhpcy5fcmV2ZXJzZWQpLDA+dCl0aGlzLl9hY3RpdmU9ITEsdGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuJiZ0aGlzLl9yZXZlcnNlZD8obD1uPSEwLG89XCJvblJldmVyc2VDb21wbGV0ZVwiKTp0aGlzLl9yYXdQcmV2VGltZT49MCYmdGhpcy5fZmlyc3QmJihsPSEwKSx0aGlzLl9yYXdQcmV2VGltZT10O2Vsc2V7aWYodGhpcy5fcmF3UHJldlRpbWU9dGhpcy5fZHVyYXRpb258fCFlfHx0fHx0aGlzLl9yYXdQcmV2VGltZT09PXQ/dDpyLDA9PT10JiZuKWZvcihzPXRoaXMuX2ZpcnN0O3MmJjA9PT1zLl9zdGFydFRpbWU7KXMuX2R1cmF0aW9ufHwobj0hMSkscz1zLl9uZXh0O3Q9MCx0aGlzLl9pbml0dGVkfHwobD0hMCl9ZWxzZXtpZih0aGlzLl9oYXNQYXVzZSYmIXRoaXMuX2ZvcmNpbmdQbGF5aGVhZCYmIWUpe2lmKHQ+PWMpZm9yKHM9dGhpcy5fZmlyc3Q7cyYmdD49cy5fc3RhcnRUaW1lJiYhdTspcy5fZHVyYXRpb258fFwiaXNQYXVzZVwiIT09cy5kYXRhfHxzLnJhdGlvfHwwPT09cy5fc3RhcnRUaW1lJiYwPT09dGhpcy5fcmF3UHJldlRpbWV8fCh1PXMpLHM9cy5fbmV4dDtlbHNlIGZvcihzPXRoaXMuX2xhc3Q7cyYmcy5fc3RhcnRUaW1lPj10JiYhdTspcy5fZHVyYXRpb258fFwiaXNQYXVzZVwiPT09cy5kYXRhJiZzLl9yYXdQcmV2VGltZT4wJiYodT1zKSxzPXMuX3ByZXY7dSYmKHRoaXMuX3RpbWU9dD11Ll9zdGFydFRpbWUsdGhpcy5fdG90YWxUaW1lPXQrdGhpcy5fY3ljbGUqKHRoaXMuX3RvdGFsRHVyYXRpb24rdGhpcy5fcmVwZWF0RGVsYXkpKX10aGlzLl90b3RhbFRpbWU9dGhpcy5fdGltZT10aGlzLl9yYXdQcmV2VGltZT10fWlmKHRoaXMuX3RpbWUhPT1jJiZ0aGlzLl9maXJzdHx8aXx8bHx8dSl7aWYodGhpcy5faW5pdHRlZHx8KHRoaXMuX2luaXR0ZWQ9ITApLHRoaXMuX2FjdGl2ZXx8IXRoaXMuX3BhdXNlZCYmdGhpcy5fdGltZSE9PWMmJnQ+MCYmKHRoaXMuX2FjdGl2ZT0hMCksMD09PWMmJnRoaXMudmFycy5vblN0YXJ0JiYwIT09dGhpcy5fdGltZSYmKGV8fHRoaXMuX2NhbGxiYWNrKFwib25TdGFydFwiKSksdGhpcy5fdGltZT49Yylmb3Iocz10aGlzLl9maXJzdDtzJiYoYT1zLl9uZXh0LCF0aGlzLl9wYXVzZWR8fGQpOykocy5fYWN0aXZlfHxzLl9zdGFydFRpbWU8PXRoaXMuX3RpbWUmJiFzLl9wYXVzZWQmJiFzLl9nYykmJih1PT09cyYmdGhpcy5wYXVzZSgpLHMuX3JldmVyc2VkP3MucmVuZGVyKChzLl9kaXJ0eT9zLnRvdGFsRHVyYXRpb24oKTpzLl90b3RhbER1cmF0aW9uKS0odC1zLl9zdGFydFRpbWUpKnMuX3RpbWVTY2FsZSxlLGkpOnMucmVuZGVyKCh0LXMuX3N0YXJ0VGltZSkqcy5fdGltZVNjYWxlLGUsaSkpLHM9YTtlbHNlIGZvcihzPXRoaXMuX2xhc3Q7cyYmKGE9cy5fcHJldiwhdGhpcy5fcGF1c2VkfHxkKTspe2lmKHMuX2FjdGl2ZXx8Yz49cy5fc3RhcnRUaW1lJiYhcy5fcGF1c2VkJiYhcy5fZ2Mpe2lmKHU9PT1zKXtmb3IodT1zLl9wcmV2O3UmJnUuZW5kVGltZSgpPnRoaXMuX3RpbWU7KXUucmVuZGVyKHUuX3JldmVyc2VkP3UudG90YWxEdXJhdGlvbigpLSh0LXUuX3N0YXJ0VGltZSkqdS5fdGltZVNjYWxlOih0LXUuX3N0YXJ0VGltZSkqdS5fdGltZVNjYWxlLGUsaSksdT11Ll9wcmV2O3U9bnVsbCx0aGlzLnBhdXNlKCl9cy5fcmV2ZXJzZWQ/cy5yZW5kZXIoKHMuX2RpcnR5P3MudG90YWxEdXJhdGlvbigpOnMuX3RvdGFsRHVyYXRpb24pLSh0LXMuX3N0YXJ0VGltZSkqcy5fdGltZVNjYWxlLGUsaSk6cy5yZW5kZXIoKHQtcy5fc3RhcnRUaW1lKSpzLl90aW1lU2NhbGUsZSxpKX1zPWF9dGhpcy5fb25VcGRhdGUmJihlfHwoaC5sZW5ndGgmJl8oKSx0aGlzLl9jYWxsYmFjayhcIm9uVXBkYXRlXCIpKSksbyYmKHRoaXMuX2djfHwocD09PXRoaXMuX3N0YXJ0VGltZXx8bSE9PXRoaXMuX3RpbWVTY2FsZSkmJigwPT09dGhpcy5fdGltZXx8Zj49dGhpcy50b3RhbER1cmF0aW9uKCkpJiYobiYmKGgubGVuZ3RoJiZfKCksdGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuJiZ0aGlzLl9lbmFibGVkKCExLCExKSx0aGlzLl9hY3RpdmU9ITEpLCFlJiZ0aGlzLnZhcnNbb10mJnRoaXMuX2NhbGxiYWNrKG8pKSl9fSxkLl9oYXNQYXVzZWRDaGlsZD1mdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLl9maXJzdDt0Oyl7aWYodC5fcGF1c2VkfHx0IGluc3RhbmNlb2YgcyYmdC5faGFzUGF1c2VkQ2hpbGQoKSlyZXR1cm4hMDt0PXQuX25leHR9cmV0dXJuITF9LGQuZ2V0Q2hpbGRyZW49ZnVuY3Rpb24odCxlLHMscil7cj1yfHwtOTk5OTk5OTk5OTtmb3IodmFyIG49W10sYT10aGlzLl9maXJzdCxvPTA7YTspcj5hLl9zdGFydFRpbWV8fChhIGluc3RhbmNlb2YgaT9lIT09ITEmJihuW28rK109YSk6KHMhPT0hMSYmKG5bbysrXT1hKSx0IT09ITEmJihuPW4uY29uY2F0KGEuZ2V0Q2hpbGRyZW4oITAsZSxzKSksbz1uLmxlbmd0aCkpKSxhPWEuX25leHQ7cmV0dXJuIG59LGQuZ2V0VHdlZW5zT2Y9ZnVuY3Rpb24odCxlKXt2YXIgcyxyLG49dGhpcy5fZ2MsYT1bXSxvPTA7Zm9yKG4mJnRoaXMuX2VuYWJsZWQoITAsITApLHM9aS5nZXRUd2VlbnNPZih0KSxyPXMubGVuZ3RoOy0tcj4tMTspKHNbcl0udGltZWxpbmU9PT10aGlzfHxlJiZ0aGlzLl9jb250YWlucyhzW3JdKSkmJihhW28rK109c1tyXSk7cmV0dXJuIG4mJnRoaXMuX2VuYWJsZWQoITEsITApLGF9LGQucmVjZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JlY2VudH0sZC5fY29udGFpbnM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQudGltZWxpbmU7ZTspe2lmKGU9PT10aGlzKXJldHVybiEwO2U9ZS50aW1lbGluZX1yZXR1cm4hMX0sZC5zaGlmdENoaWxkcmVuPWZ1bmN0aW9uKHQsZSxpKXtpPWl8fDA7Zm9yKHZhciBzLHI9dGhpcy5fZmlyc3Qsbj10aGlzLl9sYWJlbHM7cjspci5fc3RhcnRUaW1lPj1pJiYoci5fc3RhcnRUaW1lKz10KSxyPXIuX25leHQ7aWYoZSlmb3IocyBpbiBuKW5bc10+PWkmJihuW3NdKz10KTtyZXR1cm4gdGhpcy5fdW5jYWNoZSghMCl9LGQuX2tpbGw9ZnVuY3Rpb24odCxlKXtpZighdCYmIWUpcmV0dXJuIHRoaXMuX2VuYWJsZWQoITEsITEpO2Zvcih2YXIgaT1lP3RoaXMuZ2V0VHdlZW5zT2YoZSk6dGhpcy5nZXRDaGlsZHJlbighMCwhMCwhMSkscz1pLmxlbmd0aCxyPSExOy0tcz4tMTspaVtzXS5fa2lsbCh0LGUpJiYocj0hMCk7cmV0dXJuIHJ9LGQuY2xlYXI9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRDaGlsZHJlbighMSwhMCwhMCksaT1lLmxlbmd0aDtmb3IodGhpcy5fdGltZT10aGlzLl90b3RhbFRpbWU9MDstLWk+LTE7KWVbaV0uX2VuYWJsZWQoITEsITEpO3JldHVybiB0IT09ITEmJih0aGlzLl9sYWJlbHM9e30pLHRoaXMuX3VuY2FjaGUoITApfSxkLmludmFsaWRhdGU9ZnVuY3Rpb24oKXtmb3IodmFyIGU9dGhpcy5fZmlyc3Q7ZTspZS5pbnZhbGlkYXRlKCksZT1lLl9uZXh0O3JldHVybiB0LnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyl9LGQuX2VuYWJsZWQ9ZnVuY3Rpb24odCxpKXtpZih0PT09dGhpcy5fZ2MpZm9yKHZhciBzPXRoaXMuX2ZpcnN0O3M7KXMuX2VuYWJsZWQodCwhMCkscz1zLl9uZXh0O3JldHVybiBlLnByb3RvdHlwZS5fZW5hYmxlZC5jYWxsKHRoaXMsdCxpKX0sZC50b3RhbFRpbWU9ZnVuY3Rpb24oKXt0aGlzLl9mb3JjaW5nUGxheWhlYWQ9ITA7dmFyIGU9dC5wcm90b3R5cGUudG90YWxUaW1lLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gdGhpcy5fZm9yY2luZ1BsYXloZWFkPSExLGV9LGQuZHVyYXRpb249ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KDAhPT10aGlzLmR1cmF0aW9uKCkmJjAhPT10JiZ0aGlzLnRpbWVTY2FsZSh0aGlzLl9kdXJhdGlvbi90KSx0aGlzKToodGhpcy5fZGlydHkmJnRoaXMudG90YWxEdXJhdGlvbigpLHRoaXMuX2R1cmF0aW9uKX0sZC50b3RhbER1cmF0aW9uPWZ1bmN0aW9uKHQpe2lmKCFhcmd1bWVudHMubGVuZ3RoKXtpZih0aGlzLl9kaXJ0eSl7Zm9yKHZhciBlLGkscz0wLHI9dGhpcy5fbGFzdCxuPTk5OTk5OTk5OTk5OTtyOyllPXIuX3ByZXYsci5fZGlydHkmJnIudG90YWxEdXJhdGlvbigpLHIuX3N0YXJ0VGltZT5uJiZ0aGlzLl9zb3J0Q2hpbGRyZW4mJiFyLl9wYXVzZWQ/dGhpcy5hZGQocixyLl9zdGFydFRpbWUtci5fZGVsYXkpOm49ci5fc3RhcnRUaW1lLDA+ci5fc3RhcnRUaW1lJiYhci5fcGF1c2VkJiYocy09ci5fc3RhcnRUaW1lLHRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nJiYodGhpcy5fc3RhcnRUaW1lKz1yLl9zdGFydFRpbWUvdGhpcy5fdGltZVNjYWxlKSx0aGlzLnNoaWZ0Q2hpbGRyZW4oLXIuX3N0YXJ0VGltZSwhMSwtOTk5OTk5OTk5OSksbj0wKSxpPXIuX3N0YXJ0VGltZStyLl90b3RhbER1cmF0aW9uL3IuX3RpbWVTY2FsZSxpPnMmJihzPWkpLHI9ZTt0aGlzLl9kdXJhdGlvbj10aGlzLl90b3RhbER1cmF0aW9uPXMsdGhpcy5fZGlydHk9ITF9cmV0dXJuIHRoaXMuX3RvdGFsRHVyYXRpb259cmV0dXJuIDAhPT10aGlzLnRvdGFsRHVyYXRpb24oKSYmMCE9PXQmJnRoaXMudGltZVNjYWxlKHRoaXMuX3RvdGFsRHVyYXRpb24vdCksdGhpc30sZC5wYXVzZWQ9ZnVuY3Rpb24oZSl7aWYoIWUpZm9yKHZhciBpPXRoaXMuX2ZpcnN0LHM9dGhpcy5fdGltZTtpOylpLl9zdGFydFRpbWU9PT1zJiZcImlzUGF1c2VcIj09PWkuZGF0YSYmKGkuX3Jhd1ByZXZUaW1lPTApLGk9aS5fbmV4dDtyZXR1cm4gdC5wcm90b3R5cGUucGF1c2VkLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sZC51c2VzRnJhbWVzPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXMuX3RpbWVsaW5lO2UuX3RpbWVsaW5lOyllPWUuX3RpbWVsaW5lO3JldHVybiBlPT09dC5fcm9vdEZyYW1lc1RpbWVsaW5lfSxkLnJhd1RpbWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcGF1c2VkP3RoaXMuX3RvdGFsVGltZToodGhpcy5fdGltZWxpbmUucmF3VGltZSgpLXRoaXMuX3N0YXJ0VGltZSkqdGhpcy5fdGltZVNjYWxlfSxzfSwhMCl9KSxfZ3NTY29wZS5fZ3NEZWZpbmUmJl9nc1Njb3BlLl9nc1F1ZXVlLnBvcCgpKCksZnVuY3Rpb24odCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9ZnVuY3Rpb24oKXtyZXR1cm4oX2dzU2NvcGUuR3JlZW5Tb2NrR2xvYmFsc3x8X2dzU2NvcGUpW3RdfTtcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcIlR3ZWVuTGl0ZVwiXSxlKTpcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cyYmKHJlcXVpcmUoXCIuL1R3ZWVuTGl0ZS5qc1wiKSxtb2R1bGUuZXhwb3J0cz1lKCkpfShcIlRpbWVsaW5lTGl0ZVwiKTsiXX0=
},{"./TweenLite.js":38}],38:[function(require,module,exports){
(function (global){
/*!
 * VERSION: 1.18.0
 * DATE: 2015-09-03
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2015, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */
(function(t,e){"use strict";var i=t.GreenSockGlobals=t.GreenSockGlobals||t;if(!i.TweenLite){var s,r,n,a,o,l=function(t){var e,s=t.split("."),r=i;for(e=0;s.length>e;e++)r[s[e]]=r=r[s[e]]||{};return r},h=l("com.greensock"),_=1e-10,u=function(t){var e,i=[],s=t.length;for(e=0;e!==s;i.push(t[e++]));return i},f=function(){},c=function(){var t=Object.prototype.toString,e=t.call([]);return function(i){return null!=i&&(i instanceof Array||"object"==typeof i&&!!i.push&&t.call(i)===e)}}(),m={},p=function(s,r,n,a){this.sc=m[s]?m[s].sc:[],m[s]=this,this.gsClass=null,this.func=n;var o=[];this.check=function(h){for(var _,u,f,c,d,v=r.length,g=v;--v>-1;)(_=m[r[v]]||new p(r[v],[])).gsClass?(o[v]=_.gsClass,g--):h&&_.sc.push(this);if(0===g&&n)for(u=("com.greensock."+s).split("."),f=u.pop(),c=l(u.join("."))[f]=this.gsClass=n.apply(n,o),a&&(i[f]=c,d="undefined"!=typeof module&&module.exports,!d&&"function"==typeof define&&define.amd?define((t.GreenSockAMDPath?t.GreenSockAMDPath+"/":"")+s.split(".").pop(),[],function(){return c}):s===e&&d&&(module.exports=c)),v=0;this.sc.length>v;v++)this.sc[v].check()},this.check(!0)},d=t._gsDefine=function(t,e,i,s){return new p(t,e,i,s)},v=h._class=function(t,e,i){return e=e||function(){},d(t,[],function(){return e},i),e};d.globals=i;var g=[0,0,1,1],T=[],y=v("easing.Ease",function(t,e,i,s){this._func=t,this._type=i||0,this._power=s||0,this._params=e?g.concat(e):g},!0),w=y.map={},P=y.register=function(t,e,i,s){for(var r,n,a,o,l=e.split(","),_=l.length,u=(i||"easeIn,easeOut,easeInOut").split(",");--_>-1;)for(n=l[_],r=s?v("easing."+n,null,!0):h.easing[n]||{},a=u.length;--a>-1;)o=u[a],w[n+"."+o]=w[o+n]=r[o]=t.getRatio?t:t[o]||new t};for(n=y.prototype,n._calcEnd=!1,n.getRatio=function(t){if(this._func)return this._params[0]=t,this._func.apply(null,this._params);var e=this._type,i=this._power,s=1===e?1-t:2===e?t:.5>t?2*t:2*(1-t);return 1===i?s*=s:2===i?s*=s*s:3===i?s*=s*s*s:4===i&&(s*=s*s*s*s),1===e?1-s:2===e?s:.5>t?s/2:1-s/2},s=["Linear","Quad","Cubic","Quart","Quint,Strong"],r=s.length;--r>-1;)n=s[r]+",Power"+r,P(new y(null,null,1,r),n,"easeOut",!0),P(new y(null,null,2,r),n,"easeIn"+(0===r?",easeNone":"")),P(new y(null,null,3,r),n,"easeInOut");w.linear=h.easing.Linear.easeIn,w.swing=h.easing.Quad.easeInOut;var b=v("events.EventDispatcher",function(t){this._listeners={},this._eventTarget=t||this});n=b.prototype,n.addEventListener=function(t,e,i,s,r){r=r||0;var n,l,h=this._listeners[t],_=0;for(null==h&&(this._listeners[t]=h=[]),l=h.length;--l>-1;)n=h[l],n.c===e&&n.s===i?h.splice(l,1):0===_&&r>n.pr&&(_=l+1);h.splice(_,0,{c:e,s:i,up:s,pr:r}),this!==a||o||a.wake()},n.removeEventListener=function(t,e){var i,s=this._listeners[t];if(s)for(i=s.length;--i>-1;)if(s[i].c===e)return s.splice(i,1),void 0},n.dispatchEvent=function(t){var e,i,s,r=this._listeners[t];if(r)for(e=r.length,i=this._eventTarget;--e>-1;)s=r[e],s&&(s.up?s.c.call(s.s||i,{type:t,target:i}):s.c.call(s.s||i))};var k=t.requestAnimationFrame,A=t.cancelAnimationFrame,S=Date.now||function(){return(new Date).getTime()},x=S();for(s=["ms","moz","webkit","o"],r=s.length;--r>-1&&!k;)k=t[s[r]+"RequestAnimationFrame"],A=t[s[r]+"CancelAnimationFrame"]||t[s[r]+"CancelRequestAnimationFrame"];v("Ticker",function(t,e){var i,s,r,n,l,h=this,u=S(),c=e!==!1&&k,m=500,p=33,d="tick",v=function(t){var e,a,o=S()-x;o>m&&(u+=o-p),x+=o,h.time=(x-u)/1e3,e=h.time-l,(!i||e>0||t===!0)&&(h.frame++,l+=e+(e>=n?.004:n-e),a=!0),t!==!0&&(r=s(v)),a&&h.dispatchEvent(d)};b.call(h),h.time=h.frame=0,h.tick=function(){v(!0)},h.lagSmoothing=function(t,e){m=t||1/_,p=Math.min(e,m,0)},h.sleep=function(){null!=r&&(c&&A?A(r):clearTimeout(r),s=f,r=null,h===a&&(o=!1))},h.wake=function(){null!==r?h.sleep():h.frame>10&&(x=S()-m+5),s=0===i?f:c&&k?k:function(t){return setTimeout(t,0|1e3*(l-h.time)+1)},h===a&&(o=!0),v(2)},h.fps=function(t){return arguments.length?(i=t,n=1/(i||60),l=this.time+n,h.wake(),void 0):i},h.useRAF=function(t){return arguments.length?(h.sleep(),c=t,h.fps(i),void 0):c},h.fps(t),setTimeout(function(){c&&5>h.frame&&h.useRAF(!1)},1500)}),n=h.Ticker.prototype=new h.events.EventDispatcher,n.constructor=h.Ticker;var R=v("core.Animation",function(t,e){if(this.vars=e=e||{},this._duration=this._totalDuration=t||0,this._delay=Number(e.delay)||0,this._timeScale=1,this._active=e.immediateRender===!0,this.data=e.data,this._reversed=e.reversed===!0,H){o||a.wake();var i=this.vars.useFrames?K:H;i.add(this,i._time),this.vars.paused&&this.paused(!0)}});a=R.ticker=new h.Ticker,n=R.prototype,n._dirty=n._gc=n._initted=n._paused=!1,n._totalTime=n._time=0,n._rawPrevTime=-1,n._next=n._last=n._onUpdate=n._timeline=n.timeline=null,n._paused=!1;var C=function(){o&&S()-x>2e3&&a.wake(),setTimeout(C,2e3)};C(),n.play=function(t,e){return null!=t&&this.seek(t,e),this.reversed(!1).paused(!1)},n.pause=function(t,e){return null!=t&&this.seek(t,e),this.paused(!0)},n.resume=function(t,e){return null!=t&&this.seek(t,e),this.paused(!1)},n.seek=function(t,e){return this.totalTime(Number(t),e!==!1)},n.restart=function(t,e){return this.reversed(!1).paused(!1).totalTime(t?-this._delay:0,e!==!1,!0)},n.reverse=function(t,e){return null!=t&&this.seek(t||this.totalDuration(),e),this.reversed(!0).paused(!1)},n.render=function(){},n.invalidate=function(){return this._time=this._totalTime=0,this._initted=this._gc=!1,this._rawPrevTime=-1,(this._gc||!this.timeline)&&this._enabled(!0),this},n.isActive=function(){var t,e=this._timeline,i=this._startTime;return!e||!this._gc&&!this._paused&&e.isActive()&&(t=e.rawTime())>=i&&i+this.totalDuration()/this._timeScale>t},n._enabled=function(t,e){return o||a.wake(),this._gc=!t,this._active=this.isActive(),e!==!0&&(t&&!this.timeline?this._timeline.add(this,this._startTime-this._delay):!t&&this.timeline&&this._timeline._remove(this,!0)),!1},n._kill=function(){return this._enabled(!1,!1)},n.kill=function(t,e){return this._kill(t,e),this},n._uncache=function(t){for(var e=t?this:this.timeline;e;)e._dirty=!0,e=e.timeline;return this},n._swapSelfInParams=function(t){for(var e=t.length,i=t.concat();--e>-1;)"{self}"===t[e]&&(i[e]=this);return i},n._callback=function(t){var e=this.vars;e[t].apply(e[t+"Scope"]||e.callbackScope||this,e[t+"Params"]||T)},n.eventCallback=function(t,e,i,s){if("on"===(t||"").substr(0,2)){var r=this.vars;if(1===arguments.length)return r[t];null==e?delete r[t]:(r[t]=e,r[t+"Params"]=c(i)&&-1!==i.join("").indexOf("{self}")?this._swapSelfInParams(i):i,r[t+"Scope"]=s),"onUpdate"===t&&(this._onUpdate=e)}return this},n.delay=function(t){return arguments.length?(this._timeline.smoothChildTiming&&this.startTime(this._startTime+t-this._delay),this._delay=t,this):this._delay},n.duration=function(t){return arguments.length?(this._duration=this._totalDuration=t,this._uncache(!0),this._timeline.smoothChildTiming&&this._time>0&&this._time<this._duration&&0!==t&&this.totalTime(this._totalTime*(t/this._duration),!0),this):(this._dirty=!1,this._duration)},n.totalDuration=function(t){return this._dirty=!1,arguments.length?this.duration(t):this._totalDuration},n.time=function(t,e){return arguments.length?(this._dirty&&this.totalDuration(),this.totalTime(t>this._duration?this._duration:t,e)):this._time},n.totalTime=function(t,e,i){if(o||a.wake(),!arguments.length)return this._totalTime;if(this._timeline){if(0>t&&!i&&(t+=this.totalDuration()),this._timeline.smoothChildTiming){this._dirty&&this.totalDuration();var s=this._totalDuration,r=this._timeline;if(t>s&&!i&&(t=s),this._startTime=(this._paused?this._pauseTime:r._time)-(this._reversed?s-t:t)/this._timeScale,r._dirty||this._uncache(!1),r._timeline)for(;r._timeline;)r._timeline._time!==(r._startTime+r._totalTime)/r._timeScale&&r.totalTime(r._totalTime,!0),r=r._timeline}this._gc&&this._enabled(!0,!1),(this._totalTime!==t||0===this._duration)&&(z.length&&V(),this.render(t,e,!1),z.length&&V())}return this},n.progress=n.totalProgress=function(t,e){var i=this.duration();return arguments.length?this.totalTime(i*t,e):i?this._time/i:this.ratio},n.startTime=function(t){return arguments.length?(t!==this._startTime&&(this._startTime=t,this.timeline&&this.timeline._sortChildren&&this.timeline.add(this,t-this._delay)),this):this._startTime},n.endTime=function(t){return this._startTime+(0!=t?this.totalDuration():this.duration())/this._timeScale},n.timeScale=function(t){if(!arguments.length)return this._timeScale;if(t=t||_,this._timeline&&this._timeline.smoothChildTiming){var e=this._pauseTime,i=e||0===e?e:this._timeline.totalTime();this._startTime=i-(i-this._startTime)*this._timeScale/t}return this._timeScale=t,this._uncache(!1)},n.reversed=function(t){return arguments.length?(t!=this._reversed&&(this._reversed=t,this.totalTime(this._timeline&&!this._timeline.smoothChildTiming?this.totalDuration()-this._totalTime:this._totalTime,!0)),this):this._reversed},n.paused=function(t){if(!arguments.length)return this._paused;var e,i,s=this._timeline;return t!=this._paused&&s&&(o||t||a.wake(),e=s.rawTime(),i=e-this._pauseTime,!t&&s.smoothChildTiming&&(this._startTime+=i,this._uncache(!1)),this._pauseTime=t?e:null,this._paused=t,this._active=this.isActive(),!t&&0!==i&&this._initted&&this.duration()&&(e=s.smoothChildTiming?this._totalTime:(e-this._startTime)/this._timeScale,this.render(e,e===this._totalTime,!0))),this._gc&&!t&&this._enabled(!0,!1),this};var D=v("core.SimpleTimeline",function(t){R.call(this,0,t),this.autoRemoveChildren=this.smoothChildTiming=!0});n=D.prototype=new R,n.constructor=D,n.kill()._gc=!1,n._first=n._last=n._recent=null,n._sortChildren=!1,n.add=n.insert=function(t,e){var i,s;if(t._startTime=Number(e||0)+t._delay,t._paused&&this!==t._timeline&&(t._pauseTime=t._startTime+(this.rawTime()-t._startTime)/t._timeScale),t.timeline&&t.timeline._remove(t,!0),t.timeline=t._timeline=this,t._gc&&t._enabled(!0,!0),i=this._last,this._sortChildren)for(s=t._startTime;i&&i._startTime>s;)i=i._prev;return i?(t._next=i._next,i._next=t):(t._next=this._first,this._first=t),t._next?t._next._prev=t:this._last=t,t._prev=i,this._recent=t,this._timeline&&this._uncache(!0),this},n._remove=function(t,e){return t.timeline===this&&(e||t._enabled(!1,!0),t._prev?t._prev._next=t._next:this._first===t&&(this._first=t._next),t._next?t._next._prev=t._prev:this._last===t&&(this._last=t._prev),t._next=t._prev=t.timeline=null,t===this._recent&&(this._recent=this._last),this._timeline&&this._uncache(!0)),this},n.render=function(t,e,i){var s,r=this._first;for(this._totalTime=this._time=this._rawPrevTime=t;r;)s=r._next,(r._active||t>=r._startTime&&!r._paused)&&(r._reversed?r.render((r._dirty?r.totalDuration():r._totalDuration)-(t-r._startTime)*r._timeScale,e,i):r.render((t-r._startTime)*r._timeScale,e,i)),r=s},n.rawTime=function(){return o||a.wake(),this._totalTime};var I=v("TweenLite",function(e,i,s){if(R.call(this,i,s),this.render=I.prototype.render,null==e)throw"Cannot tween a null target.";this.target=e="string"!=typeof e?e:I.selector(e)||e;var r,n,a,o=e.jquery||e.length&&e!==t&&e[0]&&(e[0]===t||e[0].nodeType&&e[0].style&&!e.nodeType),l=this.vars.overwrite;if(this._overwrite=l=null==l?$[I.defaultOverwrite]:"number"==typeof l?l>>0:$[l],(o||e instanceof Array||e.push&&c(e))&&"number"!=typeof e[0])for(this._targets=a=u(e),this._propLookup=[],this._siblings=[],r=0;a.length>r;r++)n=a[r],n?"string"!=typeof n?n.length&&n!==t&&n[0]&&(n[0]===t||n[0].nodeType&&n[0].style&&!n.nodeType)?(a.splice(r--,1),this._targets=a=a.concat(u(n))):(this._siblings[r]=W(n,this,!1),1===l&&this._siblings[r].length>1&&Y(n,this,null,1,this._siblings[r])):(n=a[r--]=I.selector(n),"string"==typeof n&&a.splice(r+1,1)):a.splice(r--,1);else this._propLookup={},this._siblings=W(e,this,!1),1===l&&this._siblings.length>1&&Y(e,this,null,1,this._siblings);(this.vars.immediateRender||0===i&&0===this._delay&&this.vars.immediateRender!==!1)&&(this._time=-_,this.render(-this._delay))},!0),E=function(e){return e&&e.length&&e!==t&&e[0]&&(e[0]===t||e[0].nodeType&&e[0].style&&!e.nodeType)},O=function(t,e){var i,s={};for(i in t)M[i]||i in e&&"transform"!==i&&"x"!==i&&"y"!==i&&"width"!==i&&"height"!==i&&"className"!==i&&"border"!==i||!(!Q[i]||Q[i]&&Q[i]._autoCSS)||(s[i]=t[i],delete t[i]);t.css=s};n=I.prototype=new R,n.constructor=I,n.kill()._gc=!1,n.ratio=0,n._firstPT=n._targets=n._overwrittenProps=n._startAt=null,n._notifyPluginsOfEnabled=n._lazy=!1,I.version="1.18.0",I.defaultEase=n._ease=new y(null,null,1,1),I.defaultOverwrite="auto",I.ticker=a,I.autoSleep=120,I.lagSmoothing=function(t,e){a.lagSmoothing(t,e)},I.selector=t.$||t.jQuery||function(e){var i=t.$||t.jQuery;return i?(I.selector=i,i(e)):"undefined"==typeof document?e:document.querySelectorAll?document.querySelectorAll(e):document.getElementById("#"===e.charAt(0)?e.substr(1):e)};var z=[],F={},L=/(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,N=function(t){for(var e,i=this._firstPT,s=1e-6;i;)e=i.blob?t?this.join(""):this.start:i.c*t+i.s,i.r?e=Math.round(e):s>e&&e>-s&&(e=0),i.f?i.fp?i.t[i.p](i.fp,e):i.t[i.p](e):i.t[i.p]=e,i=i._next},U=function(t,e,i,s){var r,n,a,o,l,h,_,u=[t,e],f=0,c="",m=0;for(u.start=t,i&&(i(u),t=u[0],e=u[1]),u.length=0,r=t.match(L)||[],n=e.match(L)||[],s&&(s._next=null,s.blob=1,u._firstPT=s),l=n.length,o=0;l>o;o++)_=n[o],h=e.substr(f,e.indexOf(_,f)-f),c+=h||!o?h:",",f+=h.length,m?m=(m+1)%5:"rgba("===h.substr(-5)&&(m=1),_===r[o]||o>=r.length?c+=_:(c&&(u.push(c),c=""),a=parseFloat(r[o]),u.push(a),u._firstPT={_next:u._firstPT,t:u,p:u.length-1,s:a,c:("="===_.charAt(1)?parseInt(_.charAt(0)+"1",10)*parseFloat(_.substr(2)):parseFloat(_)-a)||0,f:0,r:m&&4>m}),f+=_.length;return c+=e.substr(f),c&&u.push(c),u.setRatio=N,u},j=function(t,e,i,s,r,n,a,o){var l,h,_="get"===i?t[e]:i,u=typeof t[e],f="string"==typeof s&&"="===s.charAt(1),c={t:t,p:e,s:_,f:"function"===u,pg:0,n:r||e,r:n,pr:0,c:f?parseInt(s.charAt(0)+"1",10)*parseFloat(s.substr(2)):parseFloat(s)-_||0};return"number"!==u&&("function"===u&&"get"===i&&(h=e.indexOf("set")||"function"!=typeof t["get"+e.substr(3)]?e:"get"+e.substr(3),c.s=_=a?t[h](a):t[h]()),"string"==typeof _&&(a||isNaN(_))?(c.fp=a,l=U(_,s,o||I.defaultStringFilter,c),c={t:l,p:"setRatio",s:0,c:1,f:2,pg:0,n:r||e,pr:0}):f||(c.c=parseFloat(s)-parseFloat(_)||0)),c.c?((c._next=this._firstPT)&&(c._next._prev=c),this._firstPT=c,c):void 0},G=I._internals={isArray:c,isSelector:E,lazyTweens:z,blobDif:U},Q=I._plugins={},q=G.tweenLookup={},B=0,M=G.reservedProps={ease:1,delay:1,overwrite:1,onComplete:1,onCompleteParams:1,onCompleteScope:1,useFrames:1,runBackwards:1,startAt:1,onUpdate:1,onUpdateParams:1,onUpdateScope:1,onStart:1,onStartParams:1,onStartScope:1,onReverseComplete:1,onReverseCompleteParams:1,onReverseCompleteScope:1,onRepeat:1,onRepeatParams:1,onRepeatScope:1,easeParams:1,yoyo:1,immediateRender:1,repeat:1,repeatDelay:1,data:1,paused:1,reversed:1,autoCSS:1,lazy:1,onOverwrite:1,callbackScope:1,stringFilter:1},$={none:0,all:1,auto:2,concurrent:3,allOnStart:4,preexisting:5,"true":1,"false":0},K=R._rootFramesTimeline=new D,H=R._rootTimeline=new D,J=30,V=G.lazyRender=function(){var t,e=z.length;for(F={};--e>-1;)t=z[e],t&&t._lazy!==!1&&(t.render(t._lazy[0],t._lazy[1],!0),t._lazy=!1);z.length=0};H._startTime=a.time,K._startTime=a.frame,H._active=K._active=!0,setTimeout(V,1),R._updateRoot=I.render=function(){var t,e,i;if(z.length&&V(),H.render((a.time-H._startTime)*H._timeScale,!1,!1),K.render((a.frame-K._startTime)*K._timeScale,!1,!1),z.length&&V(),a.frame>=J){J=a.frame+(parseInt(I.autoSleep,10)||120);for(i in q){for(e=q[i].tweens,t=e.length;--t>-1;)e[t]._gc&&e.splice(t,1);0===e.length&&delete q[i]}if(i=H._first,(!i||i._paused)&&I.autoSleep&&!K._first&&1===a._listeners.tick.length){for(;i&&i._paused;)i=i._next;i||a.sleep()}}},a.addEventListener("tick",R._updateRoot);var W=function(t,e,i){var s,r,n=t._gsTweenID;if(q[n||(t._gsTweenID=n="t"+B++)]||(q[n]={target:t,tweens:[]}),e&&(s=q[n].tweens,s[r=s.length]=e,i))for(;--r>-1;)s[r]===e&&s.splice(r,1);return q[n].tweens},X=function(t,e,i,s){var r,n,a=t.vars.onOverwrite;return a&&(r=a(t,e,i,s)),a=I.onOverwrite,a&&(n=a(t,e,i,s)),r!==!1&&n!==!1},Y=function(t,e,i,s,r){var n,a,o,l;if(1===s||s>=4){for(l=r.length,n=0;l>n;n++)if((o=r[n])!==e)o._gc||o._kill(null,t,e)&&(a=!0);else if(5===s)break;return a}var h,u=e._startTime+_,f=[],c=0,m=0===e._duration;for(n=r.length;--n>-1;)(o=r[n])===e||o._gc||o._paused||(o._timeline!==e._timeline?(h=h||Z(e,0,m),0===Z(o,h,m)&&(f[c++]=o)):u>=o._startTime&&o._startTime+o.totalDuration()/o._timeScale>u&&((m||!o._initted)&&2e-10>=u-o._startTime||(f[c++]=o)));for(n=c;--n>-1;)if(o=f[n],2===s&&o._kill(i,t,e)&&(a=!0),2!==s||!o._firstPT&&o._initted){if(2!==s&&!X(o,e))continue;o._enabled(!1,!1)&&(a=!0)}return a},Z=function(t,e,i){for(var s=t._timeline,r=s._timeScale,n=t._startTime;s._timeline;){if(n+=s._startTime,r*=s._timeScale,s._paused)return-100;s=s._timeline}return n/=r,n>e?n-e:i&&n===e||!t._initted&&2*_>n-e?_:(n+=t.totalDuration()/t._timeScale/r)>e+_?0:n-e-_};n._init=function(){var t,e,i,s,r,n=this.vars,a=this._overwrittenProps,o=this._duration,l=!!n.immediateRender,h=n.ease;if(n.startAt){this._startAt&&(this._startAt.render(-1,!0),this._startAt.kill()),r={};for(s in n.startAt)r[s]=n.startAt[s];if(r.overwrite=!1,r.immediateRender=!0,r.lazy=l&&n.lazy!==!1,r.startAt=r.delay=null,this._startAt=I.to(this.target,0,r),l)if(this._time>0)this._startAt=null;else if(0!==o)return}else if(n.runBackwards&&0!==o)if(this._startAt)this._startAt.render(-1,!0),this._startAt.kill(),this._startAt=null;else{0!==this._time&&(l=!1),i={};for(s in n)M[s]&&"autoCSS"!==s||(i[s]=n[s]);if(i.overwrite=0,i.data="isFromStart",i.lazy=l&&n.lazy!==!1,i.immediateRender=l,this._startAt=I.to(this.target,0,i),l){if(0===this._time)return}else this._startAt._init(),this._startAt._enabled(!1),this.vars.immediateRender&&(this._startAt=null)}if(this._ease=h=h?h instanceof y?h:"function"==typeof h?new y(h,n.easeParams):w[h]||I.defaultEase:I.defaultEase,n.easeParams instanceof Array&&h.config&&(this._ease=h.config.apply(h,n.easeParams)),this._easeType=this._ease._type,this._easePower=this._ease._power,this._firstPT=null,this._targets)for(t=this._targets.length;--t>-1;)this._initProps(this._targets[t],this._propLookup[t]={},this._siblings[t],a?a[t]:null)&&(e=!0);else e=this._initProps(this.target,this._propLookup,this._siblings,a);if(e&&I._onPluginEvent("_onInitAllProps",this),a&&(this._firstPT||"function"!=typeof this.target&&this._enabled(!1,!1)),n.runBackwards)for(i=this._firstPT;i;)i.s+=i.c,i.c=-i.c,i=i._next;this._onUpdate=n.onUpdate,this._initted=!0},n._initProps=function(e,i,s,r){var n,a,o,l,h,_;if(null==e)return!1;F[e._gsTweenID]&&V(),this.vars.css||e.style&&e!==t&&e.nodeType&&Q.css&&this.vars.autoCSS!==!1&&O(this.vars,e);for(n in this.vars)if(_=this.vars[n],M[n])_&&(_ instanceof Array||_.push&&c(_))&&-1!==_.join("").indexOf("{self}")&&(this.vars[n]=_=this._swapSelfInParams(_,this));else if(Q[n]&&(l=new Q[n])._onInitTween(e,this.vars[n],this)){for(this._firstPT=h={_next:this._firstPT,t:l,p:"setRatio",s:0,c:1,f:1,n:n,pg:1,pr:l._priority},a=l._overwriteProps.length;--a>-1;)i[l._overwriteProps[a]]=this._firstPT;(l._priority||l._onInitAllProps)&&(o=!0),(l._onDisable||l._onEnable)&&(this._notifyPluginsOfEnabled=!0),h._next&&(h._next._prev=h)}else i[n]=j.call(this,e,n,"get",_,n,0,null,this.vars.stringFilter);return r&&this._kill(r,e)?this._initProps(e,i,s,r):this._overwrite>1&&this._firstPT&&s.length>1&&Y(e,this,i,this._overwrite,s)?(this._kill(i,e),this._initProps(e,i,s,r)):(this._firstPT&&(this.vars.lazy!==!1&&this._duration||this.vars.lazy&&!this._duration)&&(F[e._gsTweenID]=!0),o)},n.render=function(t,e,i){var s,r,n,a,o=this._time,l=this._duration,h=this._rawPrevTime;if(t>=l)this._totalTime=this._time=l,this.ratio=this._ease._calcEnd?this._ease.getRatio(1):1,this._reversed||(s=!0,r="onComplete",i=i||this._timeline.autoRemoveChildren),0===l&&(this._initted||!this.vars.lazy||i)&&(this._startTime===this._timeline._duration&&(t=0),(0===t||0>h||h===_&&"isPause"!==this.data)&&h!==t&&(i=!0,h>_&&(r="onReverseComplete")),this._rawPrevTime=a=!e||t||h===t?t:_);else if(1e-7>t)this._totalTime=this._time=0,this.ratio=this._ease._calcEnd?this._ease.getRatio(0):0,(0!==o||0===l&&h>0)&&(r="onReverseComplete",s=this._reversed),0>t&&(this._active=!1,0===l&&(this._initted||!this.vars.lazy||i)&&(h>=0&&(h!==_||"isPause"!==this.data)&&(i=!0),this._rawPrevTime=a=!e||t||h===t?t:_)),this._initted||(i=!0);else if(this._totalTime=this._time=t,this._easeType){var u=t/l,f=this._easeType,c=this._easePower;(1===f||3===f&&u>=.5)&&(u=1-u),3===f&&(u*=2),1===c?u*=u:2===c?u*=u*u:3===c?u*=u*u*u:4===c&&(u*=u*u*u*u),this.ratio=1===f?1-u:2===f?u:.5>t/l?u/2:1-u/2}else this.ratio=this._ease.getRatio(t/l);if(this._time!==o||i){if(!this._initted){if(this._init(),!this._initted||this._gc)return;if(!i&&this._firstPT&&(this.vars.lazy!==!1&&this._duration||this.vars.lazy&&!this._duration))return this._time=this._totalTime=o,this._rawPrevTime=h,z.push(this),this._lazy=[t,e],void 0;this._time&&!s?this.ratio=this._ease.getRatio(this._time/l):s&&this._ease._calcEnd&&(this.ratio=this._ease.getRatio(0===this._time?0:1))}for(this._lazy!==!1&&(this._lazy=!1),this._active||!this._paused&&this._time!==o&&t>=0&&(this._active=!0),0===o&&(this._startAt&&(t>=0?this._startAt.render(t,e,i):r||(r="_dummyGS")),this.vars.onStart&&(0!==this._time||0===l)&&(e||this._callback("onStart"))),n=this._firstPT;n;)n.f?n.t[n.p](n.c*this.ratio+n.s):n.t[n.p]=n.c*this.ratio+n.s,n=n._next;this._onUpdate&&(0>t&&this._startAt&&t!==-1e-4&&this._startAt.render(t,e,i),e||(this._time!==o||s)&&this._callback("onUpdate")),r&&(!this._gc||i)&&(0>t&&this._startAt&&!this._onUpdate&&t!==-1e-4&&this._startAt.render(t,e,i),s&&(this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!e&&this.vars[r]&&this._callback(r),0===l&&this._rawPrevTime===_&&a!==_&&(this._rawPrevTime=0))}},n._kill=function(t,e,i){if("all"===t&&(t=null),null==t&&(null==e||e===this.target))return this._lazy=!1,this._enabled(!1,!1);e="string"!=typeof e?e||this._targets||this.target:I.selector(e)||e;var s,r,n,a,o,l,h,_,u,f=i&&this._time&&i._startTime===this._startTime&&this._timeline===i._timeline;if((c(e)||E(e))&&"number"!=typeof e[0])for(s=e.length;--s>-1;)this._kill(t,e[s],i)&&(l=!0);else{if(this._targets){for(s=this._targets.length;--s>-1;)if(e===this._targets[s]){o=this._propLookup[s]||{},this._overwrittenProps=this._overwrittenProps||[],r=this._overwrittenProps[s]=t?this._overwrittenProps[s]||{}:"all";break}}else{if(e!==this.target)return!1;o=this._propLookup,r=this._overwrittenProps=t?this._overwrittenProps||{}:"all"}if(o){if(h=t||o,_=t!==r&&"all"!==r&&t!==o&&("object"!=typeof t||!t._tempKill),i&&(I.onOverwrite||this.vars.onOverwrite)){for(n in h)o[n]&&(u||(u=[]),u.push(n));if((u||!t)&&!X(this,i,e,u))return!1}for(n in h)(a=o[n])&&(f&&(a.f?a.t[a.p](a.s):a.t[a.p]=a.s,l=!0),a.pg&&a.t._kill(h)&&(l=!0),a.pg&&0!==a.t._overwriteProps.length||(a._prev?a._prev._next=a._next:a===this._firstPT&&(this._firstPT=a._next),a._next&&(a._next._prev=a._prev),a._next=a._prev=null),delete o[n]),_&&(r[n]=1);!this._firstPT&&this._initted&&this._enabled(!1,!1)}}return l},n.invalidate=function(){return this._notifyPluginsOfEnabled&&I._onPluginEvent("_onDisable",this),this._firstPT=this._overwrittenProps=this._startAt=this._onUpdate=null,this._notifyPluginsOfEnabled=this._active=this._lazy=!1,this._propLookup=this._targets?{}:[],R.prototype.invalidate.call(this),this.vars.immediateRender&&(this._time=-_,this.render(-this._delay)),this},n._enabled=function(t,e){if(o||a.wake(),t&&this._gc){var i,s=this._targets;if(s)for(i=s.length;--i>-1;)this._siblings[i]=W(s[i],this,!0);else this._siblings=W(this.target,this,!0)}return R.prototype._enabled.call(this,t,e),this._notifyPluginsOfEnabled&&this._firstPT?I._onPluginEvent(t?"_onEnable":"_onDisable",this):!1},I.to=function(t,e,i){return new I(t,e,i)},I.from=function(t,e,i){return i.runBackwards=!0,i.immediateRender=0!=i.immediateRender,new I(t,e,i)},I.fromTo=function(t,e,i,s){return s.startAt=i,s.immediateRender=0!=s.immediateRender&&0!=i.immediateRender,new I(t,e,s)},I.delayedCall=function(t,e,i,s,r){return new I(e,0,{delay:t,onComplete:e,onCompleteParams:i,callbackScope:s,onReverseComplete:e,onReverseCompleteParams:i,immediateRender:!1,lazy:!1,useFrames:r,overwrite:0})},I.set=function(t,e){return new I(t,0,e)},I.getTweensOf=function(t,e){if(null==t)return[];t="string"!=typeof t?t:I.selector(t)||t;var i,s,r,n;if((c(t)||E(t))&&"number"!=typeof t[0]){for(i=t.length,s=[];--i>-1;)s=s.concat(I.getTweensOf(t[i],e));for(i=s.length;--i>-1;)for(n=s[i],r=i;--r>-1;)n===s[r]&&s.splice(i,1)}else for(s=W(t).concat(),i=s.length;--i>-1;)(s[i]._gc||e&&!s[i].isActive())&&s.splice(i,1);return s},I.killTweensOf=I.killDelayedCallsTo=function(t,e,i){"object"==typeof e&&(i=e,e=!1);for(var s=I.getTweensOf(t,e),r=s.length;--r>-1;)s[r]._kill(i,t)};var te=v("plugins.TweenPlugin",function(t,e){this._overwriteProps=(t||"").split(","),this._propName=this._overwriteProps[0],this._priority=e||0,this._super=te.prototype},!0);if(n=te.prototype,te.version="1.18.0",te.API=2,n._firstPT=null,n._addTween=j,n.setRatio=N,n._kill=function(t){var e,i=this._overwriteProps,s=this._firstPT;if(null!=t[this._propName])this._overwriteProps=[];else for(e=i.length;--e>-1;)null!=t[i[e]]&&i.splice(e,1);for(;s;)null!=t[s.n]&&(s._next&&(s._next._prev=s._prev),s._prev?(s._prev._next=s._next,s._prev=null):this._firstPT===s&&(this._firstPT=s._next)),s=s._next;return!1},n._roundProps=function(t,e){for(var i=this._firstPT;i;)(t[this._propName]||null!=i.n&&t[i.n.split(this._propName+"_").join("")])&&(i.r=e),i=i._next},I._onPluginEvent=function(t,e){var i,s,r,n,a,o=e._firstPT;if("_onInitAllProps"===t){for(;o;){for(a=o._next,s=r;s&&s.pr>o.pr;)s=s._next;(o._prev=s?s._prev:n)?o._prev._next=o:r=o,(o._next=s)?s._prev=o:n=o,o=a}o=e._firstPT=r}for(;o;)o.pg&&"function"==typeof o.t[t]&&o.t[t]()&&(i=!0),o=o._next;return i},te.activate=function(t){for(var e=t.length;--e>-1;)t[e].API===te.API&&(Q[(new t[e])._propName]=t[e]);return!0},d.plugin=function(t){if(!(t&&t.propName&&t.init&&t.API))throw"illegal plugin definition.";var e,i=t.propName,s=t.priority||0,r=t.overwriteProps,n={init:"_onInitTween",set:"setRatio",kill:"_kill",round:"_roundProps",initAll:"_onInitAllProps"},a=v("plugins."+i.charAt(0).toUpperCase()+i.substr(1)+"Plugin",function(){te.call(this,i,s),this._overwriteProps=r||[]},t.global===!0),o=a.prototype=new te(i);o.constructor=a,a.API=t.API;for(e in n)"function"==typeof t[e]&&(o[n[e]]=t[e]);return a.version=t.version,te.activate([a]),a},s=t._gsQueue){for(r=0;s.length>r;r++)s[r]();for(n in m)m[n].func||t.console.log("GSAP encountered missing dependency: com.greensock."+n)}o=!1}})("undefined"!=typeof module&&module.exports&&"undefined"!=typeof global?global:this||window,"TweenLite");
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9qYXZhc2NyaXB0L2xpYnMvVHdlZW5NYXgvVHdlZW5MaXRlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVkVSU0lPTjogMS4xOC4wXG4gKiBEQVRFOiAyMDE1LTA5LTAzXG4gKiBVUERBVEVTIEFORCBET0NTIEFUOiBodHRwOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwOC0yMDE1LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIHdvcmsgaXMgc3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cDovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBzb2Z0d2FyZSBhZ3JlZW1lbnQgdGhhdCB3YXMgaXNzdWVkIHdpdGggeW91ciBtZW1iZXJzaGlwLlxuICogXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiAqL1xuKGZ1bmN0aW9uKHQsZSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9dC5HcmVlblNvY2tHbG9iYWxzPXQuR3JlZW5Tb2NrR2xvYmFsc3x8dDtpZighaS5Ud2VlbkxpdGUpe3ZhciBzLHIsbixhLG8sbD1mdW5jdGlvbih0KXt2YXIgZSxzPXQuc3BsaXQoXCIuXCIpLHI9aTtmb3IoZT0wO3MubGVuZ3RoPmU7ZSsrKXJbc1tlXV09cj1yW3NbZV1dfHx7fTtyZXR1cm4gcn0saD1sKFwiY29tLmdyZWVuc29ja1wiKSxfPTFlLTEwLHU9ZnVuY3Rpb24odCl7dmFyIGUsaT1bXSxzPXQubGVuZ3RoO2ZvcihlPTA7ZSE9PXM7aS5wdXNoKHRbZSsrXSkpO3JldHVybiBpfSxmPWZ1bmN0aW9uKCl7fSxjPWZ1bmN0aW9uKCl7dmFyIHQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxlPXQuY2FsbChbXSk7cmV0dXJuIGZ1bmN0aW9uKGkpe3JldHVybiBudWxsIT1pJiYoaSBpbnN0YW5jZW9mIEFycmF5fHxcIm9iamVjdFwiPT10eXBlb2YgaSYmISFpLnB1c2gmJnQuY2FsbChpKT09PWUpfX0oKSxtPXt9LHA9ZnVuY3Rpb24ocyxyLG4sYSl7dGhpcy5zYz1tW3NdP21bc10uc2M6W10sbVtzXT10aGlzLHRoaXMuZ3NDbGFzcz1udWxsLHRoaXMuZnVuYz1uO3ZhciBvPVtdO3RoaXMuY2hlY2s9ZnVuY3Rpb24oaCl7Zm9yKHZhciBfLHUsZixjLGQsdj1yLmxlbmd0aCxnPXY7LS12Pi0xOykoXz1tW3Jbdl1dfHxuZXcgcChyW3ZdLFtdKSkuZ3NDbGFzcz8ob1t2XT1fLmdzQ2xhc3MsZy0tKTpoJiZfLnNjLnB1c2godGhpcyk7aWYoMD09PWcmJm4pZm9yKHU9KFwiY29tLmdyZWVuc29jay5cIitzKS5zcGxpdChcIi5cIiksZj11LnBvcCgpLGM9bCh1LmpvaW4oXCIuXCIpKVtmXT10aGlzLmdzQ2xhc3M9bi5hcHBseShuLG8pLGEmJihpW2ZdPWMsZD1cInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cywhZCYmXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZSgodC5HcmVlblNvY2tBTURQYXRoP3QuR3JlZW5Tb2NrQU1EUGF0aCtcIi9cIjpcIlwiKStzLnNwbGl0KFwiLlwiKS5wb3AoKSxbXSxmdW5jdGlvbigpe3JldHVybiBjfSk6cz09PWUmJmQmJihtb2R1bGUuZXhwb3J0cz1jKSksdj0wO3RoaXMuc2MubGVuZ3RoPnY7disrKXRoaXMuc2Nbdl0uY2hlY2soKX0sdGhpcy5jaGVjayghMCl9LGQ9dC5fZ3NEZWZpbmU9ZnVuY3Rpb24odCxlLGkscyl7cmV0dXJuIG5ldyBwKHQsZSxpLHMpfSx2PWguX2NsYXNzPWZ1bmN0aW9uKHQsZSxpKXtyZXR1cm4gZT1lfHxmdW5jdGlvbigpe30sZCh0LFtdLGZ1bmN0aW9uKCl7cmV0dXJuIGV9LGkpLGV9O2QuZ2xvYmFscz1pO3ZhciBnPVswLDAsMSwxXSxUPVtdLHk9dihcImVhc2luZy5FYXNlXCIsZnVuY3Rpb24odCxlLGkscyl7dGhpcy5fZnVuYz10LHRoaXMuX3R5cGU9aXx8MCx0aGlzLl9wb3dlcj1zfHwwLHRoaXMuX3BhcmFtcz1lP2cuY29uY2F0KGUpOmd9LCEwKSx3PXkubWFwPXt9LFA9eS5yZWdpc3Rlcj1mdW5jdGlvbih0LGUsaSxzKXtmb3IodmFyIHIsbixhLG8sbD1lLnNwbGl0KFwiLFwiKSxfPWwubGVuZ3RoLHU9KGl8fFwiZWFzZUluLGVhc2VPdXQsZWFzZUluT3V0XCIpLnNwbGl0KFwiLFwiKTstLV8+LTE7KWZvcihuPWxbX10scj1zP3YoXCJlYXNpbmcuXCIrbixudWxsLCEwKTpoLmVhc2luZ1tuXXx8e30sYT11Lmxlbmd0aDstLWE+LTE7KW89dVthXSx3W24rXCIuXCIrb109d1tvK25dPXJbb109dC5nZXRSYXRpbz90OnRbb118fG5ldyB0fTtmb3Iobj15LnByb3RvdHlwZSxuLl9jYWxjRW5kPSExLG4uZ2V0UmF0aW89ZnVuY3Rpb24odCl7aWYodGhpcy5fZnVuYylyZXR1cm4gdGhpcy5fcGFyYW1zWzBdPXQsdGhpcy5fZnVuYy5hcHBseShudWxsLHRoaXMuX3BhcmFtcyk7dmFyIGU9dGhpcy5fdHlwZSxpPXRoaXMuX3Bvd2VyLHM9MT09PWU/MS10OjI9PT1lP3Q6LjU+dD8yKnQ6MiooMS10KTtyZXR1cm4gMT09PWk/cyo9czoyPT09aT9zKj1zKnM6Mz09PWk/cyo9cypzKnM6ND09PWkmJihzKj1zKnMqcypzKSwxPT09ZT8xLXM6Mj09PWU/czouNT50P3MvMjoxLXMvMn0scz1bXCJMaW5lYXJcIixcIlF1YWRcIixcIkN1YmljXCIsXCJRdWFydFwiLFwiUXVpbnQsU3Ryb25nXCJdLHI9cy5sZW5ndGg7LS1yPi0xOyluPXNbcl0rXCIsUG93ZXJcIityLFAobmV3IHkobnVsbCxudWxsLDEsciksbixcImVhc2VPdXRcIiwhMCksUChuZXcgeShudWxsLG51bGwsMixyKSxuLFwiZWFzZUluXCIrKDA9PT1yP1wiLGVhc2VOb25lXCI6XCJcIikpLFAobmV3IHkobnVsbCxudWxsLDMsciksbixcImVhc2VJbk91dFwiKTt3LmxpbmVhcj1oLmVhc2luZy5MaW5lYXIuZWFzZUluLHcuc3dpbmc9aC5lYXNpbmcuUXVhZC5lYXNlSW5PdXQ7dmFyIGI9dihcImV2ZW50cy5FdmVudERpc3BhdGNoZXJcIixmdW5jdGlvbih0KXt0aGlzLl9saXN0ZW5lcnM9e30sdGhpcy5fZXZlbnRUYXJnZXQ9dHx8dGhpc30pO249Yi5wcm90b3R5cGUsbi5hZGRFdmVudExpc3RlbmVyPWZ1bmN0aW9uKHQsZSxpLHMscil7cj1yfHwwO3ZhciBuLGwsaD10aGlzLl9saXN0ZW5lcnNbdF0sXz0wO2ZvcihudWxsPT1oJiYodGhpcy5fbGlzdGVuZXJzW3RdPWg9W10pLGw9aC5sZW5ndGg7LS1sPi0xOyluPWhbbF0sbi5jPT09ZSYmbi5zPT09aT9oLnNwbGljZShsLDEpOjA9PT1fJiZyPm4ucHImJihfPWwrMSk7aC5zcGxpY2UoXywwLHtjOmUsczppLHVwOnMscHI6cn0pLHRoaXMhPT1hfHxvfHxhLndha2UoKX0sbi5yZW1vdmVFdmVudExpc3RlbmVyPWZ1bmN0aW9uKHQsZSl7dmFyIGkscz10aGlzLl9saXN0ZW5lcnNbdF07aWYocylmb3IoaT1zLmxlbmd0aDstLWk+LTE7KWlmKHNbaV0uYz09PWUpcmV0dXJuIHMuc3BsaWNlKGksMSksdm9pZCAwfSxuLmRpc3BhdGNoRXZlbnQ9ZnVuY3Rpb24odCl7dmFyIGUsaSxzLHI9dGhpcy5fbGlzdGVuZXJzW3RdO2lmKHIpZm9yKGU9ci5sZW5ndGgsaT10aGlzLl9ldmVudFRhcmdldDstLWU+LTE7KXM9cltlXSxzJiYocy51cD9zLmMuY2FsbChzLnN8fGkse3R5cGU6dCx0YXJnZXQ6aX0pOnMuYy5jYWxsKHMuc3x8aSkpfTt2YXIgaz10LnJlcXVlc3RBbmltYXRpb25GcmFtZSxBPXQuY2FuY2VsQW5pbWF0aW9uRnJhbWUsUz1EYXRlLm5vd3x8ZnVuY3Rpb24oKXtyZXR1cm4obmV3IERhdGUpLmdldFRpbWUoKX0seD1TKCk7Zm9yKHM9W1wibXNcIixcIm1velwiLFwid2Via2l0XCIsXCJvXCJdLHI9cy5sZW5ndGg7LS1yPi0xJiYhazspaz10W3Nbcl0rXCJSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl0sQT10W3Nbcl0rXCJDYW5jZWxBbmltYXRpb25GcmFtZVwiXXx8dFtzW3JdK1wiQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdO3YoXCJUaWNrZXJcIixmdW5jdGlvbih0LGUpe3ZhciBpLHMscixuLGwsaD10aGlzLHU9UygpLGM9ZSE9PSExJiZrLG09NTAwLHA9MzMsZD1cInRpY2tcIix2PWZ1bmN0aW9uKHQpe3ZhciBlLGEsbz1TKCkteDtvPm0mJih1Kz1vLXApLHgrPW8saC50aW1lPSh4LXUpLzFlMyxlPWgudGltZS1sLCghaXx8ZT4wfHx0PT09ITApJiYoaC5mcmFtZSsrLGwrPWUrKGU+PW4/LjAwNDpuLWUpLGE9ITApLHQhPT0hMCYmKHI9cyh2KSksYSYmaC5kaXNwYXRjaEV2ZW50KGQpfTtiLmNhbGwoaCksaC50aW1lPWguZnJhbWU9MCxoLnRpY2s9ZnVuY3Rpb24oKXt2KCEwKX0saC5sYWdTbW9vdGhpbmc9ZnVuY3Rpb24odCxlKXttPXR8fDEvXyxwPU1hdGgubWluKGUsbSwwKX0saC5zbGVlcD1mdW5jdGlvbigpe251bGwhPXImJihjJiZBP0Eocik6Y2xlYXJUaW1lb3V0KHIpLHM9ZixyPW51bGwsaD09PWEmJihvPSExKSl9LGgud2FrZT1mdW5jdGlvbigpe251bGwhPT1yP2guc2xlZXAoKTpoLmZyYW1lPjEwJiYoeD1TKCktbSs1KSxzPTA9PT1pP2Y6YyYmaz9rOmZ1bmN0aW9uKHQpe3JldHVybiBzZXRUaW1lb3V0KHQsMHwxZTMqKGwtaC50aW1lKSsxKX0saD09PWEmJihvPSEwKSx2KDIpfSxoLmZwcz1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oaT10LG49MS8oaXx8NjApLGw9dGhpcy50aW1lK24saC53YWtlKCksdm9pZCAwKTppfSxoLnVzZVJBRj1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oaC5zbGVlcCgpLGM9dCxoLmZwcyhpKSx2b2lkIDApOmN9LGguZnBzKHQpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtjJiY1PmguZnJhbWUmJmgudXNlUkFGKCExKX0sMTUwMCl9KSxuPWguVGlja2VyLnByb3RvdHlwZT1uZXcgaC5ldmVudHMuRXZlbnREaXNwYXRjaGVyLG4uY29uc3RydWN0b3I9aC5UaWNrZXI7dmFyIFI9dihcImNvcmUuQW5pbWF0aW9uXCIsZnVuY3Rpb24odCxlKXtpZih0aGlzLnZhcnM9ZT1lfHx7fSx0aGlzLl9kdXJhdGlvbj10aGlzLl90b3RhbER1cmF0aW9uPXR8fDAsdGhpcy5fZGVsYXk9TnVtYmVyKGUuZGVsYXkpfHwwLHRoaXMuX3RpbWVTY2FsZT0xLHRoaXMuX2FjdGl2ZT1lLmltbWVkaWF0ZVJlbmRlcj09PSEwLHRoaXMuZGF0YT1lLmRhdGEsdGhpcy5fcmV2ZXJzZWQ9ZS5yZXZlcnNlZD09PSEwLEgpe298fGEud2FrZSgpO3ZhciBpPXRoaXMudmFycy51c2VGcmFtZXM/SzpIO2kuYWRkKHRoaXMsaS5fdGltZSksdGhpcy52YXJzLnBhdXNlZCYmdGhpcy5wYXVzZWQoITApfX0pO2E9Ui50aWNrZXI9bmV3IGguVGlja2VyLG49Ui5wcm90b3R5cGUsbi5fZGlydHk9bi5fZ2M9bi5faW5pdHRlZD1uLl9wYXVzZWQ9ITEsbi5fdG90YWxUaW1lPW4uX3RpbWU9MCxuLl9yYXdQcmV2VGltZT0tMSxuLl9uZXh0PW4uX2xhc3Q9bi5fb25VcGRhdGU9bi5fdGltZWxpbmU9bi50aW1lbGluZT1udWxsLG4uX3BhdXNlZD0hMTt2YXIgQz1mdW5jdGlvbigpe28mJlMoKS14PjJlMyYmYS53YWtlKCksc2V0VGltZW91dChDLDJlMyl9O0MoKSxuLnBsYXk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbCE9dCYmdGhpcy5zZWVrKHQsZSksdGhpcy5yZXZlcnNlZCghMSkucGF1c2VkKCExKX0sbi5wYXVzZT1mdW5jdGlvbih0LGUpe3JldHVybiBudWxsIT10JiZ0aGlzLnNlZWsodCxlKSx0aGlzLnBhdXNlZCghMCl9LG4ucmVzdW1lPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG51bGwhPXQmJnRoaXMuc2Vlayh0LGUpLHRoaXMucGF1c2VkKCExKX0sbi5zZWVrPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudG90YWxUaW1lKE51bWJlcih0KSxlIT09ITEpfSxuLnJlc3RhcnQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5yZXZlcnNlZCghMSkucGF1c2VkKCExKS50b3RhbFRpbWUodD8tdGhpcy5fZGVsYXk6MCxlIT09ITEsITApfSxuLnJldmVyc2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbCE9dCYmdGhpcy5zZWVrKHR8fHRoaXMudG90YWxEdXJhdGlvbigpLGUpLHRoaXMucmV2ZXJzZWQoITApLnBhdXNlZCghMSl9LG4ucmVuZGVyPWZ1bmN0aW9uKCl7fSxuLmludmFsaWRhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdGltZT10aGlzLl90b3RhbFRpbWU9MCx0aGlzLl9pbml0dGVkPXRoaXMuX2djPSExLHRoaXMuX3Jhd1ByZXZUaW1lPS0xLCh0aGlzLl9nY3x8IXRoaXMudGltZWxpbmUpJiZ0aGlzLl9lbmFibGVkKCEwKSx0aGlzfSxuLmlzQWN0aXZlPWZ1bmN0aW9uKCl7dmFyIHQsZT10aGlzLl90aW1lbGluZSxpPXRoaXMuX3N0YXJ0VGltZTtyZXR1cm4hZXx8IXRoaXMuX2djJiYhdGhpcy5fcGF1c2VkJiZlLmlzQWN0aXZlKCkmJih0PWUucmF3VGltZSgpKT49aSYmaSt0aGlzLnRvdGFsRHVyYXRpb24oKS90aGlzLl90aW1lU2NhbGU+dH0sbi5fZW5hYmxlZD1mdW5jdGlvbih0LGUpe3JldHVybiBvfHxhLndha2UoKSx0aGlzLl9nYz0hdCx0aGlzLl9hY3RpdmU9dGhpcy5pc0FjdGl2ZSgpLGUhPT0hMCYmKHQmJiF0aGlzLnRpbWVsaW5lP3RoaXMuX3RpbWVsaW5lLmFkZCh0aGlzLHRoaXMuX3N0YXJ0VGltZS10aGlzLl9kZWxheSk6IXQmJnRoaXMudGltZWxpbmUmJnRoaXMuX3RpbWVsaW5lLl9yZW1vdmUodGhpcywhMCkpLCExfSxuLl9raWxsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2VuYWJsZWQoITEsITEpfSxuLmtpbGw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fa2lsbCh0LGUpLHRoaXN9LG4uX3VuY2FjaGU9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQ/dGhpczp0aGlzLnRpbWVsaW5lO2U7KWUuX2RpcnR5PSEwLGU9ZS50aW1lbGluZTtyZXR1cm4gdGhpc30sbi5fc3dhcFNlbGZJblBhcmFtcz1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5sZW5ndGgsaT10LmNvbmNhdCgpOy0tZT4tMTspXCJ7c2VsZn1cIj09PXRbZV0mJihpW2VdPXRoaXMpO3JldHVybiBpfSxuLl9jYWxsYmFjaz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLnZhcnM7ZVt0XS5hcHBseShlW3QrXCJTY29wZVwiXXx8ZS5jYWxsYmFja1Njb3BlfHx0aGlzLGVbdCtcIlBhcmFtc1wiXXx8VCl9LG4uZXZlbnRDYWxsYmFjaz1mdW5jdGlvbih0LGUsaSxzKXtpZihcIm9uXCI9PT0odHx8XCJcIikuc3Vic3RyKDAsMikpe3ZhciByPXRoaXMudmFycztpZigxPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gclt0XTtudWxsPT1lP2RlbGV0ZSByW3RdOihyW3RdPWUsclt0K1wiUGFyYW1zXCJdPWMoaSkmJi0xIT09aS5qb2luKFwiXCIpLmluZGV4T2YoXCJ7c2VsZn1cIik/dGhpcy5fc3dhcFNlbGZJblBhcmFtcyhpKTppLHJbdCtcIlNjb3BlXCJdPXMpLFwib25VcGRhdGVcIj09PXQmJih0aGlzLl9vblVwZGF0ZT1lKX1yZXR1cm4gdGhpc30sbi5kZWxheT1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcmJnRoaXMuc3RhcnRUaW1lKHRoaXMuX3N0YXJ0VGltZSt0LXRoaXMuX2RlbGF5KSx0aGlzLl9kZWxheT10LHRoaXMpOnRoaXMuX2RlbGF5fSxuLmR1cmF0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh0aGlzLl9kdXJhdGlvbj10aGlzLl90b3RhbER1cmF0aW9uPXQsdGhpcy5fdW5jYWNoZSghMCksdGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcmJnRoaXMuX3RpbWU+MCYmdGhpcy5fdGltZTx0aGlzLl9kdXJhdGlvbiYmMCE9PXQmJnRoaXMudG90YWxUaW1lKHRoaXMuX3RvdGFsVGltZSoodC90aGlzLl9kdXJhdGlvbiksITApLHRoaXMpOih0aGlzLl9kaXJ0eT0hMSx0aGlzLl9kdXJhdGlvbil9LG4udG90YWxEdXJhdGlvbj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fZGlydHk9ITEsYXJndW1lbnRzLmxlbmd0aD90aGlzLmR1cmF0aW9uKHQpOnRoaXMuX3RvdGFsRHVyYXRpb259LG4udGltZT1mdW5jdGlvbih0LGUpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh0aGlzLl9kaXJ0eSYmdGhpcy50b3RhbER1cmF0aW9uKCksdGhpcy50b3RhbFRpbWUodD50aGlzLl9kdXJhdGlvbj90aGlzLl9kdXJhdGlvbjp0LGUpKTp0aGlzLl90aW1lfSxuLnRvdGFsVGltZT1mdW5jdGlvbih0LGUsaSl7aWYob3x8YS53YWtlKCksIWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuX3RvdGFsVGltZTtpZih0aGlzLl90aW1lbGluZSl7aWYoMD50JiYhaSYmKHQrPXRoaXMudG90YWxEdXJhdGlvbigpKSx0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZyl7dGhpcy5fZGlydHkmJnRoaXMudG90YWxEdXJhdGlvbigpO3ZhciBzPXRoaXMuX3RvdGFsRHVyYXRpb24scj10aGlzLl90aW1lbGluZTtpZih0PnMmJiFpJiYodD1zKSx0aGlzLl9zdGFydFRpbWU9KHRoaXMuX3BhdXNlZD90aGlzLl9wYXVzZVRpbWU6ci5fdGltZSktKHRoaXMuX3JldmVyc2VkP3MtdDp0KS90aGlzLl90aW1lU2NhbGUsci5fZGlydHl8fHRoaXMuX3VuY2FjaGUoITEpLHIuX3RpbWVsaW5lKWZvcig7ci5fdGltZWxpbmU7KXIuX3RpbWVsaW5lLl90aW1lIT09KHIuX3N0YXJ0VGltZStyLl90b3RhbFRpbWUpL3IuX3RpbWVTY2FsZSYmci50b3RhbFRpbWUoci5fdG90YWxUaW1lLCEwKSxyPXIuX3RpbWVsaW5lfXRoaXMuX2djJiZ0aGlzLl9lbmFibGVkKCEwLCExKSwodGhpcy5fdG90YWxUaW1lIT09dHx8MD09PXRoaXMuX2R1cmF0aW9uKSYmKHoubGVuZ3RoJiZWKCksdGhpcy5yZW5kZXIodCxlLCExKSx6Lmxlbmd0aCYmVigpKX1yZXR1cm4gdGhpc30sbi5wcm9ncmVzcz1uLnRvdGFsUHJvZ3Jlc3M9ZnVuY3Rpb24odCxlKXt2YXIgaT10aGlzLmR1cmF0aW9uKCk7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/dGhpcy50b3RhbFRpbWUoaSp0LGUpOmk/dGhpcy5fdGltZS9pOnRoaXMucmF0aW99LG4uc3RhcnRUaW1lPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh0IT09dGhpcy5fc3RhcnRUaW1lJiYodGhpcy5fc3RhcnRUaW1lPXQsdGhpcy50aW1lbGluZSYmdGhpcy50aW1lbGluZS5fc29ydENoaWxkcmVuJiZ0aGlzLnRpbWVsaW5lLmFkZCh0aGlzLHQtdGhpcy5fZGVsYXkpKSx0aGlzKTp0aGlzLl9zdGFydFRpbWV9LG4uZW5kVGltZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fc3RhcnRUaW1lKygwIT10P3RoaXMudG90YWxEdXJhdGlvbigpOnRoaXMuZHVyYXRpb24oKSkvdGhpcy5fdGltZVNjYWxlfSxuLnRpbWVTY2FsZT1mdW5jdGlvbih0KXtpZighYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5fdGltZVNjYWxlO2lmKHQ9dHx8Xyx0aGlzLl90aW1lbGluZSYmdGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpe3ZhciBlPXRoaXMuX3BhdXNlVGltZSxpPWV8fDA9PT1lP2U6dGhpcy5fdGltZWxpbmUudG90YWxUaW1lKCk7dGhpcy5fc3RhcnRUaW1lPWktKGktdGhpcy5fc3RhcnRUaW1lKSp0aGlzLl90aW1lU2NhbGUvdH1yZXR1cm4gdGhpcy5fdGltZVNjYWxlPXQsdGhpcy5fdW5jYWNoZSghMSl9LG4ucmV2ZXJzZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHQhPXRoaXMuX3JldmVyc2VkJiYodGhpcy5fcmV2ZXJzZWQ9dCx0aGlzLnRvdGFsVGltZSh0aGlzLl90aW1lbGluZSYmIXRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nP3RoaXMudG90YWxEdXJhdGlvbigpLXRoaXMuX3RvdGFsVGltZTp0aGlzLl90b3RhbFRpbWUsITApKSx0aGlzKTp0aGlzLl9yZXZlcnNlZH0sbi5wYXVzZWQ9ZnVuY3Rpb24odCl7aWYoIWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuX3BhdXNlZDt2YXIgZSxpLHM9dGhpcy5fdGltZWxpbmU7cmV0dXJuIHQhPXRoaXMuX3BhdXNlZCYmcyYmKG98fHR8fGEud2FrZSgpLGU9cy5yYXdUaW1lKCksaT1lLXRoaXMuX3BhdXNlVGltZSwhdCYmcy5zbW9vdGhDaGlsZFRpbWluZyYmKHRoaXMuX3N0YXJ0VGltZSs9aSx0aGlzLl91bmNhY2hlKCExKSksdGhpcy5fcGF1c2VUaW1lPXQ/ZTpudWxsLHRoaXMuX3BhdXNlZD10LHRoaXMuX2FjdGl2ZT10aGlzLmlzQWN0aXZlKCksIXQmJjAhPT1pJiZ0aGlzLl9pbml0dGVkJiZ0aGlzLmR1cmF0aW9uKCkmJihlPXMuc21vb3RoQ2hpbGRUaW1pbmc/dGhpcy5fdG90YWxUaW1lOihlLXRoaXMuX3N0YXJ0VGltZSkvdGhpcy5fdGltZVNjYWxlLHRoaXMucmVuZGVyKGUsZT09PXRoaXMuX3RvdGFsVGltZSwhMCkpKSx0aGlzLl9nYyYmIXQmJnRoaXMuX2VuYWJsZWQoITAsITEpLHRoaXN9O3ZhciBEPXYoXCJjb3JlLlNpbXBsZVRpbWVsaW5lXCIsZnVuY3Rpb24odCl7Ui5jYWxsKHRoaXMsMCx0KSx0aGlzLmF1dG9SZW1vdmVDaGlsZHJlbj10aGlzLnNtb290aENoaWxkVGltaW5nPSEwfSk7bj1ELnByb3RvdHlwZT1uZXcgUixuLmNvbnN0cnVjdG9yPUQsbi5raWxsKCkuX2djPSExLG4uX2ZpcnN0PW4uX2xhc3Q9bi5fcmVjZW50PW51bGwsbi5fc29ydENoaWxkcmVuPSExLG4uYWRkPW4uaW5zZXJ0PWZ1bmN0aW9uKHQsZSl7dmFyIGkscztpZih0Ll9zdGFydFRpbWU9TnVtYmVyKGV8fDApK3QuX2RlbGF5LHQuX3BhdXNlZCYmdGhpcyE9PXQuX3RpbWVsaW5lJiYodC5fcGF1c2VUaW1lPXQuX3N0YXJ0VGltZSsodGhpcy5yYXdUaW1lKCktdC5fc3RhcnRUaW1lKS90Ll90aW1lU2NhbGUpLHQudGltZWxpbmUmJnQudGltZWxpbmUuX3JlbW92ZSh0LCEwKSx0LnRpbWVsaW5lPXQuX3RpbWVsaW5lPXRoaXMsdC5fZ2MmJnQuX2VuYWJsZWQoITAsITApLGk9dGhpcy5fbGFzdCx0aGlzLl9zb3J0Q2hpbGRyZW4pZm9yKHM9dC5fc3RhcnRUaW1lO2kmJmkuX3N0YXJ0VGltZT5zOylpPWkuX3ByZXY7cmV0dXJuIGk/KHQuX25leHQ9aS5fbmV4dCxpLl9uZXh0PXQpOih0Ll9uZXh0PXRoaXMuX2ZpcnN0LHRoaXMuX2ZpcnN0PXQpLHQuX25leHQ/dC5fbmV4dC5fcHJldj10OnRoaXMuX2xhc3Q9dCx0Ll9wcmV2PWksdGhpcy5fcmVjZW50PXQsdGhpcy5fdGltZWxpbmUmJnRoaXMuX3VuY2FjaGUoITApLHRoaXN9LG4uX3JlbW92ZT1mdW5jdGlvbih0LGUpe3JldHVybiB0LnRpbWVsaW5lPT09dGhpcyYmKGV8fHQuX2VuYWJsZWQoITEsITApLHQuX3ByZXY/dC5fcHJldi5fbmV4dD10Ll9uZXh0OnRoaXMuX2ZpcnN0PT09dCYmKHRoaXMuX2ZpcnN0PXQuX25leHQpLHQuX25leHQ/dC5fbmV4dC5fcHJldj10Ll9wcmV2OnRoaXMuX2xhc3Q9PT10JiYodGhpcy5fbGFzdD10Ll9wcmV2KSx0Ll9uZXh0PXQuX3ByZXY9dC50aW1lbGluZT1udWxsLHQ9PT10aGlzLl9yZWNlbnQmJih0aGlzLl9yZWNlbnQ9dGhpcy5fbGFzdCksdGhpcy5fdGltZWxpbmUmJnRoaXMuX3VuY2FjaGUoITApKSx0aGlzfSxuLnJlbmRlcj1mdW5jdGlvbih0LGUsaSl7dmFyIHMscj10aGlzLl9maXJzdDtmb3IodGhpcy5fdG90YWxUaW1lPXRoaXMuX3RpbWU9dGhpcy5fcmF3UHJldlRpbWU9dDtyOylzPXIuX25leHQsKHIuX2FjdGl2ZXx8dD49ci5fc3RhcnRUaW1lJiYhci5fcGF1c2VkKSYmKHIuX3JldmVyc2VkP3IucmVuZGVyKChyLl9kaXJ0eT9yLnRvdGFsRHVyYXRpb24oKTpyLl90b3RhbER1cmF0aW9uKS0odC1yLl9zdGFydFRpbWUpKnIuX3RpbWVTY2FsZSxlLGkpOnIucmVuZGVyKCh0LXIuX3N0YXJ0VGltZSkqci5fdGltZVNjYWxlLGUsaSkpLHI9c30sbi5yYXdUaW1lPWZ1bmN0aW9uKCl7cmV0dXJuIG98fGEud2FrZSgpLHRoaXMuX3RvdGFsVGltZX07dmFyIEk9dihcIlR3ZWVuTGl0ZVwiLGZ1bmN0aW9uKGUsaSxzKXtpZihSLmNhbGwodGhpcyxpLHMpLHRoaXMucmVuZGVyPUkucHJvdG90eXBlLnJlbmRlcixudWxsPT1lKXRocm93XCJDYW5ub3QgdHdlZW4gYSBudWxsIHRhcmdldC5cIjt0aGlzLnRhcmdldD1lPVwic3RyaW5nXCIhPXR5cGVvZiBlP2U6SS5zZWxlY3RvcihlKXx8ZTt2YXIgcixuLGEsbz1lLmpxdWVyeXx8ZS5sZW5ndGgmJmUhPT10JiZlWzBdJiYoZVswXT09PXR8fGVbMF0ubm9kZVR5cGUmJmVbMF0uc3R5bGUmJiFlLm5vZGVUeXBlKSxsPXRoaXMudmFycy5vdmVyd3JpdGU7aWYodGhpcy5fb3ZlcndyaXRlPWw9bnVsbD09bD8kW0kuZGVmYXVsdE92ZXJ3cml0ZV06XCJudW1iZXJcIj09dHlwZW9mIGw/bD4+MDokW2xdLChvfHxlIGluc3RhbmNlb2YgQXJyYXl8fGUucHVzaCYmYyhlKSkmJlwibnVtYmVyXCIhPXR5cGVvZiBlWzBdKWZvcih0aGlzLl90YXJnZXRzPWE9dShlKSx0aGlzLl9wcm9wTG9va3VwPVtdLHRoaXMuX3NpYmxpbmdzPVtdLHI9MDthLmxlbmd0aD5yO3IrKyluPWFbcl0sbj9cInN0cmluZ1wiIT10eXBlb2Ygbj9uLmxlbmd0aCYmbiE9PXQmJm5bMF0mJihuWzBdPT09dHx8blswXS5ub2RlVHlwZSYmblswXS5zdHlsZSYmIW4ubm9kZVR5cGUpPyhhLnNwbGljZShyLS0sMSksdGhpcy5fdGFyZ2V0cz1hPWEuY29uY2F0KHUobikpKToodGhpcy5fc2libGluZ3Nbcl09VyhuLHRoaXMsITEpLDE9PT1sJiZ0aGlzLl9zaWJsaW5nc1tyXS5sZW5ndGg+MSYmWShuLHRoaXMsbnVsbCwxLHRoaXMuX3NpYmxpbmdzW3JdKSk6KG49YVtyLS1dPUkuc2VsZWN0b3IobiksXCJzdHJpbmdcIj09dHlwZW9mIG4mJmEuc3BsaWNlKHIrMSwxKSk6YS5zcGxpY2Uoci0tLDEpO2Vsc2UgdGhpcy5fcHJvcExvb2t1cD17fSx0aGlzLl9zaWJsaW5ncz1XKGUsdGhpcywhMSksMT09PWwmJnRoaXMuX3NpYmxpbmdzLmxlbmd0aD4xJiZZKGUsdGhpcyxudWxsLDEsdGhpcy5fc2libGluZ3MpOyh0aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyfHwwPT09aSYmMD09PXRoaXMuX2RlbGF5JiZ0aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyIT09ITEpJiYodGhpcy5fdGltZT0tXyx0aGlzLnJlbmRlcigtdGhpcy5fZGVsYXkpKX0sITApLEU9ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUubGVuZ3RoJiZlIT09dCYmZVswXSYmKGVbMF09PT10fHxlWzBdLm5vZGVUeXBlJiZlWzBdLnN0eWxlJiYhZS5ub2RlVHlwZSl9LE89ZnVuY3Rpb24odCxlKXt2YXIgaSxzPXt9O2ZvcihpIGluIHQpTVtpXXx8aSBpbiBlJiZcInRyYW5zZm9ybVwiIT09aSYmXCJ4XCIhPT1pJiZcInlcIiE9PWkmJlwid2lkdGhcIiE9PWkmJlwiaGVpZ2h0XCIhPT1pJiZcImNsYXNzTmFtZVwiIT09aSYmXCJib3JkZXJcIiE9PWl8fCEoIVFbaV18fFFbaV0mJlFbaV0uX2F1dG9DU1MpfHwoc1tpXT10W2ldLGRlbGV0ZSB0W2ldKTt0LmNzcz1zfTtuPUkucHJvdG90eXBlPW5ldyBSLG4uY29uc3RydWN0b3I9SSxuLmtpbGwoKS5fZ2M9ITEsbi5yYXRpbz0wLG4uX2ZpcnN0UFQ9bi5fdGFyZ2V0cz1uLl9vdmVyd3JpdHRlblByb3BzPW4uX3N0YXJ0QXQ9bnVsbCxuLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkPW4uX2xhenk9ITEsSS52ZXJzaW9uPVwiMS4xOC4wXCIsSS5kZWZhdWx0RWFzZT1uLl9lYXNlPW5ldyB5KG51bGwsbnVsbCwxLDEpLEkuZGVmYXVsdE92ZXJ3cml0ZT1cImF1dG9cIixJLnRpY2tlcj1hLEkuYXV0b1NsZWVwPTEyMCxJLmxhZ1Ntb290aGluZz1mdW5jdGlvbih0LGUpe2EubGFnU21vb3RoaW5nKHQsZSl9LEkuc2VsZWN0b3I9dC4kfHx0LmpRdWVyeXx8ZnVuY3Rpb24oZSl7dmFyIGk9dC4kfHx0LmpRdWVyeTtyZXR1cm4gaT8oSS5zZWxlY3Rvcj1pLGkoZSkpOlwidW5kZWZpbmVkXCI9PXR5cGVvZiBkb2N1bWVudD9lOmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGw/ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlKTpkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIiNcIj09PWUuY2hhckF0KDApP2Uuc3Vic3RyKDEpOmUpfTt2YXIgej1bXSxGPXt9LEw9Lyg/OigtfC09fFxcKz0pP1xcZCpcXC4/XFxkKig/OmVbXFwtK10/XFxkKyk/KVswLTldL2dpLE49ZnVuY3Rpb24odCl7Zm9yKHZhciBlLGk9dGhpcy5fZmlyc3RQVCxzPTFlLTY7aTspZT1pLmJsb2I/dD90aGlzLmpvaW4oXCJcIik6dGhpcy5zdGFydDppLmMqdCtpLnMsaS5yP2U9TWF0aC5yb3VuZChlKTpzPmUmJmU+LXMmJihlPTApLGkuZj9pLmZwP2kudFtpLnBdKGkuZnAsZSk6aS50W2kucF0oZSk6aS50W2kucF09ZSxpPWkuX25leHR9LFU9ZnVuY3Rpb24odCxlLGkscyl7dmFyIHIsbixhLG8sbCxoLF8sdT1bdCxlXSxmPTAsYz1cIlwiLG09MDtmb3IodS5zdGFydD10LGkmJihpKHUpLHQ9dVswXSxlPXVbMV0pLHUubGVuZ3RoPTAscj10Lm1hdGNoKEwpfHxbXSxuPWUubWF0Y2goTCl8fFtdLHMmJihzLl9uZXh0PW51bGwscy5ibG9iPTEsdS5fZmlyc3RQVD1zKSxsPW4ubGVuZ3RoLG89MDtsPm87bysrKV89bltvXSxoPWUuc3Vic3RyKGYsZS5pbmRleE9mKF8sZiktZiksYys9aHx8IW8/aDpcIixcIixmKz1oLmxlbmd0aCxtP209KG0rMSklNTpcInJnYmEoXCI9PT1oLnN1YnN0cigtNSkmJihtPTEpLF89PT1yW29dfHxvPj1yLmxlbmd0aD9jKz1fOihjJiYodS5wdXNoKGMpLGM9XCJcIiksYT1wYXJzZUZsb2F0KHJbb10pLHUucHVzaChhKSx1Ll9maXJzdFBUPXtfbmV4dDp1Ll9maXJzdFBULHQ6dSxwOnUubGVuZ3RoLTEsczphLGM6KFwiPVwiPT09Xy5jaGFyQXQoMSk/cGFyc2VJbnQoXy5jaGFyQXQoMCkrXCIxXCIsMTApKnBhcnNlRmxvYXQoXy5zdWJzdHIoMikpOnBhcnNlRmxvYXQoXyktYSl8fDAsZjowLHI6bSYmND5tfSksZis9Xy5sZW5ndGg7cmV0dXJuIGMrPWUuc3Vic3RyKGYpLGMmJnUucHVzaChjKSx1LnNldFJhdGlvPU4sdX0saj1mdW5jdGlvbih0LGUsaSxzLHIsbixhLG8pe3ZhciBsLGgsXz1cImdldFwiPT09aT90W2VdOmksdT10eXBlb2YgdFtlXSxmPVwic3RyaW5nXCI9PXR5cGVvZiBzJiZcIj1cIj09PXMuY2hhckF0KDEpLGM9e3Q6dCxwOmUsczpfLGY6XCJmdW5jdGlvblwiPT09dSxwZzowLG46cnx8ZSxyOm4scHI6MCxjOmY/cGFyc2VJbnQocy5jaGFyQXQoMCkrXCIxXCIsMTApKnBhcnNlRmxvYXQocy5zdWJzdHIoMikpOnBhcnNlRmxvYXQocyktX3x8MH07cmV0dXJuXCJudW1iZXJcIiE9PXUmJihcImZ1bmN0aW9uXCI9PT11JiZcImdldFwiPT09aSYmKGg9ZS5pbmRleE9mKFwic2V0XCIpfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiB0W1wiZ2V0XCIrZS5zdWJzdHIoMyldP2U6XCJnZXRcIitlLnN1YnN0cigzKSxjLnM9Xz1hP3RbaF0oYSk6dFtoXSgpKSxcInN0cmluZ1wiPT10eXBlb2YgXyYmKGF8fGlzTmFOKF8pKT8oYy5mcD1hLGw9VShfLHMsb3x8SS5kZWZhdWx0U3RyaW5nRmlsdGVyLGMpLGM9e3Q6bCxwOlwic2V0UmF0aW9cIixzOjAsYzoxLGY6MixwZzowLG46cnx8ZSxwcjowfSk6Znx8KGMuYz1wYXJzZUZsb2F0KHMpLXBhcnNlRmxvYXQoXyl8fDApKSxjLmM/KChjLl9uZXh0PXRoaXMuX2ZpcnN0UFQpJiYoYy5fbmV4dC5fcHJldj1jKSx0aGlzLl9maXJzdFBUPWMsYyk6dm9pZCAwfSxHPUkuX2ludGVybmFscz17aXNBcnJheTpjLGlzU2VsZWN0b3I6RSxsYXp5VHdlZW5zOnosYmxvYkRpZjpVfSxRPUkuX3BsdWdpbnM9e30scT1HLnR3ZWVuTG9va3VwPXt9LEI9MCxNPUcucmVzZXJ2ZWRQcm9wcz17ZWFzZToxLGRlbGF5OjEsb3ZlcndyaXRlOjEsb25Db21wbGV0ZToxLG9uQ29tcGxldGVQYXJhbXM6MSxvbkNvbXBsZXRlU2NvcGU6MSx1c2VGcmFtZXM6MSxydW5CYWNrd2FyZHM6MSxzdGFydEF0OjEsb25VcGRhdGU6MSxvblVwZGF0ZVBhcmFtczoxLG9uVXBkYXRlU2NvcGU6MSxvblN0YXJ0OjEsb25TdGFydFBhcmFtczoxLG9uU3RhcnRTY29wZToxLG9uUmV2ZXJzZUNvbXBsZXRlOjEsb25SZXZlcnNlQ29tcGxldGVQYXJhbXM6MSxvblJldmVyc2VDb21wbGV0ZVNjb3BlOjEsb25SZXBlYXQ6MSxvblJlcGVhdFBhcmFtczoxLG9uUmVwZWF0U2NvcGU6MSxlYXNlUGFyYW1zOjEseW95bzoxLGltbWVkaWF0ZVJlbmRlcjoxLHJlcGVhdDoxLHJlcGVhdERlbGF5OjEsZGF0YToxLHBhdXNlZDoxLHJldmVyc2VkOjEsYXV0b0NTUzoxLGxhenk6MSxvbk92ZXJ3cml0ZToxLGNhbGxiYWNrU2NvcGU6MSxzdHJpbmdGaWx0ZXI6MX0sJD17bm9uZTowLGFsbDoxLGF1dG86Mixjb25jdXJyZW50OjMsYWxsT25TdGFydDo0LHByZWV4aXN0aW5nOjUsXCJ0cnVlXCI6MSxcImZhbHNlXCI6MH0sSz1SLl9yb290RnJhbWVzVGltZWxpbmU9bmV3IEQsSD1SLl9yb290VGltZWxpbmU9bmV3IEQsSj0zMCxWPUcubGF6eVJlbmRlcj1mdW5jdGlvbigpe3ZhciB0LGU9ei5sZW5ndGg7Zm9yKEY9e307LS1lPi0xOyl0PXpbZV0sdCYmdC5fbGF6eSE9PSExJiYodC5yZW5kZXIodC5fbGF6eVswXSx0Ll9sYXp5WzFdLCEwKSx0Ll9sYXp5PSExKTt6Lmxlbmd0aD0wfTtILl9zdGFydFRpbWU9YS50aW1lLEsuX3N0YXJ0VGltZT1hLmZyYW1lLEguX2FjdGl2ZT1LLl9hY3RpdmU9ITAsc2V0VGltZW91dChWLDEpLFIuX3VwZGF0ZVJvb3Q9SS5yZW5kZXI9ZnVuY3Rpb24oKXt2YXIgdCxlLGk7aWYoei5sZW5ndGgmJlYoKSxILnJlbmRlcigoYS50aW1lLUguX3N0YXJ0VGltZSkqSC5fdGltZVNjYWxlLCExLCExKSxLLnJlbmRlcigoYS5mcmFtZS1LLl9zdGFydFRpbWUpKksuX3RpbWVTY2FsZSwhMSwhMSksei5sZW5ndGgmJlYoKSxhLmZyYW1lPj1KKXtKPWEuZnJhbWUrKHBhcnNlSW50KEkuYXV0b1NsZWVwLDEwKXx8MTIwKTtmb3IoaSBpbiBxKXtmb3IoZT1xW2ldLnR3ZWVucyx0PWUubGVuZ3RoOy0tdD4tMTspZVt0XS5fZ2MmJmUuc3BsaWNlKHQsMSk7MD09PWUubGVuZ3RoJiZkZWxldGUgcVtpXX1pZihpPUguX2ZpcnN0LCghaXx8aS5fcGF1c2VkKSYmSS5hdXRvU2xlZXAmJiFLLl9maXJzdCYmMT09PWEuX2xpc3RlbmVycy50aWNrLmxlbmd0aCl7Zm9yKDtpJiZpLl9wYXVzZWQ7KWk9aS5fbmV4dDtpfHxhLnNsZWVwKCl9fX0sYS5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLFIuX3VwZGF0ZVJvb3QpO3ZhciBXPWZ1bmN0aW9uKHQsZSxpKXt2YXIgcyxyLG49dC5fZ3NUd2VlbklEO2lmKHFbbnx8KHQuX2dzVHdlZW5JRD1uPVwidFwiK0IrKyldfHwocVtuXT17dGFyZ2V0OnQsdHdlZW5zOltdfSksZSYmKHM9cVtuXS50d2VlbnMsc1tyPXMubGVuZ3RoXT1lLGkpKWZvcig7LS1yPi0xOylzW3JdPT09ZSYmcy5zcGxpY2UociwxKTtyZXR1cm4gcVtuXS50d2VlbnN9LFg9ZnVuY3Rpb24odCxlLGkscyl7dmFyIHIsbixhPXQudmFycy5vbk92ZXJ3cml0ZTtyZXR1cm4gYSYmKHI9YSh0LGUsaSxzKSksYT1JLm9uT3ZlcndyaXRlLGEmJihuPWEodCxlLGkscykpLHIhPT0hMSYmbiE9PSExfSxZPWZ1bmN0aW9uKHQsZSxpLHMscil7dmFyIG4sYSxvLGw7aWYoMT09PXN8fHM+PTQpe2ZvcihsPXIubGVuZ3RoLG49MDtsPm47bisrKWlmKChvPXJbbl0pIT09ZSlvLl9nY3x8by5fa2lsbChudWxsLHQsZSkmJihhPSEwKTtlbHNlIGlmKDU9PT1zKWJyZWFrO3JldHVybiBhfXZhciBoLHU9ZS5fc3RhcnRUaW1lK18sZj1bXSxjPTAsbT0wPT09ZS5fZHVyYXRpb247Zm9yKG49ci5sZW5ndGg7LS1uPi0xOykobz1yW25dKT09PWV8fG8uX2djfHxvLl9wYXVzZWR8fChvLl90aW1lbGluZSE9PWUuX3RpbWVsaW5lPyhoPWh8fFooZSwwLG0pLDA9PT1aKG8saCxtKSYmKGZbYysrXT1vKSk6dT49by5fc3RhcnRUaW1lJiZvLl9zdGFydFRpbWUrby50b3RhbER1cmF0aW9uKCkvby5fdGltZVNjYWxlPnUmJigobXx8IW8uX2luaXR0ZWQpJiYyZS0xMD49dS1vLl9zdGFydFRpbWV8fChmW2MrK109bykpKTtmb3Iobj1jOy0tbj4tMTspaWYobz1mW25dLDI9PT1zJiZvLl9raWxsKGksdCxlKSYmKGE9ITApLDIhPT1zfHwhby5fZmlyc3RQVCYmby5faW5pdHRlZCl7aWYoMiE9PXMmJiFYKG8sZSkpY29udGludWU7by5fZW5hYmxlZCghMSwhMSkmJihhPSEwKX1yZXR1cm4gYX0sWj1mdW5jdGlvbih0LGUsaSl7Zm9yKHZhciBzPXQuX3RpbWVsaW5lLHI9cy5fdGltZVNjYWxlLG49dC5fc3RhcnRUaW1lO3MuX3RpbWVsaW5lOyl7aWYobis9cy5fc3RhcnRUaW1lLHIqPXMuX3RpbWVTY2FsZSxzLl9wYXVzZWQpcmV0dXJuLTEwMDtzPXMuX3RpbWVsaW5lfXJldHVybiBuLz1yLG4+ZT9uLWU6aSYmbj09PWV8fCF0Ll9pbml0dGVkJiYyKl8+bi1lP186KG4rPXQudG90YWxEdXJhdGlvbigpL3QuX3RpbWVTY2FsZS9yKT5lK18/MDpuLWUtX307bi5faW5pdD1mdW5jdGlvbigpe3ZhciB0LGUsaSxzLHIsbj10aGlzLnZhcnMsYT10aGlzLl9vdmVyd3JpdHRlblByb3BzLG89dGhpcy5fZHVyYXRpb24sbD0hIW4uaW1tZWRpYXRlUmVuZGVyLGg9bi5lYXNlO2lmKG4uc3RhcnRBdCl7dGhpcy5fc3RhcnRBdCYmKHRoaXMuX3N0YXJ0QXQucmVuZGVyKC0xLCEwKSx0aGlzLl9zdGFydEF0LmtpbGwoKSkscj17fTtmb3IocyBpbiBuLnN0YXJ0QXQpcltzXT1uLnN0YXJ0QXRbc107aWYoci5vdmVyd3JpdGU9ITEsci5pbW1lZGlhdGVSZW5kZXI9ITAsci5sYXp5PWwmJm4ubGF6eSE9PSExLHIuc3RhcnRBdD1yLmRlbGF5PW51bGwsdGhpcy5fc3RhcnRBdD1JLnRvKHRoaXMudGFyZ2V0LDAsciksbClpZih0aGlzLl90aW1lPjApdGhpcy5fc3RhcnRBdD1udWxsO2Vsc2UgaWYoMCE9PW8pcmV0dXJufWVsc2UgaWYobi5ydW5CYWNrd2FyZHMmJjAhPT1vKWlmKHRoaXMuX3N0YXJ0QXQpdGhpcy5fc3RhcnRBdC5yZW5kZXIoLTEsITApLHRoaXMuX3N0YXJ0QXQua2lsbCgpLHRoaXMuX3N0YXJ0QXQ9bnVsbDtlbHNlezAhPT10aGlzLl90aW1lJiYobD0hMSksaT17fTtmb3IocyBpbiBuKU1bc10mJlwiYXV0b0NTU1wiIT09c3x8KGlbc109bltzXSk7aWYoaS5vdmVyd3JpdGU9MCxpLmRhdGE9XCJpc0Zyb21TdGFydFwiLGkubGF6eT1sJiZuLmxhenkhPT0hMSxpLmltbWVkaWF0ZVJlbmRlcj1sLHRoaXMuX3N0YXJ0QXQ9SS50byh0aGlzLnRhcmdldCwwLGkpLGwpe2lmKDA9PT10aGlzLl90aW1lKXJldHVybn1lbHNlIHRoaXMuX3N0YXJ0QXQuX2luaXQoKSx0aGlzLl9zdGFydEF0Ll9lbmFibGVkKCExKSx0aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyJiYodGhpcy5fc3RhcnRBdD1udWxsKX1pZih0aGlzLl9lYXNlPWg9aD9oIGluc3RhbmNlb2YgeT9oOlwiZnVuY3Rpb25cIj09dHlwZW9mIGg/bmV3IHkoaCxuLmVhc2VQYXJhbXMpOndbaF18fEkuZGVmYXVsdEVhc2U6SS5kZWZhdWx0RWFzZSxuLmVhc2VQYXJhbXMgaW5zdGFuY2VvZiBBcnJheSYmaC5jb25maWcmJih0aGlzLl9lYXNlPWguY29uZmlnLmFwcGx5KGgsbi5lYXNlUGFyYW1zKSksdGhpcy5fZWFzZVR5cGU9dGhpcy5fZWFzZS5fdHlwZSx0aGlzLl9lYXNlUG93ZXI9dGhpcy5fZWFzZS5fcG93ZXIsdGhpcy5fZmlyc3RQVD1udWxsLHRoaXMuX3RhcmdldHMpZm9yKHQ9dGhpcy5fdGFyZ2V0cy5sZW5ndGg7LS10Pi0xOyl0aGlzLl9pbml0UHJvcHModGhpcy5fdGFyZ2V0c1t0XSx0aGlzLl9wcm9wTG9va3VwW3RdPXt9LHRoaXMuX3NpYmxpbmdzW3RdLGE/YVt0XTpudWxsKSYmKGU9ITApO2Vsc2UgZT10aGlzLl9pbml0UHJvcHModGhpcy50YXJnZXQsdGhpcy5fcHJvcExvb2t1cCx0aGlzLl9zaWJsaW5ncyxhKTtpZihlJiZJLl9vblBsdWdpbkV2ZW50KFwiX29uSW5pdEFsbFByb3BzXCIsdGhpcyksYSYmKHRoaXMuX2ZpcnN0UFR8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIHRoaXMudGFyZ2V0JiZ0aGlzLl9lbmFibGVkKCExLCExKSksbi5ydW5CYWNrd2FyZHMpZm9yKGk9dGhpcy5fZmlyc3RQVDtpOylpLnMrPWkuYyxpLmM9LWkuYyxpPWkuX25leHQ7dGhpcy5fb25VcGRhdGU9bi5vblVwZGF0ZSx0aGlzLl9pbml0dGVkPSEwfSxuLl9pbml0UHJvcHM9ZnVuY3Rpb24oZSxpLHMscil7dmFyIG4sYSxvLGwsaCxfO2lmKG51bGw9PWUpcmV0dXJuITE7RltlLl9nc1R3ZWVuSURdJiZWKCksdGhpcy52YXJzLmNzc3x8ZS5zdHlsZSYmZSE9PXQmJmUubm9kZVR5cGUmJlEuY3NzJiZ0aGlzLnZhcnMuYXV0b0NTUyE9PSExJiZPKHRoaXMudmFycyxlKTtmb3IobiBpbiB0aGlzLnZhcnMpaWYoXz10aGlzLnZhcnNbbl0sTVtuXSlfJiYoXyBpbnN0YW5jZW9mIEFycmF5fHxfLnB1c2gmJmMoXykpJiYtMSE9PV8uam9pbihcIlwiKS5pbmRleE9mKFwie3NlbGZ9XCIpJiYodGhpcy52YXJzW25dPV89dGhpcy5fc3dhcFNlbGZJblBhcmFtcyhfLHRoaXMpKTtlbHNlIGlmKFFbbl0mJihsPW5ldyBRW25dKS5fb25Jbml0VHdlZW4oZSx0aGlzLnZhcnNbbl0sdGhpcykpe2Zvcih0aGlzLl9maXJzdFBUPWg9e19uZXh0OnRoaXMuX2ZpcnN0UFQsdDpsLHA6XCJzZXRSYXRpb1wiLHM6MCxjOjEsZjoxLG46bixwZzoxLHByOmwuX3ByaW9yaXR5fSxhPWwuX292ZXJ3cml0ZVByb3BzLmxlbmd0aDstLWE+LTE7KWlbbC5fb3ZlcndyaXRlUHJvcHNbYV1dPXRoaXMuX2ZpcnN0UFQ7KGwuX3ByaW9yaXR5fHxsLl9vbkluaXRBbGxQcm9wcykmJihvPSEwKSwobC5fb25EaXNhYmxlfHxsLl9vbkVuYWJsZSkmJih0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkPSEwKSxoLl9uZXh0JiYoaC5fbmV4dC5fcHJldj1oKX1lbHNlIGlbbl09ai5jYWxsKHRoaXMsZSxuLFwiZ2V0XCIsXyxuLDAsbnVsbCx0aGlzLnZhcnMuc3RyaW5nRmlsdGVyKTtyZXR1cm4gciYmdGhpcy5fa2lsbChyLGUpP3RoaXMuX2luaXRQcm9wcyhlLGkscyxyKTp0aGlzLl9vdmVyd3JpdGU+MSYmdGhpcy5fZmlyc3RQVCYmcy5sZW5ndGg+MSYmWShlLHRoaXMsaSx0aGlzLl9vdmVyd3JpdGUscyk/KHRoaXMuX2tpbGwoaSxlKSx0aGlzLl9pbml0UHJvcHMoZSxpLHMscikpOih0aGlzLl9maXJzdFBUJiYodGhpcy52YXJzLmxhenkhPT0hMSYmdGhpcy5fZHVyYXRpb258fHRoaXMudmFycy5sYXp5JiYhdGhpcy5fZHVyYXRpb24pJiYoRltlLl9nc1R3ZWVuSURdPSEwKSxvKX0sbi5yZW5kZXI9ZnVuY3Rpb24odCxlLGkpe3ZhciBzLHIsbixhLG89dGhpcy5fdGltZSxsPXRoaXMuX2R1cmF0aW9uLGg9dGhpcy5fcmF3UHJldlRpbWU7aWYodD49bCl0aGlzLl90b3RhbFRpbWU9dGhpcy5fdGltZT1sLHRoaXMucmF0aW89dGhpcy5fZWFzZS5fY2FsY0VuZD90aGlzLl9lYXNlLmdldFJhdGlvKDEpOjEsdGhpcy5fcmV2ZXJzZWR8fChzPSEwLHI9XCJvbkNvbXBsZXRlXCIsaT1pfHx0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pLDA9PT1sJiYodGhpcy5faW5pdHRlZHx8IXRoaXMudmFycy5sYXp5fHxpKSYmKHRoaXMuX3N0YXJ0VGltZT09PXRoaXMuX3RpbWVsaW5lLl9kdXJhdGlvbiYmKHQ9MCksKDA9PT10fHwwPmh8fGg9PT1fJiZcImlzUGF1c2VcIiE9PXRoaXMuZGF0YSkmJmghPT10JiYoaT0hMCxoPl8mJihyPVwib25SZXZlcnNlQ29tcGxldGVcIikpLHRoaXMuX3Jhd1ByZXZUaW1lPWE9IWV8fHR8fGg9PT10P3Q6Xyk7ZWxzZSBpZigxZS03PnQpdGhpcy5fdG90YWxUaW1lPXRoaXMuX3RpbWU9MCx0aGlzLnJhdGlvPXRoaXMuX2Vhc2UuX2NhbGNFbmQ/dGhpcy5fZWFzZS5nZXRSYXRpbygwKTowLCgwIT09b3x8MD09PWwmJmg+MCkmJihyPVwib25SZXZlcnNlQ29tcGxldGVcIixzPXRoaXMuX3JldmVyc2VkKSwwPnQmJih0aGlzLl9hY3RpdmU9ITEsMD09PWwmJih0aGlzLl9pbml0dGVkfHwhdGhpcy52YXJzLmxhenl8fGkpJiYoaD49MCYmKGghPT1ffHxcImlzUGF1c2VcIiE9PXRoaXMuZGF0YSkmJihpPSEwKSx0aGlzLl9yYXdQcmV2VGltZT1hPSFlfHx0fHxoPT09dD90Ol8pKSx0aGlzLl9pbml0dGVkfHwoaT0hMCk7ZWxzZSBpZih0aGlzLl90b3RhbFRpbWU9dGhpcy5fdGltZT10LHRoaXMuX2Vhc2VUeXBlKXt2YXIgdT10L2wsZj10aGlzLl9lYXNlVHlwZSxjPXRoaXMuX2Vhc2VQb3dlcjsoMT09PWZ8fDM9PT1mJiZ1Pj0uNSkmJih1PTEtdSksMz09PWYmJih1Kj0yKSwxPT09Yz91Kj11OjI9PT1jP3UqPXUqdTozPT09Yz91Kj11KnUqdTo0PT09YyYmKHUqPXUqdSp1KnUpLHRoaXMucmF0aW89MT09PWY/MS11OjI9PT1mP3U6LjU+dC9sP3UvMjoxLXUvMn1lbHNlIHRoaXMucmF0aW89dGhpcy5fZWFzZS5nZXRSYXRpbyh0L2wpO2lmKHRoaXMuX3RpbWUhPT1vfHxpKXtpZighdGhpcy5faW5pdHRlZCl7aWYodGhpcy5faW5pdCgpLCF0aGlzLl9pbml0dGVkfHx0aGlzLl9nYylyZXR1cm47aWYoIWkmJnRoaXMuX2ZpcnN0UFQmJih0aGlzLnZhcnMubGF6eSE9PSExJiZ0aGlzLl9kdXJhdGlvbnx8dGhpcy52YXJzLmxhenkmJiF0aGlzLl9kdXJhdGlvbikpcmV0dXJuIHRoaXMuX3RpbWU9dGhpcy5fdG90YWxUaW1lPW8sdGhpcy5fcmF3UHJldlRpbWU9aCx6LnB1c2godGhpcyksdGhpcy5fbGF6eT1bdCxlXSx2b2lkIDA7dGhpcy5fdGltZSYmIXM/dGhpcy5yYXRpbz10aGlzLl9lYXNlLmdldFJhdGlvKHRoaXMuX3RpbWUvbCk6cyYmdGhpcy5fZWFzZS5fY2FsY0VuZCYmKHRoaXMucmF0aW89dGhpcy5fZWFzZS5nZXRSYXRpbygwPT09dGhpcy5fdGltZT8wOjEpKX1mb3IodGhpcy5fbGF6eSE9PSExJiYodGhpcy5fbGF6eT0hMSksdGhpcy5fYWN0aXZlfHwhdGhpcy5fcGF1c2VkJiZ0aGlzLl90aW1lIT09byYmdD49MCYmKHRoaXMuX2FjdGl2ZT0hMCksMD09PW8mJih0aGlzLl9zdGFydEF0JiYodD49MD90aGlzLl9zdGFydEF0LnJlbmRlcih0LGUsaSk6cnx8KHI9XCJfZHVtbXlHU1wiKSksdGhpcy52YXJzLm9uU3RhcnQmJigwIT09dGhpcy5fdGltZXx8MD09PWwpJiYoZXx8dGhpcy5fY2FsbGJhY2soXCJvblN0YXJ0XCIpKSksbj10aGlzLl9maXJzdFBUO247KW4uZj9uLnRbbi5wXShuLmMqdGhpcy5yYXRpbytuLnMpOm4udFtuLnBdPW4uYyp0aGlzLnJhdGlvK24ucyxuPW4uX25leHQ7dGhpcy5fb25VcGRhdGUmJigwPnQmJnRoaXMuX3N0YXJ0QXQmJnQhPT0tMWUtNCYmdGhpcy5fc3RhcnRBdC5yZW5kZXIodCxlLGkpLGV8fCh0aGlzLl90aW1lIT09b3x8cykmJnRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIikpLHImJighdGhpcy5fZ2N8fGkpJiYoMD50JiZ0aGlzLl9zdGFydEF0JiYhdGhpcy5fb25VcGRhdGUmJnQhPT0tMWUtNCYmdGhpcy5fc3RhcnRBdC5yZW5kZXIodCxlLGkpLHMmJih0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4mJnRoaXMuX2VuYWJsZWQoITEsITEpLHRoaXMuX2FjdGl2ZT0hMSksIWUmJnRoaXMudmFyc1tyXSYmdGhpcy5fY2FsbGJhY2sociksMD09PWwmJnRoaXMuX3Jhd1ByZXZUaW1lPT09XyYmYSE9PV8mJih0aGlzLl9yYXdQcmV2VGltZT0wKSl9fSxuLl9raWxsPWZ1bmN0aW9uKHQsZSxpKXtpZihcImFsbFwiPT09dCYmKHQ9bnVsbCksbnVsbD09dCYmKG51bGw9PWV8fGU9PT10aGlzLnRhcmdldCkpcmV0dXJuIHRoaXMuX2xhenk9ITEsdGhpcy5fZW5hYmxlZCghMSwhMSk7ZT1cInN0cmluZ1wiIT10eXBlb2YgZT9lfHx0aGlzLl90YXJnZXRzfHx0aGlzLnRhcmdldDpJLnNlbGVjdG9yKGUpfHxlO3ZhciBzLHIsbixhLG8sbCxoLF8sdSxmPWkmJnRoaXMuX3RpbWUmJmkuX3N0YXJ0VGltZT09PXRoaXMuX3N0YXJ0VGltZSYmdGhpcy5fdGltZWxpbmU9PT1pLl90aW1lbGluZTtpZigoYyhlKXx8RShlKSkmJlwibnVtYmVyXCIhPXR5cGVvZiBlWzBdKWZvcihzPWUubGVuZ3RoOy0tcz4tMTspdGhpcy5fa2lsbCh0LGVbc10saSkmJihsPSEwKTtlbHNle2lmKHRoaXMuX3RhcmdldHMpe2ZvcihzPXRoaXMuX3RhcmdldHMubGVuZ3RoOy0tcz4tMTspaWYoZT09PXRoaXMuX3RhcmdldHNbc10pe289dGhpcy5fcHJvcExvb2t1cFtzXXx8e30sdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcz10aGlzLl9vdmVyd3JpdHRlblByb3BzfHxbXSxyPXRoaXMuX292ZXJ3cml0dGVuUHJvcHNbc109dD90aGlzLl9vdmVyd3JpdHRlblByb3BzW3NdfHx7fTpcImFsbFwiO2JyZWFrfX1lbHNle2lmKGUhPT10aGlzLnRhcmdldClyZXR1cm4hMTtvPXRoaXMuX3Byb3BMb29rdXAscj10aGlzLl9vdmVyd3JpdHRlblByb3BzPXQ/dGhpcy5fb3ZlcndyaXR0ZW5Qcm9wc3x8e306XCJhbGxcIn1pZihvKXtpZihoPXR8fG8sXz10IT09ciYmXCJhbGxcIiE9PXImJnQhPT1vJiYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fCF0Ll90ZW1wS2lsbCksaSYmKEkub25PdmVyd3JpdGV8fHRoaXMudmFycy5vbk92ZXJ3cml0ZSkpe2ZvcihuIGluIGgpb1tuXSYmKHV8fCh1PVtdKSx1LnB1c2gobikpO2lmKCh1fHwhdCkmJiFYKHRoaXMsaSxlLHUpKXJldHVybiExfWZvcihuIGluIGgpKGE9b1tuXSkmJihmJiYoYS5mP2EudFthLnBdKGEucyk6YS50W2EucF09YS5zLGw9ITApLGEucGcmJmEudC5fa2lsbChoKSYmKGw9ITApLGEucGcmJjAhPT1hLnQuX292ZXJ3cml0ZVByb3BzLmxlbmd0aHx8KGEuX3ByZXY/YS5fcHJldi5fbmV4dD1hLl9uZXh0OmE9PT10aGlzLl9maXJzdFBUJiYodGhpcy5fZmlyc3RQVD1hLl9uZXh0KSxhLl9uZXh0JiYoYS5fbmV4dC5fcHJldj1hLl9wcmV2KSxhLl9uZXh0PWEuX3ByZXY9bnVsbCksZGVsZXRlIG9bbl0pLF8mJihyW25dPTEpOyF0aGlzLl9maXJzdFBUJiZ0aGlzLl9pbml0dGVkJiZ0aGlzLl9lbmFibGVkKCExLCExKX19cmV0dXJuIGx9LG4uaW52YWxpZGF0ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkJiZJLl9vblBsdWdpbkV2ZW50KFwiX29uRGlzYWJsZVwiLHRoaXMpLHRoaXMuX2ZpcnN0UFQ9dGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcz10aGlzLl9zdGFydEF0PXRoaXMuX29uVXBkYXRlPW51bGwsdGhpcy5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZD10aGlzLl9hY3RpdmU9dGhpcy5fbGF6eT0hMSx0aGlzLl9wcm9wTG9va3VwPXRoaXMuX3RhcmdldHM/e306W10sUi5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMpLHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXImJih0aGlzLl90aW1lPS1fLHRoaXMucmVuZGVyKC10aGlzLl9kZWxheSkpLHRoaXN9LG4uX2VuYWJsZWQ9ZnVuY3Rpb24odCxlKXtpZihvfHxhLndha2UoKSx0JiZ0aGlzLl9nYyl7dmFyIGkscz10aGlzLl90YXJnZXRzO2lmKHMpZm9yKGk9cy5sZW5ndGg7LS1pPi0xOyl0aGlzLl9zaWJsaW5nc1tpXT1XKHNbaV0sdGhpcywhMCk7ZWxzZSB0aGlzLl9zaWJsaW5ncz1XKHRoaXMudGFyZ2V0LHRoaXMsITApfXJldHVybiBSLnByb3RvdHlwZS5fZW5hYmxlZC5jYWxsKHRoaXMsdCxlKSx0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkJiZ0aGlzLl9maXJzdFBUP0kuX29uUGx1Z2luRXZlbnQodD9cIl9vbkVuYWJsZVwiOlwiX29uRGlzYWJsZVwiLHRoaXMpOiExfSxJLnRvPWZ1bmN0aW9uKHQsZSxpKXtyZXR1cm4gbmV3IEkodCxlLGkpfSxJLmZyb209ZnVuY3Rpb24odCxlLGkpe3JldHVybiBpLnJ1bkJhY2t3YXJkcz0hMCxpLmltbWVkaWF0ZVJlbmRlcj0wIT1pLmltbWVkaWF0ZVJlbmRlcixuZXcgSSh0LGUsaSl9LEkuZnJvbVRvPWZ1bmN0aW9uKHQsZSxpLHMpe3JldHVybiBzLnN0YXJ0QXQ9aSxzLmltbWVkaWF0ZVJlbmRlcj0wIT1zLmltbWVkaWF0ZVJlbmRlciYmMCE9aS5pbW1lZGlhdGVSZW5kZXIsbmV3IEkodCxlLHMpfSxJLmRlbGF5ZWRDYWxsPWZ1bmN0aW9uKHQsZSxpLHMscil7cmV0dXJuIG5ldyBJKGUsMCx7ZGVsYXk6dCxvbkNvbXBsZXRlOmUsb25Db21wbGV0ZVBhcmFtczppLGNhbGxiYWNrU2NvcGU6cyxvblJldmVyc2VDb21wbGV0ZTplLG9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zOmksaW1tZWRpYXRlUmVuZGVyOiExLGxhenk6ITEsdXNlRnJhbWVzOnIsb3ZlcndyaXRlOjB9KX0sSS5zZXQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IEkodCwwLGUpfSxJLmdldFR3ZWVuc09mPWZ1bmN0aW9uKHQsZSl7aWYobnVsbD09dClyZXR1cm5bXTt0PVwic3RyaW5nXCIhPXR5cGVvZiB0P3Q6SS5zZWxlY3Rvcih0KXx8dDt2YXIgaSxzLHIsbjtpZigoYyh0KXx8RSh0KSkmJlwibnVtYmVyXCIhPXR5cGVvZiB0WzBdKXtmb3IoaT10Lmxlbmd0aCxzPVtdOy0taT4tMTspcz1zLmNvbmNhdChJLmdldFR3ZWVuc09mKHRbaV0sZSkpO2ZvcihpPXMubGVuZ3RoOy0taT4tMTspZm9yKG49c1tpXSxyPWk7LS1yPi0xOyluPT09c1tyXSYmcy5zcGxpY2UoaSwxKX1lbHNlIGZvcihzPVcodCkuY29uY2F0KCksaT1zLmxlbmd0aDstLWk+LTE7KShzW2ldLl9nY3x8ZSYmIXNbaV0uaXNBY3RpdmUoKSkmJnMuc3BsaWNlKGksMSk7cmV0dXJuIHN9LEkua2lsbFR3ZWVuc09mPUkua2lsbERlbGF5ZWRDYWxsc1RvPWZ1bmN0aW9uKHQsZSxpKXtcIm9iamVjdFwiPT10eXBlb2YgZSYmKGk9ZSxlPSExKTtmb3IodmFyIHM9SS5nZXRUd2VlbnNPZih0LGUpLHI9cy5sZW5ndGg7LS1yPi0xOylzW3JdLl9raWxsKGksdCl9O3ZhciB0ZT12KFwicGx1Z2lucy5Ud2VlblBsdWdpblwiLGZ1bmN0aW9uKHQsZSl7dGhpcy5fb3ZlcndyaXRlUHJvcHM9KHR8fFwiXCIpLnNwbGl0KFwiLFwiKSx0aGlzLl9wcm9wTmFtZT10aGlzLl9vdmVyd3JpdGVQcm9wc1swXSx0aGlzLl9wcmlvcml0eT1lfHwwLHRoaXMuX3N1cGVyPXRlLnByb3RvdHlwZX0sITApO2lmKG49dGUucHJvdG90eXBlLHRlLnZlcnNpb249XCIxLjE4LjBcIix0ZS5BUEk9MixuLl9maXJzdFBUPW51bGwsbi5fYWRkVHdlZW49aixuLnNldFJhdGlvPU4sbi5fa2lsbD1mdW5jdGlvbih0KXt2YXIgZSxpPXRoaXMuX292ZXJ3cml0ZVByb3BzLHM9dGhpcy5fZmlyc3RQVDtpZihudWxsIT10W3RoaXMuX3Byb3BOYW1lXSl0aGlzLl9vdmVyd3JpdGVQcm9wcz1bXTtlbHNlIGZvcihlPWkubGVuZ3RoOy0tZT4tMTspbnVsbCE9dFtpW2VdXSYmaS5zcGxpY2UoZSwxKTtmb3IoO3M7KW51bGwhPXRbcy5uXSYmKHMuX25leHQmJihzLl9uZXh0Ll9wcmV2PXMuX3ByZXYpLHMuX3ByZXY/KHMuX3ByZXYuX25leHQ9cy5fbmV4dCxzLl9wcmV2PW51bGwpOnRoaXMuX2ZpcnN0UFQ9PT1zJiYodGhpcy5fZmlyc3RQVD1zLl9uZXh0KSkscz1zLl9uZXh0O3JldHVybiExfSxuLl9yb3VuZFByb3BzPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBpPXRoaXMuX2ZpcnN0UFQ7aTspKHRbdGhpcy5fcHJvcE5hbWVdfHxudWxsIT1pLm4mJnRbaS5uLnNwbGl0KHRoaXMuX3Byb3BOYW1lK1wiX1wiKS5qb2luKFwiXCIpXSkmJihpLnI9ZSksaT1pLl9uZXh0fSxJLl9vblBsdWdpbkV2ZW50PWZ1bmN0aW9uKHQsZSl7dmFyIGkscyxyLG4sYSxvPWUuX2ZpcnN0UFQ7aWYoXCJfb25Jbml0QWxsUHJvcHNcIj09PXQpe2Zvcig7bzspe2ZvcihhPW8uX25leHQscz1yO3MmJnMucHI+by5wcjspcz1zLl9uZXh0OyhvLl9wcmV2PXM/cy5fcHJldjpuKT9vLl9wcmV2Ll9uZXh0PW86cj1vLChvLl9uZXh0PXMpP3MuX3ByZXY9bzpuPW8sbz1hfW89ZS5fZmlyc3RQVD1yfWZvcig7bzspby5wZyYmXCJmdW5jdGlvblwiPT10eXBlb2Ygby50W3RdJiZvLnRbdF0oKSYmKGk9ITApLG89by5fbmV4dDtyZXR1cm4gaX0sdGUuYWN0aXZhdGU9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQubGVuZ3RoOy0tZT4tMTspdFtlXS5BUEk9PT10ZS5BUEkmJihRWyhuZXcgdFtlXSkuX3Byb3BOYW1lXT10W2VdKTtyZXR1cm4hMH0sZC5wbHVnaW49ZnVuY3Rpb24odCl7aWYoISh0JiZ0LnByb3BOYW1lJiZ0LmluaXQmJnQuQVBJKSl0aHJvd1wiaWxsZWdhbCBwbHVnaW4gZGVmaW5pdGlvbi5cIjt2YXIgZSxpPXQucHJvcE5hbWUscz10LnByaW9yaXR5fHwwLHI9dC5vdmVyd3JpdGVQcm9wcyxuPXtpbml0OlwiX29uSW5pdFR3ZWVuXCIsc2V0Olwic2V0UmF0aW9cIixraWxsOlwiX2tpbGxcIixyb3VuZDpcIl9yb3VuZFByb3BzXCIsaW5pdEFsbDpcIl9vbkluaXRBbGxQcm9wc1wifSxhPXYoXCJwbHVnaW5zLlwiK2kuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkraS5zdWJzdHIoMSkrXCJQbHVnaW5cIixmdW5jdGlvbigpe3RlLmNhbGwodGhpcyxpLHMpLHRoaXMuX292ZXJ3cml0ZVByb3BzPXJ8fFtdfSx0Lmdsb2JhbD09PSEwKSxvPWEucHJvdG90eXBlPW5ldyB0ZShpKTtvLmNvbnN0cnVjdG9yPWEsYS5BUEk9dC5BUEk7Zm9yKGUgaW4gbilcImZ1bmN0aW9uXCI9PXR5cGVvZiB0W2VdJiYob1tuW2VdXT10W2VdKTtyZXR1cm4gYS52ZXJzaW9uPXQudmVyc2lvbix0ZS5hY3RpdmF0ZShbYV0pLGF9LHM9dC5fZ3NRdWV1ZSl7Zm9yKHI9MDtzLmxlbmd0aD5yO3IrKylzW3JdKCk7Zm9yKG4gaW4gbSltW25dLmZ1bmN8fHQuY29uc29sZS5sb2coXCJHU0FQIGVuY291bnRlcmVkIG1pc3NpbmcgZGVwZW5kZW5jeTogY29tLmdyZWVuc29jay5cIituKX1vPSExfX0pKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDp0aGlzfHx3aW5kb3csXCJUd2VlbkxpdGVcIik7Il19
},{}],39:[function(require,module,exports){
(function (global){
/*!
 * VERSION: 1.18.0
 * DATE: 2015-09-05
 * UPDATES AND DOCS AT: http://greensock.com
 * 
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2015, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope="undefined"!=typeof module&&module.exports&&"undefined"!=typeof global?global:this||window;(_gsScope._gsQueue||(_gsScope._gsQueue=[])).push(function(){"use strict";_gsScope._gsDefine("TweenMax",["core.Animation","core.SimpleTimeline","TweenLite"],function(t,e,i){var s=function(t){var e,i=[],s=t.length;for(e=0;e!==s;i.push(t[e++]));return i},r=function(t,e,i){var s,r,n=t.cycle;for(s in n)r=n[s],t[s]="function"==typeof r?r.call(e[i],i):r[i%r.length];delete t.cycle},n=function(t,e,s){i.call(this,t,e,s),this._cycle=0,this._yoyo=this.vars.yoyo===!0,this._repeat=this.vars.repeat||0,this._repeatDelay=this.vars.repeatDelay||0,this._dirty=!0,this.render=n.prototype.render},a=1e-10,o=i._internals,l=o.isSelector,h=o.isArray,_=n.prototype=i.to({},.1,{}),u=[];n.version="1.18.0",_.constructor=n,_.kill()._gc=!1,n.killTweensOf=n.killDelayedCallsTo=i.killTweensOf,n.getTweensOf=i.getTweensOf,n.lagSmoothing=i.lagSmoothing,n.ticker=i.ticker,n.render=i.render,_.invalidate=function(){return this._yoyo=this.vars.yoyo===!0,this._repeat=this.vars.repeat||0,this._repeatDelay=this.vars.repeatDelay||0,this._uncache(!0),i.prototype.invalidate.call(this)},_.updateTo=function(t,e){var s,r=this.ratio,n=this.vars.immediateRender||t.immediateRender;e&&this._startTime<this._timeline._time&&(this._startTime=this._timeline._time,this._uncache(!1),this._gc?this._enabled(!0,!1):this._timeline.insert(this,this._startTime-this._delay));for(s in t)this.vars[s]=t[s];if(this._initted||n)if(e)this._initted=!1,n&&this.render(0,!0,!0);else if(this._gc&&this._enabled(!0,!1),this._notifyPluginsOfEnabled&&this._firstPT&&i._onPluginEvent("_onDisable",this),this._time/this._duration>.998){var a=this._time;this.render(0,!0,!1),this._initted=!1,this.render(a,!0,!1)}else if(this._time>0||n){this._initted=!1,this._init();for(var o,l=1/(1-r),h=this._firstPT;h;)o=h.s+h.c,h.c*=l,h.s=o-h.c,h=h._next}return this},_.render=function(t,e,i){this._initted||0===this._duration&&this.vars.repeat&&this.invalidate();var s,r,n,l,h,_,u,c,f=this._dirty?this.totalDuration():this._totalDuration,p=this._time,m=this._totalTime,d=this._cycle,g=this._duration,v=this._rawPrevTime;if(t>=f?(this._totalTime=f,this._cycle=this._repeat,this._yoyo&&0!==(1&this._cycle)?(this._time=0,this.ratio=this._ease._calcEnd?this._ease.getRatio(0):0):(this._time=g,this.ratio=this._ease._calcEnd?this._ease.getRatio(1):1),this._reversed||(s=!0,r="onComplete",i=i||this._timeline.autoRemoveChildren),0===g&&(this._initted||!this.vars.lazy||i)&&(this._startTime===this._timeline._duration&&(t=0),(0===t||0>v||v===a)&&v!==t&&(i=!0,v>a&&(r="onReverseComplete")),this._rawPrevTime=c=!e||t||v===t?t:a)):1e-7>t?(this._totalTime=this._time=this._cycle=0,this.ratio=this._ease._calcEnd?this._ease.getRatio(0):0,(0!==m||0===g&&v>0)&&(r="onReverseComplete",s=this._reversed),0>t&&(this._active=!1,0===g&&(this._initted||!this.vars.lazy||i)&&(v>=0&&(i=!0),this._rawPrevTime=c=!e||t||v===t?t:a)),this._initted||(i=!0)):(this._totalTime=this._time=t,0!==this._repeat&&(l=g+this._repeatDelay,this._cycle=this._totalTime/l>>0,0!==this._cycle&&this._cycle===this._totalTime/l&&this._cycle--,this._time=this._totalTime-this._cycle*l,this._yoyo&&0!==(1&this._cycle)&&(this._time=g-this._time),this._time>g?this._time=g:0>this._time&&(this._time=0)),this._easeType?(h=this._time/g,_=this._easeType,u=this._easePower,(1===_||3===_&&h>=.5)&&(h=1-h),3===_&&(h*=2),1===u?h*=h:2===u?h*=h*h:3===u?h*=h*h*h:4===u&&(h*=h*h*h*h),this.ratio=1===_?1-h:2===_?h:.5>this._time/g?h/2:1-h/2):this.ratio=this._ease.getRatio(this._time/g)),p===this._time&&!i&&d===this._cycle)return m!==this._totalTime&&this._onUpdate&&(e||this._callback("onUpdate")),void 0;if(!this._initted){if(this._init(),!this._initted||this._gc)return;if(!i&&this._firstPT&&(this.vars.lazy!==!1&&this._duration||this.vars.lazy&&!this._duration))return this._time=p,this._totalTime=m,this._rawPrevTime=v,this._cycle=d,o.lazyTweens.push(this),this._lazy=[t,e],void 0;this._time&&!s?this.ratio=this._ease.getRatio(this._time/g):s&&this._ease._calcEnd&&(this.ratio=this._ease.getRatio(0===this._time?0:1))}for(this._lazy!==!1&&(this._lazy=!1),this._active||!this._paused&&this._time!==p&&t>=0&&(this._active=!0),0===m&&(2===this._initted&&t>0&&this._init(),this._startAt&&(t>=0?this._startAt.render(t,e,i):r||(r="_dummyGS")),this.vars.onStart&&(0!==this._totalTime||0===g)&&(e||this._callback("onStart"))),n=this._firstPT;n;)n.f?n.t[n.p](n.c*this.ratio+n.s):n.t[n.p]=n.c*this.ratio+n.s,n=n._next;this._onUpdate&&(0>t&&this._startAt&&this._startTime&&this._startAt.render(t,e,i),e||(this._totalTime!==m||s)&&this._callback("onUpdate")),this._cycle!==d&&(e||this._gc||this.vars.onRepeat&&this._callback("onRepeat")),r&&(!this._gc||i)&&(0>t&&this._startAt&&!this._onUpdate&&this._startTime&&this._startAt.render(t,e,i),s&&(this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!e&&this.vars[r]&&this._callback(r),0===g&&this._rawPrevTime===a&&c!==a&&(this._rawPrevTime=0))},n.to=function(t,e,i){return new n(t,e,i)},n.from=function(t,e,i){return i.runBackwards=!0,i.immediateRender=0!=i.immediateRender,new n(t,e,i)},n.fromTo=function(t,e,i,s){return s.startAt=i,s.immediateRender=0!=s.immediateRender&&0!=i.immediateRender,new n(t,e,s)},n.staggerTo=n.allTo=function(t,e,a,o,_,c,f){o=o||0;var p,m,d,g,v=a.delay||0,y=[],T=function(){a.onComplete&&a.onComplete.apply(a.onCompleteScope||this,arguments),_.apply(f||a.callbackScope||this,c||u)},x=a.cycle,w=a.startAt&&a.startAt.cycle;for(h(t)||("string"==typeof t&&(t=i.selector(t)||t),l(t)&&(t=s(t))),t=t||[],0>o&&(t=s(t),t.reverse(),o*=-1),p=t.length-1,d=0;p>=d;d++){m={};for(g in a)m[g]=a[g];if(x&&r(m,t,d),w){w=m.startAt={};for(g in a.startAt)w[g]=a.startAt[g];r(m.startAt,t,d)}m.delay=v,d===p&&_&&(m.onComplete=T),y[d]=new n(t[d],e,m),v+=o}return y},n.staggerFrom=n.allFrom=function(t,e,i,s,r,a,o){return i.runBackwards=!0,i.immediateRender=0!=i.immediateRender,n.staggerTo(t,e,i,s,r,a,o)},n.staggerFromTo=n.allFromTo=function(t,e,i,s,r,a,o,l){return s.startAt=i,s.immediateRender=0!=s.immediateRender&&0!=i.immediateRender,n.staggerTo(t,e,s,r,a,o,l)},n.delayedCall=function(t,e,i,s,r){return new n(e,0,{delay:t,onComplete:e,onCompleteParams:i,callbackScope:s,onReverseComplete:e,onReverseCompleteParams:i,immediateRender:!1,useFrames:r,overwrite:0})},n.set=function(t,e){return new n(t,0,e)},n.isTweening=function(t){return i.getTweensOf(t,!0).length>0};var c=function(t,e){for(var s=[],r=0,n=t._first;n;)n instanceof i?s[r++]=n:(e&&(s[r++]=n),s=s.concat(c(n,e)),r=s.length),n=n._next;return s},f=n.getAllTweens=function(e){return c(t._rootTimeline,e).concat(c(t._rootFramesTimeline,e))};n.killAll=function(t,i,s,r){null==i&&(i=!0),null==s&&(s=!0);var n,a,o,l=f(0!=r),h=l.length,_=i&&s&&r;for(o=0;h>o;o++)a=l[o],(_||a instanceof e||(n=a.target===a.vars.onComplete)&&s||i&&!n)&&(t?a.totalTime(a._reversed?0:a.totalDuration()):a._enabled(!1,!1))},n.killChildTweensOf=function(t,e){if(null!=t){var r,a,_,u,c,f=o.tweenLookup;if("string"==typeof t&&(t=i.selector(t)||t),l(t)&&(t=s(t)),h(t))for(u=t.length;--u>-1;)n.killChildTweensOf(t[u],e);else{r=[];for(_ in f)for(a=f[_].target.parentNode;a;)a===t&&(r=r.concat(f[_].tweens)),a=a.parentNode;for(c=r.length,u=0;c>u;u++)e&&r[u].totalTime(r[u].totalDuration()),r[u]._enabled(!1,!1)}}};var p=function(t,i,s,r){i=i!==!1,s=s!==!1,r=r!==!1;for(var n,a,o=f(r),l=i&&s&&r,h=o.length;--h>-1;)a=o[h],(l||a instanceof e||(n=a.target===a.vars.onComplete)&&s||i&&!n)&&a.paused(t)};return n.pauseAll=function(t,e,i){p(!0,t,e,i)},n.resumeAll=function(t,e,i){p(!1,t,e,i)},n.globalTimeScale=function(e){var s=t._rootTimeline,r=i.ticker.time;return arguments.length?(e=e||a,s._startTime=r-(r-s._startTime)*s._timeScale/e,s=t._rootFramesTimeline,r=i.ticker.frame,s._startTime=r-(r-s._startTime)*s._timeScale/e,s._timeScale=t._rootTimeline._timeScale=e,e):s._timeScale},_.progress=function(t){return arguments.length?this.totalTime(this.duration()*(this._yoyo&&0!==(1&this._cycle)?1-t:t)+this._cycle*(this._duration+this._repeatDelay),!1):this._time/this.duration()},_.totalProgress=function(t){return arguments.length?this.totalTime(this.totalDuration()*t,!1):this._totalTime/this.totalDuration()},_.time=function(t,e){return arguments.length?(this._dirty&&this.totalDuration(),t>this._duration&&(t=this._duration),this._yoyo&&0!==(1&this._cycle)?t=this._duration-t+this._cycle*(this._duration+this._repeatDelay):0!==this._repeat&&(t+=this._cycle*(this._duration+this._repeatDelay)),this.totalTime(t,e)):this._time},_.duration=function(e){return arguments.length?t.prototype.duration.call(this,e):this._duration},_.totalDuration=function(t){return arguments.length?-1===this._repeat?this:this.duration((t-this._repeat*this._repeatDelay)/(this._repeat+1)):(this._dirty&&(this._totalDuration=-1===this._repeat?999999999999:this._duration*(this._repeat+1)+this._repeatDelay*this._repeat,this._dirty=!1),this._totalDuration)},_.repeat=function(t){return arguments.length?(this._repeat=t,this._uncache(!0)):this._repeat},_.repeatDelay=function(t){return arguments.length?(this._repeatDelay=t,this._uncache(!0)):this._repeatDelay},_.yoyo=function(t){return arguments.length?(this._yoyo=t,this):this._yoyo},n},!0),_gsScope._gsDefine("TimelineLite",["core.Animation","core.SimpleTimeline","TweenLite"],function(t,e,i){var s=function(t){e.call(this,t),this._labels={},this.autoRemoveChildren=this.vars.autoRemoveChildren===!0,this.smoothChildTiming=this.vars.smoothChildTiming===!0,this._sortChildren=!0,this._onUpdate=this.vars.onUpdate;var i,s,r=this.vars;for(s in r)i=r[s],l(i)&&-1!==i.join("").indexOf("{self}")&&(r[s]=this._swapSelfInParams(i));l(r.tweens)&&this.add(r.tweens,0,r.align,r.stagger)},r=1e-10,n=i._internals,a=s._internals={},o=n.isSelector,l=n.isArray,h=n.lazyTweens,_=n.lazyRender,u=_gsScope._gsDefine.globals,c=function(t){var e,i={};for(e in t)i[e]=t[e];return i},f=function(t,e,i){var s,r,n=t.cycle;for(s in n)r=n[s],t[s]="function"==typeof r?r.call(e[i],i):r[i%r.length];delete t.cycle},p=a.pauseCallback=function(){},m=function(t){var e,i=[],s=t.length;for(e=0;e!==s;i.push(t[e++]));return i},d=s.prototype=new e;return s.version="1.18.0",d.constructor=s,d.kill()._gc=d._forcingPlayhead=d._hasPause=!1,d.to=function(t,e,s,r){var n=s.repeat&&u.TweenMax||i;return e?this.add(new n(t,e,s),r):this.set(t,s,r)},d.from=function(t,e,s,r){return this.add((s.repeat&&u.TweenMax||i).from(t,e,s),r)},d.fromTo=function(t,e,s,r,n){var a=r.repeat&&u.TweenMax||i;return e?this.add(a.fromTo(t,e,s,r),n):this.set(t,r,n)},d.staggerTo=function(t,e,r,n,a,l,h,_){var u,p,d=new s({onComplete:l,onCompleteParams:h,callbackScope:_,smoothChildTiming:this.smoothChildTiming}),g=r.cycle;for("string"==typeof t&&(t=i.selector(t)||t),t=t||[],o(t)&&(t=m(t)),n=n||0,0>n&&(t=m(t),t.reverse(),n*=-1),p=0;t.length>p;p++)u=c(r),u.startAt&&(u.startAt=c(u.startAt),u.startAt.cycle&&f(u.startAt,t,p)),g&&f(u,t,p),d.to(t[p],e,u,p*n);return this.add(d,a)},d.staggerFrom=function(t,e,i,s,r,n,a,o){return i.immediateRender=0!=i.immediateRender,i.runBackwards=!0,this.staggerTo(t,e,i,s,r,n,a,o)},d.staggerFromTo=function(t,e,i,s,r,n,a,o,l){return s.startAt=i,s.immediateRender=0!=s.immediateRender&&0!=i.immediateRender,this.staggerTo(t,e,s,r,n,a,o,l)},d.call=function(t,e,s,r){return this.add(i.delayedCall(0,t,e,s),r)},d.set=function(t,e,s){return s=this._parseTimeOrLabel(s,0,!0),null==e.immediateRender&&(e.immediateRender=s===this._time&&!this._paused),this.add(new i(t,0,e),s)},s.exportRoot=function(t,e){t=t||{},null==t.smoothChildTiming&&(t.smoothChildTiming=!0);var r,n,a=new s(t),o=a._timeline;for(null==e&&(e=!0),o._remove(a,!0),a._startTime=0,a._rawPrevTime=a._time=a._totalTime=o._time,r=o._first;r;)n=r._next,e&&r instanceof i&&r.target===r.vars.onComplete||a.add(r,r._startTime-r._delay),r=n;return o.add(a,0),a},d.add=function(r,n,a,o){var h,_,u,c,f,p;if("number"!=typeof n&&(n=this._parseTimeOrLabel(n,0,!0,r)),!(r instanceof t)){if(r instanceof Array||r&&r.push&&l(r)){for(a=a||"normal",o=o||0,h=n,_=r.length,u=0;_>u;u++)l(c=r[u])&&(c=new s({tweens:c})),this.add(c,h),"string"!=typeof c&&"function"!=typeof c&&("sequence"===a?h=c._startTime+c.totalDuration()/c._timeScale:"start"===a&&(c._startTime-=c.delay())),h+=o;return this._uncache(!0)}if("string"==typeof r)return this.addLabel(r,n);if("function"!=typeof r)throw"Cannot add "+r+" into the timeline; it is not a tween, timeline, function, or string.";r=i.delayedCall(0,r)}if(e.prototype.add.call(this,r,n),(this._gc||this._time===this._duration)&&!this._paused&&this._duration<this.duration())for(f=this,p=f.rawTime()>r._startTime;f._timeline;)p&&f._timeline.smoothChildTiming?f.totalTime(f._totalTime,!0):f._gc&&f._enabled(!0,!1),f=f._timeline;return this},d.remove=function(e){if(e instanceof t){this._remove(e,!1);var i=e._timeline=e.vars.useFrames?t._rootFramesTimeline:t._rootTimeline;return e._startTime=(e._paused?e._pauseTime:i._time)-(e._reversed?e.totalDuration()-e._totalTime:e._totalTime)/e._timeScale,this}if(e instanceof Array||e&&e.push&&l(e)){for(var s=e.length;--s>-1;)this.remove(e[s]);return this}return"string"==typeof e?this.removeLabel(e):this.kill(null,e)},d._remove=function(t,i){e.prototype._remove.call(this,t,i);var s=this._last;return s?this._time>s._startTime+s._totalDuration/s._timeScale&&(this._time=this.duration(),this._totalTime=this._totalDuration):this._time=this._totalTime=this._duration=this._totalDuration=0,this},d.append=function(t,e){return this.add(t,this._parseTimeOrLabel(null,e,!0,t))},d.insert=d.insertMultiple=function(t,e,i,s){return this.add(t,e||0,i,s)},d.appendMultiple=function(t,e,i,s){return this.add(t,this._parseTimeOrLabel(null,e,!0,t),i,s)},d.addLabel=function(t,e){return this._labels[t]=this._parseTimeOrLabel(e),this},d.addPause=function(t,e,s,r){var n=i.delayedCall(0,p,s,r||this);return n.vars.onComplete=n.vars.onReverseComplete=e,n.data="isPause",this._hasPause=!0,this.add(n,t)},d.removeLabel=function(t){return delete this._labels[t],this},d.getLabelTime=function(t){return null!=this._labels[t]?this._labels[t]:-1},d._parseTimeOrLabel=function(e,i,s,r){var n;if(r instanceof t&&r.timeline===this)this.remove(r);else if(r&&(r instanceof Array||r.push&&l(r)))for(n=r.length;--n>-1;)r[n]instanceof t&&r[n].timeline===this&&this.remove(r[n]);if("string"==typeof i)return this._parseTimeOrLabel(i,s&&"number"==typeof e&&null==this._labels[i]?e-this.duration():0,s);if(i=i||0,"string"!=typeof e||!isNaN(e)&&null==this._labels[e])null==e&&(e=this.duration());else{if(n=e.indexOf("="),-1===n)return null==this._labels[e]?s?this._labels[e]=this.duration()+i:i:this._labels[e]+i;i=parseInt(e.charAt(n-1)+"1",10)*Number(e.substr(n+1)),e=n>1?this._parseTimeOrLabel(e.substr(0,n-1),0,s):this.duration()}return Number(e)+i},d.seek=function(t,e){return this.totalTime("number"==typeof t?t:this._parseTimeOrLabel(t),e!==!1)},d.stop=function(){return this.paused(!0)},d.gotoAndPlay=function(t,e){return this.play(t,e)},d.gotoAndStop=function(t,e){return this.pause(t,e)},d.render=function(t,e,i){this._gc&&this._enabled(!0,!1);var s,n,a,o,l,u,c=this._dirty?this.totalDuration():this._totalDuration,f=this._time,p=this._startTime,m=this._timeScale,d=this._paused;if(t>=c)this._totalTime=this._time=c,this._reversed||this._hasPausedChild()||(n=!0,o="onComplete",l=!!this._timeline.autoRemoveChildren,0===this._duration&&(0===t||0>this._rawPrevTime||this._rawPrevTime===r)&&this._rawPrevTime!==t&&this._first&&(l=!0,this._rawPrevTime>r&&(o="onReverseComplete"))),this._rawPrevTime=this._duration||!e||t||this._rawPrevTime===t?t:r,t=c+1e-4;else if(1e-7>t)if(this._totalTime=this._time=0,(0!==f||0===this._duration&&this._rawPrevTime!==r&&(this._rawPrevTime>0||0>t&&this._rawPrevTime>=0))&&(o="onReverseComplete",n=this._reversed),0>t)this._active=!1,this._timeline.autoRemoveChildren&&this._reversed?(l=n=!0,o="onReverseComplete"):this._rawPrevTime>=0&&this._first&&(l=!0),this._rawPrevTime=t;else{if(this._rawPrevTime=this._duration||!e||t||this._rawPrevTime===t?t:r,0===t&&n)for(s=this._first;s&&0===s._startTime;)s._duration||(n=!1),s=s._next;t=0,this._initted||(l=!0)}else{if(this._hasPause&&!this._forcingPlayhead&&!e){if(t>=f)for(s=this._first;s&&t>=s._startTime&&!u;)s._duration||"isPause"!==s.data||s.ratio||0===s._startTime&&0===this._rawPrevTime||(u=s),s=s._next;else for(s=this._last;s&&s._startTime>=t&&!u;)s._duration||"isPause"===s.data&&s._rawPrevTime>0&&(u=s),s=s._prev;u&&(this._time=t=u._startTime,this._totalTime=t+this._cycle*(this._totalDuration+this._repeatDelay))}this._totalTime=this._time=this._rawPrevTime=t}if(this._time!==f&&this._first||i||l||u){if(this._initted||(this._initted=!0),this._active||!this._paused&&this._time!==f&&t>0&&(this._active=!0),0===f&&this.vars.onStart&&0!==this._time&&(e||this._callback("onStart")),this._time>=f)for(s=this._first;s&&(a=s._next,!this._paused||d);)(s._active||s._startTime<=this._time&&!s._paused&&!s._gc)&&(u===s&&this.pause(),s._reversed?s.render((s._dirty?s.totalDuration():s._totalDuration)-(t-s._startTime)*s._timeScale,e,i):s.render((t-s._startTime)*s._timeScale,e,i)),s=a;else for(s=this._last;s&&(a=s._prev,!this._paused||d);){if(s._active||f>=s._startTime&&!s._paused&&!s._gc){if(u===s){for(u=s._prev;u&&u.endTime()>this._time;)u.render(u._reversed?u.totalDuration()-(t-u._startTime)*u._timeScale:(t-u._startTime)*u._timeScale,e,i),u=u._prev;u=null,this.pause()}s._reversed?s.render((s._dirty?s.totalDuration():s._totalDuration)-(t-s._startTime)*s._timeScale,e,i):s.render((t-s._startTime)*s._timeScale,e,i)}s=a}this._onUpdate&&(e||(h.length&&_(),this._callback("onUpdate"))),o&&(this._gc||(p===this._startTime||m!==this._timeScale)&&(0===this._time||c>=this.totalDuration())&&(n&&(h.length&&_(),this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!e&&this.vars[o]&&this._callback(o)))}},d._hasPausedChild=function(){for(var t=this._first;t;){if(t._paused||t instanceof s&&t._hasPausedChild())return!0;t=t._next}return!1},d.getChildren=function(t,e,s,r){r=r||-9999999999;for(var n=[],a=this._first,o=0;a;)r>a._startTime||(a instanceof i?e!==!1&&(n[o++]=a):(s!==!1&&(n[o++]=a),t!==!1&&(n=n.concat(a.getChildren(!0,e,s)),o=n.length))),a=a._next;return n},d.getTweensOf=function(t,e){var s,r,n=this._gc,a=[],o=0;for(n&&this._enabled(!0,!0),s=i.getTweensOf(t),r=s.length;--r>-1;)(s[r].timeline===this||e&&this._contains(s[r]))&&(a[o++]=s[r]);return n&&this._enabled(!1,!0),a},d.recent=function(){return this._recent},d._contains=function(t){for(var e=t.timeline;e;){if(e===this)return!0;e=e.timeline}return!1},d.shiftChildren=function(t,e,i){i=i||0;for(var s,r=this._first,n=this._labels;r;)r._startTime>=i&&(r._startTime+=t),r=r._next;if(e)for(s in n)n[s]>=i&&(n[s]+=t);return this._uncache(!0)},d._kill=function(t,e){if(!t&&!e)return this._enabled(!1,!1);for(var i=e?this.getTweensOf(e):this.getChildren(!0,!0,!1),s=i.length,r=!1;--s>-1;)i[s]._kill(t,e)&&(r=!0);return r},d.clear=function(t){var e=this.getChildren(!1,!0,!0),i=e.length;for(this._time=this._totalTime=0;--i>-1;)e[i]._enabled(!1,!1);return t!==!1&&(this._labels={}),this._uncache(!0)},d.invalidate=function(){for(var e=this._first;e;)e.invalidate(),e=e._next;return t.prototype.invalidate.call(this)},d._enabled=function(t,i){if(t===this._gc)for(var s=this._first;s;)s._enabled(t,!0),s=s._next;return e.prototype._enabled.call(this,t,i)},d.totalTime=function(){this._forcingPlayhead=!0;var e=t.prototype.totalTime.apply(this,arguments);return this._forcingPlayhead=!1,e},d.duration=function(t){return arguments.length?(0!==this.duration()&&0!==t&&this.timeScale(this._duration/t),this):(this._dirty&&this.totalDuration(),this._duration)},d.totalDuration=function(t){if(!arguments.length){if(this._dirty){for(var e,i,s=0,r=this._last,n=999999999999;r;)e=r._prev,r._dirty&&r.totalDuration(),r._startTime>n&&this._sortChildren&&!r._paused?this.add(r,r._startTime-r._delay):n=r._startTime,0>r._startTime&&!r._paused&&(s-=r._startTime,this._timeline.smoothChildTiming&&(this._startTime+=r._startTime/this._timeScale),this.shiftChildren(-r._startTime,!1,-9999999999),n=0),i=r._startTime+r._totalDuration/r._timeScale,i>s&&(s=i),r=e;this._duration=this._totalDuration=s,this._dirty=!1}return this._totalDuration}return 0!==this.totalDuration()&&0!==t&&this.timeScale(this._totalDuration/t),this},d.paused=function(e){if(!e)for(var i=this._first,s=this._time;i;)i._startTime===s&&"isPause"===i.data&&(i._rawPrevTime=0),i=i._next;return t.prototype.paused.apply(this,arguments)},d.usesFrames=function(){for(var e=this._timeline;e._timeline;)e=e._timeline;return e===t._rootFramesTimeline},d.rawTime=function(){return this._paused?this._totalTime:(this._timeline.rawTime()-this._startTime)*this._timeScale},s},!0),_gsScope._gsDefine("TimelineMax",["TimelineLite","TweenLite","easing.Ease"],function(t,e,i){var s=function(e){t.call(this,e),this._repeat=this.vars.repeat||0,this._repeatDelay=this.vars.repeatDelay||0,this._cycle=0,this._yoyo=this.vars.yoyo===!0,this._dirty=!0},r=1e-10,n=e._internals,a=n.lazyTweens,o=n.lazyRender,l=new i(null,null,1,0),h=s.prototype=new t;return h.constructor=s,h.kill()._gc=!1,s.version="1.18.0",h.invalidate=function(){return this._yoyo=this.vars.yoyo===!0,this._repeat=this.vars.repeat||0,this._repeatDelay=this.vars.repeatDelay||0,this._uncache(!0),t.prototype.invalidate.call(this)},h.addCallback=function(t,i,s,r){return this.add(e.delayedCall(0,t,s,r),i)},h.removeCallback=function(t,e){if(t)if(null==e)this._kill(null,t);else for(var i=this.getTweensOf(t,!1),s=i.length,r=this._parseTimeOrLabel(e);--s>-1;)i[s]._startTime===r&&i[s]._enabled(!1,!1);return this},h.removePause=function(e){return this.removeCallback(t._internals.pauseCallback,e)},h.tweenTo=function(t,i){i=i||{};var s,r,n,a={ease:l,useFrames:this.usesFrames(),immediateRender:!1};for(r in i)a[r]=i[r];return a.time=this._parseTimeOrLabel(t),s=Math.abs(Number(a.time)-this._time)/this._timeScale||.001,n=new e(this,s,a),a.onStart=function(){n.target.paused(!0),n.vars.time!==n.target.time()&&s===n.duration()&&n.duration(Math.abs(n.vars.time-n.target.time())/n.target._timeScale),i.onStart&&n._callback("onStart")},n},h.tweenFromTo=function(t,e,i){i=i||{},t=this._parseTimeOrLabel(t),i.startAt={onComplete:this.seek,onCompleteParams:[t],callbackScope:this},i.immediateRender=i.immediateRender!==!1;var s=this.tweenTo(e,i);return s.duration(Math.abs(s.vars.time-t)/this._timeScale||.001)},h.render=function(t,e,i){this._gc&&this._enabled(!0,!1);var s,n,l,h,_,u,c,f=this._dirty?this.totalDuration():this._totalDuration,p=this._duration,m=this._time,d=this._totalTime,g=this._startTime,v=this._timeScale,y=this._rawPrevTime,T=this._paused,x=this._cycle;if(t>=f)this._locked||(this._totalTime=f,this._cycle=this._repeat),this._reversed||this._hasPausedChild()||(n=!0,h="onComplete",_=!!this._timeline.autoRemoveChildren,0===this._duration&&(0===t||0>y||y===r)&&y!==t&&this._first&&(_=!0,y>r&&(h="onReverseComplete"))),this._rawPrevTime=this._duration||!e||t||this._rawPrevTime===t?t:r,this._yoyo&&0!==(1&this._cycle)?this._time=t=0:(this._time=p,t=p+1e-4);else if(1e-7>t)if(this._locked||(this._totalTime=this._cycle=0),this._time=0,(0!==m||0===p&&y!==r&&(y>0||0>t&&y>=0)&&!this._locked)&&(h="onReverseComplete",n=this._reversed),0>t)this._active=!1,this._timeline.autoRemoveChildren&&this._reversed?(_=n=!0,h="onReverseComplete"):y>=0&&this._first&&(_=!0),this._rawPrevTime=t;else{if(this._rawPrevTime=p||!e||t||this._rawPrevTime===t?t:r,0===t&&n)for(s=this._first;s&&0===s._startTime;)s._duration||(n=!1),s=s._next;t=0,this._initted||(_=!0)}else if(0===p&&0>y&&(_=!0),this._time=this._rawPrevTime=t,this._locked||(this._totalTime=t,0!==this._repeat&&(u=p+this._repeatDelay,this._cycle=this._totalTime/u>>0,0!==this._cycle&&this._cycle===this._totalTime/u&&this._cycle--,this._time=this._totalTime-this._cycle*u,this._yoyo&&0!==(1&this._cycle)&&(this._time=p-this._time),this._time>p?(this._time=p,t=p+1e-4):0>this._time?this._time=t=0:t=this._time)),this._hasPause&&!this._forcingPlayhead&&!e){if(t=this._time,t>=m)for(s=this._first;s&&t>=s._startTime&&!c;)s._duration||"isPause"!==s.data||s.ratio||0===s._startTime&&0===this._rawPrevTime||(c=s),s=s._next;else for(s=this._last;s&&s._startTime>=t&&!c;)s._duration||"isPause"===s.data&&s._rawPrevTime>0&&(c=s),s=s._prev;c&&(this._time=t=c._startTime,this._totalTime=t+this._cycle*(this._totalDuration+this._repeatDelay))}if(this._cycle!==x&&!this._locked){var w=this._yoyo&&0!==(1&x),b=w===(this._yoyo&&0!==(1&this._cycle)),P=this._totalTime,k=this._cycle,S=this._rawPrevTime,R=this._time;if(this._totalTime=x*p,x>this._cycle?w=!w:this._totalTime+=p,this._time=m,this._rawPrevTime=0===p?y-1e-4:y,this._cycle=x,this._locked=!0,m=w?0:p,this.render(m,e,0===p),e||this._gc||this.vars.onRepeat&&this._callback("onRepeat"),b&&(m=w?p+1e-4:-1e-4,this.render(m,!0,!1)),this._locked=!1,this._paused&&!T)return;this._time=R,this._totalTime=P,this._cycle=k,this._rawPrevTime=S}if(!(this._time!==m&&this._first||i||_||c))return d!==this._totalTime&&this._onUpdate&&(e||this._callback("onUpdate")),void 0;if(this._initted||(this._initted=!0),this._active||!this._paused&&this._totalTime!==d&&t>0&&(this._active=!0),0===d&&this.vars.onStart&&0!==this._totalTime&&(e||this._callback("onStart")),this._time>=m)for(s=this._first;s&&(l=s._next,!this._paused||T);)(s._active||s._startTime<=this._time&&!s._paused&&!s._gc)&&(c===s&&this.pause(),s._reversed?s.render((s._dirty?s.totalDuration():s._totalDuration)-(t-s._startTime)*s._timeScale,e,i):s.render((t-s._startTime)*s._timeScale,e,i)),s=l;else for(s=this._last;s&&(l=s._prev,!this._paused||T);){if(s._active||m>=s._startTime&&!s._paused&&!s._gc){if(c===s){for(c=s._prev;c&&c.endTime()>this._time;)c.render(c._reversed?c.totalDuration()-(t-c._startTime)*c._timeScale:(t-c._startTime)*c._timeScale,e,i),c=c._prev;c=null,this.pause()}s._reversed?s.render((s._dirty?s.totalDuration():s._totalDuration)-(t-s._startTime)*s._timeScale,e,i):s.render((t-s._startTime)*s._timeScale,e,i)}s=l}this._onUpdate&&(e||(a.length&&o(),this._callback("onUpdate"))),h&&(this._locked||this._gc||(g===this._startTime||v!==this._timeScale)&&(0===this._time||f>=this.totalDuration())&&(n&&(a.length&&o(),this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!e&&this.vars[h]&&this._callback(h)))},h.getActive=function(t,e,i){null==t&&(t=!0),null==e&&(e=!0),null==i&&(i=!1);var s,r,n=[],a=this.getChildren(t,e,i),o=0,l=a.length;for(s=0;l>s;s++)r=a[s],r.isActive()&&(n[o++]=r);return n},h.getLabelAfter=function(t){t||0!==t&&(t=this._time);var e,i=this.getLabelsArray(),s=i.length;for(e=0;s>e;e++)if(i[e].time>t)return i[e].name;return null},h.getLabelBefore=function(t){null==t&&(t=this._time);for(var e=this.getLabelsArray(),i=e.length;--i>-1;)if(t>e[i].time)return e[i].name;return null},h.getLabelsArray=function(){var t,e=[],i=0;for(t in this._labels)e[i++]={time:this._labels[t],name:t};return e.sort(function(t,e){return t.time-e.time}),e},h.progress=function(t,e){return arguments.length?this.totalTime(this.duration()*(this._yoyo&&0!==(1&this._cycle)?1-t:t)+this._cycle*(this._duration+this._repeatDelay),e):this._time/this.duration()},h.totalProgress=function(t,e){return arguments.length?this.totalTime(this.totalDuration()*t,e):this._totalTime/this.totalDuration()},h.totalDuration=function(e){return arguments.length?-1===this._repeat?this:this.duration((e-this._repeat*this._repeatDelay)/(this._repeat+1)):(this._dirty&&(t.prototype.totalDuration.call(this),this._totalDuration=-1===this._repeat?999999999999:this._duration*(this._repeat+1)+this._repeatDelay*this._repeat),this._totalDuration)},h.time=function(t,e){return arguments.length?(this._dirty&&this.totalDuration(),t>this._duration&&(t=this._duration),this._yoyo&&0!==(1&this._cycle)?t=this._duration-t+this._cycle*(this._duration+this._repeatDelay):0!==this._repeat&&(t+=this._cycle*(this._duration+this._repeatDelay)),this.totalTime(t,e)):this._time},h.repeat=function(t){return arguments.length?(this._repeat=t,this._uncache(!0)):this._repeat},h.repeatDelay=function(t){return arguments.length?(this._repeatDelay=t,this._uncache(!0)):this._repeatDelay},h.yoyo=function(t){return arguments.length?(this._yoyo=t,this):this._yoyo},h.currentLabel=function(t){return arguments.length?this.seek(t,!0):this.getLabelBefore(this._time+1e-8)},s},!0),function(){var t=180/Math.PI,e=[],i=[],s=[],r={},n=_gsScope._gsDefine.globals,a=function(t,e,i,s){this.a=t,this.b=e,this.c=i,this.d=s,this.da=s-t,this.ca=i-t,this.ba=e-t},o=",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",l=function(t,e,i,s){var r={a:t},n={},a={},o={c:s},l=(t+e)/2,h=(e+i)/2,_=(i+s)/2,u=(l+h)/2,c=(h+_)/2,f=(c-u)/8;return r.b=l+(t-l)/4,n.b=u+f,r.c=n.a=(r.b+n.b)/2,n.c=a.a=(u+c)/2,a.b=c-f,o.b=_+(s-_)/4,a.c=o.a=(a.b+o.b)/2,[r,n,a,o]},h=function(t,r,n,a,o){var h,_,u,c,f,p,m,d,g,v,y,T,x,w=t.length-1,b=0,P=t[0].a;for(h=0;w>h;h++)f=t[b],_=f.a,u=f.d,c=t[b+1].d,o?(y=e[h],T=i[h],x=.25*(T+y)*r/(a?.5:s[h]||.5),p=u-(u-_)*(a?.5*r:0!==y?x/y:0),m=u+(c-u)*(a?.5*r:0!==T?x/T:0),d=u-(p+((m-p)*(3*y/(y+T)+.5)/4||0))):(p=u-.5*(u-_)*r,m=u+.5*(c-u)*r,d=u-(p+m)/2),p+=d,m+=d,f.c=g=p,f.b=0!==h?P:P=f.a+.6*(f.c-f.a),f.da=u-_,f.ca=g-_,f.ba=P-_,n?(v=l(_,P,g,u),t.splice(b,1,v[0],v[1],v[2],v[3]),b+=4):b++,P=m;f=t[b],f.b=P,f.c=P+.4*(f.d-P),f.da=f.d-f.a,f.ca=f.c-f.a,f.ba=P-f.a,n&&(v=l(f.a,P,f.c,f.d),t.splice(b,1,v[0],v[1],v[2],v[3]))},_=function(t,s,r,n){var o,l,h,_,u,c,f=[];if(n)for(t=[n].concat(t),l=t.length;--l>-1;)"string"==typeof(c=t[l][s])&&"="===c.charAt(1)&&(t[l][s]=n[s]+Number(c.charAt(0)+c.substr(2)));if(o=t.length-2,0>o)return f[0]=new a(t[0][s],0,0,t[-1>o?0:1][s]),f;for(l=0;o>l;l++)h=t[l][s],_=t[l+1][s],f[l]=new a(h,0,0,_),r&&(u=t[l+2][s],e[l]=(e[l]||0)+(_-h)*(_-h),i[l]=(i[l]||0)+(u-_)*(u-_));return f[l]=new a(t[l][s],0,0,t[l+1][s]),f},u=function(t,n,a,l,u,c){var f,p,m,d,g,v,y,T,x={},w=[],b=c||t[0];u="string"==typeof u?","+u+",":o,null==n&&(n=1);for(p in t[0])w.push(p);if(t.length>1){for(T=t[t.length-1],y=!0,f=w.length;--f>-1;)if(p=w[f],Math.abs(b[p]-T[p])>.05){y=!1;break}y&&(t=t.concat(),c&&t.unshift(c),t.push(t[1]),c=t[t.length-3])}for(e.length=i.length=s.length=0,f=w.length;--f>-1;)p=w[f],r[p]=-1!==u.indexOf(","+p+","),x[p]=_(t,p,r[p],c);for(f=e.length;--f>-1;)e[f]=Math.sqrt(e[f]),i[f]=Math.sqrt(i[f]);if(!l){for(f=w.length;--f>-1;)if(r[p])for(m=x[w[f]],v=m.length-1,d=0;v>d;d++)g=m[d+1].da/i[d]+m[d].da/e[d],s[d]=(s[d]||0)+g*g;for(f=s.length;--f>-1;)s[f]=Math.sqrt(s[f])}for(f=w.length,d=a?4:1;--f>-1;)p=w[f],m=x[p],h(m,n,a,l,r[p]),y&&(m.splice(0,d),m.splice(m.length-d,d));return x},c=function(t,e,i){e=e||"soft";var s,r,n,o,l,h,_,u,c,f,p,m={},d="cubic"===e?3:2,g="soft"===e,v=[];if(g&&i&&(t=[i].concat(t)),null==t||d+1>t.length)throw"invalid Bezier data";for(c in t[0])v.push(c);for(h=v.length;--h>-1;){for(c=v[h],m[c]=l=[],f=0,u=t.length,_=0;u>_;_++)s=null==i?t[_][c]:"string"==typeof(p=t[_][c])&&"="===p.charAt(1)?i[c]+Number(p.charAt(0)+p.substr(2)):Number(p),g&&_>1&&u-1>_&&(l[f++]=(s+l[f-2])/2),l[f++]=s;for(u=f-d+1,f=0,_=0;u>_;_+=d)s=l[_],r=l[_+1],n=l[_+2],o=2===d?0:l[_+3],l[f++]=p=3===d?new a(s,r,n,o):new a(s,(2*r+s)/3,(2*r+n)/3,n);l.length=f}return m},f=function(t,e,i){for(var s,r,n,a,o,l,h,_,u,c,f,p=1/i,m=t.length;--m>-1;)for(c=t[m],n=c.a,a=c.d-n,o=c.c-n,l=c.b-n,s=r=0,_=1;i>=_;_++)h=p*_,u=1-h,s=r-(r=(h*h*a+3*u*(h*o+u*l))*h),f=m*i+_-1,e[f]=(e[f]||0)+s*s},p=function(t,e){e=e>>0||6;var i,s,r,n,a=[],o=[],l=0,h=0,_=e-1,u=[],c=[];for(i in t)f(t[i],a,e);for(r=a.length,s=0;r>s;s++)l+=Math.sqrt(a[s]),n=s%e,c[n]=l,n===_&&(h+=l,n=s/e>>0,u[n]=c,o[n]=h,l=0,c=[]);return{length:h,lengths:o,segments:u}},m=_gsScope._gsDefine.plugin({propName:"bezier",priority:-1,version:"1.3.4",API:2,global:!0,init:function(t,e,i){this._target=t,e instanceof Array&&(e={values:e}),this._func={},this._round={},this._props=[],this._timeRes=null==e.timeResolution?6:parseInt(e.timeResolution,10);var s,r,n,a,o,l=e.values||[],h={},_=l[0],f=e.autoRotate||i.vars.orientToBezier;this._autoRotate=f?f instanceof Array?f:[["x","y","rotation",f===!0?0:Number(f)||0]]:null;
for(s in _)this._props.push(s);for(n=this._props.length;--n>-1;)s=this._props[n],this._overwriteProps.push(s),r=this._func[s]="function"==typeof t[s],h[s]=r?t[s.indexOf("set")||"function"!=typeof t["get"+s.substr(3)]?s:"get"+s.substr(3)]():parseFloat(t[s]),o||h[s]!==l[0][s]&&(o=h);if(this._beziers="cubic"!==e.type&&"quadratic"!==e.type&&"soft"!==e.type?u(l,isNaN(e.curviness)?1:e.curviness,!1,"thruBasic"===e.type,e.correlate,o):c(l,e.type,h),this._segCount=this._beziers[s].length,this._timeRes){var m=p(this._beziers,this._timeRes);this._length=m.length,this._lengths=m.lengths,this._segments=m.segments,this._l1=this._li=this._s1=this._si=0,this._l2=this._lengths[0],this._curSeg=this._segments[0],this._s2=this._curSeg[0],this._prec=1/this._curSeg.length}if(f=this._autoRotate)for(this._initialRotations=[],f[0]instanceof Array||(this._autoRotate=f=[f]),n=f.length;--n>-1;){for(a=0;3>a;a++)s=f[n][a],this._func[s]="function"==typeof t[s]?t[s.indexOf("set")||"function"!=typeof t["get"+s.substr(3)]?s:"get"+s.substr(3)]:!1;s=f[n][2],this._initialRotations[n]=this._func[s]?this._func[s].call(this._target):this._target[s]}return this._startRatio=i.vars.runBackwards?1:0,!0},set:function(e){var i,s,r,n,a,o,l,h,_,u,c=this._segCount,f=this._func,p=this._target,m=e!==this._startRatio;if(this._timeRes){if(_=this._lengths,u=this._curSeg,e*=this._length,r=this._li,e>this._l2&&c-1>r){for(h=c-1;h>r&&e>=(this._l2=_[++r]););this._l1=_[r-1],this._li=r,this._curSeg=u=this._segments[r],this._s2=u[this._s1=this._si=0]}else if(this._l1>e&&r>0){for(;r>0&&(this._l1=_[--r])>=e;);0===r&&this._l1>e?this._l1=0:r++,this._l2=_[r],this._li=r,this._curSeg=u=this._segments[r],this._s1=u[(this._si=u.length-1)-1]||0,this._s2=u[this._si]}if(i=r,e-=this._l1,r=this._si,e>this._s2&&u.length-1>r){for(h=u.length-1;h>r&&e>=(this._s2=u[++r]););this._s1=u[r-1],this._si=r}else if(this._s1>e&&r>0){for(;r>0&&(this._s1=u[--r])>=e;);0===r&&this._s1>e?this._s1=0:r++,this._s2=u[r],this._si=r}o=(r+(e-this._s1)/(this._s2-this._s1))*this._prec}else i=0>e?0:e>=1?c-1:c*e>>0,o=(e-i*(1/c))*c;for(s=1-o,r=this._props.length;--r>-1;)n=this._props[r],a=this._beziers[n][i],l=(o*o*a.da+3*s*(o*a.ca+s*a.ba))*o+a.a,this._round[n]&&(l=Math.round(l)),f[n]?p[n](l):p[n]=l;if(this._autoRotate){var d,g,v,y,T,x,w,b=this._autoRotate;for(r=b.length;--r>-1;)n=b[r][2],x=b[r][3]||0,w=b[r][4]===!0?1:t,a=this._beziers[b[r][0]],d=this._beziers[b[r][1]],a&&d&&(a=a[i],d=d[i],g=a.a+(a.b-a.a)*o,y=a.b+(a.c-a.b)*o,g+=(y-g)*o,y+=(a.c+(a.d-a.c)*o-y)*o,v=d.a+(d.b-d.a)*o,T=d.b+(d.c-d.b)*o,v+=(T-v)*o,T+=(d.c+(d.d-d.c)*o-T)*o,l=m?Math.atan2(T-v,y-g)*w+x:this._initialRotations[r],f[n]?p[n](l):p[n]=l)}}}),d=m.prototype;m.bezierThrough=u,m.cubicToQuadratic=l,m._autoCSS=!0,m.quadraticToCubic=function(t,e,i){return new a(t,(2*e+t)/3,(2*e+i)/3,i)},m._cssRegister=function(){var t=n.CSSPlugin;if(t){var e=t._internals,i=e._parseToProxy,s=e._setPluginRatio,r=e.CSSPropTween;e._registerComplexSpecialProp("bezier",{parser:function(t,e,n,a,o,l){e instanceof Array&&(e={values:e}),l=new m;var h,_,u,c=e.values,f=c.length-1,p=[],d={};if(0>f)return o;for(h=0;f>=h;h++)u=i(t,c[h],a,o,l,f!==h),p[h]=u.end;for(_ in e)d[_]=e[_];return d.values=p,o=new r(t,"bezier",0,0,u.pt,2),o.data=u,o.plugin=l,o.setRatio=s,0===d.autoRotate&&(d.autoRotate=!0),!d.autoRotate||d.autoRotate instanceof Array||(h=d.autoRotate===!0?0:Number(d.autoRotate),d.autoRotate=null!=u.end.left?[["left","top","rotation",h,!1]]:null!=u.end.x?[["x","y","rotation",h,!1]]:!1),d.autoRotate&&(a._transform||a._enableTransforms(!1),u.autoRotate=a._target._gsTransform),l._onInitTween(u.proxy,d,a._tween),o}})}},d._roundProps=function(t,e){for(var i=this._overwriteProps,s=i.length;--s>-1;)(t[i[s]]||t.bezier||t.bezierThrough)&&(this._round[i[s]]=e)},d._kill=function(t){var e,i,s=this._props;for(e in this._beziers)if(e in t)for(delete this._beziers[e],delete this._func[e],i=s.length;--i>-1;)s[i]===e&&s.splice(i,1);return this._super._kill.call(this,t)}}(),_gsScope._gsDefine("plugins.CSSPlugin",["plugins.TweenPlugin","TweenLite"],function(t,e){var i,s,r,n,a=function(){t.call(this,"css"),this._overwriteProps.length=0,this.setRatio=a.prototype.setRatio},o=_gsScope._gsDefine.globals,l={},h=a.prototype=new t("css");h.constructor=a,a.version="1.18.0",a.API=2,a.defaultTransformPerspective=0,a.defaultSkewType="compensated",a.defaultSmoothOrigin=!0,h="px",a.suffixMap={top:h,right:h,bottom:h,left:h,width:h,height:h,fontSize:h,padding:h,margin:h,perspective:h,lineHeight:""};var _,u,c,f,p,m,d=/(?:\d|\-\d|\.\d|\-\.\d)+/g,g=/(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,v=/(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,y=/(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,T=/(?:\d|\-|\+|=|#|\.)*/g,x=/opacity *= *([^)]*)/i,w=/opacity:([^;]*)/i,b=/alpha\(opacity *=.+?\)/i,P=/^(rgb|hsl)/,k=/([A-Z])/g,S=/-([a-z])/gi,R=/(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,O=function(t,e){return e.toUpperCase()},A=/(?:Left|Right|Width)/i,C=/(M11|M12|M21|M22)=[\d\-\.e]+/gi,D=/progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,M=/,(?=[^\)]*(?:\(|$))/gi,z=Math.PI/180,F=180/Math.PI,I={},E=document,N=function(t){return E.createElementNS?E.createElementNS("http://www.w3.org/1999/xhtml",t):E.createElement(t)},L=N("div"),X=N("img"),B=a._internals={_specialProps:l},j=navigator.userAgent,Y=function(){var t=j.indexOf("Android"),e=N("a");return c=-1!==j.indexOf("Safari")&&-1===j.indexOf("Chrome")&&(-1===t||Number(j.substr(t+8,1))>3),p=c&&6>Number(j.substr(j.indexOf("Version/")+8,1)),f=-1!==j.indexOf("Firefox"),(/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(j)||/Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(j))&&(m=parseFloat(RegExp.$1)),e?(e.style.cssText="top:1px;opacity:.55;",/^0.55/.test(e.style.opacity)):!1}(),U=function(t){return x.test("string"==typeof t?t:(t.currentStyle?t.currentStyle.filter:t.style.filter)||"")?parseFloat(RegExp.$1)/100:1},q=function(t){window.console&&console.log(t)},V="",G="",W=function(t,e){e=e||L;var i,s,r=e.style;if(void 0!==r[t])return t;for(t=t.charAt(0).toUpperCase()+t.substr(1),i=["O","Moz","ms","Ms","Webkit"],s=5;--s>-1&&void 0===r[i[s]+t];);return s>=0?(G=3===s?"ms":i[s],V="-"+G.toLowerCase()+"-",G+t):null},Z=E.defaultView?E.defaultView.getComputedStyle:function(){},Q=a.getStyle=function(t,e,i,s,r){var n;return Y||"opacity"!==e?(!s&&t.style[e]?n=t.style[e]:(i=i||Z(t))?n=i[e]||i.getPropertyValue(e)||i.getPropertyValue(e.replace(k,"-$1").toLowerCase()):t.currentStyle&&(n=t.currentStyle[e]),null==r||n&&"none"!==n&&"auto"!==n&&"auto auto"!==n?n:r):U(t)},$=B.convertToPixels=function(t,i,s,r,n){if("px"===r||!r)return s;if("auto"===r||!s)return 0;var o,l,h,_=A.test(i),u=t,c=L.style,f=0>s;if(f&&(s=-s),"%"===r&&-1!==i.indexOf("border"))o=s/100*(_?t.clientWidth:t.clientHeight);else{if(c.cssText="border:0 solid red;position:"+Q(t,"position")+";line-height:0;","%"!==r&&u.appendChild&&"v"!==r.charAt(0)&&"rem"!==r)c[_?"borderLeftWidth":"borderTopWidth"]=s+r;else{if(u=t.parentNode||E.body,l=u._gsCache,h=e.ticker.frame,l&&_&&l.time===h)return l.width*s/100;c[_?"width":"height"]=s+r}u.appendChild(L),o=parseFloat(L[_?"offsetWidth":"offsetHeight"]),u.removeChild(L),_&&"%"===r&&a.cacheWidths!==!1&&(l=u._gsCache=u._gsCache||{},l.time=h,l.width=100*(o/s)),0!==o||n||(o=$(t,i,s,r,!0))}return f?-o:o},H=B.calculateOffset=function(t,e,i){if("absolute"!==Q(t,"position",i))return 0;var s="left"===e?"Left":"Top",r=Q(t,"margin"+s,i);return t["offset"+s]-($(t,e,parseFloat(r),r.replace(T,""))||0)},K=function(t,e){var i,s,r,n={};if(e=e||Z(t,null))if(i=e.length)for(;--i>-1;)r=e[i],(-1===r.indexOf("-transform")||ke===r)&&(n[r.replace(S,O)]=e.getPropertyValue(r));else for(i in e)(-1===i.indexOf("Transform")||Pe===i)&&(n[i]=e[i]);else if(e=t.currentStyle||t.style)for(i in e)"string"==typeof i&&void 0===n[i]&&(n[i.replace(S,O)]=e[i]);return Y||(n.opacity=U(t)),s=Ne(t,e,!1),n.rotation=s.rotation,n.skewX=s.skewX,n.scaleX=s.scaleX,n.scaleY=s.scaleY,n.x=s.x,n.y=s.y,Re&&(n.z=s.z,n.rotationX=s.rotationX,n.rotationY=s.rotationY,n.scaleZ=s.scaleZ),n.filters&&delete n.filters,n},J=function(t,e,i,s,r){var n,a,o,l={},h=t.style;for(a in i)"cssText"!==a&&"length"!==a&&isNaN(a)&&(e[a]!==(n=i[a])||r&&r[a])&&-1===a.indexOf("Origin")&&("number"==typeof n||"string"==typeof n)&&(l[a]="auto"!==n||"left"!==a&&"top"!==a?""!==n&&"auto"!==n&&"none"!==n||"string"!=typeof e[a]||""===e[a].replace(y,"")?n:0:H(t,a),void 0!==h[a]&&(o=new pe(h,a,h[a],o)));if(s)for(a in s)"className"!==a&&(l[a]=s[a]);return{difs:l,firstMPT:o}},te={width:["Left","Right"],height:["Top","Bottom"]},ee=["marginLeft","marginRight","marginTop","marginBottom"],ie=function(t,e,i){var s=parseFloat("width"===e?t.offsetWidth:t.offsetHeight),r=te[e],n=r.length;for(i=i||Z(t,null);--n>-1;)s-=parseFloat(Q(t,"padding"+r[n],i,!0))||0,s-=parseFloat(Q(t,"border"+r[n]+"Width",i,!0))||0;return s},se=function(t,e){if("contain"===t||"auto"===t||"auto auto"===t)return t+" ";(null==t||""===t)&&(t="0 0");var i=t.split(" "),s=-1!==t.indexOf("left")?"0%":-1!==t.indexOf("right")?"100%":i[0],r=-1!==t.indexOf("top")?"0%":-1!==t.indexOf("bottom")?"100%":i[1];return null==r?r="center"===s?"50%":"0":"center"===r&&(r="50%"),("center"===s||isNaN(parseFloat(s))&&-1===(s+"").indexOf("="))&&(s="50%"),t=s+" "+r+(i.length>2?" "+i[2]:""),e&&(e.oxp=-1!==s.indexOf("%"),e.oyp=-1!==r.indexOf("%"),e.oxr="="===s.charAt(1),e.oyr="="===r.charAt(1),e.ox=parseFloat(s.replace(y,"")),e.oy=parseFloat(r.replace(y,"")),e.v=t),e||t},re=function(t,e){return"string"==typeof t&&"="===t.charAt(1)?parseInt(t.charAt(0)+"1",10)*parseFloat(t.substr(2)):parseFloat(t)-parseFloat(e)},ne=function(t,e){return null==t?e:"string"==typeof t&&"="===t.charAt(1)?parseInt(t.charAt(0)+"1",10)*parseFloat(t.substr(2))+e:parseFloat(t)},ae=function(t,e,i,s){var r,n,a,o,l,h=1e-6;return null==t?o=e:"number"==typeof t?o=t:(r=360,n=t.split("_"),l="="===t.charAt(1),a=(l?parseInt(t.charAt(0)+"1",10)*parseFloat(n[0].substr(2)):parseFloat(n[0]))*(-1===t.indexOf("rad")?1:F)-(l?0:e),n.length&&(s&&(s[i]=e+a),-1!==t.indexOf("short")&&(a%=r,a!==a%(r/2)&&(a=0>a?a+r:a-r)),-1!==t.indexOf("_cw")&&0>a?a=(a+9999999999*r)%r-(0|a/r)*r:-1!==t.indexOf("ccw")&&a>0&&(a=(a-9999999999*r)%r-(0|a/r)*r)),o=e+a),h>o&&o>-h&&(o=0),o},oe={aqua:[0,255,255],lime:[0,255,0],silver:[192,192,192],black:[0,0,0],maroon:[128,0,0],teal:[0,128,128],blue:[0,0,255],navy:[0,0,128],white:[255,255,255],fuchsia:[255,0,255],olive:[128,128,0],yellow:[255,255,0],orange:[255,165,0],gray:[128,128,128],purple:[128,0,128],green:[0,128,0],red:[255,0,0],pink:[255,192,203],cyan:[0,255,255],transparent:[255,255,255,0]},le=function(t,e,i){return t=0>t?t+1:t>1?t-1:t,0|255*(1>6*t?e+6*(i-e)*t:.5>t?i:2>3*t?e+6*(i-e)*(2/3-t):e)+.5},he=a.parseColor=function(t,e){var i,s,r,n,a,o,l,h,_,u,c;if(t)if("number"==typeof t)i=[t>>16,255&t>>8,255&t];else{if(","===t.charAt(t.length-1)&&(t=t.substr(0,t.length-1)),oe[t])i=oe[t];else if("#"===t.charAt(0))4===t.length&&(s=t.charAt(1),r=t.charAt(2),n=t.charAt(3),t="#"+s+s+r+r+n+n),t=parseInt(t.substr(1),16),i=[t>>16,255&t>>8,255&t];else if("hsl"===t.substr(0,3))if(i=c=t.match(d),e){if(-1!==t.indexOf("="))return t.match(g)}else a=Number(i[0])%360/360,o=Number(i[1])/100,l=Number(i[2])/100,r=.5>=l?l*(o+1):l+o-l*o,s=2*l-r,i.length>3&&(i[3]=Number(t[3])),i[0]=le(a+1/3,s,r),i[1]=le(a,s,r),i[2]=le(a-1/3,s,r);else i=t.match(d)||oe.transparent;i[0]=Number(i[0]),i[1]=Number(i[1]),i[2]=Number(i[2]),i.length>3&&(i[3]=Number(i[3]))}else i=oe.black;return e&&!c&&(s=i[0]/255,r=i[1]/255,n=i[2]/255,h=Math.max(s,r,n),_=Math.min(s,r,n),l=(h+_)/2,h===_?a=o=0:(u=h-_,o=l>.5?u/(2-h-_):u/(h+_),a=h===s?(r-n)/u+(n>r?6:0):h===r?(n-s)/u+2:(s-r)/u+4,a*=60),i[0]=0|a+.5,i[1]=0|100*o+.5,i[2]=0|100*l+.5),i},_e=function(t,e){var i,s,r,n=t.match(ue)||[],a=0,o=n.length?"":t;for(i=0;n.length>i;i++)s=n[i],r=t.substr(a,t.indexOf(s,a)-a),a+=r.length+s.length,s=he(s,e),3===s.length&&s.push(1),o+=r+(e?"hsla("+s[0]+","+s[1]+"%,"+s[2]+"%,"+s[3]:"rgba("+s.join(","))+")";return o},ue="(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#.+?\\b";for(h in oe)ue+="|"+h+"\\b";ue=RegExp(ue+")","gi"),a.colorStringFilter=function(t){var e,i=t[0]+t[1];ue.lastIndex=0,ue.test(i)&&(e=-1!==i.indexOf("hsl(")||-1!==i.indexOf("hsla("),t[0]=_e(t[0],e),t[1]=_e(t[1],e))},e.defaultStringFilter||(e.defaultStringFilter=a.colorStringFilter);var ce=function(t,e,i,s){if(null==t)return function(t){return t};var r,n=e?(t.match(ue)||[""])[0]:"",a=t.split(n).join("").match(v)||[],o=t.substr(0,t.indexOf(a[0])),l=")"===t.charAt(t.length-1)?")":"",h=-1!==t.indexOf(" ")?" ":",",_=a.length,u=_>0?a[0].replace(d,""):"";return _?r=e?function(t){var e,c,f,p;if("number"==typeof t)t+=u;else if(s&&M.test(t)){for(p=t.replace(M,"|").split("|"),f=0;p.length>f;f++)p[f]=r(p[f]);return p.join(",")}if(e=(t.match(ue)||[n])[0],c=t.split(e).join("").match(v)||[],f=c.length,_>f--)for(;_>++f;)c[f]=i?c[0|(f-1)/2]:a[f];return o+c.join(h)+h+e+l+(-1!==t.indexOf("inset")?" inset":"")}:function(t){var e,n,c;if("number"==typeof t)t+=u;else if(s&&M.test(t)){for(n=t.replace(M,"|").split("|"),c=0;n.length>c;c++)n[c]=r(n[c]);return n.join(",")}if(e=t.match(v)||[],c=e.length,_>c--)for(;_>++c;)e[c]=i?e[0|(c-1)/2]:a[c];return o+e.join(h)+l}:function(t){return t}},fe=function(t){return t=t.split(","),function(e,i,s,r,n,a,o){var l,h=(i+"").split(" ");for(o={},l=0;4>l;l++)o[t[l]]=h[l]=h[l]||h[(l-1)/2>>0];return r.parse(e,o,n,a)}},pe=(B._setPluginRatio=function(t){this.plugin.setRatio(t);for(var e,i,s,r,n=this.data,a=n.proxy,o=n.firstMPT,l=1e-6;o;)e=a[o.v],o.r?e=Math.round(e):l>e&&e>-l&&(e=0),o.t[o.p]=e,o=o._next;if(n.autoRotate&&(n.autoRotate.rotation=a.rotation),1===t)for(o=n.firstMPT;o;){if(i=o.t,i.type){if(1===i.type){for(r=i.xs0+i.s+i.xs1,s=1;i.l>s;s++)r+=i["xn"+s]+i["xs"+(s+1)];i.e=r}}else i.e=i.s+i.xs0;o=o._next}},function(t,e,i,s,r){this.t=t,this.p=e,this.v=i,this.r=r,s&&(s._prev=this,this._next=s)}),me=(B._parseToProxy=function(t,e,i,s,r,n){var a,o,l,h,_,u=s,c={},f={},p=i._transform,m=I;for(i._transform=null,I=e,s=_=i.parse(t,e,s,r),I=m,n&&(i._transform=p,u&&(u._prev=null,u._prev&&(u._prev._next=null)));s&&s!==u;){if(1>=s.type&&(o=s.p,f[o]=s.s+s.c,c[o]=s.s,n||(h=new pe(s,"s",o,h,s.r),s.c=0),1===s.type))for(a=s.l;--a>0;)l="xn"+a,o=s.p+"_"+l,f[o]=s.data[l],c[o]=s[l],n||(h=new pe(s,l,o,h,s.rxp[l]));s=s._next}return{proxy:c,end:f,firstMPT:h,pt:_}},B.CSSPropTween=function(t,e,s,r,a,o,l,h,_,u,c){this.t=t,this.p=e,this.s=s,this.c=r,this.n=l||e,t instanceof me||n.push(this.n),this.r=h,this.type=o||0,_&&(this.pr=_,i=!0),this.b=void 0===u?s:u,this.e=void 0===c?s+r:c,a&&(this._next=a,a._prev=this)}),de=function(t,e,i,s,r,n){var a=new me(t,e,i,s-i,r,-1,n);return a.b=i,a.e=a.xs0=s,a},ge=a.parseComplex=function(t,e,i,s,r,n,a,o,l,h){i=i||n||"",a=new me(t,e,0,0,a,h?2:1,null,!1,o,i,s),s+="";var u,c,f,p,m,v,y,T,x,w,b,P,k,S=i.split(", ").join(",").split(" "),R=s.split(", ").join(",").split(" "),O=S.length,A=_!==!1;for((-1!==s.indexOf(",")||-1!==i.indexOf(","))&&(S=S.join(" ").replace(M,", ").split(" "),R=R.join(" ").replace(M,", ").split(" "),O=S.length),O!==R.length&&(S=(n||"").split(" "),O=S.length),a.plugin=l,a.setRatio=h,ue.lastIndex=0,u=0;O>u;u++)if(p=S[u],m=R[u],T=parseFloat(p),T||0===T)a.appendXtra("",T,re(m,T),m.replace(g,""),A&&-1!==m.indexOf("px"),!0);else if(r&&ue.test(p))P=","===m.charAt(m.length-1)?"),":")",k=-1!==m.indexOf("hsl")&&Y,p=he(p,k),m=he(m,k),x=p.length+m.length>6,x&&!Y&&0===m[3]?(a["xs"+a.l]+=a.l?" transparent":"transparent",a.e=a.e.split(R[u]).join("transparent")):(Y||(x=!1),k?a.appendXtra(x?"hsla(":"hsl(",p[0],re(m[0],p[0]),",",!1,!0).appendXtra("",p[1],re(m[1],p[1]),"%,",!1).appendXtra("",p[2],re(m[2],p[2]),x?"%,":"%"+P,!1):a.appendXtra(x?"rgba(":"rgb(",p[0],m[0]-p[0],",",!0,!0).appendXtra("",p[1],m[1]-p[1],",",!0).appendXtra("",p[2],m[2]-p[2],x?",":P,!0),x&&(p=4>p.length?1:p[3],a.appendXtra("",p,(4>m.length?1:m[3])-p,P,!1))),ue.lastIndex=0;else if(v=p.match(d)){if(y=m.match(g),!y||y.length!==v.length)return a;for(f=0,c=0;v.length>c;c++)b=v[c],w=p.indexOf(b,f),a.appendXtra(p.substr(f,w-f),Number(b),re(y[c],b),"",A&&"px"===p.substr(w+b.length,2),0===c),f=w+b.length;a["xs"+a.l]+=p.substr(f)}else a["xs"+a.l]+=a.l?" "+p:p;if(-1!==s.indexOf("=")&&a.data){for(P=a.xs0+a.data.s,u=1;a.l>u;u++)P+=a["xs"+u]+a.data["xn"+u];a.e=P+a["xs"+u]}return a.l||(a.type=-1,a.xs0=a.e),a.xfirst||a},ve=9;for(h=me.prototype,h.l=h.pr=0;--ve>0;)h["xn"+ve]=0,h["xs"+ve]="";h.xs0="",h._next=h._prev=h.xfirst=h.data=h.plugin=h.setRatio=h.rxp=null,h.appendXtra=function(t,e,i,s,r,n){var a=this,o=a.l;return a["xs"+o]+=n&&o?" "+t:t||"",i||0===o||a.plugin?(a.l++,a.type=a.setRatio?2:1,a["xs"+a.l]=s||"",o>0?(a.data["xn"+o]=e+i,a.rxp["xn"+o]=r,a["xn"+o]=e,a.plugin||(a.xfirst=new me(a,"xn"+o,e,i,a.xfirst||a,0,a.n,r,a.pr),a.xfirst.xs0=0),a):(a.data={s:e+i},a.rxp={},a.s=e,a.c=i,a.r=r,a)):(a["xs"+o]+=e+(s||""),a)};var ye=function(t,e){e=e||{},this.p=e.prefix?W(t)||t:t,l[t]=l[this.p]=this,this.format=e.formatter||ce(e.defaultValue,e.color,e.collapsible,e.multi),e.parser&&(this.parse=e.parser),this.clrs=e.color,this.multi=e.multi,this.keyword=e.keyword,this.dflt=e.defaultValue,this.pr=e.priority||0},Te=B._registerComplexSpecialProp=function(t,e,i){"object"!=typeof e&&(e={parser:i});var s,r,n=t.split(","),a=e.defaultValue;for(i=i||[a],s=0;n.length>s;s++)e.prefix=0===s&&e.prefix,e.defaultValue=i[s]||a,r=new ye(n[s],e)},xe=function(t){if(!l[t]){var e=t.charAt(0).toUpperCase()+t.substr(1)+"Plugin";Te(t,{parser:function(t,i,s,r,n,a,h){var _=o.com.greensock.plugins[e];return _?(_._cssRegister(),l[s].parse(t,i,s,r,n,a,h)):(q("Error: "+e+" js file not loaded."),n)}})}};h=ye.prototype,h.parseComplex=function(t,e,i,s,r,n){var a,o,l,h,_,u,c=this.keyword;if(this.multi&&(M.test(i)||M.test(e)?(o=e.replace(M,"|").split("|"),l=i.replace(M,"|").split("|")):c&&(o=[e],l=[i])),l){for(h=l.length>o.length?l.length:o.length,a=0;h>a;a++)e=o[a]=o[a]||this.dflt,i=l[a]=l[a]||this.dflt,c&&(_=e.indexOf(c),u=i.indexOf(c),_!==u&&(-1===u?o[a]=o[a].split(c).join(""):-1===_&&(o[a]+=" "+c)));e=o.join(", "),i=l.join(", ")}return ge(t,this.p,e,i,this.clrs,this.dflt,s,this.pr,r,n)},h.parse=function(t,e,i,s,n,a){return this.parseComplex(t.style,this.format(Q(t,this.p,r,!1,this.dflt)),this.format(e),n,a)},a.registerSpecialProp=function(t,e,i){Te(t,{parser:function(t,s,r,n,a,o){var l=new me(t,r,0,0,a,2,r,!1,i);return l.plugin=o,l.setRatio=e(t,s,n._tween,r),l},priority:i})},a.useSVGTransformAttr=c||f;var we,be="scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),Pe=W("transform"),ke=V+"transform",Se=W("transformOrigin"),Re=null!==W("perspective"),Oe=B.Transform=function(){this.perspective=parseFloat(a.defaultTransformPerspective)||0,this.force3D=a.defaultForce3D!==!1&&Re?a.defaultForce3D||"auto":!1},Ae=window.SVGElement,Ce=function(t,e,i){var s,r=E.createElementNS("http://www.w3.org/2000/svg",t),n=/([a-z])([A-Z])/g;for(s in i)r.setAttributeNS(null,s.replace(n,"$1-$2").toLowerCase(),i[s]);return e.appendChild(r),r},De=E.documentElement,Me=function(){var t,e,i,s=m||/Android/i.test(j)&&!window.chrome;return E.createElementNS&&!s&&(t=Ce("svg",De),e=Ce("rect",t,{width:100,height:50,x:100}),i=e.getBoundingClientRect().width,e.style[Se]="50% 50%",e.style[Pe]="scaleX(0.5)",s=i===e.getBoundingClientRect().width&&!(f&&Re),De.removeChild(t)),s}(),ze=function(t,e,i,s,r){var n,o,l,h,_,u,c,f,p,m,d,g,v,y,T=t._gsTransform,x=Ee(t,!0);T&&(v=T.xOrigin,y=T.yOrigin),(!s||2>(n=s.split(" ")).length)&&(c=t.getBBox(),e=se(e).split(" "),n=[(-1!==e[0].indexOf("%")?parseFloat(e[0])/100*c.width:parseFloat(e[0]))+c.x,(-1!==e[1].indexOf("%")?parseFloat(e[1])/100*c.height:parseFloat(e[1]))+c.y]),i.xOrigin=h=parseFloat(n[0]),i.yOrigin=_=parseFloat(n[1]),s&&x!==Ie&&(u=x[0],c=x[1],f=x[2],p=x[3],m=x[4],d=x[5],g=u*p-c*f,o=h*(p/g)+_*(-f/g)+(f*d-p*m)/g,l=h*(-c/g)+_*(u/g)-(u*d-c*m)/g,h=i.xOrigin=n[0]=o,_=i.yOrigin=n[1]=l),T&&(r||r!==!1&&a.defaultSmoothOrigin!==!1?(o=h-v,l=_-y,T.xOffset+=o*x[0]+l*x[2]-o,T.yOffset+=o*x[1]+l*x[3]-l):T.xOffset=T.yOffset=0),t.setAttribute("data-svg-origin",n.join(" "))},Fe=function(t){return!!(Ae&&"function"==typeof t.getBBox&&t.getCTM&&(!t.parentNode||t.parentNode.getBBox&&t.parentNode.getCTM))},Ie=[1,0,0,1,0,0],Ee=function(t,e){var i,s,r,n,a,o=t._gsTransform||new Oe,l=1e5;if(Pe?s=Q(t,ke,null,!0):t.currentStyle&&(s=t.currentStyle.filter.match(C),s=s&&4===s.length?[s[0].substr(4),Number(s[2].substr(4)),Number(s[1].substr(4)),s[3].substr(4),o.x||0,o.y||0].join(","):""),i=!s||"none"===s||"matrix(1, 0, 0, 1, 0, 0)"===s,(o.svg||t.getBBox&&Fe(t))&&(i&&-1!==(t.style[Pe]+"").indexOf("matrix")&&(s=t.style[Pe],i=0),r=t.getAttribute("transform"),i&&r&&(-1!==r.indexOf("matrix")?(s=r,i=0):-1!==r.indexOf("translate")&&(s="matrix(1,0,0,1,"+r.match(/(?:\-|\b)[\d\-\.e]+\b/gi).join(",")+")",i=0))),i)return Ie;for(r=(s||"").match(/(?:\-|\b)[\d\-\.e]+\b/gi)||[],ve=r.length;--ve>-1;)n=Number(r[ve]),r[ve]=(a=n-(n|=0))?(0|a*l+(0>a?-.5:.5))/l+n:n;return e&&r.length>6?[r[0],r[1],r[4],r[5],r[12],r[13]]:r},Ne=B.getTransform=function(t,i,s,n){if(t._gsTransform&&s&&!n)return t._gsTransform;var o,l,h,_,u,c,f=s?t._gsTransform||new Oe:new Oe,p=0>f.scaleX,m=2e-5,d=1e5,g=Re?parseFloat(Q(t,Se,i,!1,"0 0 0").split(" ")[2])||f.zOrigin||0:0,v=parseFloat(a.defaultTransformPerspective)||0;if(f.svg=!(!t.getBBox||!Fe(t)),f.svg&&(ze(t,Q(t,Se,r,!1,"50% 50%")+"",f,t.getAttribute("data-svg-origin")),we=a.useSVGTransformAttr||Me),o=Ee(t),o!==Ie){if(16===o.length){var y,T,x,w,b,P=o[0],k=o[1],S=o[2],R=o[3],O=o[4],A=o[5],C=o[6],D=o[7],M=o[8],z=o[9],I=o[10],E=o[12],N=o[13],L=o[14],X=o[11],B=Math.atan2(C,I);f.zOrigin&&(L=-f.zOrigin,E=M*L-o[12],N=z*L-o[13],L=I*L+f.zOrigin-o[14]),f.rotationX=B*F,B&&(w=Math.cos(-B),b=Math.sin(-B),y=O*w+M*b,T=A*w+z*b,x=C*w+I*b,M=O*-b+M*w,z=A*-b+z*w,I=C*-b+I*w,X=D*-b+X*w,O=y,A=T,C=x),B=Math.atan2(M,I),f.rotationY=B*F,B&&(w=Math.cos(-B),b=Math.sin(-B),y=P*w-M*b,T=k*w-z*b,x=S*w-I*b,z=k*b+z*w,I=S*b+I*w,X=R*b+X*w,P=y,k=T,S=x),B=Math.atan2(k,P),f.rotation=B*F,B&&(w=Math.cos(-B),b=Math.sin(-B),P=P*w+O*b,T=k*w+A*b,A=k*-b+A*w,C=S*-b+C*w,k=T),f.rotationX&&Math.abs(f.rotationX)+Math.abs(f.rotation)>359.9&&(f.rotationX=f.rotation=0,f.rotationY+=180),f.scaleX=(0|Math.sqrt(P*P+k*k)*d+.5)/d,f.scaleY=(0|Math.sqrt(A*A+z*z)*d+.5)/d,f.scaleZ=(0|Math.sqrt(C*C+I*I)*d+.5)/d,f.skewX=0,f.perspective=X?1/(0>X?-X:X):0,f.x=E,f.y=N,f.z=L,f.svg&&(f.x-=f.xOrigin-(f.xOrigin*P-f.yOrigin*O),f.y-=f.yOrigin-(f.yOrigin*k-f.xOrigin*A))}else if(!(Re&&!n&&o.length&&f.x===o[4]&&f.y===o[5]&&(f.rotationX||f.rotationY)||void 0!==f.x&&"none"===Q(t,"display",i))){var j=o.length>=6,Y=j?o[0]:1,U=o[1]||0,q=o[2]||0,V=j?o[3]:1;f.x=o[4]||0,f.y=o[5]||0,h=Math.sqrt(Y*Y+U*U),_=Math.sqrt(V*V+q*q),u=Y||U?Math.atan2(U,Y)*F:f.rotation||0,c=q||V?Math.atan2(q,V)*F+u:f.skewX||0,Math.abs(c)>90&&270>Math.abs(c)&&(p?(h*=-1,c+=0>=u?180:-180,u+=0>=u?180:-180):(_*=-1,c+=0>=c?180:-180)),f.scaleX=h,f.scaleY=_,f.rotation=u,f.skewX=c,Re&&(f.rotationX=f.rotationY=f.z=0,f.perspective=v,f.scaleZ=1),f.svg&&(f.x-=f.xOrigin-(f.xOrigin*Y+f.yOrigin*q),f.y-=f.yOrigin-(f.xOrigin*U+f.yOrigin*V))}f.zOrigin=g;for(l in f)m>f[l]&&f[l]>-m&&(f[l]=0)}return s&&(t._gsTransform=f,f.svg&&(we&&t.style[Pe]?e.delayedCall(.001,function(){je(t.style,Pe)}):!we&&t.getAttribute("transform")&&e.delayedCall(.001,function(){t.removeAttribute("transform")}))),f},Le=function(t){var e,i,s=this.data,r=-s.rotation*z,n=r+s.skewX*z,a=1e5,o=(0|Math.cos(r)*s.scaleX*a)/a,l=(0|Math.sin(r)*s.scaleX*a)/a,h=(0|Math.sin(n)*-s.scaleY*a)/a,_=(0|Math.cos(n)*s.scaleY*a)/a,u=this.t.style,c=this.t.currentStyle;if(c){i=l,l=-h,h=-i,e=c.filter,u.filter="";var f,p,d=this.t.offsetWidth,g=this.t.offsetHeight,v="absolute"!==c.position,y="progid:DXImageTransform.Microsoft.Matrix(M11="+o+", M12="+l+", M21="+h+", M22="+_,w=s.x+d*s.xPercent/100,b=s.y+g*s.yPercent/100;if(null!=s.ox&&(f=(s.oxp?.01*d*s.ox:s.ox)-d/2,p=(s.oyp?.01*g*s.oy:s.oy)-g/2,w+=f-(f*o+p*l),b+=p-(f*h+p*_)),v?(f=d/2,p=g/2,y+=", Dx="+(f-(f*o+p*l)+w)+", Dy="+(p-(f*h+p*_)+b)+")"):y+=", sizingMethod='auto expand')",u.filter=-1!==e.indexOf("DXImageTransform.Microsoft.Matrix(")?e.replace(D,y):y+" "+e,(0===t||1===t)&&1===o&&0===l&&0===h&&1===_&&(v&&-1===y.indexOf("Dx=0, Dy=0")||x.test(e)&&100!==parseFloat(RegExp.$1)||-1===e.indexOf("gradient("&&e.indexOf("Alpha"))&&u.removeAttribute("filter")),!v){var P,k,S,R=8>m?1:-1;for(f=s.ieOffsetX||0,p=s.ieOffsetY||0,s.ieOffsetX=Math.round((d-((0>o?-o:o)*d+(0>l?-l:l)*g))/2+w),s.ieOffsetY=Math.round((g-((0>_?-_:_)*g+(0>h?-h:h)*d))/2+b),ve=0;4>ve;ve++)k=ee[ve],P=c[k],i=-1!==P.indexOf("px")?parseFloat(P):$(this.t,k,parseFloat(P),P.replace(T,""))||0,S=i!==s[k]?2>ve?-s.ieOffsetX:-s.ieOffsetY:2>ve?f-s.ieOffsetX:p-s.ieOffsetY,u[k]=(s[k]=Math.round(i-S*(0===ve||2===ve?1:R)))+"px"}}},Xe=B.set3DTransformRatio=B.setTransformRatio=function(t){var e,i,s,r,n,a,o,l,h,_,u,c,p,m,d,g,v,y,T,x,w,b,P,k=this.data,S=this.t.style,R=k.rotation,O=k.rotationX,A=k.rotationY,C=k.scaleX,D=k.scaleY,M=k.scaleZ,F=k.x,I=k.y,E=k.z,N=k.svg,L=k.perspective,X=k.force3D;if(!(((1!==t&&0!==t||"auto"!==X||this.tween._totalTime!==this.tween._totalDuration&&this.tween._totalTime)&&X||E||L||A||O)&&(!we||!N)&&Re))return R||k.skewX||N?(R*=z,b=k.skewX*z,P=1e5,e=Math.cos(R)*C,r=Math.sin(R)*C,i=Math.sin(R-b)*-D,n=Math.cos(R-b)*D,b&&"simple"===k.skewType&&(v=Math.tan(b),v=Math.sqrt(1+v*v),i*=v,n*=v,k.skewY&&(e*=v,r*=v)),N&&(F+=k.xOrigin-(k.xOrigin*e+k.yOrigin*i)+k.xOffset,I+=k.yOrigin-(k.xOrigin*r+k.yOrigin*n)+k.yOffset,we&&(k.xPercent||k.yPercent)&&(m=this.t.getBBox(),F+=.01*k.xPercent*m.width,I+=.01*k.yPercent*m.height),m=1e-6,m>F&&F>-m&&(F=0),m>I&&I>-m&&(I=0)),T=(0|e*P)/P+","+(0|r*P)/P+","+(0|i*P)/P+","+(0|n*P)/P+","+F+","+I+")",N&&we?this.t.setAttribute("transform","matrix("+T):S[Pe]=(k.xPercent||k.yPercent?"translate("+k.xPercent+"%,"+k.yPercent+"%) matrix(":"matrix(")+T):S[Pe]=(k.xPercent||k.yPercent?"translate("+k.xPercent+"%,"+k.yPercent+"%) matrix(":"matrix(")+C+",0,0,"+D+","+F+","+I+")",void 0;if(f&&(m=1e-4,m>C&&C>-m&&(C=M=2e-5),m>D&&D>-m&&(D=M=2e-5),!L||k.z||k.rotationX||k.rotationY||(L=0)),R||k.skewX)R*=z,d=e=Math.cos(R),g=r=Math.sin(R),k.skewX&&(R-=k.skewX*z,d=Math.cos(R),g=Math.sin(R),"simple"===k.skewType&&(v=Math.tan(k.skewX*z),v=Math.sqrt(1+v*v),d*=v,g*=v,k.skewY&&(e*=v,r*=v))),i=-g,n=d;else{if(!(A||O||1!==M||L||N))return S[Pe]=(k.xPercent||k.yPercent?"translate("+k.xPercent+"%,"+k.yPercent+"%) translate3d(":"translate3d(")+F+"px,"+I+"px,"+E+"px)"+(1!==C||1!==D?" scale("+C+","+D+")":""),void 0;e=n=1,i=r=0}h=1,s=a=o=l=_=u=0,c=L?-1/L:0,p=k.zOrigin,m=1e-6,x=",",w="0",R=A*z,R&&(d=Math.cos(R),g=Math.sin(R),o=-g,_=c*-g,s=e*g,a=r*g,h=d,c*=d,e*=d,r*=d),R=O*z,R&&(d=Math.cos(R),g=Math.sin(R),v=i*d+s*g,y=n*d+a*g,l=h*g,u=c*g,s=i*-g+s*d,a=n*-g+a*d,h*=d,c*=d,i=v,n=y),1!==M&&(s*=M,a*=M,h*=M,c*=M),1!==D&&(i*=D,n*=D,l*=D,u*=D),1!==C&&(e*=C,r*=C,o*=C,_*=C),(p||N)&&(p&&(F+=s*-p,I+=a*-p,E+=h*-p+p),N&&(F+=k.xOrigin-(k.xOrigin*e+k.yOrigin*i)+k.xOffset,I+=k.yOrigin-(k.xOrigin*r+k.yOrigin*n)+k.yOffset),m>F&&F>-m&&(F=w),m>I&&I>-m&&(I=w),m>E&&E>-m&&(E=0)),T=k.xPercent||k.yPercent?"translate("+k.xPercent+"%,"+k.yPercent+"%) matrix3d(":"matrix3d(",T+=(m>e&&e>-m?w:e)+x+(m>r&&r>-m?w:r)+x+(m>o&&o>-m?w:o),T+=x+(m>_&&_>-m?w:_)+x+(m>i&&i>-m?w:i)+x+(m>n&&n>-m?w:n),O||A?(T+=x+(m>l&&l>-m?w:l)+x+(m>u&&u>-m?w:u)+x+(m>s&&s>-m?w:s),T+=x+(m>a&&a>-m?w:a)+x+(m>h&&h>-m?w:h)+x+(m>c&&c>-m?w:c)+x):T+=",0,0,0,0,1,0,",T+=F+x+I+x+E+x+(L?1+-E/L:1)+")",S[Pe]=T};h=Oe.prototype,h.x=h.y=h.z=h.skewX=h.skewY=h.rotation=h.rotationX=h.rotationY=h.zOrigin=h.xPercent=h.yPercent=h.xOffset=h.yOffset=0,h.scaleX=h.scaleY=h.scaleZ=1,Te("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin",{parser:function(t,e,i,s,n,o,l){if(s._lastParsedTransform===l)return n;s._lastParsedTransform=l;var h,_,u,c,f,p,m,d,g,v,y=t._gsTransform,T=t.style,x=1e-6,w=be.length,b=l,P={},k="transformOrigin";if(l.display?(c=Q(t,"display"),T.display="block",h=Ne(t,r,!0,l.parseTransform),T.display=c):h=Ne(t,r,!0,l.parseTransform),s._transform=h,"string"==typeof b.transform&&Pe)c=L.style,c[Pe]=b.transform,c.display="block",c.position="absolute",E.body.appendChild(L),_=Ne(L,null,!1),E.body.removeChild(L),_.perspective||(_.perspective=h.perspective),null!=b.xPercent&&(_.xPercent=ne(b.xPercent,h.xPercent)),null!=b.yPercent&&(_.yPercent=ne(b.yPercent,h.yPercent));else if("object"==typeof b){if(_={scaleX:ne(null!=b.scaleX?b.scaleX:b.scale,h.scaleX),scaleY:ne(null!=b.scaleY?b.scaleY:b.scale,h.scaleY),scaleZ:ne(b.scaleZ,h.scaleZ),x:ne(b.x,h.x),y:ne(b.y,h.y),z:ne(b.z,h.z),xPercent:ne(b.xPercent,h.xPercent),yPercent:ne(b.yPercent,h.yPercent),perspective:ne(b.transformPerspective,h.perspective)},d=b.directionalRotation,null!=d)if("object"==typeof d)for(c in d)b[c]=d[c];else b.rotation=d;"string"==typeof b.x&&-1!==b.x.indexOf("%")&&(_.x=0,_.xPercent=ne(b.x,h.xPercent)),"string"==typeof b.y&&-1!==b.y.indexOf("%")&&(_.y=0,_.yPercent=ne(b.y,h.yPercent)),_.rotation=ae("rotation"in b?b.rotation:"shortRotation"in b?b.shortRotation+"_short":"rotationZ"in b?b.rotationZ:h.rotation,h.rotation,"rotation",P),Re&&(_.rotationX=ae("rotationX"in b?b.rotationX:"shortRotationX"in b?b.shortRotationX+"_short":h.rotationX||0,h.rotationX,"rotationX",P),_.rotationY=ae("rotationY"in b?b.rotationY:"shortRotationY"in b?b.shortRotationY+"_short":h.rotationY||0,h.rotationY,"rotationY",P)),_.skewX=null==b.skewX?h.skewX:ae(b.skewX,h.skewX),_.skewY=null==b.skewY?h.skewY:ae(b.skewY,h.skewY),(u=_.skewY-h.skewY)&&(_.skewX+=u,_.rotation+=u)}for(Re&&null!=b.force3D&&(h.force3D=b.force3D,m=!0),h.skewType=b.skewType||h.skewType||a.defaultSkewType,p=h.force3D||h.z||h.rotationX||h.rotationY||_.z||_.rotationX||_.rotationY||_.perspective,p||null==b.scale||(_.scaleZ=1);--w>-1;)i=be[w],f=_[i]-h[i],(f>x||-x>f||null!=b[i]||null!=I[i])&&(m=!0,n=new me(h,i,h[i],f,n),i in P&&(n.e=P[i]),n.xs0=0,n.plugin=o,s._overwriteProps.push(n.n));return f=b.transformOrigin,h.svg&&(f||b.svgOrigin)&&(g=h.xOffset,v=h.yOffset,ze(t,se(f),_,b.svgOrigin,b.smoothOrigin),n=de(h,"xOrigin",(y?h:_).xOrigin,_.xOrigin,n,k),n=de(h,"yOrigin",(y?h:_).yOrigin,_.yOrigin,n,k),(g!==h.xOffset||v!==h.yOffset)&&(n=de(h,"xOffset",y?g:h.xOffset,h.xOffset,n,k),n=de(h,"yOffset",y?v:h.yOffset,h.yOffset,n,k)),f=we?null:"0px 0px"),(f||Re&&p&&h.zOrigin)&&(Pe?(m=!0,i=Se,f=(f||Q(t,i,r,!1,"50% 50%"))+"",n=new me(T,i,0,0,n,-1,k),n.b=T[i],n.plugin=o,Re?(c=h.zOrigin,f=f.split(" "),h.zOrigin=(f.length>2&&(0===c||"0px"!==f[2])?parseFloat(f[2]):c)||0,n.xs0=n.e=f[0]+" "+(f[1]||"50%")+" 0px",n=new me(h,"zOrigin",0,0,n,-1,n.n),n.b=c,n.xs0=n.e=h.zOrigin):n.xs0=n.e=f):se(f+"",h)),m&&(s._transformType=h.svg&&we||!p&&3!==this._transformType?2:3),n},prefix:!0}),Te("boxShadow",{defaultValue:"0px 0px 0px 0px #999",prefix:!0,color:!0,multi:!0,keyword:"inset"}),Te("borderRadius",{defaultValue:"0px",parser:function(t,e,i,n,a){e=this.format(e);var o,l,h,_,u,c,f,p,m,d,g,v,y,T,x,w,b=["borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius"],P=t.style;for(m=parseFloat(t.offsetWidth),d=parseFloat(t.offsetHeight),o=e.split(" "),l=0;b.length>l;l++)this.p.indexOf("border")&&(b[l]=W(b[l])),u=_=Q(t,b[l],r,!1,"0px"),-1!==u.indexOf(" ")&&(_=u.split(" "),u=_[0],_=_[1]),c=h=o[l],f=parseFloat(u),v=u.substr((f+"").length),y="="===c.charAt(1),y?(p=parseInt(c.charAt(0)+"1",10),c=c.substr(2),p*=parseFloat(c),g=c.substr((p+"").length-(0>p?1:0))||""):(p=parseFloat(c),g=c.substr((p+"").length)),""===g&&(g=s[i]||v),g!==v&&(T=$(t,"borderLeft",f,v),x=$(t,"borderTop",f,v),"%"===g?(u=100*(T/m)+"%",_=100*(x/d)+"%"):"em"===g?(w=$(t,"borderLeft",1,"em"),u=T/w+"em",_=x/w+"em"):(u=T+"px",_=x+"px"),y&&(c=parseFloat(u)+p+g,h=parseFloat(_)+p+g)),a=ge(P,b[l],u+" "+_,c+" "+h,!1,"0px",a);return a},prefix:!0,formatter:ce("0px 0px 0px 0px",!1,!0)}),Te("backgroundPosition",{defaultValue:"0 0",parser:function(t,e,i,s,n,a){var o,l,h,_,u,c,f="background-position",p=r||Z(t,null),d=this.format((p?m?p.getPropertyValue(f+"-x")+" "+p.getPropertyValue(f+"-y"):p.getPropertyValue(f):t.currentStyle.backgroundPositionX+" "+t.currentStyle.backgroundPositionY)||"0 0"),g=this.format(e);
if(-1!==d.indexOf("%")!=(-1!==g.indexOf("%"))&&(c=Q(t,"backgroundImage").replace(R,""),c&&"none"!==c)){for(o=d.split(" "),l=g.split(" "),X.setAttribute("src",c),h=2;--h>-1;)d=o[h],_=-1!==d.indexOf("%"),_!==(-1!==l[h].indexOf("%"))&&(u=0===h?t.offsetWidth-X.width:t.offsetHeight-X.height,o[h]=_?parseFloat(d)/100*u+"px":100*(parseFloat(d)/u)+"%");d=o.join(" ")}return this.parseComplex(t.style,d,g,n,a)},formatter:se}),Te("backgroundSize",{defaultValue:"0 0",formatter:se}),Te("perspective",{defaultValue:"0px",prefix:!0}),Te("perspectiveOrigin",{defaultValue:"50% 50%",prefix:!0}),Te("transformStyle",{prefix:!0}),Te("backfaceVisibility",{prefix:!0}),Te("userSelect",{prefix:!0}),Te("margin",{parser:fe("marginTop,marginRight,marginBottom,marginLeft")}),Te("padding",{parser:fe("paddingTop,paddingRight,paddingBottom,paddingLeft")}),Te("clip",{defaultValue:"rect(0px,0px,0px,0px)",parser:function(t,e,i,s,n,a){var o,l,h;return 9>m?(l=t.currentStyle,h=8>m?" ":",",o="rect("+l.clipTop+h+l.clipRight+h+l.clipBottom+h+l.clipLeft+")",e=this.format(e).split(",").join(h)):(o=this.format(Q(t,this.p,r,!1,this.dflt)),e=this.format(e)),this.parseComplex(t.style,o,e,n,a)}}),Te("textShadow",{defaultValue:"0px 0px 0px #999",color:!0,multi:!0}),Te("autoRound,strictUnits",{parser:function(t,e,i,s,r){return r}}),Te("border",{defaultValue:"0px solid #000",parser:function(t,e,i,s,n,a){return this.parseComplex(t.style,this.format(Q(t,"borderTopWidth",r,!1,"0px")+" "+Q(t,"borderTopStyle",r,!1,"solid")+" "+Q(t,"borderTopColor",r,!1,"#000")),this.format(e),n,a)},color:!0,formatter:function(t){var e=t.split(" ");return e[0]+" "+(e[1]||"solid")+" "+(t.match(ue)||["#000"])[0]}}),Te("borderWidth",{parser:fe("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")}),Te("float,cssFloat,styleFloat",{parser:function(t,e,i,s,r){var n=t.style,a="cssFloat"in n?"cssFloat":"styleFloat";return new me(n,a,0,0,r,-1,i,!1,0,n[a],e)}});var Be=function(t){var e,i=this.t,s=i.filter||Q(this.data,"filter")||"",r=0|this.s+this.c*t;100===r&&(-1===s.indexOf("atrix(")&&-1===s.indexOf("radient(")&&-1===s.indexOf("oader(")?(i.removeAttribute("filter"),e=!Q(this.data,"filter")):(i.filter=s.replace(b,""),e=!0)),e||(this.xn1&&(i.filter=s=s||"alpha(opacity="+r+")"),-1===s.indexOf("pacity")?0===r&&this.xn1||(i.filter=s+" alpha(opacity="+r+")"):i.filter=s.replace(x,"opacity="+r))};Te("opacity,alpha,autoAlpha",{defaultValue:"1",parser:function(t,e,i,s,n,a){var o=parseFloat(Q(t,"opacity",r,!1,"1")),l=t.style,h="autoAlpha"===i;return"string"==typeof e&&"="===e.charAt(1)&&(e=("-"===e.charAt(0)?-1:1)*parseFloat(e.substr(2))+o),h&&1===o&&"hidden"===Q(t,"visibility",r)&&0!==e&&(o=0),Y?n=new me(l,"opacity",o,e-o,n):(n=new me(l,"opacity",100*o,100*(e-o),n),n.xn1=h?1:0,l.zoom=1,n.type=2,n.b="alpha(opacity="+n.s+")",n.e="alpha(opacity="+(n.s+n.c)+")",n.data=t,n.plugin=a,n.setRatio=Be),h&&(n=new me(l,"visibility",0,0,n,-1,null,!1,0,0!==o?"inherit":"hidden",0===e?"hidden":"inherit"),n.xs0="inherit",s._overwriteProps.push(n.n),s._overwriteProps.push(i)),n}});var je=function(t,e){e&&(t.removeProperty?(("ms"===e.substr(0,2)||"webkit"===e.substr(0,6))&&(e="-"+e),t.removeProperty(e.replace(k,"-$1").toLowerCase())):t.removeAttribute(e))},Ye=function(t){if(this.t._gsClassPT=this,1===t||0===t){this.t.setAttribute("class",0===t?this.b:this.e);for(var e=this.data,i=this.t.style;e;)e.v?i[e.p]=e.v:je(i,e.p),e=e._next;1===t&&this.t._gsClassPT===this&&(this.t._gsClassPT=null)}else this.t.getAttribute("class")!==this.e&&this.t.setAttribute("class",this.e)};Te("className",{parser:function(t,e,s,n,a,o,l){var h,_,u,c,f,p=t.getAttribute("class")||"",m=t.style.cssText;if(a=n._classNamePT=new me(t,s,0,0,a,2),a.setRatio=Ye,a.pr=-11,i=!0,a.b=p,_=K(t,r),u=t._gsClassPT){for(c={},f=u.data;f;)c[f.p]=1,f=f._next;u.setRatio(1)}return t._gsClassPT=a,a.e="="!==e.charAt(1)?e:p.replace(RegExp("\\s*\\b"+e.substr(2)+"\\b"),"")+("+"===e.charAt(0)?" "+e.substr(2):""),t.setAttribute("class",a.e),h=J(t,_,K(t),l,c),t.setAttribute("class",p),a.data=h.firstMPT,t.style.cssText=m,a=a.xfirst=n.parse(t,h.difs,a,o)}});var Ue=function(t){if((1===t||0===t)&&this.data._totalTime===this.data._totalDuration&&"isFromStart"!==this.data.data){var e,i,s,r,n,a=this.t.style,o=l.transform.parse;if("all"===this.e)a.cssText="",r=!0;else for(e=this.e.split(" ").join("").split(","),s=e.length;--s>-1;)i=e[s],l[i]&&(l[i].parse===o?r=!0:i="transformOrigin"===i?Se:l[i].p),je(a,i);r&&(je(a,Pe),n=this.t._gsTransform,n&&(n.svg&&this.t.removeAttribute("data-svg-origin"),delete this.t._gsTransform))}};for(Te("clearProps",{parser:function(t,e,s,r,n){return n=new me(t,s,0,0,n,2),n.setRatio=Ue,n.e=e,n.pr=-10,n.data=r._tween,i=!0,n}}),h="bezier,throwProps,physicsProps,physics2D".split(","),ve=h.length;ve--;)xe(h[ve]);h=a.prototype,h._firstPT=h._lastParsedTransform=h._transform=null,h._onInitTween=function(t,e,o){if(!t.nodeType)return!1;this._target=t,this._tween=o,this._vars=e,_=e.autoRound,i=!1,s=e.suffixMap||a.suffixMap,r=Z(t,""),n=this._overwriteProps;var h,f,m,d,g,v,y,T,x,b=t.style;if(u&&""===b.zIndex&&(h=Q(t,"zIndex",r),("auto"===h||""===h)&&this._addLazySet(b,"zIndex",0)),"string"==typeof e&&(d=b.cssText,h=K(t,r),b.cssText=d+";"+e,h=J(t,h,K(t)).difs,!Y&&w.test(e)&&(h.opacity=parseFloat(RegExp.$1)),e=h,b.cssText=d),this._firstPT=f=e.className?l.className.parse(t,e.className,"className",this,null,null,e):this.parse(t,e,null),this._transformType){for(x=3===this._transformType,Pe?c&&(u=!0,""===b.zIndex&&(y=Q(t,"zIndex",r),("auto"===y||""===y)&&this._addLazySet(b,"zIndex",0)),p&&this._addLazySet(b,"WebkitBackfaceVisibility",this._vars.WebkitBackfaceVisibility||(x?"visible":"hidden"))):b.zoom=1,m=f;m&&m._next;)m=m._next;T=new me(t,"transform",0,0,null,2),this._linkCSSP(T,null,m),T.setRatio=Pe?Xe:Le,T.data=this._transform||Ne(t,r,!0),T.tween=o,T.pr=-1,n.pop()}if(i){for(;f;){for(v=f._next,m=d;m&&m.pr>f.pr;)m=m._next;(f._prev=m?m._prev:g)?f._prev._next=f:d=f,(f._next=m)?m._prev=f:g=f,f=v}this._firstPT=d}return!0},h.parse=function(t,e,i,n){var a,o,h,u,c,f,p,m,d,g,v=t.style;for(a in e)f=e[a],o=l[a],o?i=o.parse(t,f,a,this,i,n,e):(c=Q(t,a,r)+"",d="string"==typeof f,"color"===a||"fill"===a||"stroke"===a||-1!==a.indexOf("Color")||d&&P.test(f)?(d||(f=he(f),f=(f.length>3?"rgba(":"rgb(")+f.join(",")+")"),i=ge(v,a,c,f,!0,"transparent",i,0,n)):!d||-1===f.indexOf(" ")&&-1===f.indexOf(",")?(h=parseFloat(c),p=h||0===h?c.substr((h+"").length):"",(""===c||"auto"===c)&&("width"===a||"height"===a?(h=ie(t,a,r),p="px"):"left"===a||"top"===a?(h=H(t,a,r),p="px"):(h="opacity"!==a?0:1,p="")),g=d&&"="===f.charAt(1),g?(u=parseInt(f.charAt(0)+"1",10),f=f.substr(2),u*=parseFloat(f),m=f.replace(T,"")):(u=parseFloat(f),m=d?f.replace(T,""):""),""===m&&(m=a in s?s[a]:p),f=u||0===u?(g?u+h:u)+m:e[a],p!==m&&""!==m&&(u||0===u)&&h&&(h=$(t,a,h,p),"%"===m?(h/=$(t,a,100,"%")/100,e.strictUnits!==!0&&(c=h+"%")):"em"===m||"rem"===m?h/=$(t,a,1,m):"px"!==m&&(u=$(t,a,u,m),m="px"),g&&(u||0===u)&&(f=u+h+m)),g&&(u+=h),!h&&0!==h||!u&&0!==u?void 0!==v[a]&&(f||"NaN"!=f+""&&null!=f)?(i=new me(v,a,u||h||0,0,i,-1,a,!1,0,c,f),i.xs0="none"!==f||"display"!==a&&-1===a.indexOf("Style")?f:c):q("invalid "+a+" tween value: "+e[a]):(i=new me(v,a,h,u-h,i,0,a,_!==!1&&("px"===m||"zIndex"===a),0,c,f),i.xs0=m)):i=ge(v,a,c,f,!0,null,i,0,n)),n&&i&&!i.plugin&&(i.plugin=n);return i},h.setRatio=function(t){var e,i,s,r=this._firstPT,n=1e-6;if(1!==t||this._tween._time!==this._tween._duration&&0!==this._tween._time)if(t||this._tween._time!==this._tween._duration&&0!==this._tween._time||this._tween._rawPrevTime===-1e-6)for(;r;){if(e=r.c*t+r.s,r.r?e=Math.round(e):n>e&&e>-n&&(e=0),r.type)if(1===r.type)if(s=r.l,2===s)r.t[r.p]=r.xs0+e+r.xs1+r.xn1+r.xs2;else if(3===s)r.t[r.p]=r.xs0+e+r.xs1+r.xn1+r.xs2+r.xn2+r.xs3;else if(4===s)r.t[r.p]=r.xs0+e+r.xs1+r.xn1+r.xs2+r.xn2+r.xs3+r.xn3+r.xs4;else if(5===s)r.t[r.p]=r.xs0+e+r.xs1+r.xn1+r.xs2+r.xn2+r.xs3+r.xn3+r.xs4+r.xn4+r.xs5;else{for(i=r.xs0+e+r.xs1,s=1;r.l>s;s++)i+=r["xn"+s]+r["xs"+(s+1)];r.t[r.p]=i}else-1===r.type?r.t[r.p]=r.xs0:r.setRatio&&r.setRatio(t);else r.t[r.p]=e+r.xs0;r=r._next}else for(;r;)2!==r.type?r.t[r.p]=r.b:r.setRatio(t),r=r._next;else for(;r;){if(2!==r.type)if(r.r&&-1!==r.type)if(e=Math.round(r.s+r.c),r.type){if(1===r.type){for(s=r.l,i=r.xs0+e+r.xs1,s=1;r.l>s;s++)i+=r["xn"+s]+r["xs"+(s+1)];r.t[r.p]=i}}else r.t[r.p]=e+r.xs0;else r.t[r.p]=r.e;else r.setRatio(t);r=r._next}},h._enableTransforms=function(t){this._transform=this._transform||Ne(this._target,r,!0),this._transformType=this._transform.svg&&we||!t&&3!==this._transformType?2:3};var qe=function(){this.t[this.p]=this.e,this.data._linkCSSP(this,this._next,null,!0)};h._addLazySet=function(t,e,i){var s=this._firstPT=new me(t,e,0,0,this._firstPT,2);s.e=i,s.setRatio=qe,s.data=this},h._linkCSSP=function(t,e,i,s){return t&&(e&&(e._prev=t),t._next&&(t._next._prev=t._prev),t._prev?t._prev._next=t._next:this._firstPT===t&&(this._firstPT=t._next,s=!0),i?i._next=t:s||null!==this._firstPT||(this._firstPT=t),t._next=e,t._prev=i),t},h._kill=function(e){var i,s,r,n=e;if(e.autoAlpha||e.alpha){n={};for(s in e)n[s]=e[s];n.opacity=1,n.autoAlpha&&(n.visibility=1)}return e.className&&(i=this._classNamePT)&&(r=i.xfirst,r&&r._prev?this._linkCSSP(r._prev,i._next,r._prev._prev):r===this._firstPT&&(this._firstPT=i._next),i._next&&this._linkCSSP(i._next,i._next._next,r._prev),this._classNamePT=null),t.prototype._kill.call(this,n)};var Ve=function(t,e,i){var s,r,n,a;if(t.slice)for(r=t.length;--r>-1;)Ve(t[r],e,i);else for(s=t.childNodes,r=s.length;--r>-1;)n=s[r],a=n.type,n.style&&(e.push(K(n)),i&&i.push(n)),1!==a&&9!==a&&11!==a||!n.childNodes.length||Ve(n,e,i)};return a.cascadeTo=function(t,i,s){var r,n,a,o,l=e.to(t,i,s),h=[l],_=[],u=[],c=[],f=e._internals.reservedProps;for(t=l._targets||l.target,Ve(t,_,c),l.render(i,!0,!0),Ve(t,u),l.render(0,!0,!0),l._enabled(!0),r=c.length;--r>-1;)if(n=J(c[r],_[r],u[r]),n.firstMPT){n=n.difs;for(a in s)f[a]&&(n[a]=s[a]);o={};for(a in n)o[a]=_[r][a];h.push(e.fromTo(c[r],i,o,n))}return h},t.activate([a]),a},!0),function(){var t=_gsScope._gsDefine.plugin({propName:"roundProps",version:"1.5",priority:-1,API:2,init:function(t,e,i){return this._tween=i,!0}}),e=function(t){for(;t;)t.f||t.blob||(t.r=1),t=t._next},i=t.prototype;i._onInitAllProps=function(){for(var t,i,s,r=this._tween,n=r.vars.roundProps.join?r.vars.roundProps:r.vars.roundProps.split(","),a=n.length,o={},l=r._propLookup.roundProps;--a>-1;)o[n[a]]=1;for(a=n.length;--a>-1;)for(t=n[a],i=r._firstPT;i;)s=i._next,i.pg?i.t._roundProps(o,!0):i.n===t&&(2===i.f&&i.t?e(i.t._firstPT):(this._add(i.t,t,i.s,i.c),s&&(s._prev=i._prev),i._prev?i._prev._next=s:r._firstPT===i&&(r._firstPT=s),i._next=i._prev=null,r._propLookup[t]=l)),i=s;return!1},i._add=function(t,e,i,s){this._addTween(t,e,i,i+s,e,!0),this._overwriteProps.push(e)}}(),function(){_gsScope._gsDefine.plugin({propName:"attr",API:2,version:"0.5.0",init:function(t,e){var i;if("function"!=typeof t.setAttribute)return!1;for(i in e)this._addTween(t,"setAttribute",t.getAttribute(i)+"",e[i]+"",i,!1,i),this._overwriteProps.push(i);return!0}})}(),_gsScope._gsDefine.plugin({propName:"directionalRotation",version:"0.2.1",API:2,init:function(t,e){"object"!=typeof e&&(e={rotation:e}),this.finals={};var i,s,r,n,a,o,l=e.useRadians===!0?2*Math.PI:360,h=1e-6;for(i in e)"useRadians"!==i&&(o=(e[i]+"").split("_"),s=o[0],r=parseFloat("function"!=typeof t[i]?t[i]:t[i.indexOf("set")||"function"!=typeof t["get"+i.substr(3)]?i:"get"+i.substr(3)]()),n=this.finals[i]="string"==typeof s&&"="===s.charAt(1)?r+parseInt(s.charAt(0)+"1",10)*Number(s.substr(2)):Number(s)||0,a=n-r,o.length&&(s=o.join("_"),-1!==s.indexOf("short")&&(a%=l,a!==a%(l/2)&&(a=0>a?a+l:a-l)),-1!==s.indexOf("_cw")&&0>a?a=(a+9999999999*l)%l-(0|a/l)*l:-1!==s.indexOf("ccw")&&a>0&&(a=(a-9999999999*l)%l-(0|a/l)*l)),(a>h||-h>a)&&(this._addTween(t,i,r,r+a,i),this._overwriteProps.push(i)));return!0},set:function(t){var e;if(1!==t)this._super.setRatio.call(this,t);else for(e=this._firstPT;e;)e.f?e.t[e.p](this.finals[e.p]):e.t[e.p]=this.finals[e.p],e=e._next}})._autoCSS=!0,_gsScope._gsDefine("easing.Back",["easing.Ease"],function(t){var e,i,s,r=_gsScope.GreenSockGlobals||_gsScope,n=r.com.greensock,a=2*Math.PI,o=Math.PI/2,l=n._class,h=function(e,i){var s=l("easing."+e,function(){},!0),r=s.prototype=new t;return r.constructor=s,r.getRatio=i,s},_=t.register||function(){},u=function(t,e,i,s){var r=l("easing."+t,{easeOut:new e,easeIn:new i,easeInOut:new s},!0);return _(r,t),r},c=function(t,e,i){this.t=t,this.v=e,i&&(this.next=i,i.prev=this,this.c=i.v-e,this.gap=i.t-t)},f=function(e,i){var s=l("easing."+e,function(t){this._p1=t||0===t?t:1.70158,this._p2=1.525*this._p1},!0),r=s.prototype=new t;return r.constructor=s,r.getRatio=i,r.config=function(t){return new s(t)},s},p=u("Back",f("BackOut",function(t){return(t-=1)*t*((this._p1+1)*t+this._p1)+1}),f("BackIn",function(t){return t*t*((this._p1+1)*t-this._p1)}),f("BackInOut",function(t){return 1>(t*=2)?.5*t*t*((this._p2+1)*t-this._p2):.5*((t-=2)*t*((this._p2+1)*t+this._p2)+2)})),m=l("easing.SlowMo",function(t,e,i){e=e||0===e?e:.7,null==t?t=.7:t>1&&(t=1),this._p=1!==t?e:0,this._p1=(1-t)/2,this._p2=t,this._p3=this._p1+this._p2,this._calcEnd=i===!0},!0),d=m.prototype=new t;return d.constructor=m,d.getRatio=function(t){var e=t+(.5-t)*this._p;return this._p1>t?this._calcEnd?1-(t=1-t/this._p1)*t:e-(t=1-t/this._p1)*t*t*t*e:t>this._p3?this._calcEnd?1-(t=(t-this._p3)/this._p1)*t:e+(t-e)*(t=(t-this._p3)/this._p1)*t*t*t:this._calcEnd?1:e},m.ease=new m(.7,.7),d.config=m.config=function(t,e,i){return new m(t,e,i)},e=l("easing.SteppedEase",function(t){t=t||1,this._p1=1/t,this._p2=t+1},!0),d=e.prototype=new t,d.constructor=e,d.getRatio=function(t){return 0>t?t=0:t>=1&&(t=.999999999),(this._p2*t>>0)*this._p1},d.config=e.config=function(t){return new e(t)},i=l("easing.RoughEase",function(e){e=e||{};for(var i,s,r,n,a,o,l=e.taper||"none",h=[],_=0,u=0|(e.points||20),f=u,p=e.randomize!==!1,m=e.clamp===!0,d=e.template instanceof t?e.template:null,g="number"==typeof e.strength?.4*e.strength:.4;--f>-1;)i=p?Math.random():1/u*f,s=d?d.getRatio(i):i,"none"===l?r=g:"out"===l?(n=1-i,r=n*n*g):"in"===l?r=i*i*g:.5>i?(n=2*i,r=.5*n*n*g):(n=2*(1-i),r=.5*n*n*g),p?s+=Math.random()*r-.5*r:f%2?s+=.5*r:s-=.5*r,m&&(s>1?s=1:0>s&&(s=0)),h[_++]={x:i,y:s};for(h.sort(function(t,e){return t.x-e.x}),o=new c(1,1,null),f=u;--f>-1;)a=h[f],o=new c(a.x,a.y,o);this._prev=new c(0,0,0!==o.t?o:o.next)},!0),d=i.prototype=new t,d.constructor=i,d.getRatio=function(t){var e=this._prev;if(t>e.t){for(;e.next&&t>=e.t;)e=e.next;e=e.prev}else for(;e.prev&&e.t>=t;)e=e.prev;return this._prev=e,e.v+(t-e.t)/e.gap*e.c},d.config=function(t){return new i(t)},i.ease=new i,u("Bounce",h("BounceOut",function(t){return 1/2.75>t?7.5625*t*t:2/2.75>t?7.5625*(t-=1.5/2.75)*t+.75:2.5/2.75>t?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375}),h("BounceIn",function(t){return 1/2.75>(t=1-t)?1-7.5625*t*t:2/2.75>t?1-(7.5625*(t-=1.5/2.75)*t+.75):2.5/2.75>t?1-(7.5625*(t-=2.25/2.75)*t+.9375):1-(7.5625*(t-=2.625/2.75)*t+.984375)}),h("BounceInOut",function(t){var e=.5>t;return t=e?1-2*t:2*t-1,t=1/2.75>t?7.5625*t*t:2/2.75>t?7.5625*(t-=1.5/2.75)*t+.75:2.5/2.75>t?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375,e?.5*(1-t):.5*t+.5})),u("Circ",h("CircOut",function(t){return Math.sqrt(1-(t-=1)*t)}),h("CircIn",function(t){return-(Math.sqrt(1-t*t)-1)}),h("CircInOut",function(t){return 1>(t*=2)?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)})),s=function(e,i,s){var r=l("easing."+e,function(t,e){this._p1=t>=1?t:1,this._p2=(e||s)/(1>t?t:1),this._p3=this._p2/a*(Math.asin(1/this._p1)||0),this._p2=a/this._p2},!0),n=r.prototype=new t;return n.constructor=r,n.getRatio=i,n.config=function(t,e){return new r(t,e)},r},u("Elastic",s("ElasticOut",function(t){return this._p1*Math.pow(2,-10*t)*Math.sin((t-this._p3)*this._p2)+1},.3),s("ElasticIn",function(t){return-(this._p1*Math.pow(2,10*(t-=1))*Math.sin((t-this._p3)*this._p2))},.3),s("ElasticInOut",function(t){return 1>(t*=2)?-.5*this._p1*Math.pow(2,10*(t-=1))*Math.sin((t-this._p3)*this._p2):.5*this._p1*Math.pow(2,-10*(t-=1))*Math.sin((t-this._p3)*this._p2)+1},.45)),u("Expo",h("ExpoOut",function(t){return 1-Math.pow(2,-10*t)}),h("ExpoIn",function(t){return Math.pow(2,10*(t-1))-.001}),h("ExpoInOut",function(t){return 1>(t*=2)?.5*Math.pow(2,10*(t-1)):.5*(2-Math.pow(2,-10*(t-1)))})),u("Sine",h("SineOut",function(t){return Math.sin(t*o)}),h("SineIn",function(t){return-Math.cos(t*o)+1}),h("SineInOut",function(t){return-.5*(Math.cos(Math.PI*t)-1)})),l("easing.EaseLookup",{find:function(e){return t.map[e]}},!0),_(r.SlowMo,"SlowMo","ease,"),_(i,"RoughEase","ease,"),_(e,"SteppedEase","ease,"),p},!0)}),_gsScope._gsDefine&&_gsScope._gsQueue.pop()(),function(t,e){"use strict";var i=t.GreenSockGlobals=t.GreenSockGlobals||t;if(!i.TweenLite){var s,r,n,a,o,l=function(t){var e,s=t.split("."),r=i;for(e=0;s.length>e;e++)r[s[e]]=r=r[s[e]]||{};return r},h=l("com.greensock"),_=1e-10,u=function(t){var e,i=[],s=t.length;for(e=0;e!==s;i.push(t[e++]));return i},c=function(){},f=function(){var t=Object.prototype.toString,e=t.call([]);return function(i){return null!=i&&(i instanceof Array||"object"==typeof i&&!!i.push&&t.call(i)===e)}}(),p={},m=function(s,r,n,a){this.sc=p[s]?p[s].sc:[],p[s]=this,this.gsClass=null,this.func=n;var o=[];this.check=function(h){for(var _,u,c,f,d,g=r.length,v=g;--g>-1;)(_=p[r[g]]||new m(r[g],[])).gsClass?(o[g]=_.gsClass,v--):h&&_.sc.push(this);if(0===v&&n)for(u=("com.greensock."+s).split("."),c=u.pop(),f=l(u.join("."))[c]=this.gsClass=n.apply(n,o),a&&(i[c]=f,d="undefined"!=typeof module&&module.exports,!d&&"function"==typeof define&&define.amd?define((t.GreenSockAMDPath?t.GreenSockAMDPath+"/":"")+s.split(".").pop(),[],function(){return f}):s===e&&d&&(module.exports=f)),g=0;this.sc.length>g;g++)this.sc[g].check()},this.check(!0)},d=t._gsDefine=function(t,e,i,s){return new m(t,e,i,s)},g=h._class=function(t,e,i){return e=e||function(){},d(t,[],function(){return e},i),e};d.globals=i;var v=[0,0,1,1],y=[],T=g("easing.Ease",function(t,e,i,s){this._func=t,this._type=i||0,this._power=s||0,this._params=e?v.concat(e):v},!0),x=T.map={},w=T.register=function(t,e,i,s){for(var r,n,a,o,l=e.split(","),_=l.length,u=(i||"easeIn,easeOut,easeInOut").split(",");--_>-1;)for(n=l[_],r=s?g("easing."+n,null,!0):h.easing[n]||{},a=u.length;--a>-1;)o=u[a],x[n+"."+o]=x[o+n]=r[o]=t.getRatio?t:t[o]||new t};for(n=T.prototype,n._calcEnd=!1,n.getRatio=function(t){if(this._func)return this._params[0]=t,this._func.apply(null,this._params);var e=this._type,i=this._power,s=1===e?1-t:2===e?t:.5>t?2*t:2*(1-t);return 1===i?s*=s:2===i?s*=s*s:3===i?s*=s*s*s:4===i&&(s*=s*s*s*s),1===e?1-s:2===e?s:.5>t?s/2:1-s/2},s=["Linear","Quad","Cubic","Quart","Quint,Strong"],r=s.length;--r>-1;)n=s[r]+",Power"+r,w(new T(null,null,1,r),n,"easeOut",!0),w(new T(null,null,2,r),n,"easeIn"+(0===r?",easeNone":"")),w(new T(null,null,3,r),n,"easeInOut");x.linear=h.easing.Linear.easeIn,x.swing=h.easing.Quad.easeInOut;var b=g("events.EventDispatcher",function(t){this._listeners={},this._eventTarget=t||this});n=b.prototype,n.addEventListener=function(t,e,i,s,r){r=r||0;var n,l,h=this._listeners[t],_=0;for(null==h&&(this._listeners[t]=h=[]),l=h.length;--l>-1;)n=h[l],n.c===e&&n.s===i?h.splice(l,1):0===_&&r>n.pr&&(_=l+1);h.splice(_,0,{c:e,s:i,up:s,pr:r}),this!==a||o||a.wake()},n.removeEventListener=function(t,e){var i,s=this._listeners[t];if(s)for(i=s.length;--i>-1;)if(s[i].c===e)return s.splice(i,1),void 0},n.dispatchEvent=function(t){var e,i,s,r=this._listeners[t];if(r)for(e=r.length,i=this._eventTarget;--e>-1;)s=r[e],s&&(s.up?s.c.call(s.s||i,{type:t,target:i}):s.c.call(s.s||i))};var P=t.requestAnimationFrame,k=t.cancelAnimationFrame,S=Date.now||function(){return(new Date).getTime()},R=S();for(s=["ms","moz","webkit","o"],r=s.length;--r>-1&&!P;)P=t[s[r]+"RequestAnimationFrame"],k=t[s[r]+"CancelAnimationFrame"]||t[s[r]+"CancelRequestAnimationFrame"];g("Ticker",function(t,e){var i,s,r,n,l,h=this,u=S(),f=e!==!1&&P,p=500,m=33,d="tick",g=function(t){var e,a,o=S()-R;o>p&&(u+=o-m),R+=o,h.time=(R-u)/1e3,e=h.time-l,(!i||e>0||t===!0)&&(h.frame++,l+=e+(e>=n?.004:n-e),a=!0),t!==!0&&(r=s(g)),a&&h.dispatchEvent(d)};b.call(h),h.time=h.frame=0,h.tick=function(){g(!0)},h.lagSmoothing=function(t,e){p=t||1/_,m=Math.min(e,p,0)},h.sleep=function(){null!=r&&(f&&k?k(r):clearTimeout(r),s=c,r=null,h===a&&(o=!1))},h.wake=function(){null!==r?h.sleep():h.frame>10&&(R=S()-p+5),s=0===i?c:f&&P?P:function(t){return setTimeout(t,0|1e3*(l-h.time)+1)},h===a&&(o=!0),g(2)},h.fps=function(t){return arguments.length?(i=t,n=1/(i||60),l=this.time+n,h.wake(),void 0):i},h.useRAF=function(t){return arguments.length?(h.sleep(),f=t,h.fps(i),void 0):f},h.fps(t),setTimeout(function(){f&&5>h.frame&&h.useRAF(!1)},1500)}),n=h.Ticker.prototype=new h.events.EventDispatcher,n.constructor=h.Ticker;var O=g("core.Animation",function(t,e){if(this.vars=e=e||{},this._duration=this._totalDuration=t||0,this._delay=Number(e.delay)||0,this._timeScale=1,this._active=e.immediateRender===!0,this.data=e.data,this._reversed=e.reversed===!0,W){o||a.wake();var i=this.vars.useFrames?G:W;i.add(this,i._time),this.vars.paused&&this.paused(!0)}});a=O.ticker=new h.Ticker,n=O.prototype,n._dirty=n._gc=n._initted=n._paused=!1,n._totalTime=n._time=0,n._rawPrevTime=-1,n._next=n._last=n._onUpdate=n._timeline=n.timeline=null,n._paused=!1;var A=function(){o&&S()-R>2e3&&a.wake(),setTimeout(A,2e3)};A(),n.play=function(t,e){return null!=t&&this.seek(t,e),this.reversed(!1).paused(!1)},n.pause=function(t,e){return null!=t&&this.seek(t,e),this.paused(!0)},n.resume=function(t,e){return null!=t&&this.seek(t,e),this.paused(!1)},n.seek=function(t,e){return this.totalTime(Number(t),e!==!1)},n.restart=function(t,e){return this.reversed(!1).paused(!1).totalTime(t?-this._delay:0,e!==!1,!0)},n.reverse=function(t,e){return null!=t&&this.seek(t||this.totalDuration(),e),this.reversed(!0).paused(!1)},n.render=function(){},n.invalidate=function(){return this._time=this._totalTime=0,this._initted=this._gc=!1,this._rawPrevTime=-1,(this._gc||!this.timeline)&&this._enabled(!0),this},n.isActive=function(){var t,e=this._timeline,i=this._startTime;return!e||!this._gc&&!this._paused&&e.isActive()&&(t=e.rawTime())>=i&&i+this.totalDuration()/this._timeScale>t},n._enabled=function(t,e){return o||a.wake(),this._gc=!t,this._active=this.isActive(),e!==!0&&(t&&!this.timeline?this._timeline.add(this,this._startTime-this._delay):!t&&this.timeline&&this._timeline._remove(this,!0)),!1},n._kill=function(){return this._enabled(!1,!1)},n.kill=function(t,e){return this._kill(t,e),this},n._uncache=function(t){for(var e=t?this:this.timeline;e;)e._dirty=!0,e=e.timeline;return this},n._swapSelfInParams=function(t){for(var e=t.length,i=t.concat();--e>-1;)"{self}"===t[e]&&(i[e]=this);return i},n._callback=function(t){var e=this.vars;e[t].apply(e[t+"Scope"]||e.callbackScope||this,e[t+"Params"]||y)},n.eventCallback=function(t,e,i,s){if("on"===(t||"").substr(0,2)){var r=this.vars;if(1===arguments.length)return r[t];null==e?delete r[t]:(r[t]=e,r[t+"Params"]=f(i)&&-1!==i.join("").indexOf("{self}")?this._swapSelfInParams(i):i,r[t+"Scope"]=s),"onUpdate"===t&&(this._onUpdate=e)}return this},n.delay=function(t){return arguments.length?(this._timeline.smoothChildTiming&&this.startTime(this._startTime+t-this._delay),this._delay=t,this):this._delay},n.duration=function(t){return arguments.length?(this._duration=this._totalDuration=t,this._uncache(!0),this._timeline.smoothChildTiming&&this._time>0&&this._time<this._duration&&0!==t&&this.totalTime(this._totalTime*(t/this._duration),!0),this):(this._dirty=!1,this._duration)},n.totalDuration=function(t){return this._dirty=!1,arguments.length?this.duration(t):this._totalDuration},n.time=function(t,e){return arguments.length?(this._dirty&&this.totalDuration(),this.totalTime(t>this._duration?this._duration:t,e)):this._time},n.totalTime=function(t,e,i){if(o||a.wake(),!arguments.length)return this._totalTime;if(this._timeline){if(0>t&&!i&&(t+=this.totalDuration()),this._timeline.smoothChildTiming){this._dirty&&this.totalDuration();var s=this._totalDuration,r=this._timeline;if(t>s&&!i&&(t=s),this._startTime=(this._paused?this._pauseTime:r._time)-(this._reversed?s-t:t)/this._timeScale,r._dirty||this._uncache(!1),r._timeline)for(;r._timeline;)r._timeline._time!==(r._startTime+r._totalTime)/r._timeScale&&r.totalTime(r._totalTime,!0),r=r._timeline}this._gc&&this._enabled(!0,!1),(this._totalTime!==t||0===this._duration)&&(F.length&&Q(),this.render(t,e,!1),F.length&&Q())}return this},n.progress=n.totalProgress=function(t,e){var i=this.duration();return arguments.length?this.totalTime(i*t,e):i?this._time/i:this.ratio},n.startTime=function(t){return arguments.length?(t!==this._startTime&&(this._startTime=t,this.timeline&&this.timeline._sortChildren&&this.timeline.add(this,t-this._delay)),this):this._startTime},n.endTime=function(t){return this._startTime+(0!=t?this.totalDuration():this.duration())/this._timeScale},n.timeScale=function(t){if(!arguments.length)return this._timeScale;if(t=t||_,this._timeline&&this._timeline.smoothChildTiming){var e=this._pauseTime,i=e||0===e?e:this._timeline.totalTime();this._startTime=i-(i-this._startTime)*this._timeScale/t}return this._timeScale=t,this._uncache(!1)},n.reversed=function(t){return arguments.length?(t!=this._reversed&&(this._reversed=t,this.totalTime(this._timeline&&!this._timeline.smoothChildTiming?this.totalDuration()-this._totalTime:this._totalTime,!0)),this):this._reversed},n.paused=function(t){if(!arguments.length)return this._paused;var e,i,s=this._timeline;return t!=this._paused&&s&&(o||t||a.wake(),e=s.rawTime(),i=e-this._pauseTime,!t&&s.smoothChildTiming&&(this._startTime+=i,this._uncache(!1)),this._pauseTime=t?e:null,this._paused=t,this._active=this.isActive(),!t&&0!==i&&this._initted&&this.duration()&&(e=s.smoothChildTiming?this._totalTime:(e-this._startTime)/this._timeScale,this.render(e,e===this._totalTime,!0))),this._gc&&!t&&this._enabled(!0,!1),this};var C=g("core.SimpleTimeline",function(t){O.call(this,0,t),this.autoRemoveChildren=this.smoothChildTiming=!0});n=C.prototype=new O,n.constructor=C,n.kill()._gc=!1,n._first=n._last=n._recent=null,n._sortChildren=!1,n.add=n.insert=function(t,e){var i,s;if(t._startTime=Number(e||0)+t._delay,t._paused&&this!==t._timeline&&(t._pauseTime=t._startTime+(this.rawTime()-t._startTime)/t._timeScale),t.timeline&&t.timeline._remove(t,!0),t.timeline=t._timeline=this,t._gc&&t._enabled(!0,!0),i=this._last,this._sortChildren)for(s=t._startTime;i&&i._startTime>s;)i=i._prev;return i?(t._next=i._next,i._next=t):(t._next=this._first,this._first=t),t._next?t._next._prev=t:this._last=t,t._prev=i,this._recent=t,this._timeline&&this._uncache(!0),this},n._remove=function(t,e){return t.timeline===this&&(e||t._enabled(!1,!0),t._prev?t._prev._next=t._next:this._first===t&&(this._first=t._next),t._next?t._next._prev=t._prev:this._last===t&&(this._last=t._prev),t._next=t._prev=t.timeline=null,t===this._recent&&(this._recent=this._last),this._timeline&&this._uncache(!0)),this},n.render=function(t,e,i){var s,r=this._first;for(this._totalTime=this._time=this._rawPrevTime=t;r;)s=r._next,(r._active||t>=r._startTime&&!r._paused)&&(r._reversed?r.render((r._dirty?r.totalDuration():r._totalDuration)-(t-r._startTime)*r._timeScale,e,i):r.render((t-r._startTime)*r._timeScale,e,i)),r=s},n.rawTime=function(){return o||a.wake(),this._totalTime};var D=g("TweenLite",function(e,i,s){if(O.call(this,i,s),this.render=D.prototype.render,null==e)throw"Cannot tween a null target.";this.target=e="string"!=typeof e?e:D.selector(e)||e;var r,n,a,o=e.jquery||e.length&&e!==t&&e[0]&&(e[0]===t||e[0].nodeType&&e[0].style&&!e.nodeType),l=this.vars.overwrite;if(this._overwrite=l=null==l?V[D.defaultOverwrite]:"number"==typeof l?l>>0:V[l],(o||e instanceof Array||e.push&&f(e))&&"number"!=typeof e[0])for(this._targets=a=u(e),this._propLookup=[],this._siblings=[],r=0;a.length>r;r++)n=a[r],n?"string"!=typeof n?n.length&&n!==t&&n[0]&&(n[0]===t||n[0].nodeType&&n[0].style&&!n.nodeType)?(a.splice(r--,1),this._targets=a=a.concat(u(n))):(this._siblings[r]=$(n,this,!1),1===l&&this._siblings[r].length>1&&K(n,this,null,1,this._siblings[r])):(n=a[r--]=D.selector(n),"string"==typeof n&&a.splice(r+1,1)):a.splice(r--,1);else this._propLookup={},this._siblings=$(e,this,!1),1===l&&this._siblings.length>1&&K(e,this,null,1,this._siblings);(this.vars.immediateRender||0===i&&0===this._delay&&this.vars.immediateRender!==!1)&&(this._time=-_,this.render(-this._delay))},!0),M=function(e){return e&&e.length&&e!==t&&e[0]&&(e[0]===t||e[0].nodeType&&e[0].style&&!e.nodeType)},z=function(t,e){var i,s={};for(i in t)q[i]||i in e&&"transform"!==i&&"x"!==i&&"y"!==i&&"width"!==i&&"height"!==i&&"className"!==i&&"border"!==i||!(!j[i]||j[i]&&j[i]._autoCSS)||(s[i]=t[i],delete t[i]);t.css=s};n=D.prototype=new O,n.constructor=D,n.kill()._gc=!1,n.ratio=0,n._firstPT=n._targets=n._overwrittenProps=n._startAt=null,n._notifyPluginsOfEnabled=n._lazy=!1,D.version="1.18.0",D.defaultEase=n._ease=new T(null,null,1,1),D.defaultOverwrite="auto",D.ticker=a,D.autoSleep=120,D.lagSmoothing=function(t,e){a.lagSmoothing(t,e)},D.selector=t.$||t.jQuery||function(e){var i=t.$||t.jQuery;return i?(D.selector=i,i(e)):"undefined"==typeof document?e:document.querySelectorAll?document.querySelectorAll(e):document.getElementById("#"===e.charAt(0)?e.substr(1):e)};var F=[],I={},E=/(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,N=function(t){for(var e,i=this._firstPT,s=1e-6;i;)e=i.blob?t?this.join(""):this.start:i.c*t+i.s,i.r?e=Math.round(e):s>e&&e>-s&&(e=0),i.f?i.fp?i.t[i.p](i.fp,e):i.t[i.p](e):i.t[i.p]=e,i=i._next},L=function(t,e,i,s){var r,n,a,o,l,h,_,u=[t,e],c=0,f="",p=0;for(u.start=t,i&&(i(u),t=u[0],e=u[1]),u.length=0,r=t.match(E)||[],n=e.match(E)||[],s&&(s._next=null,s.blob=1,u._firstPT=s),l=n.length,o=0;l>o;o++)_=n[o],h=e.substr(c,e.indexOf(_,c)-c),f+=h||!o?h:",",c+=h.length,p?p=(p+1)%5:"rgba("===h.substr(-5)&&(p=1),_===r[o]||o>=r.length?f+=_:(f&&(u.push(f),f=""),a=parseFloat(r[o]),u.push(a),u._firstPT={_next:u._firstPT,t:u,p:u.length-1,s:a,c:("="===_.charAt(1)?parseInt(_.charAt(0)+"1",10)*parseFloat(_.substr(2)):parseFloat(_)-a)||0,f:0,r:p&&4>p}),c+=_.length;return f+=e.substr(c),f&&u.push(f),u.setRatio=N,u},X=function(t,e,i,s,r,n,a,o){var l,h,_="get"===i?t[e]:i,u=typeof t[e],c="string"==typeof s&&"="===s.charAt(1),f={t:t,p:e,s:_,f:"function"===u,pg:0,n:r||e,r:n,pr:0,c:c?parseInt(s.charAt(0)+"1",10)*parseFloat(s.substr(2)):parseFloat(s)-_||0};return"number"!==u&&("function"===u&&"get"===i&&(h=e.indexOf("set")||"function"!=typeof t["get"+e.substr(3)]?e:"get"+e.substr(3),f.s=_=a?t[h](a):t[h]()),"string"==typeof _&&(a||isNaN(_))?(f.fp=a,l=L(_,s,o||D.defaultStringFilter,f),f={t:l,p:"setRatio",s:0,c:1,f:2,pg:0,n:r||e,pr:0}):c||(f.c=parseFloat(s)-parseFloat(_)||0)),f.c?((f._next=this._firstPT)&&(f._next._prev=f),this._firstPT=f,f):void 0},B=D._internals={isArray:f,isSelector:M,lazyTweens:F,blobDif:L},j=D._plugins={},Y=B.tweenLookup={},U=0,q=B.reservedProps={ease:1,delay:1,overwrite:1,onComplete:1,onCompleteParams:1,onCompleteScope:1,useFrames:1,runBackwards:1,startAt:1,onUpdate:1,onUpdateParams:1,onUpdateScope:1,onStart:1,onStartParams:1,onStartScope:1,onReverseComplete:1,onReverseCompleteParams:1,onReverseCompleteScope:1,onRepeat:1,onRepeatParams:1,onRepeatScope:1,easeParams:1,yoyo:1,immediateRender:1,repeat:1,repeatDelay:1,data:1,paused:1,reversed:1,autoCSS:1,lazy:1,onOverwrite:1,callbackScope:1,stringFilter:1},V={none:0,all:1,auto:2,concurrent:3,allOnStart:4,preexisting:5,"true":1,"false":0},G=O._rootFramesTimeline=new C,W=O._rootTimeline=new C,Z=30,Q=B.lazyRender=function(){var t,e=F.length;for(I={};--e>-1;)t=F[e],t&&t._lazy!==!1&&(t.render(t._lazy[0],t._lazy[1],!0),t._lazy=!1);F.length=0};W._startTime=a.time,G._startTime=a.frame,W._active=G._active=!0,setTimeout(Q,1),O._updateRoot=D.render=function(){var t,e,i;if(F.length&&Q(),W.render((a.time-W._startTime)*W._timeScale,!1,!1),G.render((a.frame-G._startTime)*G._timeScale,!1,!1),F.length&&Q(),a.frame>=Z){Z=a.frame+(parseInt(D.autoSleep,10)||120);
for(i in Y){for(e=Y[i].tweens,t=e.length;--t>-1;)e[t]._gc&&e.splice(t,1);0===e.length&&delete Y[i]}if(i=W._first,(!i||i._paused)&&D.autoSleep&&!G._first&&1===a._listeners.tick.length){for(;i&&i._paused;)i=i._next;i||a.sleep()}}},a.addEventListener("tick",O._updateRoot);var $=function(t,e,i){var s,r,n=t._gsTweenID;if(Y[n||(t._gsTweenID=n="t"+U++)]||(Y[n]={target:t,tweens:[]}),e&&(s=Y[n].tweens,s[r=s.length]=e,i))for(;--r>-1;)s[r]===e&&s.splice(r,1);return Y[n].tweens},H=function(t,e,i,s){var r,n,a=t.vars.onOverwrite;return a&&(r=a(t,e,i,s)),a=D.onOverwrite,a&&(n=a(t,e,i,s)),r!==!1&&n!==!1},K=function(t,e,i,s,r){var n,a,o,l;if(1===s||s>=4){for(l=r.length,n=0;l>n;n++)if((o=r[n])!==e)o._gc||o._kill(null,t,e)&&(a=!0);else if(5===s)break;return a}var h,u=e._startTime+_,c=[],f=0,p=0===e._duration;for(n=r.length;--n>-1;)(o=r[n])===e||o._gc||o._paused||(o._timeline!==e._timeline?(h=h||J(e,0,p),0===J(o,h,p)&&(c[f++]=o)):u>=o._startTime&&o._startTime+o.totalDuration()/o._timeScale>u&&((p||!o._initted)&&2e-10>=u-o._startTime||(c[f++]=o)));for(n=f;--n>-1;)if(o=c[n],2===s&&o._kill(i,t,e)&&(a=!0),2!==s||!o._firstPT&&o._initted){if(2!==s&&!H(o,e))continue;o._enabled(!1,!1)&&(a=!0)}return a},J=function(t,e,i){for(var s=t._timeline,r=s._timeScale,n=t._startTime;s._timeline;){if(n+=s._startTime,r*=s._timeScale,s._paused)return-100;s=s._timeline}return n/=r,n>e?n-e:i&&n===e||!t._initted&&2*_>n-e?_:(n+=t.totalDuration()/t._timeScale/r)>e+_?0:n-e-_};n._init=function(){var t,e,i,s,r,n=this.vars,a=this._overwrittenProps,o=this._duration,l=!!n.immediateRender,h=n.ease;if(n.startAt){this._startAt&&(this._startAt.render(-1,!0),this._startAt.kill()),r={};for(s in n.startAt)r[s]=n.startAt[s];if(r.overwrite=!1,r.immediateRender=!0,r.lazy=l&&n.lazy!==!1,r.startAt=r.delay=null,this._startAt=D.to(this.target,0,r),l)if(this._time>0)this._startAt=null;else if(0!==o)return}else if(n.runBackwards&&0!==o)if(this._startAt)this._startAt.render(-1,!0),this._startAt.kill(),this._startAt=null;else{0!==this._time&&(l=!1),i={};for(s in n)q[s]&&"autoCSS"!==s||(i[s]=n[s]);if(i.overwrite=0,i.data="isFromStart",i.lazy=l&&n.lazy!==!1,i.immediateRender=l,this._startAt=D.to(this.target,0,i),l){if(0===this._time)return}else this._startAt._init(),this._startAt._enabled(!1),this.vars.immediateRender&&(this._startAt=null)}if(this._ease=h=h?h instanceof T?h:"function"==typeof h?new T(h,n.easeParams):x[h]||D.defaultEase:D.defaultEase,n.easeParams instanceof Array&&h.config&&(this._ease=h.config.apply(h,n.easeParams)),this._easeType=this._ease._type,this._easePower=this._ease._power,this._firstPT=null,this._targets)for(t=this._targets.length;--t>-1;)this._initProps(this._targets[t],this._propLookup[t]={},this._siblings[t],a?a[t]:null)&&(e=!0);else e=this._initProps(this.target,this._propLookup,this._siblings,a);if(e&&D._onPluginEvent("_onInitAllProps",this),a&&(this._firstPT||"function"!=typeof this.target&&this._enabled(!1,!1)),n.runBackwards)for(i=this._firstPT;i;)i.s+=i.c,i.c=-i.c,i=i._next;this._onUpdate=n.onUpdate,this._initted=!0},n._initProps=function(e,i,s,r){var n,a,o,l,h,_;if(null==e)return!1;I[e._gsTweenID]&&Q(),this.vars.css||e.style&&e!==t&&e.nodeType&&j.css&&this.vars.autoCSS!==!1&&z(this.vars,e);for(n in this.vars)if(_=this.vars[n],q[n])_&&(_ instanceof Array||_.push&&f(_))&&-1!==_.join("").indexOf("{self}")&&(this.vars[n]=_=this._swapSelfInParams(_,this));else if(j[n]&&(l=new j[n])._onInitTween(e,this.vars[n],this)){for(this._firstPT=h={_next:this._firstPT,t:l,p:"setRatio",s:0,c:1,f:1,n:n,pg:1,pr:l._priority},a=l._overwriteProps.length;--a>-1;)i[l._overwriteProps[a]]=this._firstPT;(l._priority||l._onInitAllProps)&&(o=!0),(l._onDisable||l._onEnable)&&(this._notifyPluginsOfEnabled=!0),h._next&&(h._next._prev=h)}else i[n]=X.call(this,e,n,"get",_,n,0,null,this.vars.stringFilter);return r&&this._kill(r,e)?this._initProps(e,i,s,r):this._overwrite>1&&this._firstPT&&s.length>1&&K(e,this,i,this._overwrite,s)?(this._kill(i,e),this._initProps(e,i,s,r)):(this._firstPT&&(this.vars.lazy!==!1&&this._duration||this.vars.lazy&&!this._duration)&&(I[e._gsTweenID]=!0),o)},n.render=function(t,e,i){var s,r,n,a,o=this._time,l=this._duration,h=this._rawPrevTime;if(t>=l)this._totalTime=this._time=l,this.ratio=this._ease._calcEnd?this._ease.getRatio(1):1,this._reversed||(s=!0,r="onComplete",i=i||this._timeline.autoRemoveChildren),0===l&&(this._initted||!this.vars.lazy||i)&&(this._startTime===this._timeline._duration&&(t=0),(0===t||0>h||h===_&&"isPause"!==this.data)&&h!==t&&(i=!0,h>_&&(r="onReverseComplete")),this._rawPrevTime=a=!e||t||h===t?t:_);else if(1e-7>t)this._totalTime=this._time=0,this.ratio=this._ease._calcEnd?this._ease.getRatio(0):0,(0!==o||0===l&&h>0)&&(r="onReverseComplete",s=this._reversed),0>t&&(this._active=!1,0===l&&(this._initted||!this.vars.lazy||i)&&(h>=0&&(h!==_||"isPause"!==this.data)&&(i=!0),this._rawPrevTime=a=!e||t||h===t?t:_)),this._initted||(i=!0);else if(this._totalTime=this._time=t,this._easeType){var u=t/l,c=this._easeType,f=this._easePower;(1===c||3===c&&u>=.5)&&(u=1-u),3===c&&(u*=2),1===f?u*=u:2===f?u*=u*u:3===f?u*=u*u*u:4===f&&(u*=u*u*u*u),this.ratio=1===c?1-u:2===c?u:.5>t/l?u/2:1-u/2}else this.ratio=this._ease.getRatio(t/l);if(this._time!==o||i){if(!this._initted){if(this._init(),!this._initted||this._gc)return;if(!i&&this._firstPT&&(this.vars.lazy!==!1&&this._duration||this.vars.lazy&&!this._duration))return this._time=this._totalTime=o,this._rawPrevTime=h,F.push(this),this._lazy=[t,e],void 0;this._time&&!s?this.ratio=this._ease.getRatio(this._time/l):s&&this._ease._calcEnd&&(this.ratio=this._ease.getRatio(0===this._time?0:1))}for(this._lazy!==!1&&(this._lazy=!1),this._active||!this._paused&&this._time!==o&&t>=0&&(this._active=!0),0===o&&(this._startAt&&(t>=0?this._startAt.render(t,e,i):r||(r="_dummyGS")),this.vars.onStart&&(0!==this._time||0===l)&&(e||this._callback("onStart"))),n=this._firstPT;n;)n.f?n.t[n.p](n.c*this.ratio+n.s):n.t[n.p]=n.c*this.ratio+n.s,n=n._next;this._onUpdate&&(0>t&&this._startAt&&t!==-1e-4&&this._startAt.render(t,e,i),e||(this._time!==o||s)&&this._callback("onUpdate")),r&&(!this._gc||i)&&(0>t&&this._startAt&&!this._onUpdate&&t!==-1e-4&&this._startAt.render(t,e,i),s&&(this._timeline.autoRemoveChildren&&this._enabled(!1,!1),this._active=!1),!e&&this.vars[r]&&this._callback(r),0===l&&this._rawPrevTime===_&&a!==_&&(this._rawPrevTime=0))}},n._kill=function(t,e,i){if("all"===t&&(t=null),null==t&&(null==e||e===this.target))return this._lazy=!1,this._enabled(!1,!1);e="string"!=typeof e?e||this._targets||this.target:D.selector(e)||e;var s,r,n,a,o,l,h,_,u,c=i&&this._time&&i._startTime===this._startTime&&this._timeline===i._timeline;if((f(e)||M(e))&&"number"!=typeof e[0])for(s=e.length;--s>-1;)this._kill(t,e[s],i)&&(l=!0);else{if(this._targets){for(s=this._targets.length;--s>-1;)if(e===this._targets[s]){o=this._propLookup[s]||{},this._overwrittenProps=this._overwrittenProps||[],r=this._overwrittenProps[s]=t?this._overwrittenProps[s]||{}:"all";break}}else{if(e!==this.target)return!1;o=this._propLookup,r=this._overwrittenProps=t?this._overwrittenProps||{}:"all"}if(o){if(h=t||o,_=t!==r&&"all"!==r&&t!==o&&("object"!=typeof t||!t._tempKill),i&&(D.onOverwrite||this.vars.onOverwrite)){for(n in h)o[n]&&(u||(u=[]),u.push(n));if((u||!t)&&!H(this,i,e,u))return!1}for(n in h)(a=o[n])&&(c&&(a.f?a.t[a.p](a.s):a.t[a.p]=a.s,l=!0),a.pg&&a.t._kill(h)&&(l=!0),a.pg&&0!==a.t._overwriteProps.length||(a._prev?a._prev._next=a._next:a===this._firstPT&&(this._firstPT=a._next),a._next&&(a._next._prev=a._prev),a._next=a._prev=null),delete o[n]),_&&(r[n]=1);!this._firstPT&&this._initted&&this._enabled(!1,!1)}}return l},n.invalidate=function(){return this._notifyPluginsOfEnabled&&D._onPluginEvent("_onDisable",this),this._firstPT=this._overwrittenProps=this._startAt=this._onUpdate=null,this._notifyPluginsOfEnabled=this._active=this._lazy=!1,this._propLookup=this._targets?{}:[],O.prototype.invalidate.call(this),this.vars.immediateRender&&(this._time=-_,this.render(-this._delay)),this},n._enabled=function(t,e){if(o||a.wake(),t&&this._gc){var i,s=this._targets;if(s)for(i=s.length;--i>-1;)this._siblings[i]=$(s[i],this,!0);else this._siblings=$(this.target,this,!0)}return O.prototype._enabled.call(this,t,e),this._notifyPluginsOfEnabled&&this._firstPT?D._onPluginEvent(t?"_onEnable":"_onDisable",this):!1},D.to=function(t,e,i){return new D(t,e,i)},D.from=function(t,e,i){return i.runBackwards=!0,i.immediateRender=0!=i.immediateRender,new D(t,e,i)},D.fromTo=function(t,e,i,s){return s.startAt=i,s.immediateRender=0!=s.immediateRender&&0!=i.immediateRender,new D(t,e,s)},D.delayedCall=function(t,e,i,s,r){return new D(e,0,{delay:t,onComplete:e,onCompleteParams:i,callbackScope:s,onReverseComplete:e,onReverseCompleteParams:i,immediateRender:!1,lazy:!1,useFrames:r,overwrite:0})},D.set=function(t,e){return new D(t,0,e)},D.getTweensOf=function(t,e){if(null==t)return[];t="string"!=typeof t?t:D.selector(t)||t;var i,s,r,n;if((f(t)||M(t))&&"number"!=typeof t[0]){for(i=t.length,s=[];--i>-1;)s=s.concat(D.getTweensOf(t[i],e));for(i=s.length;--i>-1;)for(n=s[i],r=i;--r>-1;)n===s[r]&&s.splice(i,1)}else for(s=$(t).concat(),i=s.length;--i>-1;)(s[i]._gc||e&&!s[i].isActive())&&s.splice(i,1);return s},D.killTweensOf=D.killDelayedCallsTo=function(t,e,i){"object"==typeof e&&(i=e,e=!1);for(var s=D.getTweensOf(t,e),r=s.length;--r>-1;)s[r]._kill(i,t)};var te=g("plugins.TweenPlugin",function(t,e){this._overwriteProps=(t||"").split(","),this._propName=this._overwriteProps[0],this._priority=e||0,this._super=te.prototype},!0);if(n=te.prototype,te.version="1.18.0",te.API=2,n._firstPT=null,n._addTween=X,n.setRatio=N,n._kill=function(t){var e,i=this._overwriteProps,s=this._firstPT;if(null!=t[this._propName])this._overwriteProps=[];else for(e=i.length;--e>-1;)null!=t[i[e]]&&i.splice(e,1);for(;s;)null!=t[s.n]&&(s._next&&(s._next._prev=s._prev),s._prev?(s._prev._next=s._next,s._prev=null):this._firstPT===s&&(this._firstPT=s._next)),s=s._next;return!1},n._roundProps=function(t,e){for(var i=this._firstPT;i;)(t[this._propName]||null!=i.n&&t[i.n.split(this._propName+"_").join("")])&&(i.r=e),i=i._next},D._onPluginEvent=function(t,e){var i,s,r,n,a,o=e._firstPT;if("_onInitAllProps"===t){for(;o;){for(a=o._next,s=r;s&&s.pr>o.pr;)s=s._next;(o._prev=s?s._prev:n)?o._prev._next=o:r=o,(o._next=s)?s._prev=o:n=o,o=a}o=e._firstPT=r}for(;o;)o.pg&&"function"==typeof o.t[t]&&o.t[t]()&&(i=!0),o=o._next;return i},te.activate=function(t){for(var e=t.length;--e>-1;)t[e].API===te.API&&(j[(new t[e])._propName]=t[e]);return!0},d.plugin=function(t){if(!(t&&t.propName&&t.init&&t.API))throw"illegal plugin definition.";var e,i=t.propName,s=t.priority||0,r=t.overwriteProps,n={init:"_onInitTween",set:"setRatio",kill:"_kill",round:"_roundProps",initAll:"_onInitAllProps"},a=g("plugins."+i.charAt(0).toUpperCase()+i.substr(1)+"Plugin",function(){te.call(this,i,s),this._overwriteProps=r||[]},t.global===!0),o=a.prototype=new te(i);o.constructor=a,a.API=t.API;for(e in n)"function"==typeof t[e]&&(o[n[e]]=t[e]);return a.version=t.version,te.activate([a]),a},s=t._gsQueue){for(r=0;s.length>r;r++)s[r]();for(n in p)p[n].func||t.console.log("GSAP encountered missing dependency: com.greensock."+n)}o=!1}}("undefined"!=typeof module&&module.exports&&"undefined"!=typeof global?global:this||window,"TweenMax");
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9qYXZhc2NyaXB0L2xpYnMvVHdlZW5NYXgvVHdlZW5NYXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVkVSU0lPTjogMS4xOC4wXG4gKiBEQVRFOiAyMDE1LTA5LTA1XG4gKiBVUERBVEVTIEFORCBET0NTIEFUOiBodHRwOi8vZ3JlZW5zb2NrLmNvbVxuICogXG4gKiBJbmNsdWRlcyBhbGwgb2YgdGhlIGZvbGxvd2luZzogVHdlZW5MaXRlLCBUd2Vlbk1heCwgVGltZWxpbmVMaXRlLCBUaW1lbGluZU1heCwgRWFzZVBhY2ssIENTU1BsdWdpbiwgUm91bmRQcm9wc1BsdWdpbiwgQmV6aWVyUGx1Z2luLCBBdHRyUGx1Z2luLCBEaXJlY3Rpb25hbFJvdGF0aW9uUGx1Z2luXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDA4LTIwMTUsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgd29yayBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIHNvZnR3YXJlIGFncmVlbWVudCB0aGF0IHdhcyBpc3N1ZWQgd2l0aCB5b3VyIG1lbWJlcnNoaXAuXG4gKiBcbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuICoqL1xudmFyIF9nc1Njb3BlPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDp0aGlzfHx3aW5kb3c7KF9nc1Njb3BlLl9nc1F1ZXVlfHwoX2dzU2NvcGUuX2dzUXVldWU9W10pKS5wdXNoKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7X2dzU2NvcGUuX2dzRGVmaW5lKFwiVHdlZW5NYXhcIixbXCJjb3JlLkFuaW1hdGlvblwiLFwiY29yZS5TaW1wbGVUaW1lbGluZVwiLFwiVHdlZW5MaXRlXCJdLGZ1bmN0aW9uKHQsZSxpKXt2YXIgcz1mdW5jdGlvbih0KXt2YXIgZSxpPVtdLHM9dC5sZW5ndGg7Zm9yKGU9MDtlIT09cztpLnB1c2godFtlKytdKSk7cmV0dXJuIGl9LHI9ZnVuY3Rpb24odCxlLGkpe3ZhciBzLHIsbj10LmN5Y2xlO2ZvcihzIGluIG4pcj1uW3NdLHRbc109XCJmdW5jdGlvblwiPT10eXBlb2Ygcj9yLmNhbGwoZVtpXSxpKTpyW2klci5sZW5ndGhdO2RlbGV0ZSB0LmN5Y2xlfSxuPWZ1bmN0aW9uKHQsZSxzKXtpLmNhbGwodGhpcyx0LGUscyksdGhpcy5fY3ljbGU9MCx0aGlzLl95b3lvPXRoaXMudmFycy55b3lvPT09ITAsdGhpcy5fcmVwZWF0PXRoaXMudmFycy5yZXBlYXR8fDAsdGhpcy5fcmVwZWF0RGVsYXk9dGhpcy52YXJzLnJlcGVhdERlbGF5fHwwLHRoaXMuX2RpcnR5PSEwLHRoaXMucmVuZGVyPW4ucHJvdG90eXBlLnJlbmRlcn0sYT0xZS0xMCxvPWkuX2ludGVybmFscyxsPW8uaXNTZWxlY3RvcixoPW8uaXNBcnJheSxfPW4ucHJvdG90eXBlPWkudG8oe30sLjEse30pLHU9W107bi52ZXJzaW9uPVwiMS4xOC4wXCIsXy5jb25zdHJ1Y3Rvcj1uLF8ua2lsbCgpLl9nYz0hMSxuLmtpbGxUd2VlbnNPZj1uLmtpbGxEZWxheWVkQ2FsbHNUbz1pLmtpbGxUd2VlbnNPZixuLmdldFR3ZWVuc09mPWkuZ2V0VHdlZW5zT2Ysbi5sYWdTbW9vdGhpbmc9aS5sYWdTbW9vdGhpbmcsbi50aWNrZXI9aS50aWNrZXIsbi5yZW5kZXI9aS5yZW5kZXIsXy5pbnZhbGlkYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3lveW89dGhpcy52YXJzLnlveW89PT0hMCx0aGlzLl9yZXBlYXQ9dGhpcy52YXJzLnJlcGVhdHx8MCx0aGlzLl9yZXBlYXREZWxheT10aGlzLnZhcnMucmVwZWF0RGVsYXl8fDAsdGhpcy5fdW5jYWNoZSghMCksaS5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMpfSxfLnVwZGF0ZVRvPWZ1bmN0aW9uKHQsZSl7dmFyIHMscj10aGlzLnJhdGlvLG49dGhpcy52YXJzLmltbWVkaWF0ZVJlbmRlcnx8dC5pbW1lZGlhdGVSZW5kZXI7ZSYmdGhpcy5fc3RhcnRUaW1lPHRoaXMuX3RpbWVsaW5lLl90aW1lJiYodGhpcy5fc3RhcnRUaW1lPXRoaXMuX3RpbWVsaW5lLl90aW1lLHRoaXMuX3VuY2FjaGUoITEpLHRoaXMuX2djP3RoaXMuX2VuYWJsZWQoITAsITEpOnRoaXMuX3RpbWVsaW5lLmluc2VydCh0aGlzLHRoaXMuX3N0YXJ0VGltZS10aGlzLl9kZWxheSkpO2ZvcihzIGluIHQpdGhpcy52YXJzW3NdPXRbc107aWYodGhpcy5faW5pdHRlZHx8bilpZihlKXRoaXMuX2luaXR0ZWQ9ITEsbiYmdGhpcy5yZW5kZXIoMCwhMCwhMCk7ZWxzZSBpZih0aGlzLl9nYyYmdGhpcy5fZW5hYmxlZCghMCwhMSksdGhpcy5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZCYmdGhpcy5fZmlyc3RQVCYmaS5fb25QbHVnaW5FdmVudChcIl9vbkRpc2FibGVcIix0aGlzKSx0aGlzLl90aW1lL3RoaXMuX2R1cmF0aW9uPi45OTgpe3ZhciBhPXRoaXMuX3RpbWU7dGhpcy5yZW5kZXIoMCwhMCwhMSksdGhpcy5faW5pdHRlZD0hMSx0aGlzLnJlbmRlcihhLCEwLCExKX1lbHNlIGlmKHRoaXMuX3RpbWU+MHx8bil7dGhpcy5faW5pdHRlZD0hMSx0aGlzLl9pbml0KCk7Zm9yKHZhciBvLGw9MS8oMS1yKSxoPXRoaXMuX2ZpcnN0UFQ7aDspbz1oLnMraC5jLGguYyo9bCxoLnM9by1oLmMsaD1oLl9uZXh0fXJldHVybiB0aGlzfSxfLnJlbmRlcj1mdW5jdGlvbih0LGUsaSl7dGhpcy5faW5pdHRlZHx8MD09PXRoaXMuX2R1cmF0aW9uJiZ0aGlzLnZhcnMucmVwZWF0JiZ0aGlzLmludmFsaWRhdGUoKTt2YXIgcyxyLG4sbCxoLF8sdSxjLGY9dGhpcy5fZGlydHk/dGhpcy50b3RhbER1cmF0aW9uKCk6dGhpcy5fdG90YWxEdXJhdGlvbixwPXRoaXMuX3RpbWUsbT10aGlzLl90b3RhbFRpbWUsZD10aGlzLl9jeWNsZSxnPXRoaXMuX2R1cmF0aW9uLHY9dGhpcy5fcmF3UHJldlRpbWU7aWYodD49Zj8odGhpcy5fdG90YWxUaW1lPWYsdGhpcy5fY3ljbGU9dGhpcy5fcmVwZWF0LHRoaXMuX3lveW8mJjAhPT0oMSZ0aGlzLl9jeWNsZSk/KHRoaXMuX3RpbWU9MCx0aGlzLnJhdGlvPXRoaXMuX2Vhc2UuX2NhbGNFbmQ/dGhpcy5fZWFzZS5nZXRSYXRpbygwKTowKToodGhpcy5fdGltZT1nLHRoaXMucmF0aW89dGhpcy5fZWFzZS5fY2FsY0VuZD90aGlzLl9lYXNlLmdldFJhdGlvKDEpOjEpLHRoaXMuX3JldmVyc2VkfHwocz0hMCxyPVwib25Db21wbGV0ZVwiLGk9aXx8dGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuKSwwPT09ZyYmKHRoaXMuX2luaXR0ZWR8fCF0aGlzLnZhcnMubGF6eXx8aSkmJih0aGlzLl9zdGFydFRpbWU9PT10aGlzLl90aW1lbGluZS5fZHVyYXRpb24mJih0PTApLCgwPT09dHx8MD52fHx2PT09YSkmJnYhPT10JiYoaT0hMCx2PmEmJihyPVwib25SZXZlcnNlQ29tcGxldGVcIikpLHRoaXMuX3Jhd1ByZXZUaW1lPWM9IWV8fHR8fHY9PT10P3Q6YSkpOjFlLTc+dD8odGhpcy5fdG90YWxUaW1lPXRoaXMuX3RpbWU9dGhpcy5fY3ljbGU9MCx0aGlzLnJhdGlvPXRoaXMuX2Vhc2UuX2NhbGNFbmQ/dGhpcy5fZWFzZS5nZXRSYXRpbygwKTowLCgwIT09bXx8MD09PWcmJnY+MCkmJihyPVwib25SZXZlcnNlQ29tcGxldGVcIixzPXRoaXMuX3JldmVyc2VkKSwwPnQmJih0aGlzLl9hY3RpdmU9ITEsMD09PWcmJih0aGlzLl9pbml0dGVkfHwhdGhpcy52YXJzLmxhenl8fGkpJiYodj49MCYmKGk9ITApLHRoaXMuX3Jhd1ByZXZUaW1lPWM9IWV8fHR8fHY9PT10P3Q6YSkpLHRoaXMuX2luaXR0ZWR8fChpPSEwKSk6KHRoaXMuX3RvdGFsVGltZT10aGlzLl90aW1lPXQsMCE9PXRoaXMuX3JlcGVhdCYmKGw9Zyt0aGlzLl9yZXBlYXREZWxheSx0aGlzLl9jeWNsZT10aGlzLl90b3RhbFRpbWUvbD4+MCwwIT09dGhpcy5fY3ljbGUmJnRoaXMuX2N5Y2xlPT09dGhpcy5fdG90YWxUaW1lL2wmJnRoaXMuX2N5Y2xlLS0sdGhpcy5fdGltZT10aGlzLl90b3RhbFRpbWUtdGhpcy5fY3ljbGUqbCx0aGlzLl95b3lvJiYwIT09KDEmdGhpcy5fY3ljbGUpJiYodGhpcy5fdGltZT1nLXRoaXMuX3RpbWUpLHRoaXMuX3RpbWU+Zz90aGlzLl90aW1lPWc6MD50aGlzLl90aW1lJiYodGhpcy5fdGltZT0wKSksdGhpcy5fZWFzZVR5cGU/KGg9dGhpcy5fdGltZS9nLF89dGhpcy5fZWFzZVR5cGUsdT10aGlzLl9lYXNlUG93ZXIsKDE9PT1ffHwzPT09XyYmaD49LjUpJiYoaD0xLWgpLDM9PT1fJiYoaCo9MiksMT09PXU/aCo9aDoyPT09dT9oKj1oKmg6Mz09PXU/aCo9aCpoKmg6ND09PXUmJihoKj1oKmgqaCpoKSx0aGlzLnJhdGlvPTE9PT1fPzEtaDoyPT09Xz9oOi41PnRoaXMuX3RpbWUvZz9oLzI6MS1oLzIpOnRoaXMucmF0aW89dGhpcy5fZWFzZS5nZXRSYXRpbyh0aGlzLl90aW1lL2cpKSxwPT09dGhpcy5fdGltZSYmIWkmJmQ9PT10aGlzLl9jeWNsZSlyZXR1cm4gbSE9PXRoaXMuX3RvdGFsVGltZSYmdGhpcy5fb25VcGRhdGUmJihlfHx0aGlzLl9jYWxsYmFjayhcIm9uVXBkYXRlXCIpKSx2b2lkIDA7aWYoIXRoaXMuX2luaXR0ZWQpe2lmKHRoaXMuX2luaXQoKSwhdGhpcy5faW5pdHRlZHx8dGhpcy5fZ2MpcmV0dXJuO2lmKCFpJiZ0aGlzLl9maXJzdFBUJiYodGhpcy52YXJzLmxhenkhPT0hMSYmdGhpcy5fZHVyYXRpb258fHRoaXMudmFycy5sYXp5JiYhdGhpcy5fZHVyYXRpb24pKXJldHVybiB0aGlzLl90aW1lPXAsdGhpcy5fdG90YWxUaW1lPW0sdGhpcy5fcmF3UHJldlRpbWU9dix0aGlzLl9jeWNsZT1kLG8ubGF6eVR3ZWVucy5wdXNoKHRoaXMpLHRoaXMuX2xhenk9W3QsZV0sdm9pZCAwO3RoaXMuX3RpbWUmJiFzP3RoaXMucmF0aW89dGhpcy5fZWFzZS5nZXRSYXRpbyh0aGlzLl90aW1lL2cpOnMmJnRoaXMuX2Vhc2UuX2NhbGNFbmQmJih0aGlzLnJhdGlvPXRoaXMuX2Vhc2UuZ2V0UmF0aW8oMD09PXRoaXMuX3RpbWU/MDoxKSl9Zm9yKHRoaXMuX2xhenkhPT0hMSYmKHRoaXMuX2xhenk9ITEpLHRoaXMuX2FjdGl2ZXx8IXRoaXMuX3BhdXNlZCYmdGhpcy5fdGltZSE9PXAmJnQ+PTAmJih0aGlzLl9hY3RpdmU9ITApLDA9PT1tJiYoMj09PXRoaXMuX2luaXR0ZWQmJnQ+MCYmdGhpcy5faW5pdCgpLHRoaXMuX3N0YXJ0QXQmJih0Pj0wP3RoaXMuX3N0YXJ0QXQucmVuZGVyKHQsZSxpKTpyfHwocj1cIl9kdW1teUdTXCIpKSx0aGlzLnZhcnMub25TdGFydCYmKDAhPT10aGlzLl90b3RhbFRpbWV8fDA9PT1nKSYmKGV8fHRoaXMuX2NhbGxiYWNrKFwib25TdGFydFwiKSkpLG49dGhpcy5fZmlyc3RQVDtuOyluLmY/bi50W24ucF0obi5jKnRoaXMucmF0aW8rbi5zKTpuLnRbbi5wXT1uLmMqdGhpcy5yYXRpbytuLnMsbj1uLl9uZXh0O3RoaXMuX29uVXBkYXRlJiYoMD50JiZ0aGlzLl9zdGFydEF0JiZ0aGlzLl9zdGFydFRpbWUmJnRoaXMuX3N0YXJ0QXQucmVuZGVyKHQsZSxpKSxlfHwodGhpcy5fdG90YWxUaW1lIT09bXx8cykmJnRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIikpLHRoaXMuX2N5Y2xlIT09ZCYmKGV8fHRoaXMuX2djfHx0aGlzLnZhcnMub25SZXBlYXQmJnRoaXMuX2NhbGxiYWNrKFwib25SZXBlYXRcIikpLHImJighdGhpcy5fZ2N8fGkpJiYoMD50JiZ0aGlzLl9zdGFydEF0JiYhdGhpcy5fb25VcGRhdGUmJnRoaXMuX3N0YXJ0VGltZSYmdGhpcy5fc3RhcnRBdC5yZW5kZXIodCxlLGkpLHMmJih0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4mJnRoaXMuX2VuYWJsZWQoITEsITEpLHRoaXMuX2FjdGl2ZT0hMSksIWUmJnRoaXMudmFyc1tyXSYmdGhpcy5fY2FsbGJhY2sociksMD09PWcmJnRoaXMuX3Jhd1ByZXZUaW1lPT09YSYmYyE9PWEmJih0aGlzLl9yYXdQcmV2VGltZT0wKSl9LG4udG89ZnVuY3Rpb24odCxlLGkpe3JldHVybiBuZXcgbih0LGUsaSl9LG4uZnJvbT1mdW5jdGlvbih0LGUsaSl7cmV0dXJuIGkucnVuQmFja3dhcmRzPSEwLGkuaW1tZWRpYXRlUmVuZGVyPTAhPWkuaW1tZWRpYXRlUmVuZGVyLG5ldyBuKHQsZSxpKX0sbi5mcm9tVG89ZnVuY3Rpb24odCxlLGkscyl7cmV0dXJuIHMuc3RhcnRBdD1pLHMuaW1tZWRpYXRlUmVuZGVyPTAhPXMuaW1tZWRpYXRlUmVuZGVyJiYwIT1pLmltbWVkaWF0ZVJlbmRlcixuZXcgbih0LGUscyl9LG4uc3RhZ2dlclRvPW4uYWxsVG89ZnVuY3Rpb24odCxlLGEsbyxfLGMsZil7bz1vfHwwO3ZhciBwLG0sZCxnLHY9YS5kZWxheXx8MCx5PVtdLFQ9ZnVuY3Rpb24oKXthLm9uQ29tcGxldGUmJmEub25Db21wbGV0ZS5hcHBseShhLm9uQ29tcGxldGVTY29wZXx8dGhpcyxhcmd1bWVudHMpLF8uYXBwbHkoZnx8YS5jYWxsYmFja1Njb3BlfHx0aGlzLGN8fHUpfSx4PWEuY3ljbGUsdz1hLnN0YXJ0QXQmJmEuc3RhcnRBdC5jeWNsZTtmb3IoaCh0KXx8KFwic3RyaW5nXCI9PXR5cGVvZiB0JiYodD1pLnNlbGVjdG9yKHQpfHx0KSxsKHQpJiYodD1zKHQpKSksdD10fHxbXSwwPm8mJih0PXModCksdC5yZXZlcnNlKCksbyo9LTEpLHA9dC5sZW5ndGgtMSxkPTA7cD49ZDtkKyspe209e307Zm9yKGcgaW4gYSltW2ddPWFbZ107aWYoeCYmcihtLHQsZCksdyl7dz1tLnN0YXJ0QXQ9e307Zm9yKGcgaW4gYS5zdGFydEF0KXdbZ109YS5zdGFydEF0W2ddO3IobS5zdGFydEF0LHQsZCl9bS5kZWxheT12LGQ9PT1wJiZfJiYobS5vbkNvbXBsZXRlPVQpLHlbZF09bmV3IG4odFtkXSxlLG0pLHYrPW99cmV0dXJuIHl9LG4uc3RhZ2dlckZyb209bi5hbGxGcm9tPWZ1bmN0aW9uKHQsZSxpLHMscixhLG8pe3JldHVybiBpLnJ1bkJhY2t3YXJkcz0hMCxpLmltbWVkaWF0ZVJlbmRlcj0wIT1pLmltbWVkaWF0ZVJlbmRlcixuLnN0YWdnZXJUbyh0LGUsaSxzLHIsYSxvKX0sbi5zdGFnZ2VyRnJvbVRvPW4uYWxsRnJvbVRvPWZ1bmN0aW9uKHQsZSxpLHMscixhLG8sbCl7cmV0dXJuIHMuc3RhcnRBdD1pLHMuaW1tZWRpYXRlUmVuZGVyPTAhPXMuaW1tZWRpYXRlUmVuZGVyJiYwIT1pLmltbWVkaWF0ZVJlbmRlcixuLnN0YWdnZXJUbyh0LGUscyxyLGEsbyxsKX0sbi5kZWxheWVkQ2FsbD1mdW5jdGlvbih0LGUsaSxzLHIpe3JldHVybiBuZXcgbihlLDAse2RlbGF5OnQsb25Db21wbGV0ZTplLG9uQ29tcGxldGVQYXJhbXM6aSxjYWxsYmFja1Njb3BlOnMsb25SZXZlcnNlQ29tcGxldGU6ZSxvblJldmVyc2VDb21wbGV0ZVBhcmFtczppLGltbWVkaWF0ZVJlbmRlcjohMSx1c2VGcmFtZXM6cixvdmVyd3JpdGU6MH0pfSxuLnNldD1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgbih0LDAsZSl9LG4uaXNUd2VlbmluZz1mdW5jdGlvbih0KXtyZXR1cm4gaS5nZXRUd2VlbnNPZih0LCEwKS5sZW5ndGg+MH07dmFyIGM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIHM9W10scj0wLG49dC5fZmlyc3Q7bjspbiBpbnN0YW5jZW9mIGk/c1tyKytdPW46KGUmJihzW3IrK109bikscz1zLmNvbmNhdChjKG4sZSkpLHI9cy5sZW5ndGgpLG49bi5fbmV4dDtyZXR1cm4gc30sZj1uLmdldEFsbFR3ZWVucz1mdW5jdGlvbihlKXtyZXR1cm4gYyh0Ll9yb290VGltZWxpbmUsZSkuY29uY2F0KGModC5fcm9vdEZyYW1lc1RpbWVsaW5lLGUpKX07bi5raWxsQWxsPWZ1bmN0aW9uKHQsaSxzLHIpe251bGw9PWkmJihpPSEwKSxudWxsPT1zJiYocz0hMCk7dmFyIG4sYSxvLGw9ZigwIT1yKSxoPWwubGVuZ3RoLF89aSYmcyYmcjtmb3Iobz0wO2g+bztvKyspYT1sW29dLChffHxhIGluc3RhbmNlb2YgZXx8KG49YS50YXJnZXQ9PT1hLnZhcnMub25Db21wbGV0ZSkmJnN8fGkmJiFuKSYmKHQ/YS50b3RhbFRpbWUoYS5fcmV2ZXJzZWQ/MDphLnRvdGFsRHVyYXRpb24oKSk6YS5fZW5hYmxlZCghMSwhMSkpfSxuLmtpbGxDaGlsZFR3ZWVuc09mPWZ1bmN0aW9uKHQsZSl7aWYobnVsbCE9dCl7dmFyIHIsYSxfLHUsYyxmPW8udHdlZW5Mb29rdXA7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQmJih0PWkuc2VsZWN0b3IodCl8fHQpLGwodCkmJih0PXModCkpLGgodCkpZm9yKHU9dC5sZW5ndGg7LS11Pi0xOyluLmtpbGxDaGlsZFR3ZWVuc09mKHRbdV0sZSk7ZWxzZXtyPVtdO2ZvcihfIGluIGYpZm9yKGE9ZltfXS50YXJnZXQucGFyZW50Tm9kZTthOylhPT09dCYmKHI9ci5jb25jYXQoZltfXS50d2VlbnMpKSxhPWEucGFyZW50Tm9kZTtmb3IoYz1yLmxlbmd0aCx1PTA7Yz51O3UrKyllJiZyW3VdLnRvdGFsVGltZShyW3VdLnRvdGFsRHVyYXRpb24oKSksclt1XS5fZW5hYmxlZCghMSwhMSl9fX07dmFyIHA9ZnVuY3Rpb24odCxpLHMscil7aT1pIT09ITEscz1zIT09ITEscj1yIT09ITE7Zm9yKHZhciBuLGEsbz1mKHIpLGw9aSYmcyYmcixoPW8ubGVuZ3RoOy0taD4tMTspYT1vW2hdLChsfHxhIGluc3RhbmNlb2YgZXx8KG49YS50YXJnZXQ9PT1hLnZhcnMub25Db21wbGV0ZSkmJnN8fGkmJiFuKSYmYS5wYXVzZWQodCl9O3JldHVybiBuLnBhdXNlQWxsPWZ1bmN0aW9uKHQsZSxpKXtwKCEwLHQsZSxpKX0sbi5yZXN1bWVBbGw9ZnVuY3Rpb24odCxlLGkpe3AoITEsdCxlLGkpfSxuLmdsb2JhbFRpbWVTY2FsZT1mdW5jdGlvbihlKXt2YXIgcz10Ll9yb290VGltZWxpbmUscj1pLnRpY2tlci50aW1lO3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhlPWV8fGEscy5fc3RhcnRUaW1lPXItKHItcy5fc3RhcnRUaW1lKSpzLl90aW1lU2NhbGUvZSxzPXQuX3Jvb3RGcmFtZXNUaW1lbGluZSxyPWkudGlja2VyLmZyYW1lLHMuX3N0YXJ0VGltZT1yLShyLXMuX3N0YXJ0VGltZSkqcy5fdGltZVNjYWxlL2Uscy5fdGltZVNjYWxlPXQuX3Jvb3RUaW1lbGluZS5fdGltZVNjYWxlPWUsZSk6cy5fdGltZVNjYWxlfSxfLnByb2dyZXNzPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoP3RoaXMudG90YWxUaW1lKHRoaXMuZHVyYXRpb24oKSoodGhpcy5feW95byYmMCE9PSgxJnRoaXMuX2N5Y2xlKT8xLXQ6dCkrdGhpcy5fY3ljbGUqKHRoaXMuX2R1cmF0aW9uK3RoaXMuX3JlcGVhdERlbGF5KSwhMSk6dGhpcy5fdGltZS90aGlzLmR1cmF0aW9uKCl9LF8udG90YWxQcm9ncmVzcz1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD90aGlzLnRvdGFsVGltZSh0aGlzLnRvdGFsRHVyYXRpb24oKSp0LCExKTp0aGlzLl90b3RhbFRpbWUvdGhpcy50b3RhbER1cmF0aW9uKCl9LF8udGltZT1mdW5jdGlvbih0LGUpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh0aGlzLl9kaXJ0eSYmdGhpcy50b3RhbER1cmF0aW9uKCksdD50aGlzLl9kdXJhdGlvbiYmKHQ9dGhpcy5fZHVyYXRpb24pLHRoaXMuX3lveW8mJjAhPT0oMSZ0aGlzLl9jeWNsZSk/dD10aGlzLl9kdXJhdGlvbi10K3RoaXMuX2N5Y2xlKih0aGlzLl9kdXJhdGlvbit0aGlzLl9yZXBlYXREZWxheSk6MCE9PXRoaXMuX3JlcGVhdCYmKHQrPXRoaXMuX2N5Y2xlKih0aGlzLl9kdXJhdGlvbit0aGlzLl9yZXBlYXREZWxheSkpLHRoaXMudG90YWxUaW1lKHQsZSkpOnRoaXMuX3RpbWV9LF8uZHVyYXRpb249ZnVuY3Rpb24oZSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/dC5wcm90b3R5cGUuZHVyYXRpb24uY2FsbCh0aGlzLGUpOnRoaXMuX2R1cmF0aW9ufSxfLnRvdGFsRHVyYXRpb249ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/LTE9PT10aGlzLl9yZXBlYXQ/dGhpczp0aGlzLmR1cmF0aW9uKCh0LXRoaXMuX3JlcGVhdCp0aGlzLl9yZXBlYXREZWxheSkvKHRoaXMuX3JlcGVhdCsxKSk6KHRoaXMuX2RpcnR5JiYodGhpcy5fdG90YWxEdXJhdGlvbj0tMT09PXRoaXMuX3JlcGVhdD85OTk5OTk5OTk5OTk6dGhpcy5fZHVyYXRpb24qKHRoaXMuX3JlcGVhdCsxKSt0aGlzLl9yZXBlYXREZWxheSp0aGlzLl9yZXBlYXQsdGhpcy5fZGlydHk9ITEpLHRoaXMuX3RvdGFsRHVyYXRpb24pfSxfLnJlcGVhdD1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odGhpcy5fcmVwZWF0PXQsdGhpcy5fdW5jYWNoZSghMCkpOnRoaXMuX3JlcGVhdH0sXy5yZXBlYXREZWxheT1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odGhpcy5fcmVwZWF0RGVsYXk9dCx0aGlzLl91bmNhY2hlKCEwKSk6dGhpcy5fcmVwZWF0RGVsYXl9LF8ueW95bz1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odGhpcy5feW95bz10LHRoaXMpOnRoaXMuX3lveW99LG59LCEwKSxfZ3NTY29wZS5fZ3NEZWZpbmUoXCJUaW1lbGluZUxpdGVcIixbXCJjb3JlLkFuaW1hdGlvblwiLFwiY29yZS5TaW1wbGVUaW1lbGluZVwiLFwiVHdlZW5MaXRlXCJdLGZ1bmN0aW9uKHQsZSxpKXt2YXIgcz1mdW5jdGlvbih0KXtlLmNhbGwodGhpcyx0KSx0aGlzLl9sYWJlbHM9e30sdGhpcy5hdXRvUmVtb3ZlQ2hpbGRyZW49dGhpcy52YXJzLmF1dG9SZW1vdmVDaGlsZHJlbj09PSEwLHRoaXMuc21vb3RoQ2hpbGRUaW1pbmc9dGhpcy52YXJzLnNtb290aENoaWxkVGltaW5nPT09ITAsdGhpcy5fc29ydENoaWxkcmVuPSEwLHRoaXMuX29uVXBkYXRlPXRoaXMudmFycy5vblVwZGF0ZTt2YXIgaSxzLHI9dGhpcy52YXJzO2ZvcihzIGluIHIpaT1yW3NdLGwoaSkmJi0xIT09aS5qb2luKFwiXCIpLmluZGV4T2YoXCJ7c2VsZn1cIikmJihyW3NdPXRoaXMuX3N3YXBTZWxmSW5QYXJhbXMoaSkpO2woci50d2VlbnMpJiZ0aGlzLmFkZChyLnR3ZWVucywwLHIuYWxpZ24sci5zdGFnZ2VyKX0scj0xZS0xMCxuPWkuX2ludGVybmFscyxhPXMuX2ludGVybmFscz17fSxvPW4uaXNTZWxlY3RvcixsPW4uaXNBcnJheSxoPW4ubGF6eVR3ZWVucyxfPW4ubGF6eVJlbmRlcix1PV9nc1Njb3BlLl9nc0RlZmluZS5nbG9iYWxzLGM9ZnVuY3Rpb24odCl7dmFyIGUsaT17fTtmb3IoZSBpbiB0KWlbZV09dFtlXTtyZXR1cm4gaX0sZj1mdW5jdGlvbih0LGUsaSl7dmFyIHMscixuPXQuY3ljbGU7Zm9yKHMgaW4gbilyPW5bc10sdFtzXT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByP3IuY2FsbChlW2ldLGkpOnJbaSVyLmxlbmd0aF07ZGVsZXRlIHQuY3ljbGV9LHA9YS5wYXVzZUNhbGxiYWNrPWZ1bmN0aW9uKCl7fSxtPWZ1bmN0aW9uKHQpe3ZhciBlLGk9W10scz10Lmxlbmd0aDtmb3IoZT0wO2UhPT1zO2kucHVzaCh0W2UrK10pKTtyZXR1cm4gaX0sZD1zLnByb3RvdHlwZT1uZXcgZTtyZXR1cm4gcy52ZXJzaW9uPVwiMS4xOC4wXCIsZC5jb25zdHJ1Y3Rvcj1zLGQua2lsbCgpLl9nYz1kLl9mb3JjaW5nUGxheWhlYWQ9ZC5faGFzUGF1c2U9ITEsZC50bz1mdW5jdGlvbih0LGUscyxyKXt2YXIgbj1zLnJlcGVhdCYmdS5Ud2Vlbk1heHx8aTtyZXR1cm4gZT90aGlzLmFkZChuZXcgbih0LGUscykscik6dGhpcy5zZXQodCxzLHIpfSxkLmZyb209ZnVuY3Rpb24odCxlLHMscil7cmV0dXJuIHRoaXMuYWRkKChzLnJlcGVhdCYmdS5Ud2Vlbk1heHx8aSkuZnJvbSh0LGUscykscil9LGQuZnJvbVRvPWZ1bmN0aW9uKHQsZSxzLHIsbil7dmFyIGE9ci5yZXBlYXQmJnUuVHdlZW5NYXh8fGk7cmV0dXJuIGU/dGhpcy5hZGQoYS5mcm9tVG8odCxlLHMsciksbik6dGhpcy5zZXQodCxyLG4pfSxkLnN0YWdnZXJUbz1mdW5jdGlvbih0LGUscixuLGEsbCxoLF8pe3ZhciB1LHAsZD1uZXcgcyh7b25Db21wbGV0ZTpsLG9uQ29tcGxldGVQYXJhbXM6aCxjYWxsYmFja1Njb3BlOl8sc21vb3RoQ2hpbGRUaW1pbmc6dGhpcy5zbW9vdGhDaGlsZFRpbWluZ30pLGc9ci5jeWNsZTtmb3IoXCJzdHJpbmdcIj09dHlwZW9mIHQmJih0PWkuc2VsZWN0b3IodCl8fHQpLHQ9dHx8W10sbyh0KSYmKHQ9bSh0KSksbj1ufHwwLDA+biYmKHQ9bSh0KSx0LnJldmVyc2UoKSxuKj0tMSkscD0wO3QubGVuZ3RoPnA7cCsrKXU9YyhyKSx1LnN0YXJ0QXQmJih1LnN0YXJ0QXQ9Yyh1LnN0YXJ0QXQpLHUuc3RhcnRBdC5jeWNsZSYmZih1LnN0YXJ0QXQsdCxwKSksZyYmZih1LHQscCksZC50byh0W3BdLGUsdSxwKm4pO3JldHVybiB0aGlzLmFkZChkLGEpfSxkLnN0YWdnZXJGcm9tPWZ1bmN0aW9uKHQsZSxpLHMscixuLGEsbyl7cmV0dXJuIGkuaW1tZWRpYXRlUmVuZGVyPTAhPWkuaW1tZWRpYXRlUmVuZGVyLGkucnVuQmFja3dhcmRzPSEwLHRoaXMuc3RhZ2dlclRvKHQsZSxpLHMscixuLGEsbyl9LGQuc3RhZ2dlckZyb21Ubz1mdW5jdGlvbih0LGUsaSxzLHIsbixhLG8sbCl7cmV0dXJuIHMuc3RhcnRBdD1pLHMuaW1tZWRpYXRlUmVuZGVyPTAhPXMuaW1tZWRpYXRlUmVuZGVyJiYwIT1pLmltbWVkaWF0ZVJlbmRlcix0aGlzLnN0YWdnZXJUbyh0LGUscyxyLG4sYSxvLGwpfSxkLmNhbGw9ZnVuY3Rpb24odCxlLHMscil7cmV0dXJuIHRoaXMuYWRkKGkuZGVsYXllZENhbGwoMCx0LGUscykscil9LGQuc2V0PWZ1bmN0aW9uKHQsZSxzKXtyZXR1cm4gcz10aGlzLl9wYXJzZVRpbWVPckxhYmVsKHMsMCwhMCksbnVsbD09ZS5pbW1lZGlhdGVSZW5kZXImJihlLmltbWVkaWF0ZVJlbmRlcj1zPT09dGhpcy5fdGltZSYmIXRoaXMuX3BhdXNlZCksdGhpcy5hZGQobmV3IGkodCwwLGUpLHMpfSxzLmV4cG9ydFJvb3Q9ZnVuY3Rpb24odCxlKXt0PXR8fHt9LG51bGw9PXQuc21vb3RoQ2hpbGRUaW1pbmcmJih0LnNtb290aENoaWxkVGltaW5nPSEwKTt2YXIgcixuLGE9bmV3IHModCksbz1hLl90aW1lbGluZTtmb3IobnVsbD09ZSYmKGU9ITApLG8uX3JlbW92ZShhLCEwKSxhLl9zdGFydFRpbWU9MCxhLl9yYXdQcmV2VGltZT1hLl90aW1lPWEuX3RvdGFsVGltZT1vLl90aW1lLHI9by5fZmlyc3Q7cjspbj1yLl9uZXh0LGUmJnIgaW5zdGFuY2VvZiBpJiZyLnRhcmdldD09PXIudmFycy5vbkNvbXBsZXRlfHxhLmFkZChyLHIuX3N0YXJ0VGltZS1yLl9kZWxheSkscj1uO3JldHVybiBvLmFkZChhLDApLGF9LGQuYWRkPWZ1bmN0aW9uKHIsbixhLG8pe3ZhciBoLF8sdSxjLGYscDtpZihcIm51bWJlclwiIT10eXBlb2YgbiYmKG49dGhpcy5fcGFyc2VUaW1lT3JMYWJlbChuLDAsITAscikpLCEociBpbnN0YW5jZW9mIHQpKXtpZihyIGluc3RhbmNlb2YgQXJyYXl8fHImJnIucHVzaCYmbChyKSl7Zm9yKGE9YXx8XCJub3JtYWxcIixvPW98fDAsaD1uLF89ci5sZW5ndGgsdT0wO18+dTt1KyspbChjPXJbdV0pJiYoYz1uZXcgcyh7dHdlZW5zOmN9KSksdGhpcy5hZGQoYyxoKSxcInN0cmluZ1wiIT10eXBlb2YgYyYmXCJmdW5jdGlvblwiIT10eXBlb2YgYyYmKFwic2VxdWVuY2VcIj09PWE/aD1jLl9zdGFydFRpbWUrYy50b3RhbER1cmF0aW9uKCkvYy5fdGltZVNjYWxlOlwic3RhcnRcIj09PWEmJihjLl9zdGFydFRpbWUtPWMuZGVsYXkoKSkpLGgrPW87cmV0dXJuIHRoaXMuX3VuY2FjaGUoITApfWlmKFwic3RyaW5nXCI9PXR5cGVvZiByKXJldHVybiB0aGlzLmFkZExhYmVsKHIsbik7aWYoXCJmdW5jdGlvblwiIT10eXBlb2Ygcil0aHJvd1wiQ2Fubm90IGFkZCBcIityK1wiIGludG8gdGhlIHRpbWVsaW5lOyBpdCBpcyBub3QgYSB0d2VlbiwgdGltZWxpbmUsIGZ1bmN0aW9uLCBvciBzdHJpbmcuXCI7cj1pLmRlbGF5ZWRDYWxsKDAscil9aWYoZS5wcm90b3R5cGUuYWRkLmNhbGwodGhpcyxyLG4pLCh0aGlzLl9nY3x8dGhpcy5fdGltZT09PXRoaXMuX2R1cmF0aW9uKSYmIXRoaXMuX3BhdXNlZCYmdGhpcy5fZHVyYXRpb248dGhpcy5kdXJhdGlvbigpKWZvcihmPXRoaXMscD1mLnJhd1RpbWUoKT5yLl9zdGFydFRpbWU7Zi5fdGltZWxpbmU7KXAmJmYuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nP2YudG90YWxUaW1lKGYuX3RvdGFsVGltZSwhMCk6Zi5fZ2MmJmYuX2VuYWJsZWQoITAsITEpLGY9Zi5fdGltZWxpbmU7cmV0dXJuIHRoaXN9LGQucmVtb3ZlPWZ1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiB0KXt0aGlzLl9yZW1vdmUoZSwhMSk7dmFyIGk9ZS5fdGltZWxpbmU9ZS52YXJzLnVzZUZyYW1lcz90Ll9yb290RnJhbWVzVGltZWxpbmU6dC5fcm9vdFRpbWVsaW5lO3JldHVybiBlLl9zdGFydFRpbWU9KGUuX3BhdXNlZD9lLl9wYXVzZVRpbWU6aS5fdGltZSktKGUuX3JldmVyc2VkP2UudG90YWxEdXJhdGlvbigpLWUuX3RvdGFsVGltZTplLl90b3RhbFRpbWUpL2UuX3RpbWVTY2FsZSx0aGlzfWlmKGUgaW5zdGFuY2VvZiBBcnJheXx8ZSYmZS5wdXNoJiZsKGUpKXtmb3IodmFyIHM9ZS5sZW5ndGg7LS1zPi0xOyl0aGlzLnJlbW92ZShlW3NdKTtyZXR1cm4gdGhpc31yZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZT90aGlzLnJlbW92ZUxhYmVsKGUpOnRoaXMua2lsbChudWxsLGUpfSxkLl9yZW1vdmU9ZnVuY3Rpb24odCxpKXtlLnByb3RvdHlwZS5fcmVtb3ZlLmNhbGwodGhpcyx0LGkpO3ZhciBzPXRoaXMuX2xhc3Q7cmV0dXJuIHM/dGhpcy5fdGltZT5zLl9zdGFydFRpbWUrcy5fdG90YWxEdXJhdGlvbi9zLl90aW1lU2NhbGUmJih0aGlzLl90aW1lPXRoaXMuZHVyYXRpb24oKSx0aGlzLl90b3RhbFRpbWU9dGhpcy5fdG90YWxEdXJhdGlvbik6dGhpcy5fdGltZT10aGlzLl90b3RhbFRpbWU9dGhpcy5fZHVyYXRpb249dGhpcy5fdG90YWxEdXJhdGlvbj0wLHRoaXN9LGQuYXBwZW5kPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYWRkKHQsdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChudWxsLGUsITAsdCkpfSxkLmluc2VydD1kLmluc2VydE11bHRpcGxlPWZ1bmN0aW9uKHQsZSxpLHMpe3JldHVybiB0aGlzLmFkZCh0LGV8fDAsaSxzKX0sZC5hcHBlbmRNdWx0aXBsZT1mdW5jdGlvbih0LGUsaSxzKXtyZXR1cm4gdGhpcy5hZGQodCx0aGlzLl9wYXJzZVRpbWVPckxhYmVsKG51bGwsZSwhMCx0KSxpLHMpfSxkLmFkZExhYmVsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2xhYmVsc1t0XT10aGlzLl9wYXJzZVRpbWVPckxhYmVsKGUpLHRoaXN9LGQuYWRkUGF1c2U9ZnVuY3Rpb24odCxlLHMscil7dmFyIG49aS5kZWxheWVkQ2FsbCgwLHAscyxyfHx0aGlzKTtyZXR1cm4gbi52YXJzLm9uQ29tcGxldGU9bi52YXJzLm9uUmV2ZXJzZUNvbXBsZXRlPWUsbi5kYXRhPVwiaXNQYXVzZVwiLHRoaXMuX2hhc1BhdXNlPSEwLHRoaXMuYWRkKG4sdCl9LGQucmVtb3ZlTGFiZWw9ZnVuY3Rpb24odCl7cmV0dXJuIGRlbGV0ZSB0aGlzLl9sYWJlbHNbdF0sdGhpc30sZC5nZXRMYWJlbFRpbWU9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPXRoaXMuX2xhYmVsc1t0XT90aGlzLl9sYWJlbHNbdF06LTF9LGQuX3BhcnNlVGltZU9yTGFiZWw9ZnVuY3Rpb24oZSxpLHMscil7dmFyIG47aWYociBpbnN0YW5jZW9mIHQmJnIudGltZWxpbmU9PT10aGlzKXRoaXMucmVtb3ZlKHIpO2Vsc2UgaWYociYmKHIgaW5zdGFuY2VvZiBBcnJheXx8ci5wdXNoJiZsKHIpKSlmb3Iobj1yLmxlbmd0aDstLW4+LTE7KXJbbl1pbnN0YW5jZW9mIHQmJnJbbl0udGltZWxpbmU9PT10aGlzJiZ0aGlzLnJlbW92ZShyW25dKTtpZihcInN0cmluZ1wiPT10eXBlb2YgaSlyZXR1cm4gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChpLHMmJlwibnVtYmVyXCI9PXR5cGVvZiBlJiZudWxsPT10aGlzLl9sYWJlbHNbaV0/ZS10aGlzLmR1cmF0aW9uKCk6MCxzKTtpZihpPWl8fDAsXCJzdHJpbmdcIiE9dHlwZW9mIGV8fCFpc05hTihlKSYmbnVsbD09dGhpcy5fbGFiZWxzW2VdKW51bGw9PWUmJihlPXRoaXMuZHVyYXRpb24oKSk7ZWxzZXtpZihuPWUuaW5kZXhPZihcIj1cIiksLTE9PT1uKXJldHVybiBudWxsPT10aGlzLl9sYWJlbHNbZV0/cz90aGlzLl9sYWJlbHNbZV09dGhpcy5kdXJhdGlvbigpK2k6aTp0aGlzLl9sYWJlbHNbZV0raTtpPXBhcnNlSW50KGUuY2hhckF0KG4tMSkrXCIxXCIsMTApKk51bWJlcihlLnN1YnN0cihuKzEpKSxlPW4+MT90aGlzLl9wYXJzZVRpbWVPckxhYmVsKGUuc3Vic3RyKDAsbi0xKSwwLHMpOnRoaXMuZHVyYXRpb24oKX1yZXR1cm4gTnVtYmVyKGUpK2l9LGQuc2Vlaz1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRvdGFsVGltZShcIm51bWJlclwiPT10eXBlb2YgdD90OnRoaXMuX3BhcnNlVGltZU9yTGFiZWwodCksZSE9PSExKX0sZC5zdG9wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGF1c2VkKCEwKX0sZC5nb3RvQW5kUGxheT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnBsYXkodCxlKX0sZC5nb3RvQW5kU3RvcD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnBhdXNlKHQsZSl9LGQucmVuZGVyPWZ1bmN0aW9uKHQsZSxpKXt0aGlzLl9nYyYmdGhpcy5fZW5hYmxlZCghMCwhMSk7dmFyIHMsbixhLG8sbCx1LGM9dGhpcy5fZGlydHk/dGhpcy50b3RhbER1cmF0aW9uKCk6dGhpcy5fdG90YWxEdXJhdGlvbixmPXRoaXMuX3RpbWUscD10aGlzLl9zdGFydFRpbWUsbT10aGlzLl90aW1lU2NhbGUsZD10aGlzLl9wYXVzZWQ7aWYodD49Yyl0aGlzLl90b3RhbFRpbWU9dGhpcy5fdGltZT1jLHRoaXMuX3JldmVyc2VkfHx0aGlzLl9oYXNQYXVzZWRDaGlsZCgpfHwobj0hMCxvPVwib25Db21wbGV0ZVwiLGw9ISF0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4sMD09PXRoaXMuX2R1cmF0aW9uJiYoMD09PXR8fDA+dGhpcy5fcmF3UHJldlRpbWV8fHRoaXMuX3Jhd1ByZXZUaW1lPT09cikmJnRoaXMuX3Jhd1ByZXZUaW1lIT09dCYmdGhpcy5fZmlyc3QmJihsPSEwLHRoaXMuX3Jhd1ByZXZUaW1lPnImJihvPVwib25SZXZlcnNlQ29tcGxldGVcIikpKSx0aGlzLl9yYXdQcmV2VGltZT10aGlzLl9kdXJhdGlvbnx8IWV8fHR8fHRoaXMuX3Jhd1ByZXZUaW1lPT09dD90OnIsdD1jKzFlLTQ7ZWxzZSBpZigxZS03PnQpaWYodGhpcy5fdG90YWxUaW1lPXRoaXMuX3RpbWU9MCwoMCE9PWZ8fDA9PT10aGlzLl9kdXJhdGlvbiYmdGhpcy5fcmF3UHJldlRpbWUhPT1yJiYodGhpcy5fcmF3UHJldlRpbWU+MHx8MD50JiZ0aGlzLl9yYXdQcmV2VGltZT49MCkpJiYobz1cIm9uUmV2ZXJzZUNvbXBsZXRlXCIsbj10aGlzLl9yZXZlcnNlZCksMD50KXRoaXMuX2FjdGl2ZT0hMSx0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4mJnRoaXMuX3JldmVyc2VkPyhsPW49ITAsbz1cIm9uUmV2ZXJzZUNvbXBsZXRlXCIpOnRoaXMuX3Jhd1ByZXZUaW1lPj0wJiZ0aGlzLl9maXJzdCYmKGw9ITApLHRoaXMuX3Jhd1ByZXZUaW1lPXQ7ZWxzZXtpZih0aGlzLl9yYXdQcmV2VGltZT10aGlzLl9kdXJhdGlvbnx8IWV8fHR8fHRoaXMuX3Jhd1ByZXZUaW1lPT09dD90OnIsMD09PXQmJm4pZm9yKHM9dGhpcy5fZmlyc3Q7cyYmMD09PXMuX3N0YXJ0VGltZTspcy5fZHVyYXRpb258fChuPSExKSxzPXMuX25leHQ7dD0wLHRoaXMuX2luaXR0ZWR8fChsPSEwKX1lbHNle2lmKHRoaXMuX2hhc1BhdXNlJiYhdGhpcy5fZm9yY2luZ1BsYXloZWFkJiYhZSl7aWYodD49Zilmb3Iocz10aGlzLl9maXJzdDtzJiZ0Pj1zLl9zdGFydFRpbWUmJiF1OylzLl9kdXJhdGlvbnx8XCJpc1BhdXNlXCIhPT1zLmRhdGF8fHMucmF0aW98fDA9PT1zLl9zdGFydFRpbWUmJjA9PT10aGlzLl9yYXdQcmV2VGltZXx8KHU9cykscz1zLl9uZXh0O2Vsc2UgZm9yKHM9dGhpcy5fbGFzdDtzJiZzLl9zdGFydFRpbWU+PXQmJiF1OylzLl9kdXJhdGlvbnx8XCJpc1BhdXNlXCI9PT1zLmRhdGEmJnMuX3Jhd1ByZXZUaW1lPjAmJih1PXMpLHM9cy5fcHJldjt1JiYodGhpcy5fdGltZT10PXUuX3N0YXJ0VGltZSx0aGlzLl90b3RhbFRpbWU9dCt0aGlzLl9jeWNsZSoodGhpcy5fdG90YWxEdXJhdGlvbit0aGlzLl9yZXBlYXREZWxheSkpfXRoaXMuX3RvdGFsVGltZT10aGlzLl90aW1lPXRoaXMuX3Jhd1ByZXZUaW1lPXR9aWYodGhpcy5fdGltZSE9PWYmJnRoaXMuX2ZpcnN0fHxpfHxsfHx1KXtpZih0aGlzLl9pbml0dGVkfHwodGhpcy5faW5pdHRlZD0hMCksdGhpcy5fYWN0aXZlfHwhdGhpcy5fcGF1c2VkJiZ0aGlzLl90aW1lIT09ZiYmdD4wJiYodGhpcy5fYWN0aXZlPSEwKSwwPT09ZiYmdGhpcy52YXJzLm9uU3RhcnQmJjAhPT10aGlzLl90aW1lJiYoZXx8dGhpcy5fY2FsbGJhY2soXCJvblN0YXJ0XCIpKSx0aGlzLl90aW1lPj1mKWZvcihzPXRoaXMuX2ZpcnN0O3MmJihhPXMuX25leHQsIXRoaXMuX3BhdXNlZHx8ZCk7KShzLl9hY3RpdmV8fHMuX3N0YXJ0VGltZTw9dGhpcy5fdGltZSYmIXMuX3BhdXNlZCYmIXMuX2djKSYmKHU9PT1zJiZ0aGlzLnBhdXNlKCkscy5fcmV2ZXJzZWQ/cy5yZW5kZXIoKHMuX2RpcnR5P3MudG90YWxEdXJhdGlvbigpOnMuX3RvdGFsRHVyYXRpb24pLSh0LXMuX3N0YXJ0VGltZSkqcy5fdGltZVNjYWxlLGUsaSk6cy5yZW5kZXIoKHQtcy5fc3RhcnRUaW1lKSpzLl90aW1lU2NhbGUsZSxpKSkscz1hO2Vsc2UgZm9yKHM9dGhpcy5fbGFzdDtzJiYoYT1zLl9wcmV2LCF0aGlzLl9wYXVzZWR8fGQpOyl7aWYocy5fYWN0aXZlfHxmPj1zLl9zdGFydFRpbWUmJiFzLl9wYXVzZWQmJiFzLl9nYyl7aWYodT09PXMpe2Zvcih1PXMuX3ByZXY7dSYmdS5lbmRUaW1lKCk+dGhpcy5fdGltZTspdS5yZW5kZXIodS5fcmV2ZXJzZWQ/dS50b3RhbER1cmF0aW9uKCktKHQtdS5fc3RhcnRUaW1lKSp1Ll90aW1lU2NhbGU6KHQtdS5fc3RhcnRUaW1lKSp1Ll90aW1lU2NhbGUsZSxpKSx1PXUuX3ByZXY7dT1udWxsLHRoaXMucGF1c2UoKX1zLl9yZXZlcnNlZD9zLnJlbmRlcigocy5fZGlydHk/cy50b3RhbER1cmF0aW9uKCk6cy5fdG90YWxEdXJhdGlvbiktKHQtcy5fc3RhcnRUaW1lKSpzLl90aW1lU2NhbGUsZSxpKTpzLnJlbmRlcigodC1zLl9zdGFydFRpbWUpKnMuX3RpbWVTY2FsZSxlLGkpfXM9YX10aGlzLl9vblVwZGF0ZSYmKGV8fChoLmxlbmd0aCYmXygpLHRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIikpKSxvJiYodGhpcy5fZ2N8fChwPT09dGhpcy5fc3RhcnRUaW1lfHxtIT09dGhpcy5fdGltZVNjYWxlKSYmKDA9PT10aGlzLl90aW1lfHxjPj10aGlzLnRvdGFsRHVyYXRpb24oKSkmJihuJiYoaC5sZW5ndGgmJl8oKSx0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4mJnRoaXMuX2VuYWJsZWQoITEsITEpLHRoaXMuX2FjdGl2ZT0hMSksIWUmJnRoaXMudmFyc1tvXSYmdGhpcy5fY2FsbGJhY2sobykpKX19LGQuX2hhc1BhdXNlZENoaWxkPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuX2ZpcnN0O3Q7KXtpZih0Ll9wYXVzZWR8fHQgaW5zdGFuY2VvZiBzJiZ0Ll9oYXNQYXVzZWRDaGlsZCgpKXJldHVybiEwO3Q9dC5fbmV4dH1yZXR1cm4hMX0sZC5nZXRDaGlsZHJlbj1mdW5jdGlvbih0LGUscyxyKXtyPXJ8fC05OTk5OTk5OTk5O2Zvcih2YXIgbj1bXSxhPXRoaXMuX2ZpcnN0LG89MDthOylyPmEuX3N0YXJ0VGltZXx8KGEgaW5zdGFuY2VvZiBpP2UhPT0hMSYmKG5bbysrXT1hKToocyE9PSExJiYobltvKytdPWEpLHQhPT0hMSYmKG49bi5jb25jYXQoYS5nZXRDaGlsZHJlbighMCxlLHMpKSxvPW4ubGVuZ3RoKSkpLGE9YS5fbmV4dDtyZXR1cm4gbn0sZC5nZXRUd2VlbnNPZj1mdW5jdGlvbih0LGUpe3ZhciBzLHIsbj10aGlzLl9nYyxhPVtdLG89MDtmb3IobiYmdGhpcy5fZW5hYmxlZCghMCwhMCkscz1pLmdldFR3ZWVuc09mKHQpLHI9cy5sZW5ndGg7LS1yPi0xOykoc1tyXS50aW1lbGluZT09PXRoaXN8fGUmJnRoaXMuX2NvbnRhaW5zKHNbcl0pKSYmKGFbbysrXT1zW3JdKTtyZXR1cm4gbiYmdGhpcy5fZW5hYmxlZCghMSwhMCksYX0sZC5yZWNlbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmVjZW50fSxkLl9jb250YWlucz1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC50aW1lbGluZTtlOyl7aWYoZT09PXRoaXMpcmV0dXJuITA7ZT1lLnRpbWVsaW5lfXJldHVybiExfSxkLnNoaWZ0Q2hpbGRyZW49ZnVuY3Rpb24odCxlLGkpe2k9aXx8MDtmb3IodmFyIHMscj10aGlzLl9maXJzdCxuPXRoaXMuX2xhYmVscztyOylyLl9zdGFydFRpbWU+PWkmJihyLl9zdGFydFRpbWUrPXQpLHI9ci5fbmV4dDtpZihlKWZvcihzIGluIG4pbltzXT49aSYmKG5bc10rPXQpO3JldHVybiB0aGlzLl91bmNhY2hlKCEwKX0sZC5fa2lsbD1mdW5jdGlvbih0LGUpe2lmKCF0JiYhZSlyZXR1cm4gdGhpcy5fZW5hYmxlZCghMSwhMSk7Zm9yKHZhciBpPWU/dGhpcy5nZXRUd2VlbnNPZihlKTp0aGlzLmdldENoaWxkcmVuKCEwLCEwLCExKSxzPWkubGVuZ3RoLHI9ITE7LS1zPi0xOylpW3NdLl9raWxsKHQsZSkmJihyPSEwKTtyZXR1cm4gcn0sZC5jbGVhcj1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldENoaWxkcmVuKCExLCEwLCEwKSxpPWUubGVuZ3RoO2Zvcih0aGlzLl90aW1lPXRoaXMuX3RvdGFsVGltZT0wOy0taT4tMTspZVtpXS5fZW5hYmxlZCghMSwhMSk7cmV0dXJuIHQhPT0hMSYmKHRoaXMuX2xhYmVscz17fSksdGhpcy5fdW5jYWNoZSghMCl9LGQuaW52YWxpZGF0ZT1mdW5jdGlvbigpe2Zvcih2YXIgZT10aGlzLl9maXJzdDtlOyllLmludmFsaWRhdGUoKSxlPWUuX25leHQ7cmV0dXJuIHQucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKX0sZC5fZW5hYmxlZD1mdW5jdGlvbih0LGkpe2lmKHQ9PT10aGlzLl9nYylmb3IodmFyIHM9dGhpcy5fZmlyc3Q7czspcy5fZW5hYmxlZCh0LCEwKSxzPXMuX25leHQ7cmV0dXJuIGUucHJvdG90eXBlLl9lbmFibGVkLmNhbGwodGhpcyx0LGkpfSxkLnRvdGFsVGltZT1mdW5jdGlvbigpe3RoaXMuX2ZvcmNpbmdQbGF5aGVhZD0hMDt2YXIgZT10LnByb3RvdHlwZS50b3RhbFRpbWUuYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB0aGlzLl9mb3JjaW5nUGxheWhlYWQ9ITEsZX0sZC5kdXJhdGlvbj1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oMCE9PXRoaXMuZHVyYXRpb24oKSYmMCE9PXQmJnRoaXMudGltZVNjYWxlKHRoaXMuX2R1cmF0aW9uL3QpLHRoaXMpOih0aGlzLl9kaXJ0eSYmdGhpcy50b3RhbER1cmF0aW9uKCksdGhpcy5fZHVyYXRpb24pfSxkLnRvdGFsRHVyYXRpb249ZnVuY3Rpb24odCl7aWYoIWFyZ3VtZW50cy5sZW5ndGgpe2lmKHRoaXMuX2RpcnR5KXtmb3IodmFyIGUsaSxzPTAscj10aGlzLl9sYXN0LG49OTk5OTk5OTk5OTk5O3I7KWU9ci5fcHJldixyLl9kaXJ0eSYmci50b3RhbER1cmF0aW9uKCksci5fc3RhcnRUaW1lPm4mJnRoaXMuX3NvcnRDaGlsZHJlbiYmIXIuX3BhdXNlZD90aGlzLmFkZChyLHIuX3N0YXJ0VGltZS1yLl9kZWxheSk6bj1yLl9zdGFydFRpbWUsMD5yLl9zdGFydFRpbWUmJiFyLl9wYXVzZWQmJihzLT1yLl9zdGFydFRpbWUsdGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcmJih0aGlzLl9zdGFydFRpbWUrPXIuX3N0YXJ0VGltZS90aGlzLl90aW1lU2NhbGUpLHRoaXMuc2hpZnRDaGlsZHJlbigtci5fc3RhcnRUaW1lLCExLC05OTk5OTk5OTk5KSxuPTApLGk9ci5fc3RhcnRUaW1lK3IuX3RvdGFsRHVyYXRpb24vci5fdGltZVNjYWxlLGk+cyYmKHM9aSkscj1lO3RoaXMuX2R1cmF0aW9uPXRoaXMuX3RvdGFsRHVyYXRpb249cyx0aGlzLl9kaXJ0eT0hMX1yZXR1cm4gdGhpcy5fdG90YWxEdXJhdGlvbn1yZXR1cm4gMCE9PXRoaXMudG90YWxEdXJhdGlvbigpJiYwIT09dCYmdGhpcy50aW1lU2NhbGUodGhpcy5fdG90YWxEdXJhdGlvbi90KSx0aGlzfSxkLnBhdXNlZD1mdW5jdGlvbihlKXtpZighZSlmb3IodmFyIGk9dGhpcy5fZmlyc3Qscz10aGlzLl90aW1lO2k7KWkuX3N0YXJ0VGltZT09PXMmJlwiaXNQYXVzZVwiPT09aS5kYXRhJiYoaS5fcmF3UHJldlRpbWU9MCksaT1pLl9uZXh0O3JldHVybiB0LnByb3RvdHlwZS5wYXVzZWQuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxkLnVzZXNGcmFtZXM9ZnVuY3Rpb24oKXtmb3IodmFyIGU9dGhpcy5fdGltZWxpbmU7ZS5fdGltZWxpbmU7KWU9ZS5fdGltZWxpbmU7cmV0dXJuIGU9PT10Ll9yb290RnJhbWVzVGltZWxpbmV9LGQucmF3VGltZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9wYXVzZWQ/dGhpcy5fdG90YWxUaW1lOih0aGlzLl90aW1lbGluZS5yYXdUaW1lKCktdGhpcy5fc3RhcnRUaW1lKSp0aGlzLl90aW1lU2NhbGV9LHN9LCEwKSxfZ3NTY29wZS5fZ3NEZWZpbmUoXCJUaW1lbGluZU1heFwiLFtcIlRpbWVsaW5lTGl0ZVwiLFwiVHdlZW5MaXRlXCIsXCJlYXNpbmcuRWFzZVwiXSxmdW5jdGlvbih0LGUsaSl7dmFyIHM9ZnVuY3Rpb24oZSl7dC5jYWxsKHRoaXMsZSksdGhpcy5fcmVwZWF0PXRoaXMudmFycy5yZXBlYXR8fDAsdGhpcy5fcmVwZWF0RGVsYXk9dGhpcy52YXJzLnJlcGVhdERlbGF5fHwwLHRoaXMuX2N5Y2xlPTAsdGhpcy5feW95bz10aGlzLnZhcnMueW95bz09PSEwLHRoaXMuX2RpcnR5PSEwfSxyPTFlLTEwLG49ZS5faW50ZXJuYWxzLGE9bi5sYXp5VHdlZW5zLG89bi5sYXp5UmVuZGVyLGw9bmV3IGkobnVsbCxudWxsLDEsMCksaD1zLnByb3RvdHlwZT1uZXcgdDtyZXR1cm4gaC5jb25zdHJ1Y3Rvcj1zLGgua2lsbCgpLl9nYz0hMSxzLnZlcnNpb249XCIxLjE4LjBcIixoLmludmFsaWRhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5feW95bz10aGlzLnZhcnMueW95bz09PSEwLHRoaXMuX3JlcGVhdD10aGlzLnZhcnMucmVwZWF0fHwwLHRoaXMuX3JlcGVhdERlbGF5PXRoaXMudmFycy5yZXBlYXREZWxheXx8MCx0aGlzLl91bmNhY2hlKCEwKSx0LnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyl9LGguYWRkQ2FsbGJhY2s9ZnVuY3Rpb24odCxpLHMscil7cmV0dXJuIHRoaXMuYWRkKGUuZGVsYXllZENhbGwoMCx0LHMsciksaSl9LGgucmVtb3ZlQ2FsbGJhY2s9ZnVuY3Rpb24odCxlKXtpZih0KWlmKG51bGw9PWUpdGhpcy5fa2lsbChudWxsLHQpO2Vsc2UgZm9yKHZhciBpPXRoaXMuZ2V0VHdlZW5zT2YodCwhMSkscz1pLmxlbmd0aCxyPXRoaXMuX3BhcnNlVGltZU9yTGFiZWwoZSk7LS1zPi0xOylpW3NdLl9zdGFydFRpbWU9PT1yJiZpW3NdLl9lbmFibGVkKCExLCExKTtyZXR1cm4gdGhpc30saC5yZW1vdmVQYXVzZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZW1vdmVDYWxsYmFjayh0Ll9pbnRlcm5hbHMucGF1c2VDYWxsYmFjayxlKX0saC50d2VlblRvPWZ1bmN0aW9uKHQsaSl7aT1pfHx7fTt2YXIgcyxyLG4sYT17ZWFzZTpsLHVzZUZyYW1lczp0aGlzLnVzZXNGcmFtZXMoKSxpbW1lZGlhdGVSZW5kZXI6ITF9O2ZvcihyIGluIGkpYVtyXT1pW3JdO3JldHVybiBhLnRpbWU9dGhpcy5fcGFyc2VUaW1lT3JMYWJlbCh0KSxzPU1hdGguYWJzKE51bWJlcihhLnRpbWUpLXRoaXMuX3RpbWUpL3RoaXMuX3RpbWVTY2FsZXx8LjAwMSxuPW5ldyBlKHRoaXMscyxhKSxhLm9uU3RhcnQ9ZnVuY3Rpb24oKXtuLnRhcmdldC5wYXVzZWQoITApLG4udmFycy50aW1lIT09bi50YXJnZXQudGltZSgpJiZzPT09bi5kdXJhdGlvbigpJiZuLmR1cmF0aW9uKE1hdGguYWJzKG4udmFycy50aW1lLW4udGFyZ2V0LnRpbWUoKSkvbi50YXJnZXQuX3RpbWVTY2FsZSksaS5vblN0YXJ0JiZuLl9jYWxsYmFjayhcIm9uU3RhcnRcIil9LG59LGgudHdlZW5Gcm9tVG89ZnVuY3Rpb24odCxlLGkpe2k9aXx8e30sdD10aGlzLl9wYXJzZVRpbWVPckxhYmVsKHQpLGkuc3RhcnRBdD17b25Db21wbGV0ZTp0aGlzLnNlZWssb25Db21wbGV0ZVBhcmFtczpbdF0sY2FsbGJhY2tTY29wZTp0aGlzfSxpLmltbWVkaWF0ZVJlbmRlcj1pLmltbWVkaWF0ZVJlbmRlciE9PSExO3ZhciBzPXRoaXMudHdlZW5UbyhlLGkpO3JldHVybiBzLmR1cmF0aW9uKE1hdGguYWJzKHMudmFycy50aW1lLXQpL3RoaXMuX3RpbWVTY2FsZXx8LjAwMSl9LGgucmVuZGVyPWZ1bmN0aW9uKHQsZSxpKXt0aGlzLl9nYyYmdGhpcy5fZW5hYmxlZCghMCwhMSk7dmFyIHMsbixsLGgsXyx1LGMsZj10aGlzLl9kaXJ0eT90aGlzLnRvdGFsRHVyYXRpb24oKTp0aGlzLl90b3RhbER1cmF0aW9uLHA9dGhpcy5fZHVyYXRpb24sbT10aGlzLl90aW1lLGQ9dGhpcy5fdG90YWxUaW1lLGc9dGhpcy5fc3RhcnRUaW1lLHY9dGhpcy5fdGltZVNjYWxlLHk9dGhpcy5fcmF3UHJldlRpbWUsVD10aGlzLl9wYXVzZWQseD10aGlzLl9jeWNsZTtpZih0Pj1mKXRoaXMuX2xvY2tlZHx8KHRoaXMuX3RvdGFsVGltZT1mLHRoaXMuX2N5Y2xlPXRoaXMuX3JlcGVhdCksdGhpcy5fcmV2ZXJzZWR8fHRoaXMuX2hhc1BhdXNlZENoaWxkKCl8fChuPSEwLGg9XCJvbkNvbXBsZXRlXCIsXz0hIXRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbiwwPT09dGhpcy5fZHVyYXRpb24mJigwPT09dHx8MD55fHx5PT09cikmJnkhPT10JiZ0aGlzLl9maXJzdCYmKF89ITAseT5yJiYoaD1cIm9uUmV2ZXJzZUNvbXBsZXRlXCIpKSksdGhpcy5fcmF3UHJldlRpbWU9dGhpcy5fZHVyYXRpb258fCFlfHx0fHx0aGlzLl9yYXdQcmV2VGltZT09PXQ/dDpyLHRoaXMuX3lveW8mJjAhPT0oMSZ0aGlzLl9jeWNsZSk/dGhpcy5fdGltZT10PTA6KHRoaXMuX3RpbWU9cCx0PXArMWUtNCk7ZWxzZSBpZigxZS03PnQpaWYodGhpcy5fbG9ja2VkfHwodGhpcy5fdG90YWxUaW1lPXRoaXMuX2N5Y2xlPTApLHRoaXMuX3RpbWU9MCwoMCE9PW18fDA9PT1wJiZ5IT09ciYmKHk+MHx8MD50JiZ5Pj0wKSYmIXRoaXMuX2xvY2tlZCkmJihoPVwib25SZXZlcnNlQ29tcGxldGVcIixuPXRoaXMuX3JldmVyc2VkKSwwPnQpdGhpcy5fYWN0aXZlPSExLHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbiYmdGhpcy5fcmV2ZXJzZWQ/KF89bj0hMCxoPVwib25SZXZlcnNlQ29tcGxldGVcIik6eT49MCYmdGhpcy5fZmlyc3QmJihfPSEwKSx0aGlzLl9yYXdQcmV2VGltZT10O2Vsc2V7aWYodGhpcy5fcmF3UHJldlRpbWU9cHx8IWV8fHR8fHRoaXMuX3Jhd1ByZXZUaW1lPT09dD90OnIsMD09PXQmJm4pZm9yKHM9dGhpcy5fZmlyc3Q7cyYmMD09PXMuX3N0YXJ0VGltZTspcy5fZHVyYXRpb258fChuPSExKSxzPXMuX25leHQ7dD0wLHRoaXMuX2luaXR0ZWR8fChfPSEwKX1lbHNlIGlmKDA9PT1wJiYwPnkmJihfPSEwKSx0aGlzLl90aW1lPXRoaXMuX3Jhd1ByZXZUaW1lPXQsdGhpcy5fbG9ja2VkfHwodGhpcy5fdG90YWxUaW1lPXQsMCE9PXRoaXMuX3JlcGVhdCYmKHU9cCt0aGlzLl9yZXBlYXREZWxheSx0aGlzLl9jeWNsZT10aGlzLl90b3RhbFRpbWUvdT4+MCwwIT09dGhpcy5fY3ljbGUmJnRoaXMuX2N5Y2xlPT09dGhpcy5fdG90YWxUaW1lL3UmJnRoaXMuX2N5Y2xlLS0sdGhpcy5fdGltZT10aGlzLl90b3RhbFRpbWUtdGhpcy5fY3ljbGUqdSx0aGlzLl95b3lvJiYwIT09KDEmdGhpcy5fY3ljbGUpJiYodGhpcy5fdGltZT1wLXRoaXMuX3RpbWUpLHRoaXMuX3RpbWU+cD8odGhpcy5fdGltZT1wLHQ9cCsxZS00KTowPnRoaXMuX3RpbWU/dGhpcy5fdGltZT10PTA6dD10aGlzLl90aW1lKSksdGhpcy5faGFzUGF1c2UmJiF0aGlzLl9mb3JjaW5nUGxheWhlYWQmJiFlKXtpZih0PXRoaXMuX3RpbWUsdD49bSlmb3Iocz10aGlzLl9maXJzdDtzJiZ0Pj1zLl9zdGFydFRpbWUmJiFjOylzLl9kdXJhdGlvbnx8XCJpc1BhdXNlXCIhPT1zLmRhdGF8fHMucmF0aW98fDA9PT1zLl9zdGFydFRpbWUmJjA9PT10aGlzLl9yYXdQcmV2VGltZXx8KGM9cykscz1zLl9uZXh0O2Vsc2UgZm9yKHM9dGhpcy5fbGFzdDtzJiZzLl9zdGFydFRpbWU+PXQmJiFjOylzLl9kdXJhdGlvbnx8XCJpc1BhdXNlXCI9PT1zLmRhdGEmJnMuX3Jhd1ByZXZUaW1lPjAmJihjPXMpLHM9cy5fcHJldjtjJiYodGhpcy5fdGltZT10PWMuX3N0YXJ0VGltZSx0aGlzLl90b3RhbFRpbWU9dCt0aGlzLl9jeWNsZSoodGhpcy5fdG90YWxEdXJhdGlvbit0aGlzLl9yZXBlYXREZWxheSkpfWlmKHRoaXMuX2N5Y2xlIT09eCYmIXRoaXMuX2xvY2tlZCl7dmFyIHc9dGhpcy5feW95byYmMCE9PSgxJngpLGI9dz09PSh0aGlzLl95b3lvJiYwIT09KDEmdGhpcy5fY3ljbGUpKSxQPXRoaXMuX3RvdGFsVGltZSxrPXRoaXMuX2N5Y2xlLFM9dGhpcy5fcmF3UHJldlRpbWUsUj10aGlzLl90aW1lO2lmKHRoaXMuX3RvdGFsVGltZT14KnAseD50aGlzLl9jeWNsZT93PSF3OnRoaXMuX3RvdGFsVGltZSs9cCx0aGlzLl90aW1lPW0sdGhpcy5fcmF3UHJldlRpbWU9MD09PXA/eS0xZS00OnksdGhpcy5fY3ljbGU9eCx0aGlzLl9sb2NrZWQ9ITAsbT13PzA6cCx0aGlzLnJlbmRlcihtLGUsMD09PXApLGV8fHRoaXMuX2djfHx0aGlzLnZhcnMub25SZXBlYXQmJnRoaXMuX2NhbGxiYWNrKFwib25SZXBlYXRcIiksYiYmKG09dz9wKzFlLTQ6LTFlLTQsdGhpcy5yZW5kZXIobSwhMCwhMSkpLHRoaXMuX2xvY2tlZD0hMSx0aGlzLl9wYXVzZWQmJiFUKXJldHVybjt0aGlzLl90aW1lPVIsdGhpcy5fdG90YWxUaW1lPVAsdGhpcy5fY3ljbGU9ayx0aGlzLl9yYXdQcmV2VGltZT1TfWlmKCEodGhpcy5fdGltZSE9PW0mJnRoaXMuX2ZpcnN0fHxpfHxffHxjKSlyZXR1cm4gZCE9PXRoaXMuX3RvdGFsVGltZSYmdGhpcy5fb25VcGRhdGUmJihlfHx0aGlzLl9jYWxsYmFjayhcIm9uVXBkYXRlXCIpKSx2b2lkIDA7aWYodGhpcy5faW5pdHRlZHx8KHRoaXMuX2luaXR0ZWQ9ITApLHRoaXMuX2FjdGl2ZXx8IXRoaXMuX3BhdXNlZCYmdGhpcy5fdG90YWxUaW1lIT09ZCYmdD4wJiYodGhpcy5fYWN0aXZlPSEwKSwwPT09ZCYmdGhpcy52YXJzLm9uU3RhcnQmJjAhPT10aGlzLl90b3RhbFRpbWUmJihlfHx0aGlzLl9jYWxsYmFjayhcIm9uU3RhcnRcIikpLHRoaXMuX3RpbWU+PW0pZm9yKHM9dGhpcy5fZmlyc3Q7cyYmKGw9cy5fbmV4dCwhdGhpcy5fcGF1c2VkfHxUKTspKHMuX2FjdGl2ZXx8cy5fc3RhcnRUaW1lPD10aGlzLl90aW1lJiYhcy5fcGF1c2VkJiYhcy5fZ2MpJiYoYz09PXMmJnRoaXMucGF1c2UoKSxzLl9yZXZlcnNlZD9zLnJlbmRlcigocy5fZGlydHk/cy50b3RhbER1cmF0aW9uKCk6cy5fdG90YWxEdXJhdGlvbiktKHQtcy5fc3RhcnRUaW1lKSpzLl90aW1lU2NhbGUsZSxpKTpzLnJlbmRlcigodC1zLl9zdGFydFRpbWUpKnMuX3RpbWVTY2FsZSxlLGkpKSxzPWw7ZWxzZSBmb3Iocz10aGlzLl9sYXN0O3MmJihsPXMuX3ByZXYsIXRoaXMuX3BhdXNlZHx8VCk7KXtpZihzLl9hY3RpdmV8fG0+PXMuX3N0YXJ0VGltZSYmIXMuX3BhdXNlZCYmIXMuX2djKXtpZihjPT09cyl7Zm9yKGM9cy5fcHJldjtjJiZjLmVuZFRpbWUoKT50aGlzLl90aW1lOyljLnJlbmRlcihjLl9yZXZlcnNlZD9jLnRvdGFsRHVyYXRpb24oKS0odC1jLl9zdGFydFRpbWUpKmMuX3RpbWVTY2FsZToodC1jLl9zdGFydFRpbWUpKmMuX3RpbWVTY2FsZSxlLGkpLGM9Yy5fcHJldjtjPW51bGwsdGhpcy5wYXVzZSgpfXMuX3JldmVyc2VkP3MucmVuZGVyKChzLl9kaXJ0eT9zLnRvdGFsRHVyYXRpb24oKTpzLl90b3RhbER1cmF0aW9uKS0odC1zLl9zdGFydFRpbWUpKnMuX3RpbWVTY2FsZSxlLGkpOnMucmVuZGVyKCh0LXMuX3N0YXJ0VGltZSkqcy5fdGltZVNjYWxlLGUsaSl9cz1sfXRoaXMuX29uVXBkYXRlJiYoZXx8KGEubGVuZ3RoJiZvKCksdGhpcy5fY2FsbGJhY2soXCJvblVwZGF0ZVwiKSkpLGgmJih0aGlzLl9sb2NrZWR8fHRoaXMuX2djfHwoZz09PXRoaXMuX3N0YXJ0VGltZXx8diE9PXRoaXMuX3RpbWVTY2FsZSkmJigwPT09dGhpcy5fdGltZXx8Zj49dGhpcy50b3RhbER1cmF0aW9uKCkpJiYobiYmKGEubGVuZ3RoJiZvKCksdGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuJiZ0aGlzLl9lbmFibGVkKCExLCExKSx0aGlzLl9hY3RpdmU9ITEpLCFlJiZ0aGlzLnZhcnNbaF0mJnRoaXMuX2NhbGxiYWNrKGgpKSl9LGguZ2V0QWN0aXZlPWZ1bmN0aW9uKHQsZSxpKXtudWxsPT10JiYodD0hMCksbnVsbD09ZSYmKGU9ITApLG51bGw9PWkmJihpPSExKTt2YXIgcyxyLG49W10sYT10aGlzLmdldENoaWxkcmVuKHQsZSxpKSxvPTAsbD1hLmxlbmd0aDtmb3Iocz0wO2w+cztzKyspcj1hW3NdLHIuaXNBY3RpdmUoKSYmKG5bbysrXT1yKTtyZXR1cm4gbn0saC5nZXRMYWJlbEFmdGVyPWZ1bmN0aW9uKHQpe3R8fDAhPT10JiYodD10aGlzLl90aW1lKTt2YXIgZSxpPXRoaXMuZ2V0TGFiZWxzQXJyYXkoKSxzPWkubGVuZ3RoO2ZvcihlPTA7cz5lO2UrKylpZihpW2VdLnRpbWU+dClyZXR1cm4gaVtlXS5uYW1lO3JldHVybiBudWxsfSxoLmdldExhYmVsQmVmb3JlPWZ1bmN0aW9uKHQpe251bGw9PXQmJih0PXRoaXMuX3RpbWUpO2Zvcih2YXIgZT10aGlzLmdldExhYmVsc0FycmF5KCksaT1lLmxlbmd0aDstLWk+LTE7KWlmKHQ+ZVtpXS50aW1lKXJldHVybiBlW2ldLm5hbWU7cmV0dXJuIG51bGx9LGguZ2V0TGFiZWxzQXJyYXk9ZnVuY3Rpb24oKXt2YXIgdCxlPVtdLGk9MDtmb3IodCBpbiB0aGlzLl9sYWJlbHMpZVtpKytdPXt0aW1lOnRoaXMuX2xhYmVsc1t0XSxuYW1lOnR9O3JldHVybiBlLnNvcnQoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC50aW1lLWUudGltZX0pLGV9LGgucHJvZ3Jlc3M9ZnVuY3Rpb24odCxlKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD90aGlzLnRvdGFsVGltZSh0aGlzLmR1cmF0aW9uKCkqKHRoaXMuX3lveW8mJjAhPT0oMSZ0aGlzLl9jeWNsZSk/MS10OnQpK3RoaXMuX2N5Y2xlKih0aGlzLl9kdXJhdGlvbit0aGlzLl9yZXBlYXREZWxheSksZSk6dGhpcy5fdGltZS90aGlzLmR1cmF0aW9uKCl9LGgudG90YWxQcm9ncmVzcz1mdW5jdGlvbih0LGUpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoP3RoaXMudG90YWxUaW1lKHRoaXMudG90YWxEdXJhdGlvbigpKnQsZSk6dGhpcy5fdG90YWxUaW1lL3RoaXMudG90YWxEdXJhdGlvbigpfSxoLnRvdGFsRHVyYXRpb249ZnVuY3Rpb24oZSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/LTE9PT10aGlzLl9yZXBlYXQ/dGhpczp0aGlzLmR1cmF0aW9uKChlLXRoaXMuX3JlcGVhdCp0aGlzLl9yZXBlYXREZWxheSkvKHRoaXMuX3JlcGVhdCsxKSk6KHRoaXMuX2RpcnR5JiYodC5wcm90b3R5cGUudG90YWxEdXJhdGlvbi5jYWxsKHRoaXMpLHRoaXMuX3RvdGFsRHVyYXRpb249LTE9PT10aGlzLl9yZXBlYXQ/OTk5OTk5OTk5OTk5OnRoaXMuX2R1cmF0aW9uKih0aGlzLl9yZXBlYXQrMSkrdGhpcy5fcmVwZWF0RGVsYXkqdGhpcy5fcmVwZWF0KSx0aGlzLl90b3RhbER1cmF0aW9uKX0saC50aW1lPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHRoaXMuX2RpcnR5JiZ0aGlzLnRvdGFsRHVyYXRpb24oKSx0PnRoaXMuX2R1cmF0aW9uJiYodD10aGlzLl9kdXJhdGlvbiksdGhpcy5feW95byYmMCE9PSgxJnRoaXMuX2N5Y2xlKT90PXRoaXMuX2R1cmF0aW9uLXQrdGhpcy5fY3ljbGUqKHRoaXMuX2R1cmF0aW9uK3RoaXMuX3JlcGVhdERlbGF5KTowIT09dGhpcy5fcmVwZWF0JiYodCs9dGhpcy5fY3ljbGUqKHRoaXMuX2R1cmF0aW9uK3RoaXMuX3JlcGVhdERlbGF5KSksdGhpcy50b3RhbFRpbWUodCxlKSk6dGhpcy5fdGltZX0saC5yZXBlYXQ9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHRoaXMuX3JlcGVhdD10LHRoaXMuX3VuY2FjaGUoITApKTp0aGlzLl9yZXBlYXR9LGgucmVwZWF0RGVsYXk9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHRoaXMuX3JlcGVhdERlbGF5PXQsdGhpcy5fdW5jYWNoZSghMCkpOnRoaXMuX3JlcGVhdERlbGF5fSxoLnlveW89ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHRoaXMuX3lveW89dCx0aGlzKTp0aGlzLl95b3lvfSxoLmN1cnJlbnRMYWJlbD1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD90aGlzLnNlZWsodCwhMCk6dGhpcy5nZXRMYWJlbEJlZm9yZSh0aGlzLl90aW1lKzFlLTgpfSxzfSwhMCksZnVuY3Rpb24oKXt2YXIgdD0xODAvTWF0aC5QSSxlPVtdLGk9W10scz1bXSxyPXt9LG49X2dzU2NvcGUuX2dzRGVmaW5lLmdsb2JhbHMsYT1mdW5jdGlvbih0LGUsaSxzKXt0aGlzLmE9dCx0aGlzLmI9ZSx0aGlzLmM9aSx0aGlzLmQ9cyx0aGlzLmRhPXMtdCx0aGlzLmNhPWktdCx0aGlzLmJhPWUtdH0sbz1cIix4LHkseixsZWZ0LHRvcCxyaWdodCxib3R0b20sbWFyZ2luVG9wLG1hcmdpbkxlZnQsbWFyZ2luUmlnaHQsbWFyZ2luQm90dG9tLHBhZGRpbmdMZWZ0LHBhZGRpbmdUb3AscGFkZGluZ1JpZ2h0LHBhZGRpbmdCb3R0b20sYmFja2dyb3VuZFBvc2l0aW9uLGJhY2tncm91bmRQb3NpdGlvbl95LFwiLGw9ZnVuY3Rpb24odCxlLGkscyl7dmFyIHI9e2E6dH0sbj17fSxhPXt9LG89e2M6c30sbD0odCtlKS8yLGg9KGUraSkvMixfPShpK3MpLzIsdT0obCtoKS8yLGM9KGgrXykvMixmPShjLXUpLzg7cmV0dXJuIHIuYj1sKyh0LWwpLzQsbi5iPXUrZixyLmM9bi5hPShyLmIrbi5iKS8yLG4uYz1hLmE9KHUrYykvMixhLmI9Yy1mLG8uYj1fKyhzLV8pLzQsYS5jPW8uYT0oYS5iK28uYikvMixbcixuLGEsb119LGg9ZnVuY3Rpb24odCxyLG4sYSxvKXt2YXIgaCxfLHUsYyxmLHAsbSxkLGcsdix5LFQseCx3PXQubGVuZ3RoLTEsYj0wLFA9dFswXS5hO2ZvcihoPTA7dz5oO2grKylmPXRbYl0sXz1mLmEsdT1mLmQsYz10W2IrMV0uZCxvPyh5PWVbaF0sVD1pW2hdLHg9LjI1KihUK3kpKnIvKGE/LjU6c1toXXx8LjUpLHA9dS0odS1fKSooYT8uNSpyOjAhPT15P3gveTowKSxtPXUrKGMtdSkqKGE/LjUqcjowIT09VD94L1Q6MCksZD11LShwKygobS1wKSooMyp5Lyh5K1QpKy41KS80fHwwKSkpOihwPXUtLjUqKHUtXykqcixtPXUrLjUqKGMtdSkqcixkPXUtKHArbSkvMikscCs9ZCxtKz1kLGYuYz1nPXAsZi5iPTAhPT1oP1A6UD1mLmErLjYqKGYuYy1mLmEpLGYuZGE9dS1fLGYuY2E9Zy1fLGYuYmE9UC1fLG4/KHY9bChfLFAsZyx1KSx0LnNwbGljZShiLDEsdlswXSx2WzFdLHZbMl0sdlszXSksYis9NCk6YisrLFA9bTtmPXRbYl0sZi5iPVAsZi5jPVArLjQqKGYuZC1QKSxmLmRhPWYuZC1mLmEsZi5jYT1mLmMtZi5hLGYuYmE9UC1mLmEsbiYmKHY9bChmLmEsUCxmLmMsZi5kKSx0LnNwbGljZShiLDEsdlswXSx2WzFdLHZbMl0sdlszXSkpfSxfPWZ1bmN0aW9uKHQscyxyLG4pe3ZhciBvLGwsaCxfLHUsYyxmPVtdO2lmKG4pZm9yKHQ9W25dLmNvbmNhdCh0KSxsPXQubGVuZ3RoOy0tbD4tMTspXCJzdHJpbmdcIj09dHlwZW9mKGM9dFtsXVtzXSkmJlwiPVwiPT09Yy5jaGFyQXQoMSkmJih0W2xdW3NdPW5bc10rTnVtYmVyKGMuY2hhckF0KDApK2Muc3Vic3RyKDIpKSk7aWYobz10Lmxlbmd0aC0yLDA+bylyZXR1cm4gZlswXT1uZXcgYSh0WzBdW3NdLDAsMCx0Wy0xPm8/MDoxXVtzXSksZjtmb3IobD0wO28+bDtsKyspaD10W2xdW3NdLF89dFtsKzFdW3NdLGZbbF09bmV3IGEoaCwwLDAsXyksciYmKHU9dFtsKzJdW3NdLGVbbF09KGVbbF18fDApKyhfLWgpKihfLWgpLGlbbF09KGlbbF18fDApKyh1LV8pKih1LV8pKTtyZXR1cm4gZltsXT1uZXcgYSh0W2xdW3NdLDAsMCx0W2wrMV1bc10pLGZ9LHU9ZnVuY3Rpb24odCxuLGEsbCx1LGMpe3ZhciBmLHAsbSxkLGcsdix5LFQseD17fSx3PVtdLGI9Y3x8dFswXTt1PVwic3RyaW5nXCI9PXR5cGVvZiB1P1wiLFwiK3UrXCIsXCI6byxudWxsPT1uJiYobj0xKTtmb3IocCBpbiB0WzBdKXcucHVzaChwKTtpZih0Lmxlbmd0aD4xKXtmb3IoVD10W3QubGVuZ3RoLTFdLHk9ITAsZj13Lmxlbmd0aDstLWY+LTE7KWlmKHA9d1tmXSxNYXRoLmFicyhiW3BdLVRbcF0pPi4wNSl7eT0hMTticmVha315JiYodD10LmNvbmNhdCgpLGMmJnQudW5zaGlmdChjKSx0LnB1c2godFsxXSksYz10W3QubGVuZ3RoLTNdKX1mb3IoZS5sZW5ndGg9aS5sZW5ndGg9cy5sZW5ndGg9MCxmPXcubGVuZ3RoOy0tZj4tMTspcD13W2ZdLHJbcF09LTEhPT11LmluZGV4T2YoXCIsXCIrcCtcIixcIikseFtwXT1fKHQscCxyW3BdLGMpO2ZvcihmPWUubGVuZ3RoOy0tZj4tMTspZVtmXT1NYXRoLnNxcnQoZVtmXSksaVtmXT1NYXRoLnNxcnQoaVtmXSk7aWYoIWwpe2ZvcihmPXcubGVuZ3RoOy0tZj4tMTspaWYocltwXSlmb3IobT14W3dbZl1dLHY9bS5sZW5ndGgtMSxkPTA7dj5kO2QrKylnPW1bZCsxXS5kYS9pW2RdK21bZF0uZGEvZVtkXSxzW2RdPShzW2RdfHwwKStnKmc7Zm9yKGY9cy5sZW5ndGg7LS1mPi0xOylzW2ZdPU1hdGguc3FydChzW2ZdKX1mb3IoZj13Lmxlbmd0aCxkPWE/NDoxOy0tZj4tMTspcD13W2ZdLG09eFtwXSxoKG0sbixhLGwscltwXSkseSYmKG0uc3BsaWNlKDAsZCksbS5zcGxpY2UobS5sZW5ndGgtZCxkKSk7cmV0dXJuIHh9LGM9ZnVuY3Rpb24odCxlLGkpe2U9ZXx8XCJzb2Z0XCI7dmFyIHMscixuLG8sbCxoLF8sdSxjLGYscCxtPXt9LGQ9XCJjdWJpY1wiPT09ZT8zOjIsZz1cInNvZnRcIj09PWUsdj1bXTtpZihnJiZpJiYodD1baV0uY29uY2F0KHQpKSxudWxsPT10fHxkKzE+dC5sZW5ndGgpdGhyb3dcImludmFsaWQgQmV6aWVyIGRhdGFcIjtmb3IoYyBpbiB0WzBdKXYucHVzaChjKTtmb3IoaD12Lmxlbmd0aDstLWg+LTE7KXtmb3IoYz12W2hdLG1bY109bD1bXSxmPTAsdT10Lmxlbmd0aCxfPTA7dT5fO18rKylzPW51bGw9PWk/dFtfXVtjXTpcInN0cmluZ1wiPT10eXBlb2YocD10W19dW2NdKSYmXCI9XCI9PT1wLmNoYXJBdCgxKT9pW2NdK051bWJlcihwLmNoYXJBdCgwKStwLnN1YnN0cigyKSk6TnVtYmVyKHApLGcmJl8+MSYmdS0xPl8mJihsW2YrK109KHMrbFtmLTJdKS8yKSxsW2YrK109cztmb3IodT1mLWQrMSxmPTAsXz0wO3U+XztfKz1kKXM9bFtfXSxyPWxbXysxXSxuPWxbXysyXSxvPTI9PT1kPzA6bFtfKzNdLGxbZisrXT1wPTM9PT1kP25ldyBhKHMscixuLG8pOm5ldyBhKHMsKDIqcitzKS8zLCgyKnIrbikvMyxuKTtsLmxlbmd0aD1mfXJldHVybiBtfSxmPWZ1bmN0aW9uKHQsZSxpKXtmb3IodmFyIHMscixuLGEsbyxsLGgsXyx1LGMsZixwPTEvaSxtPXQubGVuZ3RoOy0tbT4tMTspZm9yKGM9dFttXSxuPWMuYSxhPWMuZC1uLG89Yy5jLW4sbD1jLmItbixzPXI9MCxfPTE7aT49XztfKyspaD1wKl8sdT0xLWgscz1yLShyPShoKmgqYSszKnUqKGgqbyt1KmwpKSpoKSxmPW0qaStfLTEsZVtmXT0oZVtmXXx8MCkrcypzfSxwPWZ1bmN0aW9uKHQsZSl7ZT1lPj4wfHw2O3ZhciBpLHMscixuLGE9W10sbz1bXSxsPTAsaD0wLF89ZS0xLHU9W10sYz1bXTtmb3IoaSBpbiB0KWYodFtpXSxhLGUpO2ZvcihyPWEubGVuZ3RoLHM9MDtyPnM7cysrKWwrPU1hdGguc3FydChhW3NdKSxuPXMlZSxjW25dPWwsbj09PV8mJihoKz1sLG49cy9lPj4wLHVbbl09YyxvW25dPWgsbD0wLGM9W10pO3JldHVybntsZW5ndGg6aCxsZW5ndGhzOm8sc2VnbWVudHM6dX19LG09X2dzU2NvcGUuX2dzRGVmaW5lLnBsdWdpbih7cHJvcE5hbWU6XCJiZXppZXJcIixwcmlvcml0eTotMSx2ZXJzaW9uOlwiMS4zLjRcIixBUEk6MixnbG9iYWw6ITAsaW5pdDpmdW5jdGlvbih0LGUsaSl7dGhpcy5fdGFyZ2V0PXQsZSBpbnN0YW5jZW9mIEFycmF5JiYoZT17dmFsdWVzOmV9KSx0aGlzLl9mdW5jPXt9LHRoaXMuX3JvdW5kPXt9LHRoaXMuX3Byb3BzPVtdLHRoaXMuX3RpbWVSZXM9bnVsbD09ZS50aW1lUmVzb2x1dGlvbj82OnBhcnNlSW50KGUudGltZVJlc29sdXRpb24sMTApO3ZhciBzLHIsbixhLG8sbD1lLnZhbHVlc3x8W10saD17fSxfPWxbMF0sZj1lLmF1dG9Sb3RhdGV8fGkudmFycy5vcmllbnRUb0Jlemllcjt0aGlzLl9hdXRvUm90YXRlPWY/ZiBpbnN0YW5jZW9mIEFycmF5P2Y6W1tcInhcIixcInlcIixcInJvdGF0aW9uXCIsZj09PSEwPzA6TnVtYmVyKGYpfHwwXV06bnVsbDtcbmZvcihzIGluIF8pdGhpcy5fcHJvcHMucHVzaChzKTtmb3Iobj10aGlzLl9wcm9wcy5sZW5ndGg7LS1uPi0xOylzPXRoaXMuX3Byb3BzW25dLHRoaXMuX292ZXJ3cml0ZVByb3BzLnB1c2gocykscj10aGlzLl9mdW5jW3NdPVwiZnVuY3Rpb25cIj09dHlwZW9mIHRbc10saFtzXT1yP3Rbcy5pbmRleE9mKFwic2V0XCIpfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiB0W1wiZ2V0XCIrcy5zdWJzdHIoMyldP3M6XCJnZXRcIitzLnN1YnN0cigzKV0oKTpwYXJzZUZsb2F0KHRbc10pLG98fGhbc10hPT1sWzBdW3NdJiYobz1oKTtpZih0aGlzLl9iZXppZXJzPVwiY3ViaWNcIiE9PWUudHlwZSYmXCJxdWFkcmF0aWNcIiE9PWUudHlwZSYmXCJzb2Z0XCIhPT1lLnR5cGU/dShsLGlzTmFOKGUuY3VydmluZXNzKT8xOmUuY3VydmluZXNzLCExLFwidGhydUJhc2ljXCI9PT1lLnR5cGUsZS5jb3JyZWxhdGUsbyk6YyhsLGUudHlwZSxoKSx0aGlzLl9zZWdDb3VudD10aGlzLl9iZXppZXJzW3NdLmxlbmd0aCx0aGlzLl90aW1lUmVzKXt2YXIgbT1wKHRoaXMuX2JlemllcnMsdGhpcy5fdGltZVJlcyk7dGhpcy5fbGVuZ3RoPW0ubGVuZ3RoLHRoaXMuX2xlbmd0aHM9bS5sZW5ndGhzLHRoaXMuX3NlZ21lbnRzPW0uc2VnbWVudHMsdGhpcy5fbDE9dGhpcy5fbGk9dGhpcy5fczE9dGhpcy5fc2k9MCx0aGlzLl9sMj10aGlzLl9sZW5ndGhzWzBdLHRoaXMuX2N1clNlZz10aGlzLl9zZWdtZW50c1swXSx0aGlzLl9zMj10aGlzLl9jdXJTZWdbMF0sdGhpcy5fcHJlYz0xL3RoaXMuX2N1clNlZy5sZW5ndGh9aWYoZj10aGlzLl9hdXRvUm90YXRlKWZvcih0aGlzLl9pbml0aWFsUm90YXRpb25zPVtdLGZbMF1pbnN0YW5jZW9mIEFycmF5fHwodGhpcy5fYXV0b1JvdGF0ZT1mPVtmXSksbj1mLmxlbmd0aDstLW4+LTE7KXtmb3IoYT0wOzM+YTthKyspcz1mW25dW2FdLHRoaXMuX2Z1bmNbc109XCJmdW5jdGlvblwiPT10eXBlb2YgdFtzXT90W3MuaW5kZXhPZihcInNldFwiKXx8XCJmdW5jdGlvblwiIT10eXBlb2YgdFtcImdldFwiK3Muc3Vic3RyKDMpXT9zOlwiZ2V0XCIrcy5zdWJzdHIoMyldOiExO3M9ZltuXVsyXSx0aGlzLl9pbml0aWFsUm90YXRpb25zW25dPXRoaXMuX2Z1bmNbc10/dGhpcy5fZnVuY1tzXS5jYWxsKHRoaXMuX3RhcmdldCk6dGhpcy5fdGFyZ2V0W3NdfXJldHVybiB0aGlzLl9zdGFydFJhdGlvPWkudmFycy5ydW5CYWNrd2FyZHM/MTowLCEwfSxzZXQ6ZnVuY3Rpb24oZSl7dmFyIGkscyxyLG4sYSxvLGwsaCxfLHUsYz10aGlzLl9zZWdDb3VudCxmPXRoaXMuX2Z1bmMscD10aGlzLl90YXJnZXQsbT1lIT09dGhpcy5fc3RhcnRSYXRpbztpZih0aGlzLl90aW1lUmVzKXtpZihfPXRoaXMuX2xlbmd0aHMsdT10aGlzLl9jdXJTZWcsZSo9dGhpcy5fbGVuZ3RoLHI9dGhpcy5fbGksZT50aGlzLl9sMiYmYy0xPnIpe2ZvcihoPWMtMTtoPnImJmU+PSh0aGlzLl9sMj1fWysrcl0pOyk7dGhpcy5fbDE9X1tyLTFdLHRoaXMuX2xpPXIsdGhpcy5fY3VyU2VnPXU9dGhpcy5fc2VnbWVudHNbcl0sdGhpcy5fczI9dVt0aGlzLl9zMT10aGlzLl9zaT0wXX1lbHNlIGlmKHRoaXMuX2wxPmUmJnI+MCl7Zm9yKDtyPjAmJih0aGlzLl9sMT1fWy0tcl0pPj1lOyk7MD09PXImJnRoaXMuX2wxPmU/dGhpcy5fbDE9MDpyKyssdGhpcy5fbDI9X1tyXSx0aGlzLl9saT1yLHRoaXMuX2N1clNlZz11PXRoaXMuX3NlZ21lbnRzW3JdLHRoaXMuX3MxPXVbKHRoaXMuX3NpPXUubGVuZ3RoLTEpLTFdfHwwLHRoaXMuX3MyPXVbdGhpcy5fc2ldfWlmKGk9cixlLT10aGlzLl9sMSxyPXRoaXMuX3NpLGU+dGhpcy5fczImJnUubGVuZ3RoLTE+cil7Zm9yKGg9dS5sZW5ndGgtMTtoPnImJmU+PSh0aGlzLl9zMj11Wysrcl0pOyk7dGhpcy5fczE9dVtyLTFdLHRoaXMuX3NpPXJ9ZWxzZSBpZih0aGlzLl9zMT5lJiZyPjApe2Zvcig7cj4wJiYodGhpcy5fczE9dVstLXJdKT49ZTspOzA9PT1yJiZ0aGlzLl9zMT5lP3RoaXMuX3MxPTA6cisrLHRoaXMuX3MyPXVbcl0sdGhpcy5fc2k9cn1vPShyKyhlLXRoaXMuX3MxKS8odGhpcy5fczItdGhpcy5fczEpKSp0aGlzLl9wcmVjfWVsc2UgaT0wPmU/MDplPj0xP2MtMTpjKmU+PjAsbz0oZS1pKigxL2MpKSpjO2ZvcihzPTEtbyxyPXRoaXMuX3Byb3BzLmxlbmd0aDstLXI+LTE7KW49dGhpcy5fcHJvcHNbcl0sYT10aGlzLl9iZXppZXJzW25dW2ldLGw9KG8qbyphLmRhKzMqcyoobyphLmNhK3MqYS5iYSkpKm8rYS5hLHRoaXMuX3JvdW5kW25dJiYobD1NYXRoLnJvdW5kKGwpKSxmW25dP3Bbbl0obCk6cFtuXT1sO2lmKHRoaXMuX2F1dG9Sb3RhdGUpe3ZhciBkLGcsdix5LFQseCx3LGI9dGhpcy5fYXV0b1JvdGF0ZTtmb3Iocj1iLmxlbmd0aDstLXI+LTE7KW49YltyXVsyXSx4PWJbcl1bM118fDAsdz1iW3JdWzRdPT09ITA/MTp0LGE9dGhpcy5fYmV6aWVyc1tiW3JdWzBdXSxkPXRoaXMuX2JlemllcnNbYltyXVsxXV0sYSYmZCYmKGE9YVtpXSxkPWRbaV0sZz1hLmErKGEuYi1hLmEpKm8seT1hLmIrKGEuYy1hLmIpKm8sZys9KHktZykqbyx5Kz0oYS5jKyhhLmQtYS5jKSpvLXkpKm8sdj1kLmErKGQuYi1kLmEpKm8sVD1kLmIrKGQuYy1kLmIpKm8sdis9KFQtdikqbyxUKz0oZC5jKyhkLmQtZC5jKSpvLVQpKm8sbD1tP01hdGguYXRhbjIoVC12LHktZykqdyt4OnRoaXMuX2luaXRpYWxSb3RhdGlvbnNbcl0sZltuXT9wW25dKGwpOnBbbl09bCl9fX0pLGQ9bS5wcm90b3R5cGU7bS5iZXppZXJUaHJvdWdoPXUsbS5jdWJpY1RvUXVhZHJhdGljPWwsbS5fYXV0b0NTUz0hMCxtLnF1YWRyYXRpY1RvQ3ViaWM9ZnVuY3Rpb24odCxlLGkpe3JldHVybiBuZXcgYSh0LCgyKmUrdCkvMywoMiplK2kpLzMsaSl9LG0uX2Nzc1JlZ2lzdGVyPWZ1bmN0aW9uKCl7dmFyIHQ9bi5DU1NQbHVnaW47aWYodCl7dmFyIGU9dC5faW50ZXJuYWxzLGk9ZS5fcGFyc2VUb1Byb3h5LHM9ZS5fc2V0UGx1Z2luUmF0aW8scj1lLkNTU1Byb3BUd2VlbjtlLl9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJlemllclwiLHtwYXJzZXI6ZnVuY3Rpb24odCxlLG4sYSxvLGwpe2UgaW5zdGFuY2VvZiBBcnJheSYmKGU9e3ZhbHVlczplfSksbD1uZXcgbTt2YXIgaCxfLHUsYz1lLnZhbHVlcyxmPWMubGVuZ3RoLTEscD1bXSxkPXt9O2lmKDA+ZilyZXR1cm4gbztmb3IoaD0wO2Y+PWg7aCsrKXU9aSh0LGNbaF0sYSxvLGwsZiE9PWgpLHBbaF09dS5lbmQ7Zm9yKF8gaW4gZSlkW19dPWVbX107cmV0dXJuIGQudmFsdWVzPXAsbz1uZXcgcih0LFwiYmV6aWVyXCIsMCwwLHUucHQsMiksby5kYXRhPXUsby5wbHVnaW49bCxvLnNldFJhdGlvPXMsMD09PWQuYXV0b1JvdGF0ZSYmKGQuYXV0b1JvdGF0ZT0hMCksIWQuYXV0b1JvdGF0ZXx8ZC5hdXRvUm90YXRlIGluc3RhbmNlb2YgQXJyYXl8fChoPWQuYXV0b1JvdGF0ZT09PSEwPzA6TnVtYmVyKGQuYXV0b1JvdGF0ZSksZC5hdXRvUm90YXRlPW51bGwhPXUuZW5kLmxlZnQ/W1tcImxlZnRcIixcInRvcFwiLFwicm90YXRpb25cIixoLCExXV06bnVsbCE9dS5lbmQueD9bW1wieFwiLFwieVwiLFwicm90YXRpb25cIixoLCExXV06ITEpLGQuYXV0b1JvdGF0ZSYmKGEuX3RyYW5zZm9ybXx8YS5fZW5hYmxlVHJhbnNmb3JtcyghMSksdS5hdXRvUm90YXRlPWEuX3RhcmdldC5fZ3NUcmFuc2Zvcm0pLGwuX29uSW5pdFR3ZWVuKHUucHJveHksZCxhLl90d2Vlbiksb319KX19LGQuX3JvdW5kUHJvcHM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIGk9dGhpcy5fb3ZlcndyaXRlUHJvcHMscz1pLmxlbmd0aDstLXM+LTE7KSh0W2lbc11dfHx0LmJlemllcnx8dC5iZXppZXJUaHJvdWdoKSYmKHRoaXMuX3JvdW5kW2lbc11dPWUpfSxkLl9raWxsPWZ1bmN0aW9uKHQpe3ZhciBlLGkscz10aGlzLl9wcm9wcztmb3IoZSBpbiB0aGlzLl9iZXppZXJzKWlmKGUgaW4gdClmb3IoZGVsZXRlIHRoaXMuX2JlemllcnNbZV0sZGVsZXRlIHRoaXMuX2Z1bmNbZV0saT1zLmxlbmd0aDstLWk+LTE7KXNbaV09PT1lJiZzLnNwbGljZShpLDEpO3JldHVybiB0aGlzLl9zdXBlci5fa2lsbC5jYWxsKHRoaXMsdCl9fSgpLF9nc1Njb3BlLl9nc0RlZmluZShcInBsdWdpbnMuQ1NTUGx1Z2luXCIsW1wicGx1Z2lucy5Ud2VlblBsdWdpblwiLFwiVHdlZW5MaXRlXCJdLGZ1bmN0aW9uKHQsZSl7dmFyIGkscyxyLG4sYT1mdW5jdGlvbigpe3QuY2FsbCh0aGlzLFwiY3NzXCIpLHRoaXMuX292ZXJ3cml0ZVByb3BzLmxlbmd0aD0wLHRoaXMuc2V0UmF0aW89YS5wcm90b3R5cGUuc2V0UmF0aW99LG89X2dzU2NvcGUuX2dzRGVmaW5lLmdsb2JhbHMsbD17fSxoPWEucHJvdG90eXBlPW5ldyB0KFwiY3NzXCIpO2guY29uc3RydWN0b3I9YSxhLnZlcnNpb249XCIxLjE4LjBcIixhLkFQST0yLGEuZGVmYXVsdFRyYW5zZm9ybVBlcnNwZWN0aXZlPTAsYS5kZWZhdWx0U2tld1R5cGU9XCJjb21wZW5zYXRlZFwiLGEuZGVmYXVsdFNtb290aE9yaWdpbj0hMCxoPVwicHhcIixhLnN1ZmZpeE1hcD17dG9wOmgscmlnaHQ6aCxib3R0b206aCxsZWZ0Omgsd2lkdGg6aCxoZWlnaHQ6aCxmb250U2l6ZTpoLHBhZGRpbmc6aCxtYXJnaW46aCxwZXJzcGVjdGl2ZTpoLGxpbmVIZWlnaHQ6XCJcIn07dmFyIF8sdSxjLGYscCxtLGQ9Lyg/OlxcZHxcXC1cXGR8XFwuXFxkfFxcLVxcLlxcZCkrL2csZz0vKD86XFxkfFxcLVxcZHxcXC5cXGR8XFwtXFwuXFxkfFxcKz1cXGR8XFwtPVxcZHxcXCs9LlxcZHxcXC09XFwuXFxkKSsvZyx2PS8oPzpcXCs9fFxcLT18XFwtfFxcYilbXFxkXFwtXFwuXStbYS16QS1aMC05XSooPzolfFxcYikvZ2kseT0vKD8hWystXT9cXGQqXFwuP1xcZCt8WystXXxlWystXVxcZCspW14wLTldL2csVD0vKD86XFxkfFxcLXxcXCt8PXwjfFxcLikqL2cseD0vb3BhY2l0eSAqPSAqKFteKV0qKS9pLHc9L29wYWNpdHk6KFteO10qKS9pLGI9L2FscGhhXFwob3BhY2l0eSAqPS4rP1xcKS9pLFA9L14ocmdifGhzbCkvLGs9LyhbQS1aXSkvZyxTPS8tKFthLXpdKS9naSxSPS8oXig/OnVybFxcKFxcXCJ8dXJsXFwoKSl8KD86KFxcXCJcXCkpJHxcXCkkKS9naSxPPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUudG9VcHBlckNhc2UoKX0sQT0vKD86TGVmdHxSaWdodHxXaWR0aCkvaSxDPS8oTTExfE0xMnxNMjF8TTIyKT1bXFxkXFwtXFwuZV0rL2dpLEQ9L3Byb2dpZFxcOkRYSW1hZ2VUcmFuc2Zvcm1cXC5NaWNyb3NvZnRcXC5NYXRyaXhcXCguKz9cXCkvaSxNPS8sKD89W15cXCldKig/OlxcKHwkKSkvZ2ksej1NYXRoLlBJLzE4MCxGPTE4MC9NYXRoLlBJLEk9e30sRT1kb2N1bWVudCxOPWZ1bmN0aW9uKHQpe3JldHVybiBFLmNyZWF0ZUVsZW1lbnROUz9FLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIix0KTpFLmNyZWF0ZUVsZW1lbnQodCl9LEw9TihcImRpdlwiKSxYPU4oXCJpbWdcIiksQj1hLl9pbnRlcm5hbHM9e19zcGVjaWFsUHJvcHM6bH0saj1uYXZpZ2F0b3IudXNlckFnZW50LFk9ZnVuY3Rpb24oKXt2YXIgdD1qLmluZGV4T2YoXCJBbmRyb2lkXCIpLGU9TihcImFcIik7cmV0dXJuIGM9LTEhPT1qLmluZGV4T2YoXCJTYWZhcmlcIikmJi0xPT09ai5pbmRleE9mKFwiQ2hyb21lXCIpJiYoLTE9PT10fHxOdW1iZXIoai5zdWJzdHIodCs4LDEpKT4zKSxwPWMmJjY+TnVtYmVyKGouc3Vic3RyKGouaW5kZXhPZihcIlZlcnNpb24vXCIpKzgsMSkpLGY9LTEhPT1qLmluZGV4T2YoXCJGaXJlZm94XCIpLCgvTVNJRSAoWzAtOV17MSx9W1xcLjAtOV17MCx9KS8uZXhlYyhqKXx8L1RyaWRlbnRcXC8uKnJ2OihbMC05XXsxLH1bXFwuMC05XXswLH0pLy5leGVjKGopKSYmKG09cGFyc2VGbG9hdChSZWdFeHAuJDEpKSxlPyhlLnN0eWxlLmNzc1RleHQ9XCJ0b3A6MXB4O29wYWNpdHk6LjU1O1wiLC9eMC41NS8udGVzdChlLnN0eWxlLm9wYWNpdHkpKTohMX0oKSxVPWZ1bmN0aW9uKHQpe3JldHVybiB4LnRlc3QoXCJzdHJpbmdcIj09dHlwZW9mIHQ/dDoodC5jdXJyZW50U3R5bGU/dC5jdXJyZW50U3R5bGUuZmlsdGVyOnQuc3R5bGUuZmlsdGVyKXx8XCJcIik/cGFyc2VGbG9hdChSZWdFeHAuJDEpLzEwMDoxfSxxPWZ1bmN0aW9uKHQpe3dpbmRvdy5jb25zb2xlJiZjb25zb2xlLmxvZyh0KX0sVj1cIlwiLEc9XCJcIixXPWZ1bmN0aW9uKHQsZSl7ZT1lfHxMO3ZhciBpLHMscj1lLnN0eWxlO2lmKHZvaWQgMCE9PXJbdF0pcmV0dXJuIHQ7Zm9yKHQ9dC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSt0LnN1YnN0cigxKSxpPVtcIk9cIixcIk1velwiLFwibXNcIixcIk1zXCIsXCJXZWJraXRcIl0scz01Oy0tcz4tMSYmdm9pZCAwPT09cltpW3NdK3RdOyk7cmV0dXJuIHM+PTA/KEc9Mz09PXM/XCJtc1wiOmlbc10sVj1cIi1cIitHLnRvTG93ZXJDYXNlKCkrXCItXCIsRyt0KTpudWxsfSxaPUUuZGVmYXVsdFZpZXc/RS5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlOmZ1bmN0aW9uKCl7fSxRPWEuZ2V0U3R5bGU9ZnVuY3Rpb24odCxlLGkscyxyKXt2YXIgbjtyZXR1cm4gWXx8XCJvcGFjaXR5XCIhPT1lPyghcyYmdC5zdHlsZVtlXT9uPXQuc3R5bGVbZV06KGk9aXx8Wih0KSk/bj1pW2VdfHxpLmdldFByb3BlcnR5VmFsdWUoZSl8fGkuZ2V0UHJvcGVydHlWYWx1ZShlLnJlcGxhY2UoayxcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTp0LmN1cnJlbnRTdHlsZSYmKG49dC5jdXJyZW50U3R5bGVbZV0pLG51bGw9PXJ8fG4mJlwibm9uZVwiIT09biYmXCJhdXRvXCIhPT1uJiZcImF1dG8gYXV0b1wiIT09bj9uOnIpOlUodCl9LCQ9Qi5jb252ZXJ0VG9QaXhlbHM9ZnVuY3Rpb24odCxpLHMscixuKXtpZihcInB4XCI9PT1yfHwhcilyZXR1cm4gcztpZihcImF1dG9cIj09PXJ8fCFzKXJldHVybiAwO3ZhciBvLGwsaCxfPUEudGVzdChpKSx1PXQsYz1MLnN0eWxlLGY9MD5zO2lmKGYmJihzPS1zKSxcIiVcIj09PXImJi0xIT09aS5pbmRleE9mKFwiYm9yZGVyXCIpKW89cy8xMDAqKF8/dC5jbGllbnRXaWR0aDp0LmNsaWVudEhlaWdodCk7ZWxzZXtpZihjLmNzc1RleHQ9XCJib3JkZXI6MCBzb2xpZCByZWQ7cG9zaXRpb246XCIrUSh0LFwicG9zaXRpb25cIikrXCI7bGluZS1oZWlnaHQ6MDtcIixcIiVcIiE9PXImJnUuYXBwZW5kQ2hpbGQmJlwidlwiIT09ci5jaGFyQXQoMCkmJlwicmVtXCIhPT1yKWNbXz9cImJvcmRlckxlZnRXaWR0aFwiOlwiYm9yZGVyVG9wV2lkdGhcIl09cytyO2Vsc2V7aWYodT10LnBhcmVudE5vZGV8fEUuYm9keSxsPXUuX2dzQ2FjaGUsaD1lLnRpY2tlci5mcmFtZSxsJiZfJiZsLnRpbWU9PT1oKXJldHVybiBsLndpZHRoKnMvMTAwO2NbXz9cIndpZHRoXCI6XCJoZWlnaHRcIl09cytyfXUuYXBwZW5kQ2hpbGQoTCksbz1wYXJzZUZsb2F0KExbXz9cIm9mZnNldFdpZHRoXCI6XCJvZmZzZXRIZWlnaHRcIl0pLHUucmVtb3ZlQ2hpbGQoTCksXyYmXCIlXCI9PT1yJiZhLmNhY2hlV2lkdGhzIT09ITEmJihsPXUuX2dzQ2FjaGU9dS5fZ3NDYWNoZXx8e30sbC50aW1lPWgsbC53aWR0aD0xMDAqKG8vcykpLDAhPT1vfHxufHwobz0kKHQsaSxzLHIsITApKX1yZXR1cm4gZj8tbzpvfSxIPUIuY2FsY3VsYXRlT2Zmc2V0PWZ1bmN0aW9uKHQsZSxpKXtpZihcImFic29sdXRlXCIhPT1RKHQsXCJwb3NpdGlvblwiLGkpKXJldHVybiAwO3ZhciBzPVwibGVmdFwiPT09ZT9cIkxlZnRcIjpcIlRvcFwiLHI9USh0LFwibWFyZ2luXCIrcyxpKTtyZXR1cm4gdFtcIm9mZnNldFwiK3NdLSgkKHQsZSxwYXJzZUZsb2F0KHIpLHIucmVwbGFjZShULFwiXCIpKXx8MCl9LEs9ZnVuY3Rpb24odCxlKXt2YXIgaSxzLHIsbj17fTtpZihlPWV8fFoodCxudWxsKSlpZihpPWUubGVuZ3RoKWZvcig7LS1pPi0xOylyPWVbaV0sKC0xPT09ci5pbmRleE9mKFwiLXRyYW5zZm9ybVwiKXx8a2U9PT1yKSYmKG5bci5yZXBsYWNlKFMsTyldPWUuZ2V0UHJvcGVydHlWYWx1ZShyKSk7ZWxzZSBmb3IoaSBpbiBlKSgtMT09PWkuaW5kZXhPZihcIlRyYW5zZm9ybVwiKXx8UGU9PT1pKSYmKG5baV09ZVtpXSk7ZWxzZSBpZihlPXQuY3VycmVudFN0eWxlfHx0LnN0eWxlKWZvcihpIGluIGUpXCJzdHJpbmdcIj09dHlwZW9mIGkmJnZvaWQgMD09PW5baV0mJihuW2kucmVwbGFjZShTLE8pXT1lW2ldKTtyZXR1cm4gWXx8KG4ub3BhY2l0eT1VKHQpKSxzPU5lKHQsZSwhMSksbi5yb3RhdGlvbj1zLnJvdGF0aW9uLG4uc2tld1g9cy5za2V3WCxuLnNjYWxlWD1zLnNjYWxlWCxuLnNjYWxlWT1zLnNjYWxlWSxuLng9cy54LG4ueT1zLnksUmUmJihuLno9cy56LG4ucm90YXRpb25YPXMucm90YXRpb25YLG4ucm90YXRpb25ZPXMucm90YXRpb25ZLG4uc2NhbGVaPXMuc2NhbGVaKSxuLmZpbHRlcnMmJmRlbGV0ZSBuLmZpbHRlcnMsbn0sSj1mdW5jdGlvbih0LGUsaSxzLHIpe3ZhciBuLGEsbyxsPXt9LGg9dC5zdHlsZTtmb3IoYSBpbiBpKVwiY3NzVGV4dFwiIT09YSYmXCJsZW5ndGhcIiE9PWEmJmlzTmFOKGEpJiYoZVthXSE9PShuPWlbYV0pfHxyJiZyW2FdKSYmLTE9PT1hLmluZGV4T2YoXCJPcmlnaW5cIikmJihcIm51bWJlclwiPT10eXBlb2Ygbnx8XCJzdHJpbmdcIj09dHlwZW9mIG4pJiYobFthXT1cImF1dG9cIiE9PW58fFwibGVmdFwiIT09YSYmXCJ0b3BcIiE9PWE/XCJcIiE9PW4mJlwiYXV0b1wiIT09biYmXCJub25lXCIhPT1ufHxcInN0cmluZ1wiIT10eXBlb2YgZVthXXx8XCJcIj09PWVbYV0ucmVwbGFjZSh5LFwiXCIpP246MDpIKHQsYSksdm9pZCAwIT09aFthXSYmKG89bmV3IHBlKGgsYSxoW2FdLG8pKSk7aWYocylmb3IoYSBpbiBzKVwiY2xhc3NOYW1lXCIhPT1hJiYobFthXT1zW2FdKTtyZXR1cm57ZGlmczpsLGZpcnN0TVBUOm99fSx0ZT17d2lkdGg6W1wiTGVmdFwiLFwiUmlnaHRcIl0saGVpZ2h0OltcIlRvcFwiLFwiQm90dG9tXCJdfSxlZT1bXCJtYXJnaW5MZWZ0XCIsXCJtYXJnaW5SaWdodFwiLFwibWFyZ2luVG9wXCIsXCJtYXJnaW5Cb3R0b21cIl0saWU9ZnVuY3Rpb24odCxlLGkpe3ZhciBzPXBhcnNlRmxvYXQoXCJ3aWR0aFwiPT09ZT90Lm9mZnNldFdpZHRoOnQub2Zmc2V0SGVpZ2h0KSxyPXRlW2VdLG49ci5sZW5ndGg7Zm9yKGk9aXx8Wih0LG51bGwpOy0tbj4tMTspcy09cGFyc2VGbG9hdChRKHQsXCJwYWRkaW5nXCIrcltuXSxpLCEwKSl8fDAscy09cGFyc2VGbG9hdChRKHQsXCJib3JkZXJcIityW25dK1wiV2lkdGhcIixpLCEwKSl8fDA7cmV0dXJuIHN9LHNlPWZ1bmN0aW9uKHQsZSl7aWYoXCJjb250YWluXCI9PT10fHxcImF1dG9cIj09PXR8fFwiYXV0byBhdXRvXCI9PT10KXJldHVybiB0K1wiIFwiOyhudWxsPT10fHxcIlwiPT09dCkmJih0PVwiMCAwXCIpO3ZhciBpPXQuc3BsaXQoXCIgXCIpLHM9LTEhPT10LmluZGV4T2YoXCJsZWZ0XCIpP1wiMCVcIjotMSE9PXQuaW5kZXhPZihcInJpZ2h0XCIpP1wiMTAwJVwiOmlbMF0scj0tMSE9PXQuaW5kZXhPZihcInRvcFwiKT9cIjAlXCI6LTEhPT10LmluZGV4T2YoXCJib3R0b21cIik/XCIxMDAlXCI6aVsxXTtyZXR1cm4gbnVsbD09cj9yPVwiY2VudGVyXCI9PT1zP1wiNTAlXCI6XCIwXCI6XCJjZW50ZXJcIj09PXImJihyPVwiNTAlXCIpLChcImNlbnRlclwiPT09c3x8aXNOYU4ocGFyc2VGbG9hdChzKSkmJi0xPT09KHMrXCJcIikuaW5kZXhPZihcIj1cIikpJiYocz1cIjUwJVwiKSx0PXMrXCIgXCIrcisoaS5sZW5ndGg+Mj9cIiBcIitpWzJdOlwiXCIpLGUmJihlLm94cD0tMSE9PXMuaW5kZXhPZihcIiVcIiksZS5veXA9LTEhPT1yLmluZGV4T2YoXCIlXCIpLGUub3hyPVwiPVwiPT09cy5jaGFyQXQoMSksZS5veXI9XCI9XCI9PT1yLmNoYXJBdCgxKSxlLm94PXBhcnNlRmxvYXQocy5yZXBsYWNlKHksXCJcIikpLGUub3k9cGFyc2VGbG9hdChyLnJlcGxhY2UoeSxcIlwiKSksZS52PXQpLGV8fHR9LHJlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHQmJlwiPVwiPT09dC5jaGFyQXQoMSk/cGFyc2VJbnQodC5jaGFyQXQoMCkrXCIxXCIsMTApKnBhcnNlRmxvYXQodC5zdWJzdHIoMikpOnBhcnNlRmxvYXQodCktcGFyc2VGbG9hdChlKX0sbmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbD09dD9lOlwic3RyaW5nXCI9PXR5cGVvZiB0JiZcIj1cIj09PXQuY2hhckF0KDEpP3BhcnNlSW50KHQuY2hhckF0KDApK1wiMVwiLDEwKSpwYXJzZUZsb2F0KHQuc3Vic3RyKDIpKStlOnBhcnNlRmxvYXQodCl9LGFlPWZ1bmN0aW9uKHQsZSxpLHMpe3ZhciByLG4sYSxvLGwsaD0xZS02O3JldHVybiBudWxsPT10P289ZTpcIm51bWJlclwiPT10eXBlb2YgdD9vPXQ6KHI9MzYwLG49dC5zcGxpdChcIl9cIiksbD1cIj1cIj09PXQuY2hhckF0KDEpLGE9KGw/cGFyc2VJbnQodC5jaGFyQXQoMCkrXCIxXCIsMTApKnBhcnNlRmxvYXQoblswXS5zdWJzdHIoMikpOnBhcnNlRmxvYXQoblswXSkpKigtMT09PXQuaW5kZXhPZihcInJhZFwiKT8xOkYpLShsPzA6ZSksbi5sZW5ndGgmJihzJiYoc1tpXT1lK2EpLC0xIT09dC5pbmRleE9mKFwic2hvcnRcIikmJihhJT1yLGEhPT1hJShyLzIpJiYoYT0wPmE/YStyOmEtcikpLC0xIT09dC5pbmRleE9mKFwiX2N3XCIpJiYwPmE/YT0oYSs5OTk5OTk5OTk5KnIpJXItKDB8YS9yKSpyOi0xIT09dC5pbmRleE9mKFwiY2N3XCIpJiZhPjAmJihhPShhLTk5OTk5OTk5OTkqciklci0oMHxhL3IpKnIpKSxvPWUrYSksaD5vJiZvPi1oJiYobz0wKSxvfSxvZT17YXF1YTpbMCwyNTUsMjU1XSxsaW1lOlswLDI1NSwwXSxzaWx2ZXI6WzE5MiwxOTIsMTkyXSxibGFjazpbMCwwLDBdLG1hcm9vbjpbMTI4LDAsMF0sdGVhbDpbMCwxMjgsMTI4XSxibHVlOlswLDAsMjU1XSxuYXZ5OlswLDAsMTI4XSx3aGl0ZTpbMjU1LDI1NSwyNTVdLGZ1Y2hzaWE6WzI1NSwwLDI1NV0sb2xpdmU6WzEyOCwxMjgsMF0seWVsbG93OlsyNTUsMjU1LDBdLG9yYW5nZTpbMjU1LDE2NSwwXSxncmF5OlsxMjgsMTI4LDEyOF0scHVycGxlOlsxMjgsMCwxMjhdLGdyZWVuOlswLDEyOCwwXSxyZWQ6WzI1NSwwLDBdLHBpbms6WzI1NSwxOTIsMjAzXSxjeWFuOlswLDI1NSwyNTVdLHRyYW5zcGFyZW50OlsyNTUsMjU1LDI1NSwwXX0sbGU9ZnVuY3Rpb24odCxlLGkpe3JldHVybiB0PTA+dD90KzE6dD4xP3QtMTp0LDB8MjU1KigxPjYqdD9lKzYqKGktZSkqdDouNT50P2k6Mj4zKnQ/ZSs2KihpLWUpKigyLzMtdCk6ZSkrLjV9LGhlPWEucGFyc2VDb2xvcj1mdW5jdGlvbih0LGUpe3ZhciBpLHMscixuLGEsbyxsLGgsXyx1LGM7aWYodClpZihcIm51bWJlclwiPT10eXBlb2YgdClpPVt0Pj4xNiwyNTUmdD4+OCwyNTUmdF07ZWxzZXtpZihcIixcIj09PXQuY2hhckF0KHQubGVuZ3RoLTEpJiYodD10LnN1YnN0cigwLHQubGVuZ3RoLTEpKSxvZVt0XSlpPW9lW3RdO2Vsc2UgaWYoXCIjXCI9PT10LmNoYXJBdCgwKSk0PT09dC5sZW5ndGgmJihzPXQuY2hhckF0KDEpLHI9dC5jaGFyQXQoMiksbj10LmNoYXJBdCgzKSx0PVwiI1wiK3MrcytyK3IrbituKSx0PXBhcnNlSW50KHQuc3Vic3RyKDEpLDE2KSxpPVt0Pj4xNiwyNTUmdD4+OCwyNTUmdF07ZWxzZSBpZihcImhzbFwiPT09dC5zdWJzdHIoMCwzKSlpZihpPWM9dC5tYXRjaChkKSxlKXtpZigtMSE9PXQuaW5kZXhPZihcIj1cIikpcmV0dXJuIHQubWF0Y2goZyl9ZWxzZSBhPU51bWJlcihpWzBdKSUzNjAvMzYwLG89TnVtYmVyKGlbMV0pLzEwMCxsPU51bWJlcihpWzJdKS8xMDAscj0uNT49bD9sKihvKzEpOmwrby1sKm8scz0yKmwtcixpLmxlbmd0aD4zJiYoaVszXT1OdW1iZXIodFszXSkpLGlbMF09bGUoYSsxLzMscyxyKSxpWzFdPWxlKGEscyxyKSxpWzJdPWxlKGEtMS8zLHMscik7ZWxzZSBpPXQubWF0Y2goZCl8fG9lLnRyYW5zcGFyZW50O2lbMF09TnVtYmVyKGlbMF0pLGlbMV09TnVtYmVyKGlbMV0pLGlbMl09TnVtYmVyKGlbMl0pLGkubGVuZ3RoPjMmJihpWzNdPU51bWJlcihpWzNdKSl9ZWxzZSBpPW9lLmJsYWNrO3JldHVybiBlJiYhYyYmKHM9aVswXS8yNTUscj1pWzFdLzI1NSxuPWlbMl0vMjU1LGg9TWF0aC5tYXgocyxyLG4pLF89TWF0aC5taW4ocyxyLG4pLGw9KGgrXykvMixoPT09Xz9hPW89MDoodT1oLV8sbz1sPi41P3UvKDItaC1fKTp1LyhoK18pLGE9aD09PXM/KHItbikvdSsobj5yPzY6MCk6aD09PXI/KG4tcykvdSsyOihzLXIpL3UrNCxhKj02MCksaVswXT0wfGErLjUsaVsxXT0wfDEwMCpvKy41LGlbMl09MHwxMDAqbCsuNSksaX0sX2U9ZnVuY3Rpb24odCxlKXt2YXIgaSxzLHIsbj10Lm1hdGNoKHVlKXx8W10sYT0wLG89bi5sZW5ndGg/XCJcIjp0O2ZvcihpPTA7bi5sZW5ndGg+aTtpKyspcz1uW2ldLHI9dC5zdWJzdHIoYSx0LmluZGV4T2YocyxhKS1hKSxhKz1yLmxlbmd0aCtzLmxlbmd0aCxzPWhlKHMsZSksMz09PXMubGVuZ3RoJiZzLnB1c2goMSksbys9cisoZT9cImhzbGEoXCIrc1swXStcIixcIitzWzFdK1wiJSxcIitzWzJdK1wiJSxcIitzWzNdOlwicmdiYShcIitzLmpvaW4oXCIsXCIpKStcIilcIjtyZXR1cm4gb30sdWU9XCIoPzpcXFxcYig/Oig/OnJnYnxyZ2JhfGhzbHxoc2xhKVxcXFwoLis/XFxcXCkpfFxcXFxCIy4rP1xcXFxiXCI7Zm9yKGggaW4gb2UpdWUrPVwifFwiK2grXCJcXFxcYlwiO3VlPVJlZ0V4cCh1ZStcIilcIixcImdpXCIpLGEuY29sb3JTdHJpbmdGaWx0ZXI9ZnVuY3Rpb24odCl7dmFyIGUsaT10WzBdK3RbMV07dWUubGFzdEluZGV4PTAsdWUudGVzdChpKSYmKGU9LTEhPT1pLmluZGV4T2YoXCJoc2woXCIpfHwtMSE9PWkuaW5kZXhPZihcImhzbGEoXCIpLHRbMF09X2UodFswXSxlKSx0WzFdPV9lKHRbMV0sZSkpfSxlLmRlZmF1bHRTdHJpbmdGaWx0ZXJ8fChlLmRlZmF1bHRTdHJpbmdGaWx0ZXI9YS5jb2xvclN0cmluZ0ZpbHRlcik7dmFyIGNlPWZ1bmN0aW9uKHQsZSxpLHMpe2lmKG51bGw9PXQpcmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiB0fTt2YXIgcixuPWU/KHQubWF0Y2godWUpfHxbXCJcIl0pWzBdOlwiXCIsYT10LnNwbGl0KG4pLmpvaW4oXCJcIikubWF0Y2godil8fFtdLG89dC5zdWJzdHIoMCx0LmluZGV4T2YoYVswXSkpLGw9XCIpXCI9PT10LmNoYXJBdCh0Lmxlbmd0aC0xKT9cIilcIjpcIlwiLGg9LTEhPT10LmluZGV4T2YoXCIgXCIpP1wiIFwiOlwiLFwiLF89YS5sZW5ndGgsdT1fPjA/YVswXS5yZXBsYWNlKGQsXCJcIik6XCJcIjtyZXR1cm4gXz9yPWU/ZnVuY3Rpb24odCl7dmFyIGUsYyxmLHA7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpdCs9dTtlbHNlIGlmKHMmJk0udGVzdCh0KSl7Zm9yKHA9dC5yZXBsYWNlKE0sXCJ8XCIpLnNwbGl0KFwifFwiKSxmPTA7cC5sZW5ndGg+ZjtmKyspcFtmXT1yKHBbZl0pO3JldHVybiBwLmpvaW4oXCIsXCIpfWlmKGU9KHQubWF0Y2godWUpfHxbbl0pWzBdLGM9dC5zcGxpdChlKS5qb2luKFwiXCIpLm1hdGNoKHYpfHxbXSxmPWMubGVuZ3RoLF8+Zi0tKWZvcig7Xz4rK2Y7KWNbZl09aT9jWzB8KGYtMSkvMl06YVtmXTtyZXR1cm4gbytjLmpvaW4oaCkraCtlK2wrKC0xIT09dC5pbmRleE9mKFwiaW5zZXRcIik/XCIgaW5zZXRcIjpcIlwiKX06ZnVuY3Rpb24odCl7dmFyIGUsbixjO2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0KXQrPXU7ZWxzZSBpZihzJiZNLnRlc3QodCkpe2ZvcihuPXQucmVwbGFjZShNLFwifFwiKS5zcGxpdChcInxcIiksYz0wO24ubGVuZ3RoPmM7YysrKW5bY109cihuW2NdKTtyZXR1cm4gbi5qb2luKFwiLFwiKX1pZihlPXQubWF0Y2godil8fFtdLGM9ZS5sZW5ndGgsXz5jLS0pZm9yKDtfPisrYzspZVtjXT1pP2VbMHwoYy0xKS8yXTphW2NdO3JldHVybiBvK2Uuam9pbihoKStsfTpmdW5jdGlvbih0KXtyZXR1cm4gdH19LGZlPWZ1bmN0aW9uKHQpe3JldHVybiB0PXQuc3BsaXQoXCIsXCIpLGZ1bmN0aW9uKGUsaSxzLHIsbixhLG8pe3ZhciBsLGg9KGkrXCJcIikuc3BsaXQoXCIgXCIpO2ZvcihvPXt9LGw9MDs0Pmw7bCsrKW9bdFtsXV09aFtsXT1oW2xdfHxoWyhsLTEpLzI+PjBdO3JldHVybiByLnBhcnNlKGUsbyxuLGEpfX0scGU9KEIuX3NldFBsdWdpblJhdGlvPWZ1bmN0aW9uKHQpe3RoaXMucGx1Z2luLnNldFJhdGlvKHQpO2Zvcih2YXIgZSxpLHMscixuPXRoaXMuZGF0YSxhPW4ucHJveHksbz1uLmZpcnN0TVBULGw9MWUtNjtvOyllPWFbby52XSxvLnI/ZT1NYXRoLnJvdW5kKGUpOmw+ZSYmZT4tbCYmKGU9MCksby50W28ucF09ZSxvPW8uX25leHQ7aWYobi5hdXRvUm90YXRlJiYobi5hdXRvUm90YXRlLnJvdGF0aW9uPWEucm90YXRpb24pLDE9PT10KWZvcihvPW4uZmlyc3RNUFQ7bzspe2lmKGk9by50LGkudHlwZSl7aWYoMT09PWkudHlwZSl7Zm9yKHI9aS54czAraS5zK2kueHMxLHM9MTtpLmw+cztzKyspcis9aVtcInhuXCIrc10raVtcInhzXCIrKHMrMSldO2kuZT1yfX1lbHNlIGkuZT1pLnMraS54czA7bz1vLl9uZXh0fX0sZnVuY3Rpb24odCxlLGkscyxyKXt0aGlzLnQ9dCx0aGlzLnA9ZSx0aGlzLnY9aSx0aGlzLnI9cixzJiYocy5fcHJldj10aGlzLHRoaXMuX25leHQ9cyl9KSxtZT0oQi5fcGFyc2VUb1Byb3h5PWZ1bmN0aW9uKHQsZSxpLHMscixuKXt2YXIgYSxvLGwsaCxfLHU9cyxjPXt9LGY9e30scD1pLl90cmFuc2Zvcm0sbT1JO2ZvcihpLl90cmFuc2Zvcm09bnVsbCxJPWUscz1fPWkucGFyc2UodCxlLHMsciksST1tLG4mJihpLl90cmFuc2Zvcm09cCx1JiYodS5fcHJldj1udWxsLHUuX3ByZXYmJih1Ll9wcmV2Ll9uZXh0PW51bGwpKSk7cyYmcyE9PXU7KXtpZigxPj1zLnR5cGUmJihvPXMucCxmW29dPXMucytzLmMsY1tvXT1zLnMsbnx8KGg9bmV3IHBlKHMsXCJzXCIsbyxoLHMucikscy5jPTApLDE9PT1zLnR5cGUpKWZvcihhPXMubDstLWE+MDspbD1cInhuXCIrYSxvPXMucCtcIl9cIitsLGZbb109cy5kYXRhW2xdLGNbb109c1tsXSxufHwoaD1uZXcgcGUocyxsLG8saCxzLnJ4cFtsXSkpO3M9cy5fbmV4dH1yZXR1cm57cHJveHk6YyxlbmQ6ZixmaXJzdE1QVDpoLHB0Ol99fSxCLkNTU1Byb3BUd2Vlbj1mdW5jdGlvbih0LGUscyxyLGEsbyxsLGgsXyx1LGMpe3RoaXMudD10LHRoaXMucD1lLHRoaXMucz1zLHRoaXMuYz1yLHRoaXMubj1sfHxlLHQgaW5zdGFuY2VvZiBtZXx8bi5wdXNoKHRoaXMubiksdGhpcy5yPWgsdGhpcy50eXBlPW98fDAsXyYmKHRoaXMucHI9XyxpPSEwKSx0aGlzLmI9dm9pZCAwPT09dT9zOnUsdGhpcy5lPXZvaWQgMD09PWM/cytyOmMsYSYmKHRoaXMuX25leHQ9YSxhLl9wcmV2PXRoaXMpfSksZGU9ZnVuY3Rpb24odCxlLGkscyxyLG4pe3ZhciBhPW5ldyBtZSh0LGUsaSxzLWksciwtMSxuKTtyZXR1cm4gYS5iPWksYS5lPWEueHMwPXMsYX0sZ2U9YS5wYXJzZUNvbXBsZXg9ZnVuY3Rpb24odCxlLGkscyxyLG4sYSxvLGwsaCl7aT1pfHxufHxcIlwiLGE9bmV3IG1lKHQsZSwwLDAsYSxoPzI6MSxudWxsLCExLG8saSxzKSxzKz1cIlwiO3ZhciB1LGMsZixwLG0sdix5LFQseCx3LGIsUCxrLFM9aS5zcGxpdChcIiwgXCIpLmpvaW4oXCIsXCIpLnNwbGl0KFwiIFwiKSxSPXMuc3BsaXQoXCIsIFwiKS5qb2luKFwiLFwiKS5zcGxpdChcIiBcIiksTz1TLmxlbmd0aCxBPV8hPT0hMTtmb3IoKC0xIT09cy5pbmRleE9mKFwiLFwiKXx8LTEhPT1pLmluZGV4T2YoXCIsXCIpKSYmKFM9Uy5qb2luKFwiIFwiKS5yZXBsYWNlKE0sXCIsIFwiKS5zcGxpdChcIiBcIiksUj1SLmpvaW4oXCIgXCIpLnJlcGxhY2UoTSxcIiwgXCIpLnNwbGl0KFwiIFwiKSxPPVMubGVuZ3RoKSxPIT09Ui5sZW5ndGgmJihTPShufHxcIlwiKS5zcGxpdChcIiBcIiksTz1TLmxlbmd0aCksYS5wbHVnaW49bCxhLnNldFJhdGlvPWgsdWUubGFzdEluZGV4PTAsdT0wO08+dTt1KyspaWYocD1TW3VdLG09Ult1XSxUPXBhcnNlRmxvYXQocCksVHx8MD09PVQpYS5hcHBlbmRYdHJhKFwiXCIsVCxyZShtLFQpLG0ucmVwbGFjZShnLFwiXCIpLEEmJi0xIT09bS5pbmRleE9mKFwicHhcIiksITApO2Vsc2UgaWYociYmdWUudGVzdChwKSlQPVwiLFwiPT09bS5jaGFyQXQobS5sZW5ndGgtMSk/XCIpLFwiOlwiKVwiLGs9LTEhPT1tLmluZGV4T2YoXCJoc2xcIikmJlkscD1oZShwLGspLG09aGUobSxrKSx4PXAubGVuZ3RoK20ubGVuZ3RoPjYseCYmIVkmJjA9PT1tWzNdPyhhW1wieHNcIithLmxdKz1hLmw/XCIgdHJhbnNwYXJlbnRcIjpcInRyYW5zcGFyZW50XCIsYS5lPWEuZS5zcGxpdChSW3VdKS5qb2luKFwidHJhbnNwYXJlbnRcIikpOihZfHwoeD0hMSksaz9hLmFwcGVuZFh0cmEoeD9cImhzbGEoXCI6XCJoc2woXCIscFswXSxyZShtWzBdLHBbMF0pLFwiLFwiLCExLCEwKS5hcHBlbmRYdHJhKFwiXCIscFsxXSxyZShtWzFdLHBbMV0pLFwiJSxcIiwhMSkuYXBwZW5kWHRyYShcIlwiLHBbMl0scmUobVsyXSxwWzJdKSx4P1wiJSxcIjpcIiVcIitQLCExKTphLmFwcGVuZFh0cmEoeD9cInJnYmEoXCI6XCJyZ2IoXCIscFswXSxtWzBdLXBbMF0sXCIsXCIsITAsITApLmFwcGVuZFh0cmEoXCJcIixwWzFdLG1bMV0tcFsxXSxcIixcIiwhMCkuYXBwZW5kWHRyYShcIlwiLHBbMl0sbVsyXS1wWzJdLHg/XCIsXCI6UCwhMCkseCYmKHA9ND5wLmxlbmd0aD8xOnBbM10sYS5hcHBlbmRYdHJhKFwiXCIscCwoND5tLmxlbmd0aD8xOm1bM10pLXAsUCwhMSkpKSx1ZS5sYXN0SW5kZXg9MDtlbHNlIGlmKHY9cC5tYXRjaChkKSl7aWYoeT1tLm1hdGNoKGcpLCF5fHx5Lmxlbmd0aCE9PXYubGVuZ3RoKXJldHVybiBhO2ZvcihmPTAsYz0wO3YubGVuZ3RoPmM7YysrKWI9dltjXSx3PXAuaW5kZXhPZihiLGYpLGEuYXBwZW5kWHRyYShwLnN1YnN0cihmLHctZiksTnVtYmVyKGIpLHJlKHlbY10sYiksXCJcIixBJiZcInB4XCI9PT1wLnN1YnN0cih3K2IubGVuZ3RoLDIpLDA9PT1jKSxmPXcrYi5sZW5ndGg7YVtcInhzXCIrYS5sXSs9cC5zdWJzdHIoZil9ZWxzZSBhW1wieHNcIithLmxdKz1hLmw/XCIgXCIrcDpwO2lmKC0xIT09cy5pbmRleE9mKFwiPVwiKSYmYS5kYXRhKXtmb3IoUD1hLnhzMCthLmRhdGEucyx1PTE7YS5sPnU7dSsrKVArPWFbXCJ4c1wiK3VdK2EuZGF0YVtcInhuXCIrdV07YS5lPVArYVtcInhzXCIrdV19cmV0dXJuIGEubHx8KGEudHlwZT0tMSxhLnhzMD1hLmUpLGEueGZpcnN0fHxhfSx2ZT05O2ZvcihoPW1lLnByb3RvdHlwZSxoLmw9aC5wcj0wOy0tdmU+MDspaFtcInhuXCIrdmVdPTAsaFtcInhzXCIrdmVdPVwiXCI7aC54czA9XCJcIixoLl9uZXh0PWguX3ByZXY9aC54Zmlyc3Q9aC5kYXRhPWgucGx1Z2luPWguc2V0UmF0aW89aC5yeHA9bnVsbCxoLmFwcGVuZFh0cmE9ZnVuY3Rpb24odCxlLGkscyxyLG4pe3ZhciBhPXRoaXMsbz1hLmw7cmV0dXJuIGFbXCJ4c1wiK29dKz1uJiZvP1wiIFwiK3Q6dHx8XCJcIixpfHwwPT09b3x8YS5wbHVnaW4/KGEubCsrLGEudHlwZT1hLnNldFJhdGlvPzI6MSxhW1wieHNcIithLmxdPXN8fFwiXCIsbz4wPyhhLmRhdGFbXCJ4blwiK29dPWUraSxhLnJ4cFtcInhuXCIrb109cixhW1wieG5cIitvXT1lLGEucGx1Z2lufHwoYS54Zmlyc3Q9bmV3IG1lKGEsXCJ4blwiK28sZSxpLGEueGZpcnN0fHxhLDAsYS5uLHIsYS5wciksYS54Zmlyc3QueHMwPTApLGEpOihhLmRhdGE9e3M6ZStpfSxhLnJ4cD17fSxhLnM9ZSxhLmM9aSxhLnI9cixhKSk6KGFbXCJ4c1wiK29dKz1lKyhzfHxcIlwiKSxhKX07dmFyIHllPWZ1bmN0aW9uKHQsZSl7ZT1lfHx7fSx0aGlzLnA9ZS5wcmVmaXg/Vyh0KXx8dDp0LGxbdF09bFt0aGlzLnBdPXRoaXMsdGhpcy5mb3JtYXQ9ZS5mb3JtYXR0ZXJ8fGNlKGUuZGVmYXVsdFZhbHVlLGUuY29sb3IsZS5jb2xsYXBzaWJsZSxlLm11bHRpKSxlLnBhcnNlciYmKHRoaXMucGFyc2U9ZS5wYXJzZXIpLHRoaXMuY2xycz1lLmNvbG9yLHRoaXMubXVsdGk9ZS5tdWx0aSx0aGlzLmtleXdvcmQ9ZS5rZXl3b3JkLHRoaXMuZGZsdD1lLmRlZmF1bHRWYWx1ZSx0aGlzLnByPWUucHJpb3JpdHl8fDB9LFRlPUIuX3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wPWZ1bmN0aW9uKHQsZSxpKXtcIm9iamVjdFwiIT10eXBlb2YgZSYmKGU9e3BhcnNlcjppfSk7dmFyIHMscixuPXQuc3BsaXQoXCIsXCIpLGE9ZS5kZWZhdWx0VmFsdWU7Zm9yKGk9aXx8W2FdLHM9MDtuLmxlbmd0aD5zO3MrKyllLnByZWZpeD0wPT09cyYmZS5wcmVmaXgsZS5kZWZhdWx0VmFsdWU9aVtzXXx8YSxyPW5ldyB5ZShuW3NdLGUpfSx4ZT1mdW5jdGlvbih0KXtpZighbFt0XSl7dmFyIGU9dC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSt0LnN1YnN0cigxKStcIlBsdWdpblwiO1RlKHQse3BhcnNlcjpmdW5jdGlvbih0LGkscyxyLG4sYSxoKXt2YXIgXz1vLmNvbS5ncmVlbnNvY2sucGx1Z2luc1tlXTtyZXR1cm4gXz8oXy5fY3NzUmVnaXN0ZXIoKSxsW3NdLnBhcnNlKHQsaSxzLHIsbixhLGgpKToocShcIkVycm9yOiBcIitlK1wiIGpzIGZpbGUgbm90IGxvYWRlZC5cIiksbil9fSl9fTtoPXllLnByb3RvdHlwZSxoLnBhcnNlQ29tcGxleD1mdW5jdGlvbih0LGUsaSxzLHIsbil7dmFyIGEsbyxsLGgsXyx1LGM9dGhpcy5rZXl3b3JkO2lmKHRoaXMubXVsdGkmJihNLnRlc3QoaSl8fE0udGVzdChlKT8obz1lLnJlcGxhY2UoTSxcInxcIikuc3BsaXQoXCJ8XCIpLGw9aS5yZXBsYWNlKE0sXCJ8XCIpLnNwbGl0KFwifFwiKSk6YyYmKG89W2VdLGw9W2ldKSksbCl7Zm9yKGg9bC5sZW5ndGg+by5sZW5ndGg/bC5sZW5ndGg6by5sZW5ndGgsYT0wO2g+YTthKyspZT1vW2FdPW9bYV18fHRoaXMuZGZsdCxpPWxbYV09bFthXXx8dGhpcy5kZmx0LGMmJihfPWUuaW5kZXhPZihjKSx1PWkuaW5kZXhPZihjKSxfIT09dSYmKC0xPT09dT9vW2FdPW9bYV0uc3BsaXQoYykuam9pbihcIlwiKTotMT09PV8mJihvW2FdKz1cIiBcIitjKSkpO2U9by5qb2luKFwiLCBcIiksaT1sLmpvaW4oXCIsIFwiKX1yZXR1cm4gZ2UodCx0aGlzLnAsZSxpLHRoaXMuY2xycyx0aGlzLmRmbHQscyx0aGlzLnByLHIsbil9LGgucGFyc2U9ZnVuY3Rpb24odCxlLGkscyxuLGEpe3JldHVybiB0aGlzLnBhcnNlQ29tcGxleCh0LnN0eWxlLHRoaXMuZm9ybWF0KFEodCx0aGlzLnAsciwhMSx0aGlzLmRmbHQpKSx0aGlzLmZvcm1hdChlKSxuLGEpfSxhLnJlZ2lzdGVyU3BlY2lhbFByb3A9ZnVuY3Rpb24odCxlLGkpe1RlKHQse3BhcnNlcjpmdW5jdGlvbih0LHMscixuLGEsbyl7dmFyIGw9bmV3IG1lKHQsciwwLDAsYSwyLHIsITEsaSk7cmV0dXJuIGwucGx1Z2luPW8sbC5zZXRSYXRpbz1lKHQscyxuLl90d2VlbixyKSxsfSxwcmlvcml0eTppfSl9LGEudXNlU1ZHVHJhbnNmb3JtQXR0cj1jfHxmO3ZhciB3ZSxiZT1cInNjYWxlWCxzY2FsZVksc2NhbGVaLHgseSx6LHNrZXdYLHNrZXdZLHJvdGF0aW9uLHJvdGF0aW9uWCxyb3RhdGlvblkscGVyc3BlY3RpdmUseFBlcmNlbnQseVBlcmNlbnRcIi5zcGxpdChcIixcIiksUGU9VyhcInRyYW5zZm9ybVwiKSxrZT1WK1widHJhbnNmb3JtXCIsU2U9VyhcInRyYW5zZm9ybU9yaWdpblwiKSxSZT1udWxsIT09VyhcInBlcnNwZWN0aXZlXCIpLE9lPUIuVHJhbnNmb3JtPWZ1bmN0aW9uKCl7dGhpcy5wZXJzcGVjdGl2ZT1wYXJzZUZsb2F0KGEuZGVmYXVsdFRyYW5zZm9ybVBlcnNwZWN0aXZlKXx8MCx0aGlzLmZvcmNlM0Q9YS5kZWZhdWx0Rm9yY2UzRCE9PSExJiZSZT9hLmRlZmF1bHRGb3JjZTNEfHxcImF1dG9cIjohMX0sQWU9d2luZG93LlNWR0VsZW1lbnQsQ2U9ZnVuY3Rpb24odCxlLGkpe3ZhciBzLHI9RS5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLHQpLG49LyhbYS16XSkoW0EtWl0pL2c7Zm9yKHMgaW4gaSlyLnNldEF0dHJpYnV0ZU5TKG51bGwscy5yZXBsYWNlKG4sXCIkMS0kMlwiKS50b0xvd2VyQ2FzZSgpLGlbc10pO3JldHVybiBlLmFwcGVuZENoaWxkKHIpLHJ9LERlPUUuZG9jdW1lbnRFbGVtZW50LE1lPWZ1bmN0aW9uKCl7dmFyIHQsZSxpLHM9bXx8L0FuZHJvaWQvaS50ZXN0KGopJiYhd2luZG93LmNocm9tZTtyZXR1cm4gRS5jcmVhdGVFbGVtZW50TlMmJiFzJiYodD1DZShcInN2Z1wiLERlKSxlPUNlKFwicmVjdFwiLHQse3dpZHRoOjEwMCxoZWlnaHQ6NTAseDoxMDB9KSxpPWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgsZS5zdHlsZVtTZV09XCI1MCUgNTAlXCIsZS5zdHlsZVtQZV09XCJzY2FsZVgoMC41KVwiLHM9aT09PWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgmJiEoZiYmUmUpLERlLnJlbW92ZUNoaWxkKHQpKSxzfSgpLHplPWZ1bmN0aW9uKHQsZSxpLHMscil7dmFyIG4sbyxsLGgsXyx1LGMsZixwLG0sZCxnLHYseSxUPXQuX2dzVHJhbnNmb3JtLHg9RWUodCwhMCk7VCYmKHY9VC54T3JpZ2luLHk9VC55T3JpZ2luKSwoIXN8fDI+KG49cy5zcGxpdChcIiBcIikpLmxlbmd0aCkmJihjPXQuZ2V0QkJveCgpLGU9c2UoZSkuc3BsaXQoXCIgXCIpLG49WygtMSE9PWVbMF0uaW5kZXhPZihcIiVcIik/cGFyc2VGbG9hdChlWzBdKS8xMDAqYy53aWR0aDpwYXJzZUZsb2F0KGVbMF0pKStjLngsKC0xIT09ZVsxXS5pbmRleE9mKFwiJVwiKT9wYXJzZUZsb2F0KGVbMV0pLzEwMCpjLmhlaWdodDpwYXJzZUZsb2F0KGVbMV0pKStjLnldKSxpLnhPcmlnaW49aD1wYXJzZUZsb2F0KG5bMF0pLGkueU9yaWdpbj1fPXBhcnNlRmxvYXQoblsxXSkscyYmeCE9PUllJiYodT14WzBdLGM9eFsxXSxmPXhbMl0scD14WzNdLG09eFs0XSxkPXhbNV0sZz11KnAtYypmLG89aCoocC9nKStfKigtZi9nKSsoZipkLXAqbSkvZyxsPWgqKC1jL2cpK18qKHUvZyktKHUqZC1jKm0pL2csaD1pLnhPcmlnaW49blswXT1vLF89aS55T3JpZ2luPW5bMV09bCksVCYmKHJ8fHIhPT0hMSYmYS5kZWZhdWx0U21vb3RoT3JpZ2luIT09ITE/KG89aC12LGw9Xy15LFQueE9mZnNldCs9byp4WzBdK2wqeFsyXS1vLFQueU9mZnNldCs9byp4WzFdK2wqeFszXS1sKTpULnhPZmZzZXQ9VC55T2Zmc2V0PTApLHQuc2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIsbi5qb2luKFwiIFwiKSl9LEZlPWZ1bmN0aW9uKHQpe3JldHVybiEhKEFlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LmdldEJCb3gmJnQuZ2V0Q1RNJiYoIXQucGFyZW50Tm9kZXx8dC5wYXJlbnROb2RlLmdldEJCb3gmJnQucGFyZW50Tm9kZS5nZXRDVE0pKX0sSWU9WzEsMCwwLDEsMCwwXSxFZT1mdW5jdGlvbih0LGUpe3ZhciBpLHMscixuLGEsbz10Ll9nc1RyYW5zZm9ybXx8bmV3IE9lLGw9MWU1O2lmKFBlP3M9USh0LGtlLG51bGwsITApOnQuY3VycmVudFN0eWxlJiYocz10LmN1cnJlbnRTdHlsZS5maWx0ZXIubWF0Y2goQykscz1zJiY0PT09cy5sZW5ndGg/W3NbMF0uc3Vic3RyKDQpLE51bWJlcihzWzJdLnN1YnN0cig0KSksTnVtYmVyKHNbMV0uc3Vic3RyKDQpKSxzWzNdLnN1YnN0cig0KSxvLnh8fDAsby55fHwwXS5qb2luKFwiLFwiKTpcIlwiKSxpPSFzfHxcIm5vbmVcIj09PXN8fFwibWF0cml4KDEsIDAsIDAsIDEsIDAsIDApXCI9PT1zLChvLnN2Z3x8dC5nZXRCQm94JiZGZSh0KSkmJihpJiYtMSE9PSh0LnN0eWxlW1BlXStcIlwiKS5pbmRleE9mKFwibWF0cml4XCIpJiYocz10LnN0eWxlW1BlXSxpPTApLHI9dC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiksaSYmciYmKC0xIT09ci5pbmRleE9mKFwibWF0cml4XCIpPyhzPXIsaT0wKTotMSE9PXIuaW5kZXhPZihcInRyYW5zbGF0ZVwiKSYmKHM9XCJtYXRyaXgoMSwwLDAsMSxcIityLm1hdGNoKC8oPzpcXC18XFxiKVtcXGRcXC1cXC5lXStcXGIvZ2kpLmpvaW4oXCIsXCIpK1wiKVwiLGk9MCkpKSxpKXJldHVybiBJZTtmb3Iocj0oc3x8XCJcIikubWF0Y2goLyg/OlxcLXxcXGIpW1xcZFxcLVxcLmVdK1xcYi9naSl8fFtdLHZlPXIubGVuZ3RoOy0tdmU+LTE7KW49TnVtYmVyKHJbdmVdKSxyW3ZlXT0oYT1uLShufD0wKSk/KDB8YSpsKygwPmE/LS41Oi41KSkvbCtuOm47cmV0dXJuIGUmJnIubGVuZ3RoPjY/W3JbMF0sclsxXSxyWzRdLHJbNV0sclsxMl0sclsxM11dOnJ9LE5lPUIuZ2V0VHJhbnNmb3JtPWZ1bmN0aW9uKHQsaSxzLG4pe2lmKHQuX2dzVHJhbnNmb3JtJiZzJiYhbilyZXR1cm4gdC5fZ3NUcmFuc2Zvcm07dmFyIG8sbCxoLF8sdSxjLGY9cz90Ll9nc1RyYW5zZm9ybXx8bmV3IE9lOm5ldyBPZSxwPTA+Zi5zY2FsZVgsbT0yZS01LGQ9MWU1LGc9UmU/cGFyc2VGbG9hdChRKHQsU2UsaSwhMSxcIjAgMCAwXCIpLnNwbGl0KFwiIFwiKVsyXSl8fGYuek9yaWdpbnx8MDowLHY9cGFyc2VGbG9hdChhLmRlZmF1bHRUcmFuc2Zvcm1QZXJzcGVjdGl2ZSl8fDA7aWYoZi5zdmc9ISghdC5nZXRCQm94fHwhRmUodCkpLGYuc3ZnJiYoemUodCxRKHQsU2UsciwhMSxcIjUwJSA1MCVcIikrXCJcIixmLHQuZ2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIpKSx3ZT1hLnVzZVNWR1RyYW5zZm9ybUF0dHJ8fE1lKSxvPUVlKHQpLG8hPT1JZSl7aWYoMTY9PT1vLmxlbmd0aCl7dmFyIHksVCx4LHcsYixQPW9bMF0saz1vWzFdLFM9b1syXSxSPW9bM10sTz1vWzRdLEE9b1s1XSxDPW9bNl0sRD1vWzddLE09b1s4XSx6PW9bOV0sST1vWzEwXSxFPW9bMTJdLE49b1sxM10sTD1vWzE0XSxYPW9bMTFdLEI9TWF0aC5hdGFuMihDLEkpO2Yuek9yaWdpbiYmKEw9LWYuek9yaWdpbixFPU0qTC1vWzEyXSxOPXoqTC1vWzEzXSxMPUkqTCtmLnpPcmlnaW4tb1sxNF0pLGYucm90YXRpb25YPUIqRixCJiYodz1NYXRoLmNvcygtQiksYj1NYXRoLnNpbigtQikseT1PKncrTSpiLFQ9QSp3K3oqYix4PUMqdytJKmIsTT1PKi1iK00qdyx6PUEqLWIreip3LEk9QyotYitJKncsWD1EKi1iK1gqdyxPPXksQT1ULEM9eCksQj1NYXRoLmF0YW4yKE0sSSksZi5yb3RhdGlvblk9QipGLEImJih3PU1hdGguY29zKC1CKSxiPU1hdGguc2luKC1CKSx5PVAqdy1NKmIsVD1rKncteipiLHg9Uyp3LUkqYix6PWsqYit6KncsST1TKmIrSSp3LFg9UipiK1gqdyxQPXksaz1ULFM9eCksQj1NYXRoLmF0YW4yKGssUCksZi5yb3RhdGlvbj1CKkYsQiYmKHc9TWF0aC5jb3MoLUIpLGI9TWF0aC5zaW4oLUIpLFA9UCp3K08qYixUPWsqdytBKmIsQT1rKi1iK0EqdyxDPVMqLWIrQyp3LGs9VCksZi5yb3RhdGlvblgmJk1hdGguYWJzKGYucm90YXRpb25YKStNYXRoLmFicyhmLnJvdGF0aW9uKT4zNTkuOSYmKGYucm90YXRpb25YPWYucm90YXRpb249MCxmLnJvdGF0aW9uWSs9MTgwKSxmLnNjYWxlWD0oMHxNYXRoLnNxcnQoUCpQK2sqaykqZCsuNSkvZCxmLnNjYWxlWT0oMHxNYXRoLnNxcnQoQSpBK3oqeikqZCsuNSkvZCxmLnNjYWxlWj0oMHxNYXRoLnNxcnQoQypDK0kqSSkqZCsuNSkvZCxmLnNrZXdYPTAsZi5wZXJzcGVjdGl2ZT1YPzEvKDA+WD8tWDpYKTowLGYueD1FLGYueT1OLGYuej1MLGYuc3ZnJiYoZi54LT1mLnhPcmlnaW4tKGYueE9yaWdpbipQLWYueU9yaWdpbipPKSxmLnktPWYueU9yaWdpbi0oZi55T3JpZ2luKmstZi54T3JpZ2luKkEpKX1lbHNlIGlmKCEoUmUmJiFuJiZvLmxlbmd0aCYmZi54PT09b1s0XSYmZi55PT09b1s1XSYmKGYucm90YXRpb25YfHxmLnJvdGF0aW9uWSl8fHZvaWQgMCE9PWYueCYmXCJub25lXCI9PT1RKHQsXCJkaXNwbGF5XCIsaSkpKXt2YXIgaj1vLmxlbmd0aD49NixZPWo/b1swXToxLFU9b1sxXXx8MCxxPW9bMl18fDAsVj1qP29bM106MTtmLng9b1s0XXx8MCxmLnk9b1s1XXx8MCxoPU1hdGguc3FydChZKlkrVSpVKSxfPU1hdGguc3FydChWKlYrcSpxKSx1PVl8fFU/TWF0aC5hdGFuMihVLFkpKkY6Zi5yb3RhdGlvbnx8MCxjPXF8fFY/TWF0aC5hdGFuMihxLFYpKkYrdTpmLnNrZXdYfHwwLE1hdGguYWJzKGMpPjkwJiYyNzA+TWF0aC5hYnMoYykmJihwPyhoKj0tMSxjKz0wPj11PzE4MDotMTgwLHUrPTA+PXU/MTgwOi0xODApOihfKj0tMSxjKz0wPj1jPzE4MDotMTgwKSksZi5zY2FsZVg9aCxmLnNjYWxlWT1fLGYucm90YXRpb249dSxmLnNrZXdYPWMsUmUmJihmLnJvdGF0aW9uWD1mLnJvdGF0aW9uWT1mLno9MCxmLnBlcnNwZWN0aXZlPXYsZi5zY2FsZVo9MSksZi5zdmcmJihmLngtPWYueE9yaWdpbi0oZi54T3JpZ2luKlkrZi55T3JpZ2luKnEpLGYueS09Zi55T3JpZ2luLShmLnhPcmlnaW4qVStmLnlPcmlnaW4qVikpfWYuek9yaWdpbj1nO2ZvcihsIGluIGYpbT5mW2xdJiZmW2xdPi1tJiYoZltsXT0wKX1yZXR1cm4gcyYmKHQuX2dzVHJhbnNmb3JtPWYsZi5zdmcmJih3ZSYmdC5zdHlsZVtQZV0/ZS5kZWxheWVkQ2FsbCguMDAxLGZ1bmN0aW9uKCl7amUodC5zdHlsZSxQZSl9KTohd2UmJnQuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpJiZlLmRlbGF5ZWRDYWxsKC4wMDEsZnVuY3Rpb24oKXt0LnJlbW92ZUF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKX0pKSksZn0sTGU9ZnVuY3Rpb24odCl7dmFyIGUsaSxzPXRoaXMuZGF0YSxyPS1zLnJvdGF0aW9uKnosbj1yK3Muc2tld1gqeixhPTFlNSxvPSgwfE1hdGguY29zKHIpKnMuc2NhbGVYKmEpL2EsbD0oMHxNYXRoLnNpbihyKSpzLnNjYWxlWCphKS9hLGg9KDB8TWF0aC5zaW4obikqLXMuc2NhbGVZKmEpL2EsXz0oMHxNYXRoLmNvcyhuKSpzLnNjYWxlWSphKS9hLHU9dGhpcy50LnN0eWxlLGM9dGhpcy50LmN1cnJlbnRTdHlsZTtpZihjKXtpPWwsbD0taCxoPS1pLGU9Yy5maWx0ZXIsdS5maWx0ZXI9XCJcIjt2YXIgZixwLGQ9dGhpcy50Lm9mZnNldFdpZHRoLGc9dGhpcy50Lm9mZnNldEhlaWdodCx2PVwiYWJzb2x1dGVcIiE9PWMucG9zaXRpb24seT1cInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoTTExPVwiK28rXCIsIE0xMj1cIitsK1wiLCBNMjE9XCIraCtcIiwgTTIyPVwiK18sdz1zLngrZCpzLnhQZXJjZW50LzEwMCxiPXMueStnKnMueVBlcmNlbnQvMTAwO2lmKG51bGwhPXMub3gmJihmPShzLm94cD8uMDEqZCpzLm94OnMub3gpLWQvMixwPShzLm95cD8uMDEqZypzLm95OnMub3kpLWcvMix3Kz1mLShmKm8rcCpsKSxiKz1wLShmKmgrcCpfKSksdj8oZj1kLzIscD1nLzIseSs9XCIsIER4PVwiKyhmLShmKm8rcCpsKSt3KStcIiwgRHk9XCIrKHAtKGYqaCtwKl8pK2IpK1wiKVwiKTp5Kz1cIiwgc2l6aW5nTWV0aG9kPSdhdXRvIGV4cGFuZCcpXCIsdS5maWx0ZXI9LTEhPT1lLmluZGV4T2YoXCJEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoXCIpP2UucmVwbGFjZShELHkpOnkrXCIgXCIrZSwoMD09PXR8fDE9PT10KSYmMT09PW8mJjA9PT1sJiYwPT09aCYmMT09PV8mJih2JiYtMT09PXkuaW5kZXhPZihcIkR4PTAsIER5PTBcIil8fHgudGVzdChlKSYmMTAwIT09cGFyc2VGbG9hdChSZWdFeHAuJDEpfHwtMT09PWUuaW5kZXhPZihcImdyYWRpZW50KFwiJiZlLmluZGV4T2YoXCJBbHBoYVwiKSkmJnUucmVtb3ZlQXR0cmlidXRlKFwiZmlsdGVyXCIpKSwhdil7dmFyIFAsayxTLFI9OD5tPzE6LTE7Zm9yKGY9cy5pZU9mZnNldFh8fDAscD1zLmllT2Zmc2V0WXx8MCxzLmllT2Zmc2V0WD1NYXRoLnJvdW5kKChkLSgoMD5vPy1vOm8pKmQrKDA+bD8tbDpsKSpnKSkvMit3KSxzLmllT2Zmc2V0WT1NYXRoLnJvdW5kKChnLSgoMD5fPy1fOl8pKmcrKDA+aD8taDpoKSpkKSkvMitiKSx2ZT0wOzQ+dmU7dmUrKylrPWVlW3ZlXSxQPWNba10saT0tMSE9PVAuaW5kZXhPZihcInB4XCIpP3BhcnNlRmxvYXQoUCk6JCh0aGlzLnQsayxwYXJzZUZsb2F0KFApLFAucmVwbGFjZShULFwiXCIpKXx8MCxTPWkhPT1zW2tdPzI+dmU/LXMuaWVPZmZzZXRYOi1zLmllT2Zmc2V0WToyPnZlP2Ytcy5pZU9mZnNldFg6cC1zLmllT2Zmc2V0WSx1W2tdPShzW2tdPU1hdGgucm91bmQoaS1TKigwPT09dmV8fDI9PT12ZT8xOlIpKSkrXCJweFwifX19LFhlPUIuc2V0M0RUcmFuc2Zvcm1SYXRpbz1CLnNldFRyYW5zZm9ybVJhdGlvPWZ1bmN0aW9uKHQpe3ZhciBlLGkscyxyLG4sYSxvLGwsaCxfLHUsYyxwLG0sZCxnLHYseSxULHgsdyxiLFAsaz10aGlzLmRhdGEsUz10aGlzLnQuc3R5bGUsUj1rLnJvdGF0aW9uLE89ay5yb3RhdGlvblgsQT1rLnJvdGF0aW9uWSxDPWsuc2NhbGVYLEQ9ay5zY2FsZVksTT1rLnNjYWxlWixGPWsueCxJPWsueSxFPWsueixOPWsuc3ZnLEw9ay5wZXJzcGVjdGl2ZSxYPWsuZm9yY2UzRDtpZighKCgoMSE9PXQmJjAhPT10fHxcImF1dG9cIiE9PVh8fHRoaXMudHdlZW4uX3RvdGFsVGltZSE9PXRoaXMudHdlZW4uX3RvdGFsRHVyYXRpb24mJnRoaXMudHdlZW4uX3RvdGFsVGltZSkmJlh8fEV8fEx8fEF8fE8pJiYoIXdlfHwhTikmJlJlKSlyZXR1cm4gUnx8ay5za2V3WHx8Tj8oUio9eixiPWsuc2tld1gqeixQPTFlNSxlPU1hdGguY29zKFIpKkMscj1NYXRoLnNpbihSKSpDLGk9TWF0aC5zaW4oUi1iKSotRCxuPU1hdGguY29zKFItYikqRCxiJiZcInNpbXBsZVwiPT09ay5za2V3VHlwZSYmKHY9TWF0aC50YW4oYiksdj1NYXRoLnNxcnQoMSt2KnYpLGkqPXYsbio9dixrLnNrZXdZJiYoZSo9dixyKj12KSksTiYmKEYrPWsueE9yaWdpbi0oay54T3JpZ2luKmUray55T3JpZ2luKmkpK2sueE9mZnNldCxJKz1rLnlPcmlnaW4tKGsueE9yaWdpbipyK2sueU9yaWdpbipuKStrLnlPZmZzZXQsd2UmJihrLnhQZXJjZW50fHxrLnlQZXJjZW50KSYmKG09dGhpcy50LmdldEJCb3goKSxGKz0uMDEqay54UGVyY2VudCptLndpZHRoLEkrPS4wMSprLnlQZXJjZW50Km0uaGVpZ2h0KSxtPTFlLTYsbT5GJiZGPi1tJiYoRj0wKSxtPkkmJkk+LW0mJihJPTApKSxUPSgwfGUqUCkvUCtcIixcIisoMHxyKlApL1ArXCIsXCIrKDB8aSpQKS9QK1wiLFwiKygwfG4qUCkvUCtcIixcIitGK1wiLFwiK0krXCIpXCIsTiYmd2U/dGhpcy50LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLFwibWF0cml4KFwiK1QpOlNbUGVdPShrLnhQZXJjZW50fHxrLnlQZXJjZW50P1widHJhbnNsYXRlKFwiK2sueFBlcmNlbnQrXCIlLFwiK2sueVBlcmNlbnQrXCIlKSBtYXRyaXgoXCI6XCJtYXRyaXgoXCIpK1QpOlNbUGVdPShrLnhQZXJjZW50fHxrLnlQZXJjZW50P1widHJhbnNsYXRlKFwiK2sueFBlcmNlbnQrXCIlLFwiK2sueVBlcmNlbnQrXCIlKSBtYXRyaXgoXCI6XCJtYXRyaXgoXCIpK0MrXCIsMCwwLFwiK0QrXCIsXCIrRitcIixcIitJK1wiKVwiLHZvaWQgMDtpZihmJiYobT0xZS00LG0+QyYmQz4tbSYmKEM9TT0yZS01KSxtPkQmJkQ+LW0mJihEPU09MmUtNSksIUx8fGsuenx8ay5yb3RhdGlvblh8fGsucm90YXRpb25ZfHwoTD0wKSksUnx8ay5za2V3WClSKj16LGQ9ZT1NYXRoLmNvcyhSKSxnPXI9TWF0aC5zaW4oUiksay5za2V3WCYmKFItPWsuc2tld1gqeixkPU1hdGguY29zKFIpLGc9TWF0aC5zaW4oUiksXCJzaW1wbGVcIj09PWsuc2tld1R5cGUmJih2PU1hdGgudGFuKGsuc2tld1gqeiksdj1NYXRoLnNxcnQoMSt2KnYpLGQqPXYsZyo9dixrLnNrZXdZJiYoZSo9dixyKj12KSkpLGk9LWcsbj1kO2Vsc2V7aWYoIShBfHxPfHwxIT09TXx8THx8TikpcmV0dXJuIFNbUGVdPShrLnhQZXJjZW50fHxrLnlQZXJjZW50P1widHJhbnNsYXRlKFwiK2sueFBlcmNlbnQrXCIlLFwiK2sueVBlcmNlbnQrXCIlKSB0cmFuc2xhdGUzZChcIjpcInRyYW5zbGF0ZTNkKFwiKStGK1wicHgsXCIrSStcInB4LFwiK0UrXCJweClcIisoMSE9PUN8fDEhPT1EP1wiIHNjYWxlKFwiK0MrXCIsXCIrRCtcIilcIjpcIlwiKSx2b2lkIDA7ZT1uPTEsaT1yPTB9aD0xLHM9YT1vPWw9Xz11PTAsYz1MPy0xL0w6MCxwPWsuek9yaWdpbixtPTFlLTYseD1cIixcIix3PVwiMFwiLFI9QSp6LFImJihkPU1hdGguY29zKFIpLGc9TWF0aC5zaW4oUiksbz0tZyxfPWMqLWcscz1lKmcsYT1yKmcsaD1kLGMqPWQsZSo9ZCxyKj1kKSxSPU8qeixSJiYoZD1NYXRoLmNvcyhSKSxnPU1hdGguc2luKFIpLHY9aSpkK3MqZyx5PW4qZCthKmcsbD1oKmcsdT1jKmcscz1pKi1nK3MqZCxhPW4qLWcrYSpkLGgqPWQsYyo9ZCxpPXYsbj15KSwxIT09TSYmKHMqPU0sYSo9TSxoKj1NLGMqPU0pLDEhPT1EJiYoaSo9RCxuKj1ELGwqPUQsdSo9RCksMSE9PUMmJihlKj1DLHIqPUMsbyo9QyxfKj1DKSwocHx8TikmJihwJiYoRis9cyotcCxJKz1hKi1wLEUrPWgqLXArcCksTiYmKEYrPWsueE9yaWdpbi0oay54T3JpZ2luKmUray55T3JpZ2luKmkpK2sueE9mZnNldCxJKz1rLnlPcmlnaW4tKGsueE9yaWdpbipyK2sueU9yaWdpbipuKStrLnlPZmZzZXQpLG0+RiYmRj4tbSYmKEY9dyksbT5JJiZJPi1tJiYoST13KSxtPkUmJkU+LW0mJihFPTApKSxUPWsueFBlcmNlbnR8fGsueVBlcmNlbnQ/XCJ0cmFuc2xhdGUoXCIray54UGVyY2VudCtcIiUsXCIray55UGVyY2VudCtcIiUpIG1hdHJpeDNkKFwiOlwibWF0cml4M2QoXCIsVCs9KG0+ZSYmZT4tbT93OmUpK3grKG0+ciYmcj4tbT93OnIpK3grKG0+byYmbz4tbT93Om8pLFQrPXgrKG0+XyYmXz4tbT93Ol8pK3grKG0+aSYmaT4tbT93OmkpK3grKG0+biYmbj4tbT93Om4pLE98fEE/KFQrPXgrKG0+bCYmbD4tbT93OmwpK3grKG0+dSYmdT4tbT93OnUpK3grKG0+cyYmcz4tbT93OnMpLFQrPXgrKG0+YSYmYT4tbT93OmEpK3grKG0+aCYmaD4tbT93OmgpK3grKG0+YyYmYz4tbT93OmMpK3gpOlQrPVwiLDAsMCwwLDAsMSwwLFwiLFQrPUYreCtJK3grRSt4KyhMPzErLUUvTDoxKStcIilcIixTW1BlXT1UfTtoPU9lLnByb3RvdHlwZSxoLng9aC55PWguej1oLnNrZXdYPWguc2tld1k9aC5yb3RhdGlvbj1oLnJvdGF0aW9uWD1oLnJvdGF0aW9uWT1oLnpPcmlnaW49aC54UGVyY2VudD1oLnlQZXJjZW50PWgueE9mZnNldD1oLnlPZmZzZXQ9MCxoLnNjYWxlWD1oLnNjYWxlWT1oLnNjYWxlWj0xLFRlKFwidHJhbnNmb3JtLHNjYWxlLHNjYWxlWCxzY2FsZVksc2NhbGVaLHgseSx6LHJvdGF0aW9uLHJvdGF0aW9uWCxyb3RhdGlvblkscm90YXRpb25aLHNrZXdYLHNrZXdZLHNob3J0Um90YXRpb24sc2hvcnRSb3RhdGlvblgsc2hvcnRSb3RhdGlvblksc2hvcnRSb3RhdGlvblosdHJhbnNmb3JtT3JpZ2luLHN2Z09yaWdpbix0cmFuc2Zvcm1QZXJzcGVjdGl2ZSxkaXJlY3Rpb25hbFJvdGF0aW9uLHBhcnNlVHJhbnNmb3JtLGZvcmNlM0Qsc2tld1R5cGUseFBlcmNlbnQseVBlcmNlbnQsc21vb3RoT3JpZ2luXCIse3BhcnNlcjpmdW5jdGlvbih0LGUsaSxzLG4sbyxsKXtpZihzLl9sYXN0UGFyc2VkVHJhbnNmb3JtPT09bClyZXR1cm4gbjtzLl9sYXN0UGFyc2VkVHJhbnNmb3JtPWw7dmFyIGgsXyx1LGMsZixwLG0sZCxnLHYseT10Ll9nc1RyYW5zZm9ybSxUPXQuc3R5bGUseD0xZS02LHc9YmUubGVuZ3RoLGI9bCxQPXt9LGs9XCJ0cmFuc2Zvcm1PcmlnaW5cIjtpZihsLmRpc3BsYXk/KGM9USh0LFwiZGlzcGxheVwiKSxULmRpc3BsYXk9XCJibG9ja1wiLGg9TmUodCxyLCEwLGwucGFyc2VUcmFuc2Zvcm0pLFQuZGlzcGxheT1jKTpoPU5lKHQsciwhMCxsLnBhcnNlVHJhbnNmb3JtKSxzLl90cmFuc2Zvcm09aCxcInN0cmluZ1wiPT10eXBlb2YgYi50cmFuc2Zvcm0mJlBlKWM9TC5zdHlsZSxjW1BlXT1iLnRyYW5zZm9ybSxjLmRpc3BsYXk9XCJibG9ja1wiLGMucG9zaXRpb249XCJhYnNvbHV0ZVwiLEUuYm9keS5hcHBlbmRDaGlsZChMKSxfPU5lKEwsbnVsbCwhMSksRS5ib2R5LnJlbW92ZUNoaWxkKEwpLF8ucGVyc3BlY3RpdmV8fChfLnBlcnNwZWN0aXZlPWgucGVyc3BlY3RpdmUpLG51bGwhPWIueFBlcmNlbnQmJihfLnhQZXJjZW50PW5lKGIueFBlcmNlbnQsaC54UGVyY2VudCkpLG51bGwhPWIueVBlcmNlbnQmJihfLnlQZXJjZW50PW5lKGIueVBlcmNlbnQsaC55UGVyY2VudCkpO2Vsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIGIpe2lmKF89e3NjYWxlWDpuZShudWxsIT1iLnNjYWxlWD9iLnNjYWxlWDpiLnNjYWxlLGguc2NhbGVYKSxzY2FsZVk6bmUobnVsbCE9Yi5zY2FsZVk/Yi5zY2FsZVk6Yi5zY2FsZSxoLnNjYWxlWSksc2NhbGVaOm5lKGIuc2NhbGVaLGguc2NhbGVaKSx4Om5lKGIueCxoLngpLHk6bmUoYi55LGgueSksejpuZShiLnosaC56KSx4UGVyY2VudDpuZShiLnhQZXJjZW50LGgueFBlcmNlbnQpLHlQZXJjZW50Om5lKGIueVBlcmNlbnQsaC55UGVyY2VudCkscGVyc3BlY3RpdmU6bmUoYi50cmFuc2Zvcm1QZXJzcGVjdGl2ZSxoLnBlcnNwZWN0aXZlKX0sZD1iLmRpcmVjdGlvbmFsUm90YXRpb24sbnVsbCE9ZClpZihcIm9iamVjdFwiPT10eXBlb2YgZClmb3IoYyBpbiBkKWJbY109ZFtjXTtlbHNlIGIucm90YXRpb249ZDtcInN0cmluZ1wiPT10eXBlb2YgYi54JiYtMSE9PWIueC5pbmRleE9mKFwiJVwiKSYmKF8ueD0wLF8ueFBlcmNlbnQ9bmUoYi54LGgueFBlcmNlbnQpKSxcInN0cmluZ1wiPT10eXBlb2YgYi55JiYtMSE9PWIueS5pbmRleE9mKFwiJVwiKSYmKF8ueT0wLF8ueVBlcmNlbnQ9bmUoYi55LGgueVBlcmNlbnQpKSxfLnJvdGF0aW9uPWFlKFwicm90YXRpb25cImluIGI/Yi5yb3RhdGlvbjpcInNob3J0Um90YXRpb25cImluIGI/Yi5zaG9ydFJvdGF0aW9uK1wiX3Nob3J0XCI6XCJyb3RhdGlvblpcImluIGI/Yi5yb3RhdGlvblo6aC5yb3RhdGlvbixoLnJvdGF0aW9uLFwicm90YXRpb25cIixQKSxSZSYmKF8ucm90YXRpb25YPWFlKFwicm90YXRpb25YXCJpbiBiP2Iucm90YXRpb25YOlwic2hvcnRSb3RhdGlvblhcImluIGI/Yi5zaG9ydFJvdGF0aW9uWCtcIl9zaG9ydFwiOmgucm90YXRpb25YfHwwLGgucm90YXRpb25YLFwicm90YXRpb25YXCIsUCksXy5yb3RhdGlvblk9YWUoXCJyb3RhdGlvbllcImluIGI/Yi5yb3RhdGlvblk6XCJzaG9ydFJvdGF0aW9uWVwiaW4gYj9iLnNob3J0Um90YXRpb25ZK1wiX3Nob3J0XCI6aC5yb3RhdGlvbll8fDAsaC5yb3RhdGlvblksXCJyb3RhdGlvbllcIixQKSksXy5za2V3WD1udWxsPT1iLnNrZXdYP2guc2tld1g6YWUoYi5za2V3WCxoLnNrZXdYKSxfLnNrZXdZPW51bGw9PWIuc2tld1k/aC5za2V3WTphZShiLnNrZXdZLGguc2tld1kpLCh1PV8uc2tld1ktaC5za2V3WSkmJihfLnNrZXdYKz11LF8ucm90YXRpb24rPXUpfWZvcihSZSYmbnVsbCE9Yi5mb3JjZTNEJiYoaC5mb3JjZTNEPWIuZm9yY2UzRCxtPSEwKSxoLnNrZXdUeXBlPWIuc2tld1R5cGV8fGguc2tld1R5cGV8fGEuZGVmYXVsdFNrZXdUeXBlLHA9aC5mb3JjZTNEfHxoLnp8fGgucm90YXRpb25YfHxoLnJvdGF0aW9uWXx8Xy56fHxfLnJvdGF0aW9uWHx8Xy5yb3RhdGlvbll8fF8ucGVyc3BlY3RpdmUscHx8bnVsbD09Yi5zY2FsZXx8KF8uc2NhbGVaPTEpOy0tdz4tMTspaT1iZVt3XSxmPV9baV0taFtpXSwoZj54fHwteD5mfHxudWxsIT1iW2ldfHxudWxsIT1JW2ldKSYmKG09ITAsbj1uZXcgbWUoaCxpLGhbaV0sZixuKSxpIGluIFAmJihuLmU9UFtpXSksbi54czA9MCxuLnBsdWdpbj1vLHMuX292ZXJ3cml0ZVByb3BzLnB1c2gobi5uKSk7cmV0dXJuIGY9Yi50cmFuc2Zvcm1PcmlnaW4saC5zdmcmJihmfHxiLnN2Z09yaWdpbikmJihnPWgueE9mZnNldCx2PWgueU9mZnNldCx6ZSh0LHNlKGYpLF8sYi5zdmdPcmlnaW4sYi5zbW9vdGhPcmlnaW4pLG49ZGUoaCxcInhPcmlnaW5cIiwoeT9oOl8pLnhPcmlnaW4sXy54T3JpZ2luLG4sayksbj1kZShoLFwieU9yaWdpblwiLCh5P2g6XykueU9yaWdpbixfLnlPcmlnaW4sbixrKSwoZyE9PWgueE9mZnNldHx8diE9PWgueU9mZnNldCkmJihuPWRlKGgsXCJ4T2Zmc2V0XCIseT9nOmgueE9mZnNldCxoLnhPZmZzZXQsbixrKSxuPWRlKGgsXCJ5T2Zmc2V0XCIseT92OmgueU9mZnNldCxoLnlPZmZzZXQsbixrKSksZj13ZT9udWxsOlwiMHB4IDBweFwiKSwoZnx8UmUmJnAmJmguek9yaWdpbikmJihQZT8obT0hMCxpPVNlLGY9KGZ8fFEodCxpLHIsITEsXCI1MCUgNTAlXCIpKStcIlwiLG49bmV3IG1lKFQsaSwwLDAsbiwtMSxrKSxuLmI9VFtpXSxuLnBsdWdpbj1vLFJlPyhjPWguek9yaWdpbixmPWYuc3BsaXQoXCIgXCIpLGguek9yaWdpbj0oZi5sZW5ndGg+MiYmKDA9PT1jfHxcIjBweFwiIT09ZlsyXSk/cGFyc2VGbG9hdChmWzJdKTpjKXx8MCxuLnhzMD1uLmU9ZlswXStcIiBcIisoZlsxXXx8XCI1MCVcIikrXCIgMHB4XCIsbj1uZXcgbWUoaCxcInpPcmlnaW5cIiwwLDAsbiwtMSxuLm4pLG4uYj1jLG4ueHMwPW4uZT1oLnpPcmlnaW4pOm4ueHMwPW4uZT1mKTpzZShmK1wiXCIsaCkpLG0mJihzLl90cmFuc2Zvcm1UeXBlPWguc3ZnJiZ3ZXx8IXAmJjMhPT10aGlzLl90cmFuc2Zvcm1UeXBlPzI6Myksbn0scHJlZml4OiEwfSksVGUoXCJib3hTaGFkb3dcIix7ZGVmYXVsdFZhbHVlOlwiMHB4IDBweCAwcHggMHB4ICM5OTlcIixwcmVmaXg6ITAsY29sb3I6ITAsbXVsdGk6ITAsa2V5d29yZDpcImluc2V0XCJ9KSxUZShcImJvcmRlclJhZGl1c1wiLHtkZWZhdWx0VmFsdWU6XCIwcHhcIixwYXJzZXI6ZnVuY3Rpb24odCxlLGksbixhKXtlPXRoaXMuZm9ybWF0KGUpO3ZhciBvLGwsaCxfLHUsYyxmLHAsbSxkLGcsdix5LFQseCx3LGI9W1wiYm9yZGVyVG9wTGVmdFJhZGl1c1wiLFwiYm9yZGVyVG9wUmlnaHRSYWRpdXNcIixcImJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzXCIsXCJib3JkZXJCb3R0b21MZWZ0UmFkaXVzXCJdLFA9dC5zdHlsZTtmb3IobT1wYXJzZUZsb2F0KHQub2Zmc2V0V2lkdGgpLGQ9cGFyc2VGbG9hdCh0Lm9mZnNldEhlaWdodCksbz1lLnNwbGl0KFwiIFwiKSxsPTA7Yi5sZW5ndGg+bDtsKyspdGhpcy5wLmluZGV4T2YoXCJib3JkZXJcIikmJihiW2xdPVcoYltsXSkpLHU9Xz1RKHQsYltsXSxyLCExLFwiMHB4XCIpLC0xIT09dS5pbmRleE9mKFwiIFwiKSYmKF89dS5zcGxpdChcIiBcIiksdT1fWzBdLF89X1sxXSksYz1oPW9bbF0sZj1wYXJzZUZsb2F0KHUpLHY9dS5zdWJzdHIoKGYrXCJcIikubGVuZ3RoKSx5PVwiPVwiPT09Yy5jaGFyQXQoMSkseT8ocD1wYXJzZUludChjLmNoYXJBdCgwKStcIjFcIiwxMCksYz1jLnN1YnN0cigyKSxwKj1wYXJzZUZsb2F0KGMpLGc9Yy5zdWJzdHIoKHArXCJcIikubGVuZ3RoLSgwPnA/MTowKSl8fFwiXCIpOihwPXBhcnNlRmxvYXQoYyksZz1jLnN1YnN0cigocCtcIlwiKS5sZW5ndGgpKSxcIlwiPT09ZyYmKGc9c1tpXXx8diksZyE9PXYmJihUPSQodCxcImJvcmRlckxlZnRcIixmLHYpLHg9JCh0LFwiYm9yZGVyVG9wXCIsZix2KSxcIiVcIj09PWc/KHU9MTAwKihUL20pK1wiJVwiLF89MTAwKih4L2QpK1wiJVwiKTpcImVtXCI9PT1nPyh3PSQodCxcImJvcmRlckxlZnRcIiwxLFwiZW1cIiksdT1UL3crXCJlbVwiLF89eC93K1wiZW1cIik6KHU9VCtcInB4XCIsXz14K1wicHhcIikseSYmKGM9cGFyc2VGbG9hdCh1KStwK2csaD1wYXJzZUZsb2F0KF8pK3ArZykpLGE9Z2UoUCxiW2xdLHUrXCIgXCIrXyxjK1wiIFwiK2gsITEsXCIwcHhcIixhKTtyZXR1cm4gYX0scHJlZml4OiEwLGZvcm1hdHRlcjpjZShcIjBweCAwcHggMHB4IDBweFwiLCExLCEwKX0pLFRlKFwiYmFja2dyb3VuZFBvc2l0aW9uXCIse2RlZmF1bHRWYWx1ZTpcIjAgMFwiLHBhcnNlcjpmdW5jdGlvbih0LGUsaSxzLG4sYSl7dmFyIG8sbCxoLF8sdSxjLGY9XCJiYWNrZ3JvdW5kLXBvc2l0aW9uXCIscD1yfHxaKHQsbnVsbCksZD10aGlzLmZvcm1hdCgocD9tP3AuZ2V0UHJvcGVydHlWYWx1ZShmK1wiLXhcIikrXCIgXCIrcC5nZXRQcm9wZXJ0eVZhbHVlKGYrXCIteVwiKTpwLmdldFByb3BlcnR5VmFsdWUoZik6dC5jdXJyZW50U3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uWCtcIiBcIit0LmN1cnJlbnRTdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb25ZKXx8XCIwIDBcIiksZz10aGlzLmZvcm1hdChlKTtcbmlmKC0xIT09ZC5pbmRleE9mKFwiJVwiKSE9KC0xIT09Zy5pbmRleE9mKFwiJVwiKSkmJihjPVEodCxcImJhY2tncm91bmRJbWFnZVwiKS5yZXBsYWNlKFIsXCJcIiksYyYmXCJub25lXCIhPT1jKSl7Zm9yKG89ZC5zcGxpdChcIiBcIiksbD1nLnNwbGl0KFwiIFwiKSxYLnNldEF0dHJpYnV0ZShcInNyY1wiLGMpLGg9MjstLWg+LTE7KWQ9b1toXSxfPS0xIT09ZC5pbmRleE9mKFwiJVwiKSxfIT09KC0xIT09bFtoXS5pbmRleE9mKFwiJVwiKSkmJih1PTA9PT1oP3Qub2Zmc2V0V2lkdGgtWC53aWR0aDp0Lm9mZnNldEhlaWdodC1YLmhlaWdodCxvW2hdPV8/cGFyc2VGbG9hdChkKS8xMDAqdStcInB4XCI6MTAwKihwYXJzZUZsb2F0KGQpL3UpK1wiJVwiKTtkPW8uam9pbihcIiBcIil9cmV0dXJuIHRoaXMucGFyc2VDb21wbGV4KHQuc3R5bGUsZCxnLG4sYSl9LGZvcm1hdHRlcjpzZX0pLFRlKFwiYmFja2dyb3VuZFNpemVcIix7ZGVmYXVsdFZhbHVlOlwiMCAwXCIsZm9ybWF0dGVyOnNlfSksVGUoXCJwZXJzcGVjdGl2ZVwiLHtkZWZhdWx0VmFsdWU6XCIwcHhcIixwcmVmaXg6ITB9KSxUZShcInBlcnNwZWN0aXZlT3JpZ2luXCIse2RlZmF1bHRWYWx1ZTpcIjUwJSA1MCVcIixwcmVmaXg6ITB9KSxUZShcInRyYW5zZm9ybVN0eWxlXCIse3ByZWZpeDohMH0pLFRlKFwiYmFja2ZhY2VWaXNpYmlsaXR5XCIse3ByZWZpeDohMH0pLFRlKFwidXNlclNlbGVjdFwiLHtwcmVmaXg6ITB9KSxUZShcIm1hcmdpblwiLHtwYXJzZXI6ZmUoXCJtYXJnaW5Ub3AsbWFyZ2luUmlnaHQsbWFyZ2luQm90dG9tLG1hcmdpbkxlZnRcIil9KSxUZShcInBhZGRpbmdcIix7cGFyc2VyOmZlKFwicGFkZGluZ1RvcCxwYWRkaW5nUmlnaHQscGFkZGluZ0JvdHRvbSxwYWRkaW5nTGVmdFwiKX0pLFRlKFwiY2xpcFwiLHtkZWZhdWx0VmFsdWU6XCJyZWN0KDBweCwwcHgsMHB4LDBweClcIixwYXJzZXI6ZnVuY3Rpb24odCxlLGkscyxuLGEpe3ZhciBvLGwsaDtyZXR1cm4gOT5tPyhsPXQuY3VycmVudFN0eWxlLGg9OD5tP1wiIFwiOlwiLFwiLG89XCJyZWN0KFwiK2wuY2xpcFRvcCtoK2wuY2xpcFJpZ2h0K2grbC5jbGlwQm90dG9tK2grbC5jbGlwTGVmdCtcIilcIixlPXRoaXMuZm9ybWF0KGUpLnNwbGl0KFwiLFwiKS5qb2luKGgpKToobz10aGlzLmZvcm1hdChRKHQsdGhpcy5wLHIsITEsdGhpcy5kZmx0KSksZT10aGlzLmZvcm1hdChlKSksdGhpcy5wYXJzZUNvbXBsZXgodC5zdHlsZSxvLGUsbixhKX19KSxUZShcInRleHRTaGFkb3dcIix7ZGVmYXVsdFZhbHVlOlwiMHB4IDBweCAwcHggIzk5OVwiLGNvbG9yOiEwLG11bHRpOiEwfSksVGUoXCJhdXRvUm91bmQsc3RyaWN0VW5pdHNcIix7cGFyc2VyOmZ1bmN0aW9uKHQsZSxpLHMscil7cmV0dXJuIHJ9fSksVGUoXCJib3JkZXJcIix7ZGVmYXVsdFZhbHVlOlwiMHB4IHNvbGlkICMwMDBcIixwYXJzZXI6ZnVuY3Rpb24odCxlLGkscyxuLGEpe3JldHVybiB0aGlzLnBhcnNlQ29tcGxleCh0LnN0eWxlLHRoaXMuZm9ybWF0KFEodCxcImJvcmRlclRvcFdpZHRoXCIsciwhMSxcIjBweFwiKStcIiBcIitRKHQsXCJib3JkZXJUb3BTdHlsZVwiLHIsITEsXCJzb2xpZFwiKStcIiBcIitRKHQsXCJib3JkZXJUb3BDb2xvclwiLHIsITEsXCIjMDAwXCIpKSx0aGlzLmZvcm1hdChlKSxuLGEpfSxjb2xvcjohMCxmb3JtYXR0ZXI6ZnVuY3Rpb24odCl7dmFyIGU9dC5zcGxpdChcIiBcIik7cmV0dXJuIGVbMF0rXCIgXCIrKGVbMV18fFwic29saWRcIikrXCIgXCIrKHQubWF0Y2godWUpfHxbXCIjMDAwXCJdKVswXX19KSxUZShcImJvcmRlcldpZHRoXCIse3BhcnNlcjpmZShcImJvcmRlclRvcFdpZHRoLGJvcmRlclJpZ2h0V2lkdGgsYm9yZGVyQm90dG9tV2lkdGgsYm9yZGVyTGVmdFdpZHRoXCIpfSksVGUoXCJmbG9hdCxjc3NGbG9hdCxzdHlsZUZsb2F0XCIse3BhcnNlcjpmdW5jdGlvbih0LGUsaSxzLHIpe3ZhciBuPXQuc3R5bGUsYT1cImNzc0Zsb2F0XCJpbiBuP1wiY3NzRmxvYXRcIjpcInN0eWxlRmxvYXRcIjtyZXR1cm4gbmV3IG1lKG4sYSwwLDAsciwtMSxpLCExLDAsblthXSxlKX19KTt2YXIgQmU9ZnVuY3Rpb24odCl7dmFyIGUsaT10aGlzLnQscz1pLmZpbHRlcnx8USh0aGlzLmRhdGEsXCJmaWx0ZXJcIil8fFwiXCIscj0wfHRoaXMucyt0aGlzLmMqdDsxMDA9PT1yJiYoLTE9PT1zLmluZGV4T2YoXCJhdHJpeChcIikmJi0xPT09cy5pbmRleE9mKFwicmFkaWVudChcIikmJi0xPT09cy5pbmRleE9mKFwib2FkZXIoXCIpPyhpLnJlbW92ZUF0dHJpYnV0ZShcImZpbHRlclwiKSxlPSFRKHRoaXMuZGF0YSxcImZpbHRlclwiKSk6KGkuZmlsdGVyPXMucmVwbGFjZShiLFwiXCIpLGU9ITApKSxlfHwodGhpcy54bjEmJihpLmZpbHRlcj1zPXN8fFwiYWxwaGEob3BhY2l0eT1cIityK1wiKVwiKSwtMT09PXMuaW5kZXhPZihcInBhY2l0eVwiKT8wPT09ciYmdGhpcy54bjF8fChpLmZpbHRlcj1zK1wiIGFscGhhKG9wYWNpdHk9XCIrcitcIilcIik6aS5maWx0ZXI9cy5yZXBsYWNlKHgsXCJvcGFjaXR5PVwiK3IpKX07VGUoXCJvcGFjaXR5LGFscGhhLGF1dG9BbHBoYVwiLHtkZWZhdWx0VmFsdWU6XCIxXCIscGFyc2VyOmZ1bmN0aW9uKHQsZSxpLHMsbixhKXt2YXIgbz1wYXJzZUZsb2F0KFEodCxcIm9wYWNpdHlcIixyLCExLFwiMVwiKSksbD10LnN0eWxlLGg9XCJhdXRvQWxwaGFcIj09PWk7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGUmJlwiPVwiPT09ZS5jaGFyQXQoMSkmJihlPShcIi1cIj09PWUuY2hhckF0KDApPy0xOjEpKnBhcnNlRmxvYXQoZS5zdWJzdHIoMikpK28pLGgmJjE9PT1vJiZcImhpZGRlblwiPT09USh0LFwidmlzaWJpbGl0eVwiLHIpJiYwIT09ZSYmKG89MCksWT9uPW5ldyBtZShsLFwib3BhY2l0eVwiLG8sZS1vLG4pOihuPW5ldyBtZShsLFwib3BhY2l0eVwiLDEwMCpvLDEwMCooZS1vKSxuKSxuLnhuMT1oPzE6MCxsLnpvb209MSxuLnR5cGU9MixuLmI9XCJhbHBoYShvcGFjaXR5PVwiK24ucytcIilcIixuLmU9XCJhbHBoYShvcGFjaXR5PVwiKyhuLnMrbi5jKStcIilcIixuLmRhdGE9dCxuLnBsdWdpbj1hLG4uc2V0UmF0aW89QmUpLGgmJihuPW5ldyBtZShsLFwidmlzaWJpbGl0eVwiLDAsMCxuLC0xLG51bGwsITEsMCwwIT09bz9cImluaGVyaXRcIjpcImhpZGRlblwiLDA9PT1lP1wiaGlkZGVuXCI6XCJpbmhlcml0XCIpLG4ueHMwPVwiaW5oZXJpdFwiLHMuX292ZXJ3cml0ZVByb3BzLnB1c2gobi5uKSxzLl9vdmVyd3JpdGVQcm9wcy5wdXNoKGkpKSxufX0pO3ZhciBqZT1mdW5jdGlvbih0LGUpe2UmJih0LnJlbW92ZVByb3BlcnR5PygoXCJtc1wiPT09ZS5zdWJzdHIoMCwyKXx8XCJ3ZWJraXRcIj09PWUuc3Vic3RyKDAsNikpJiYoZT1cIi1cIitlKSx0LnJlbW92ZVByb3BlcnR5KGUucmVwbGFjZShrLFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpKTp0LnJlbW92ZUF0dHJpYnV0ZShlKSl9LFllPWZ1bmN0aW9uKHQpe2lmKHRoaXMudC5fZ3NDbGFzc1BUPXRoaXMsMT09PXR8fDA9PT10KXt0aGlzLnQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwwPT09dD90aGlzLmI6dGhpcy5lKTtmb3IodmFyIGU9dGhpcy5kYXRhLGk9dGhpcy50LnN0eWxlO2U7KWUudj9pW2UucF09ZS52OmplKGksZS5wKSxlPWUuX25leHQ7MT09PXQmJnRoaXMudC5fZ3NDbGFzc1BUPT09dGhpcyYmKHRoaXMudC5fZ3NDbGFzc1BUPW51bGwpfWVsc2UgdGhpcy50LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIT09dGhpcy5lJiZ0aGlzLnQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIix0aGlzLmUpfTtUZShcImNsYXNzTmFtZVwiLHtwYXJzZXI6ZnVuY3Rpb24odCxlLHMsbixhLG8sbCl7dmFyIGgsXyx1LGMsZixwPXQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIil8fFwiXCIsbT10LnN0eWxlLmNzc1RleHQ7aWYoYT1uLl9jbGFzc05hbWVQVD1uZXcgbWUodCxzLDAsMCxhLDIpLGEuc2V0UmF0aW89WWUsYS5wcj0tMTEsaT0hMCxhLmI9cCxfPUsodCxyKSx1PXQuX2dzQ2xhc3NQVCl7Zm9yKGM9e30sZj11LmRhdGE7ZjspY1tmLnBdPTEsZj1mLl9uZXh0O3Uuc2V0UmF0aW8oMSl9cmV0dXJuIHQuX2dzQ2xhc3NQVD1hLGEuZT1cIj1cIiE9PWUuY2hhckF0KDEpP2U6cC5yZXBsYWNlKFJlZ0V4cChcIlxcXFxzKlxcXFxiXCIrZS5zdWJzdHIoMikrXCJcXFxcYlwiKSxcIlwiKSsoXCIrXCI9PT1lLmNoYXJBdCgwKT9cIiBcIitlLnN1YnN0cigyKTpcIlwiKSx0LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsYS5lKSxoPUoodCxfLEsodCksbCxjKSx0LnNldEF0dHJpYnV0ZShcImNsYXNzXCIscCksYS5kYXRhPWguZmlyc3RNUFQsdC5zdHlsZS5jc3NUZXh0PW0sYT1hLnhmaXJzdD1uLnBhcnNlKHQsaC5kaWZzLGEsbyl9fSk7dmFyIFVlPWZ1bmN0aW9uKHQpe2lmKCgxPT09dHx8MD09PXQpJiZ0aGlzLmRhdGEuX3RvdGFsVGltZT09PXRoaXMuZGF0YS5fdG90YWxEdXJhdGlvbiYmXCJpc0Zyb21TdGFydFwiIT09dGhpcy5kYXRhLmRhdGEpe3ZhciBlLGkscyxyLG4sYT10aGlzLnQuc3R5bGUsbz1sLnRyYW5zZm9ybS5wYXJzZTtpZihcImFsbFwiPT09dGhpcy5lKWEuY3NzVGV4dD1cIlwiLHI9ITA7ZWxzZSBmb3IoZT10aGlzLmUuc3BsaXQoXCIgXCIpLmpvaW4oXCJcIikuc3BsaXQoXCIsXCIpLHM9ZS5sZW5ndGg7LS1zPi0xOylpPWVbc10sbFtpXSYmKGxbaV0ucGFyc2U9PT1vP3I9ITA6aT1cInRyYW5zZm9ybU9yaWdpblwiPT09aT9TZTpsW2ldLnApLGplKGEsaSk7ciYmKGplKGEsUGUpLG49dGhpcy50Ll9nc1RyYW5zZm9ybSxuJiYobi5zdmcmJnRoaXMudC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXN2Zy1vcmlnaW5cIiksZGVsZXRlIHRoaXMudC5fZ3NUcmFuc2Zvcm0pKX19O2ZvcihUZShcImNsZWFyUHJvcHNcIix7cGFyc2VyOmZ1bmN0aW9uKHQsZSxzLHIsbil7cmV0dXJuIG49bmV3IG1lKHQscywwLDAsbiwyKSxuLnNldFJhdGlvPVVlLG4uZT1lLG4ucHI9LTEwLG4uZGF0YT1yLl90d2VlbixpPSEwLG59fSksaD1cImJlemllcix0aHJvd1Byb3BzLHBoeXNpY3NQcm9wcyxwaHlzaWNzMkRcIi5zcGxpdChcIixcIiksdmU9aC5sZW5ndGg7dmUtLTspeGUoaFt2ZV0pO2g9YS5wcm90b3R5cGUsaC5fZmlyc3RQVD1oLl9sYXN0UGFyc2VkVHJhbnNmb3JtPWguX3RyYW5zZm9ybT1udWxsLGguX29uSW5pdFR3ZWVuPWZ1bmN0aW9uKHQsZSxvKXtpZighdC5ub2RlVHlwZSlyZXR1cm4hMTt0aGlzLl90YXJnZXQ9dCx0aGlzLl90d2Vlbj1vLHRoaXMuX3ZhcnM9ZSxfPWUuYXV0b1JvdW5kLGk9ITEscz1lLnN1ZmZpeE1hcHx8YS5zdWZmaXhNYXAscj1aKHQsXCJcIiksbj10aGlzLl9vdmVyd3JpdGVQcm9wczt2YXIgaCxmLG0sZCxnLHYseSxULHgsYj10LnN0eWxlO2lmKHUmJlwiXCI9PT1iLnpJbmRleCYmKGg9USh0LFwiekluZGV4XCIsciksKFwiYXV0b1wiPT09aHx8XCJcIj09PWgpJiZ0aGlzLl9hZGRMYXp5U2V0KGIsXCJ6SW5kZXhcIiwwKSksXCJzdHJpbmdcIj09dHlwZW9mIGUmJihkPWIuY3NzVGV4dCxoPUsodCxyKSxiLmNzc1RleHQ9ZCtcIjtcIitlLGg9Sih0LGgsSyh0KSkuZGlmcywhWSYmdy50ZXN0KGUpJiYoaC5vcGFjaXR5PXBhcnNlRmxvYXQoUmVnRXhwLiQxKSksZT1oLGIuY3NzVGV4dD1kKSx0aGlzLl9maXJzdFBUPWY9ZS5jbGFzc05hbWU/bC5jbGFzc05hbWUucGFyc2UodCxlLmNsYXNzTmFtZSxcImNsYXNzTmFtZVwiLHRoaXMsbnVsbCxudWxsLGUpOnRoaXMucGFyc2UodCxlLG51bGwpLHRoaXMuX3RyYW5zZm9ybVR5cGUpe2Zvcih4PTM9PT10aGlzLl90cmFuc2Zvcm1UeXBlLFBlP2MmJih1PSEwLFwiXCI9PT1iLnpJbmRleCYmKHk9USh0LFwiekluZGV4XCIsciksKFwiYXV0b1wiPT09eXx8XCJcIj09PXkpJiZ0aGlzLl9hZGRMYXp5U2V0KGIsXCJ6SW5kZXhcIiwwKSkscCYmdGhpcy5fYWRkTGF6eVNldChiLFwiV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5XCIsdGhpcy5fdmFycy5XZWJraXRCYWNrZmFjZVZpc2liaWxpdHl8fCh4P1widmlzaWJsZVwiOlwiaGlkZGVuXCIpKSk6Yi56b29tPTEsbT1mO20mJm0uX25leHQ7KW09bS5fbmV4dDtUPW5ldyBtZSh0LFwidHJhbnNmb3JtXCIsMCwwLG51bGwsMiksdGhpcy5fbGlua0NTU1AoVCxudWxsLG0pLFQuc2V0UmF0aW89UGU/WGU6TGUsVC5kYXRhPXRoaXMuX3RyYW5zZm9ybXx8TmUodCxyLCEwKSxULnR3ZWVuPW8sVC5wcj0tMSxuLnBvcCgpfWlmKGkpe2Zvcig7Zjspe2Zvcih2PWYuX25leHQsbT1kO20mJm0ucHI+Zi5wcjspbT1tLl9uZXh0OyhmLl9wcmV2PW0/bS5fcHJldjpnKT9mLl9wcmV2Ll9uZXh0PWY6ZD1mLChmLl9uZXh0PW0pP20uX3ByZXY9ZjpnPWYsZj12fXRoaXMuX2ZpcnN0UFQ9ZH1yZXR1cm4hMH0saC5wYXJzZT1mdW5jdGlvbih0LGUsaSxuKXt2YXIgYSxvLGgsdSxjLGYscCxtLGQsZyx2PXQuc3R5bGU7Zm9yKGEgaW4gZSlmPWVbYV0sbz1sW2FdLG8/aT1vLnBhcnNlKHQsZixhLHRoaXMsaSxuLGUpOihjPVEodCxhLHIpK1wiXCIsZD1cInN0cmluZ1wiPT10eXBlb2YgZixcImNvbG9yXCI9PT1hfHxcImZpbGxcIj09PWF8fFwic3Ryb2tlXCI9PT1hfHwtMSE9PWEuaW5kZXhPZihcIkNvbG9yXCIpfHxkJiZQLnRlc3QoZik/KGR8fChmPWhlKGYpLGY9KGYubGVuZ3RoPjM/XCJyZ2JhKFwiOlwicmdiKFwiKStmLmpvaW4oXCIsXCIpK1wiKVwiKSxpPWdlKHYsYSxjLGYsITAsXCJ0cmFuc3BhcmVudFwiLGksMCxuKSk6IWR8fC0xPT09Zi5pbmRleE9mKFwiIFwiKSYmLTE9PT1mLmluZGV4T2YoXCIsXCIpPyhoPXBhcnNlRmxvYXQoYykscD1ofHwwPT09aD9jLnN1YnN0cigoaCtcIlwiKS5sZW5ndGgpOlwiXCIsKFwiXCI9PT1jfHxcImF1dG9cIj09PWMpJiYoXCJ3aWR0aFwiPT09YXx8XCJoZWlnaHRcIj09PWE/KGg9aWUodCxhLHIpLHA9XCJweFwiKTpcImxlZnRcIj09PWF8fFwidG9wXCI9PT1hPyhoPUgodCxhLHIpLHA9XCJweFwiKTooaD1cIm9wYWNpdHlcIiE9PWE/MDoxLHA9XCJcIikpLGc9ZCYmXCI9XCI9PT1mLmNoYXJBdCgxKSxnPyh1PXBhcnNlSW50KGYuY2hhckF0KDApK1wiMVwiLDEwKSxmPWYuc3Vic3RyKDIpLHUqPXBhcnNlRmxvYXQoZiksbT1mLnJlcGxhY2UoVCxcIlwiKSk6KHU9cGFyc2VGbG9hdChmKSxtPWQ/Zi5yZXBsYWNlKFQsXCJcIik6XCJcIiksXCJcIj09PW0mJihtPWEgaW4gcz9zW2FdOnApLGY9dXx8MD09PXU/KGc/dStoOnUpK206ZVthXSxwIT09bSYmXCJcIiE9PW0mJih1fHwwPT09dSkmJmgmJihoPSQodCxhLGgscCksXCIlXCI9PT1tPyhoLz0kKHQsYSwxMDAsXCIlXCIpLzEwMCxlLnN0cmljdFVuaXRzIT09ITAmJihjPWgrXCIlXCIpKTpcImVtXCI9PT1tfHxcInJlbVwiPT09bT9oLz0kKHQsYSwxLG0pOlwicHhcIiE9PW0mJih1PSQodCxhLHUsbSksbT1cInB4XCIpLGcmJih1fHwwPT09dSkmJihmPXUraCttKSksZyYmKHUrPWgpLCFoJiYwIT09aHx8IXUmJjAhPT11P3ZvaWQgMCE9PXZbYV0mJihmfHxcIk5hTlwiIT1mK1wiXCImJm51bGwhPWYpPyhpPW5ldyBtZSh2LGEsdXx8aHx8MCwwLGksLTEsYSwhMSwwLGMsZiksaS54czA9XCJub25lXCIhPT1mfHxcImRpc3BsYXlcIiE9PWEmJi0xPT09YS5pbmRleE9mKFwiU3R5bGVcIik/ZjpjKTpxKFwiaW52YWxpZCBcIithK1wiIHR3ZWVuIHZhbHVlOiBcIitlW2FdKTooaT1uZXcgbWUodixhLGgsdS1oLGksMCxhLF8hPT0hMSYmKFwicHhcIj09PW18fFwiekluZGV4XCI9PT1hKSwwLGMsZiksaS54czA9bSkpOmk9Z2UodixhLGMsZiwhMCxudWxsLGksMCxuKSksbiYmaSYmIWkucGx1Z2luJiYoaS5wbHVnaW49bik7cmV0dXJuIGl9LGguc2V0UmF0aW89ZnVuY3Rpb24odCl7dmFyIGUsaSxzLHI9dGhpcy5fZmlyc3RQVCxuPTFlLTY7aWYoMSE9PXR8fHRoaXMuX3R3ZWVuLl90aW1lIT09dGhpcy5fdHdlZW4uX2R1cmF0aW9uJiYwIT09dGhpcy5fdHdlZW4uX3RpbWUpaWYodHx8dGhpcy5fdHdlZW4uX3RpbWUhPT10aGlzLl90d2Vlbi5fZHVyYXRpb24mJjAhPT10aGlzLl90d2Vlbi5fdGltZXx8dGhpcy5fdHdlZW4uX3Jhd1ByZXZUaW1lPT09LTFlLTYpZm9yKDtyOyl7aWYoZT1yLmMqdCtyLnMsci5yP2U9TWF0aC5yb3VuZChlKTpuPmUmJmU+LW4mJihlPTApLHIudHlwZSlpZigxPT09ci50eXBlKWlmKHM9ci5sLDI9PT1zKXIudFtyLnBdPXIueHMwK2Urci54czErci54bjErci54czI7ZWxzZSBpZigzPT09cylyLnRbci5wXT1yLnhzMCtlK3IueHMxK3IueG4xK3IueHMyK3IueG4yK3IueHMzO2Vsc2UgaWYoND09PXMpci50W3IucF09ci54czArZStyLnhzMStyLnhuMStyLnhzMityLnhuMityLnhzMytyLnhuMytyLnhzNDtlbHNlIGlmKDU9PT1zKXIudFtyLnBdPXIueHMwK2Urci54czErci54bjErci54czIrci54bjIrci54czMrci54bjMrci54czQrci54bjQrci54czU7ZWxzZXtmb3IoaT1yLnhzMCtlK3IueHMxLHM9MTtyLmw+cztzKyspaSs9cltcInhuXCIrc10rcltcInhzXCIrKHMrMSldO3IudFtyLnBdPWl9ZWxzZS0xPT09ci50eXBlP3IudFtyLnBdPXIueHMwOnIuc2V0UmF0aW8mJnIuc2V0UmF0aW8odCk7ZWxzZSByLnRbci5wXT1lK3IueHMwO3I9ci5fbmV4dH1lbHNlIGZvcig7cjspMiE9PXIudHlwZT9yLnRbci5wXT1yLmI6ci5zZXRSYXRpbyh0KSxyPXIuX25leHQ7ZWxzZSBmb3IoO3I7KXtpZigyIT09ci50eXBlKWlmKHIuciYmLTEhPT1yLnR5cGUpaWYoZT1NYXRoLnJvdW5kKHIucytyLmMpLHIudHlwZSl7aWYoMT09PXIudHlwZSl7Zm9yKHM9ci5sLGk9ci54czArZStyLnhzMSxzPTE7ci5sPnM7cysrKWkrPXJbXCJ4blwiK3NdK3JbXCJ4c1wiKyhzKzEpXTtyLnRbci5wXT1pfX1lbHNlIHIudFtyLnBdPWUrci54czA7ZWxzZSByLnRbci5wXT1yLmU7ZWxzZSByLnNldFJhdGlvKHQpO3I9ci5fbmV4dH19LGguX2VuYWJsZVRyYW5zZm9ybXM9ZnVuY3Rpb24odCl7dGhpcy5fdHJhbnNmb3JtPXRoaXMuX3RyYW5zZm9ybXx8TmUodGhpcy5fdGFyZ2V0LHIsITApLHRoaXMuX3RyYW5zZm9ybVR5cGU9dGhpcy5fdHJhbnNmb3JtLnN2ZyYmd2V8fCF0JiYzIT09dGhpcy5fdHJhbnNmb3JtVHlwZT8yOjN9O3ZhciBxZT1mdW5jdGlvbigpe3RoaXMudFt0aGlzLnBdPXRoaXMuZSx0aGlzLmRhdGEuX2xpbmtDU1NQKHRoaXMsdGhpcy5fbmV4dCxudWxsLCEwKX07aC5fYWRkTGF6eVNldD1mdW5jdGlvbih0LGUsaSl7dmFyIHM9dGhpcy5fZmlyc3RQVD1uZXcgbWUodCxlLDAsMCx0aGlzLl9maXJzdFBULDIpO3MuZT1pLHMuc2V0UmF0aW89cWUscy5kYXRhPXRoaXN9LGguX2xpbmtDU1NQPWZ1bmN0aW9uKHQsZSxpLHMpe3JldHVybiB0JiYoZSYmKGUuX3ByZXY9dCksdC5fbmV4dCYmKHQuX25leHQuX3ByZXY9dC5fcHJldiksdC5fcHJldj90Ll9wcmV2Ll9uZXh0PXQuX25leHQ6dGhpcy5fZmlyc3RQVD09PXQmJih0aGlzLl9maXJzdFBUPXQuX25leHQscz0hMCksaT9pLl9uZXh0PXQ6c3x8bnVsbCE9PXRoaXMuX2ZpcnN0UFR8fCh0aGlzLl9maXJzdFBUPXQpLHQuX25leHQ9ZSx0Ll9wcmV2PWkpLHR9LGguX2tpbGw9ZnVuY3Rpb24oZSl7dmFyIGkscyxyLG49ZTtpZihlLmF1dG9BbHBoYXx8ZS5hbHBoYSl7bj17fTtmb3IocyBpbiBlKW5bc109ZVtzXTtuLm9wYWNpdHk9MSxuLmF1dG9BbHBoYSYmKG4udmlzaWJpbGl0eT0xKX1yZXR1cm4gZS5jbGFzc05hbWUmJihpPXRoaXMuX2NsYXNzTmFtZVBUKSYmKHI9aS54Zmlyc3QsciYmci5fcHJldj90aGlzLl9saW5rQ1NTUChyLl9wcmV2LGkuX25leHQsci5fcHJldi5fcHJldik6cj09PXRoaXMuX2ZpcnN0UFQmJih0aGlzLl9maXJzdFBUPWkuX25leHQpLGkuX25leHQmJnRoaXMuX2xpbmtDU1NQKGkuX25leHQsaS5fbmV4dC5fbmV4dCxyLl9wcmV2KSx0aGlzLl9jbGFzc05hbWVQVD1udWxsKSx0LnByb3RvdHlwZS5fa2lsbC5jYWxsKHRoaXMsbil9O3ZhciBWZT1mdW5jdGlvbih0LGUsaSl7dmFyIHMscixuLGE7aWYodC5zbGljZSlmb3Iocj10Lmxlbmd0aDstLXI+LTE7KVZlKHRbcl0sZSxpKTtlbHNlIGZvcihzPXQuY2hpbGROb2RlcyxyPXMubGVuZ3RoOy0tcj4tMTspbj1zW3JdLGE9bi50eXBlLG4uc3R5bGUmJihlLnB1c2goSyhuKSksaSYmaS5wdXNoKG4pKSwxIT09YSYmOSE9PWEmJjExIT09YXx8IW4uY2hpbGROb2Rlcy5sZW5ndGh8fFZlKG4sZSxpKX07cmV0dXJuIGEuY2FzY2FkZVRvPWZ1bmN0aW9uKHQsaSxzKXt2YXIgcixuLGEsbyxsPWUudG8odCxpLHMpLGg9W2xdLF89W10sdT1bXSxjPVtdLGY9ZS5faW50ZXJuYWxzLnJlc2VydmVkUHJvcHM7Zm9yKHQ9bC5fdGFyZ2V0c3x8bC50YXJnZXQsVmUodCxfLGMpLGwucmVuZGVyKGksITAsITApLFZlKHQsdSksbC5yZW5kZXIoMCwhMCwhMCksbC5fZW5hYmxlZCghMCkscj1jLmxlbmd0aDstLXI+LTE7KWlmKG49SihjW3JdLF9bcl0sdVtyXSksbi5maXJzdE1QVCl7bj1uLmRpZnM7Zm9yKGEgaW4gcylmW2FdJiYoblthXT1zW2FdKTtvPXt9O2ZvcihhIGluIG4pb1thXT1fW3JdW2FdO2gucHVzaChlLmZyb21UbyhjW3JdLGksbyxuKSl9cmV0dXJuIGh9LHQuYWN0aXZhdGUoW2FdKSxhfSwhMCksZnVuY3Rpb24oKXt2YXIgdD1fZ3NTY29wZS5fZ3NEZWZpbmUucGx1Z2luKHtwcm9wTmFtZTpcInJvdW5kUHJvcHNcIix2ZXJzaW9uOlwiMS41XCIscHJpb3JpdHk6LTEsQVBJOjIsaW5pdDpmdW5jdGlvbih0LGUsaSl7cmV0dXJuIHRoaXMuX3R3ZWVuPWksITB9fSksZT1mdW5jdGlvbih0KXtmb3IoO3Q7KXQuZnx8dC5ibG9ifHwodC5yPTEpLHQ9dC5fbmV4dH0saT10LnByb3RvdHlwZTtpLl9vbkluaXRBbGxQcm9wcz1mdW5jdGlvbigpe2Zvcih2YXIgdCxpLHMscj10aGlzLl90d2VlbixuPXIudmFycy5yb3VuZFByb3BzLmpvaW4/ci52YXJzLnJvdW5kUHJvcHM6ci52YXJzLnJvdW5kUHJvcHMuc3BsaXQoXCIsXCIpLGE9bi5sZW5ndGgsbz17fSxsPXIuX3Byb3BMb29rdXAucm91bmRQcm9wczstLWE+LTE7KW9bblthXV09MTtmb3IoYT1uLmxlbmd0aDstLWE+LTE7KWZvcih0PW5bYV0saT1yLl9maXJzdFBUO2k7KXM9aS5fbmV4dCxpLnBnP2kudC5fcm91bmRQcm9wcyhvLCEwKTppLm49PT10JiYoMj09PWkuZiYmaS50P2UoaS50Ll9maXJzdFBUKToodGhpcy5fYWRkKGkudCx0LGkucyxpLmMpLHMmJihzLl9wcmV2PWkuX3ByZXYpLGkuX3ByZXY/aS5fcHJldi5fbmV4dD1zOnIuX2ZpcnN0UFQ9PT1pJiYoci5fZmlyc3RQVD1zKSxpLl9uZXh0PWkuX3ByZXY9bnVsbCxyLl9wcm9wTG9va3VwW3RdPWwpKSxpPXM7cmV0dXJuITF9LGkuX2FkZD1mdW5jdGlvbih0LGUsaSxzKXt0aGlzLl9hZGRUd2Vlbih0LGUsaSxpK3MsZSwhMCksdGhpcy5fb3ZlcndyaXRlUHJvcHMucHVzaChlKX19KCksZnVuY3Rpb24oKXtfZ3NTY29wZS5fZ3NEZWZpbmUucGx1Z2luKHtwcm9wTmFtZTpcImF0dHJcIixBUEk6Mix2ZXJzaW9uOlwiMC41LjBcIixpbml0OmZ1bmN0aW9uKHQsZSl7dmFyIGk7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdC5zZXRBdHRyaWJ1dGUpcmV0dXJuITE7Zm9yKGkgaW4gZSl0aGlzLl9hZGRUd2Vlbih0LFwic2V0QXR0cmlidXRlXCIsdC5nZXRBdHRyaWJ1dGUoaSkrXCJcIixlW2ldK1wiXCIsaSwhMSxpKSx0aGlzLl9vdmVyd3JpdGVQcm9wcy5wdXNoKGkpO3JldHVybiEwfX0pfSgpLF9nc1Njb3BlLl9nc0RlZmluZS5wbHVnaW4oe3Byb3BOYW1lOlwiZGlyZWN0aW9uYWxSb3RhdGlvblwiLHZlcnNpb246XCIwLjIuMVwiLEFQSToyLGluaXQ6ZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiIT10eXBlb2YgZSYmKGU9e3JvdGF0aW9uOmV9KSx0aGlzLmZpbmFscz17fTt2YXIgaSxzLHIsbixhLG8sbD1lLnVzZVJhZGlhbnM9PT0hMD8yKk1hdGguUEk6MzYwLGg9MWUtNjtmb3IoaSBpbiBlKVwidXNlUmFkaWFuc1wiIT09aSYmKG89KGVbaV0rXCJcIikuc3BsaXQoXCJfXCIpLHM9b1swXSxyPXBhcnNlRmxvYXQoXCJmdW5jdGlvblwiIT10eXBlb2YgdFtpXT90W2ldOnRbaS5pbmRleE9mKFwic2V0XCIpfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiB0W1wiZ2V0XCIraS5zdWJzdHIoMyldP2k6XCJnZXRcIitpLnN1YnN0cigzKV0oKSksbj10aGlzLmZpbmFsc1tpXT1cInN0cmluZ1wiPT10eXBlb2YgcyYmXCI9XCI9PT1zLmNoYXJBdCgxKT9yK3BhcnNlSW50KHMuY2hhckF0KDApK1wiMVwiLDEwKSpOdW1iZXIocy5zdWJzdHIoMikpOk51bWJlcihzKXx8MCxhPW4tcixvLmxlbmd0aCYmKHM9by5qb2luKFwiX1wiKSwtMSE9PXMuaW5kZXhPZihcInNob3J0XCIpJiYoYSU9bCxhIT09YSUobC8yKSYmKGE9MD5hP2ErbDphLWwpKSwtMSE9PXMuaW5kZXhPZihcIl9jd1wiKSYmMD5hP2E9KGErOTk5OTk5OTk5OSpsKSVsLSgwfGEvbCkqbDotMSE9PXMuaW5kZXhPZihcImNjd1wiKSYmYT4wJiYoYT0oYS05OTk5OTk5OTk5KmwpJWwtKDB8YS9sKSpsKSksKGE+aHx8LWg+YSkmJih0aGlzLl9hZGRUd2Vlbih0LGkscixyK2EsaSksdGhpcy5fb3ZlcndyaXRlUHJvcHMucHVzaChpKSkpO3JldHVybiEwfSxzZXQ6ZnVuY3Rpb24odCl7dmFyIGU7aWYoMSE9PXQpdGhpcy5fc3VwZXIuc2V0UmF0aW8uY2FsbCh0aGlzLHQpO2Vsc2UgZm9yKGU9dGhpcy5fZmlyc3RQVDtlOyllLmY/ZS50W2UucF0odGhpcy5maW5hbHNbZS5wXSk6ZS50W2UucF09dGhpcy5maW5hbHNbZS5wXSxlPWUuX25leHR9fSkuX2F1dG9DU1M9ITAsX2dzU2NvcGUuX2dzRGVmaW5lKFwiZWFzaW5nLkJhY2tcIixbXCJlYXNpbmcuRWFzZVwiXSxmdW5jdGlvbih0KXt2YXIgZSxpLHMscj1fZ3NTY29wZS5HcmVlblNvY2tHbG9iYWxzfHxfZ3NTY29wZSxuPXIuY29tLmdyZWVuc29jayxhPTIqTWF0aC5QSSxvPU1hdGguUEkvMixsPW4uX2NsYXNzLGg9ZnVuY3Rpb24oZSxpKXt2YXIgcz1sKFwiZWFzaW5nLlwiK2UsZnVuY3Rpb24oKXt9LCEwKSxyPXMucHJvdG90eXBlPW5ldyB0O3JldHVybiByLmNvbnN0cnVjdG9yPXMsci5nZXRSYXRpbz1pLHN9LF89dC5yZWdpc3Rlcnx8ZnVuY3Rpb24oKXt9LHU9ZnVuY3Rpb24odCxlLGkscyl7dmFyIHI9bChcImVhc2luZy5cIit0LHtlYXNlT3V0Om5ldyBlLGVhc2VJbjpuZXcgaSxlYXNlSW5PdXQ6bmV3IHN9LCEwKTtyZXR1cm4gXyhyLHQpLHJ9LGM9ZnVuY3Rpb24odCxlLGkpe3RoaXMudD10LHRoaXMudj1lLGkmJih0aGlzLm5leHQ9aSxpLnByZXY9dGhpcyx0aGlzLmM9aS52LWUsdGhpcy5nYXA9aS50LXQpfSxmPWZ1bmN0aW9uKGUsaSl7dmFyIHM9bChcImVhc2luZy5cIitlLGZ1bmN0aW9uKHQpe3RoaXMuX3AxPXR8fDA9PT10P3Q6MS43MDE1OCx0aGlzLl9wMj0xLjUyNSp0aGlzLl9wMX0sITApLHI9cy5wcm90b3R5cGU9bmV3IHQ7cmV0dXJuIHIuY29uc3RydWN0b3I9cyxyLmdldFJhdGlvPWksci5jb25maWc9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBzKHQpfSxzfSxwPXUoXCJCYWNrXCIsZihcIkJhY2tPdXRcIixmdW5jdGlvbih0KXtyZXR1cm4odC09MSkqdCooKHRoaXMuX3AxKzEpKnQrdGhpcy5fcDEpKzF9KSxmKFwiQmFja0luXCIsZnVuY3Rpb24odCl7cmV0dXJuIHQqdCooKHRoaXMuX3AxKzEpKnQtdGhpcy5fcDEpfSksZihcIkJhY2tJbk91dFwiLGZ1bmN0aW9uKHQpe3JldHVybiAxPih0Kj0yKT8uNSp0KnQqKCh0aGlzLl9wMisxKSp0LXRoaXMuX3AyKTouNSooKHQtPTIpKnQqKCh0aGlzLl9wMisxKSp0K3RoaXMuX3AyKSsyKX0pKSxtPWwoXCJlYXNpbmcuU2xvd01vXCIsZnVuY3Rpb24odCxlLGkpe2U9ZXx8MD09PWU/ZTouNyxudWxsPT10P3Q9Ljc6dD4xJiYodD0xKSx0aGlzLl9wPTEhPT10P2U6MCx0aGlzLl9wMT0oMS10KS8yLHRoaXMuX3AyPXQsdGhpcy5fcDM9dGhpcy5fcDErdGhpcy5fcDIsdGhpcy5fY2FsY0VuZD1pPT09ITB9LCEwKSxkPW0ucHJvdG90eXBlPW5ldyB0O3JldHVybiBkLmNvbnN0cnVjdG9yPW0sZC5nZXRSYXRpbz1mdW5jdGlvbih0KXt2YXIgZT10KyguNS10KSp0aGlzLl9wO3JldHVybiB0aGlzLl9wMT50P3RoaXMuX2NhbGNFbmQ/MS0odD0xLXQvdGhpcy5fcDEpKnQ6ZS0odD0xLXQvdGhpcy5fcDEpKnQqdCp0KmU6dD50aGlzLl9wMz90aGlzLl9jYWxjRW5kPzEtKHQ9KHQtdGhpcy5fcDMpL3RoaXMuX3AxKSp0OmUrKHQtZSkqKHQ9KHQtdGhpcy5fcDMpL3RoaXMuX3AxKSp0KnQqdDp0aGlzLl9jYWxjRW5kPzE6ZX0sbS5lYXNlPW5ldyBtKC43LC43KSxkLmNvbmZpZz1tLmNvbmZpZz1mdW5jdGlvbih0LGUsaSl7cmV0dXJuIG5ldyBtKHQsZSxpKX0sZT1sKFwiZWFzaW5nLlN0ZXBwZWRFYXNlXCIsZnVuY3Rpb24odCl7dD10fHwxLHRoaXMuX3AxPTEvdCx0aGlzLl9wMj10KzF9LCEwKSxkPWUucHJvdG90eXBlPW5ldyB0LGQuY29uc3RydWN0b3I9ZSxkLmdldFJhdGlvPWZ1bmN0aW9uKHQpe3JldHVybiAwPnQ/dD0wOnQ+PTEmJih0PS45OTk5OTk5OTkpLCh0aGlzLl9wMip0Pj4wKSp0aGlzLl9wMX0sZC5jb25maWc9ZS5jb25maWc9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpfSxpPWwoXCJlYXNpbmcuUm91Z2hFYXNlXCIsZnVuY3Rpb24oZSl7ZT1lfHx7fTtmb3IodmFyIGkscyxyLG4sYSxvLGw9ZS50YXBlcnx8XCJub25lXCIsaD1bXSxfPTAsdT0wfChlLnBvaW50c3x8MjApLGY9dSxwPWUucmFuZG9taXplIT09ITEsbT1lLmNsYW1wPT09ITAsZD1lLnRlbXBsYXRlIGluc3RhbmNlb2YgdD9lLnRlbXBsYXRlOm51bGwsZz1cIm51bWJlclwiPT10eXBlb2YgZS5zdHJlbmd0aD8uNCplLnN0cmVuZ3RoOi40Oy0tZj4tMTspaT1wP01hdGgucmFuZG9tKCk6MS91KmYscz1kP2QuZ2V0UmF0aW8oaSk6aSxcIm5vbmVcIj09PWw/cj1nOlwib3V0XCI9PT1sPyhuPTEtaSxyPW4qbipnKTpcImluXCI9PT1sP3I9aSppKmc6LjU+aT8obj0yKmkscj0uNSpuKm4qZyk6KG49MiooMS1pKSxyPS41Km4qbipnKSxwP3MrPU1hdGgucmFuZG9tKCkqci0uNSpyOmYlMj9zKz0uNSpyOnMtPS41KnIsbSYmKHM+MT9zPTE6MD5zJiYocz0wKSksaFtfKytdPXt4OmkseTpzfTtmb3IoaC5zb3J0KGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQueC1lLnh9KSxvPW5ldyBjKDEsMSxudWxsKSxmPXU7LS1mPi0xOylhPWhbZl0sbz1uZXcgYyhhLngsYS55LG8pO3RoaXMuX3ByZXY9bmV3IGMoMCwwLDAhPT1vLnQ/bzpvLm5leHQpfSwhMCksZD1pLnByb3RvdHlwZT1uZXcgdCxkLmNvbnN0cnVjdG9yPWksZC5nZXRSYXRpbz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLl9wcmV2O2lmKHQ+ZS50KXtmb3IoO2UubmV4dCYmdD49ZS50OyllPWUubmV4dDtlPWUucHJldn1lbHNlIGZvcig7ZS5wcmV2JiZlLnQ+PXQ7KWU9ZS5wcmV2O3JldHVybiB0aGlzLl9wcmV2PWUsZS52Kyh0LWUudCkvZS5nYXAqZS5jfSxkLmNvbmZpZz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGkodCl9LGkuZWFzZT1uZXcgaSx1KFwiQm91bmNlXCIsaChcIkJvdW5jZU91dFwiLGZ1bmN0aW9uKHQpe3JldHVybiAxLzIuNzU+dD83LjU2MjUqdCp0OjIvMi43NT50PzcuNTYyNSoodC09MS41LzIuNzUpKnQrLjc1OjIuNS8yLjc1PnQ/Ny41NjI1Kih0LT0yLjI1LzIuNzUpKnQrLjkzNzU6Ny41NjI1Kih0LT0yLjYyNS8yLjc1KSp0Ky45ODQzNzV9KSxoKFwiQm91bmNlSW5cIixmdW5jdGlvbih0KXtyZXR1cm4gMS8yLjc1Pih0PTEtdCk/MS03LjU2MjUqdCp0OjIvMi43NT50PzEtKDcuNTYyNSoodC09MS41LzIuNzUpKnQrLjc1KToyLjUvMi43NT50PzEtKDcuNTYyNSoodC09Mi4yNS8yLjc1KSp0Ky45Mzc1KToxLSg3LjU2MjUqKHQtPTIuNjI1LzIuNzUpKnQrLjk4NDM3NSl9KSxoKFwiQm91bmNlSW5PdXRcIixmdW5jdGlvbih0KXt2YXIgZT0uNT50O3JldHVybiB0PWU/MS0yKnQ6Mip0LTEsdD0xLzIuNzU+dD83LjU2MjUqdCp0OjIvMi43NT50PzcuNTYyNSoodC09MS41LzIuNzUpKnQrLjc1OjIuNS8yLjc1PnQ/Ny41NjI1Kih0LT0yLjI1LzIuNzUpKnQrLjkzNzU6Ny41NjI1Kih0LT0yLjYyNS8yLjc1KSp0Ky45ODQzNzUsZT8uNSooMS10KTouNSp0Ky41fSkpLHUoXCJDaXJjXCIsaChcIkNpcmNPdXRcIixmdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5zcXJ0KDEtKHQtPTEpKnQpfSksaChcIkNpcmNJblwiLGZ1bmN0aW9uKHQpe3JldHVybi0oTWF0aC5zcXJ0KDEtdCp0KS0xKX0pLGgoXCJDaXJjSW5PdXRcIixmdW5jdGlvbih0KXtyZXR1cm4gMT4odCo9Mik/LS41KihNYXRoLnNxcnQoMS10KnQpLTEpOi41KihNYXRoLnNxcnQoMS0odC09MikqdCkrMSl9KSkscz1mdW5jdGlvbihlLGkscyl7dmFyIHI9bChcImVhc2luZy5cIitlLGZ1bmN0aW9uKHQsZSl7dGhpcy5fcDE9dD49MT90OjEsdGhpcy5fcDI9KGV8fHMpLygxPnQ/dDoxKSx0aGlzLl9wMz10aGlzLl9wMi9hKihNYXRoLmFzaW4oMS90aGlzLl9wMSl8fDApLHRoaXMuX3AyPWEvdGhpcy5fcDJ9LCEwKSxuPXIucHJvdG90eXBlPW5ldyB0O3JldHVybiBuLmNvbnN0cnVjdG9yPXIsbi5nZXRSYXRpbz1pLG4uY29uZmlnPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyByKHQsZSl9LHJ9LHUoXCJFbGFzdGljXCIscyhcIkVsYXN0aWNPdXRcIixmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fcDEqTWF0aC5wb3coMiwtMTAqdCkqTWF0aC5zaW4oKHQtdGhpcy5fcDMpKnRoaXMuX3AyKSsxfSwuMykscyhcIkVsYXN0aWNJblwiLGZ1bmN0aW9uKHQpe3JldHVybi0odGhpcy5fcDEqTWF0aC5wb3coMiwxMCoodC09MSkpKk1hdGguc2luKCh0LXRoaXMuX3AzKSp0aGlzLl9wMikpfSwuMykscyhcIkVsYXN0aWNJbk91dFwiLGZ1bmN0aW9uKHQpe3JldHVybiAxPih0Kj0yKT8tLjUqdGhpcy5fcDEqTWF0aC5wb3coMiwxMCoodC09MSkpKk1hdGguc2luKCh0LXRoaXMuX3AzKSp0aGlzLl9wMik6LjUqdGhpcy5fcDEqTWF0aC5wb3coMiwtMTAqKHQtPTEpKSpNYXRoLnNpbigodC10aGlzLl9wMykqdGhpcy5fcDIpKzF9LC40NSkpLHUoXCJFeHBvXCIsaChcIkV4cG9PdXRcIixmdW5jdGlvbih0KXtyZXR1cm4gMS1NYXRoLnBvdygyLC0xMCp0KX0pLGgoXCJFeHBvSW5cIixmdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5wb3coMiwxMCoodC0xKSktLjAwMX0pLGgoXCJFeHBvSW5PdXRcIixmdW5jdGlvbih0KXtyZXR1cm4gMT4odCo9Mik/LjUqTWF0aC5wb3coMiwxMCoodC0xKSk6LjUqKDItTWF0aC5wb3coMiwtMTAqKHQtMSkpKX0pKSx1KFwiU2luZVwiLGgoXCJTaW5lT3V0XCIsZnVuY3Rpb24odCl7cmV0dXJuIE1hdGguc2luKHQqbyl9KSxoKFwiU2luZUluXCIsZnVuY3Rpb24odCl7cmV0dXJuLU1hdGguY29zKHQqbykrMX0pLGgoXCJTaW5lSW5PdXRcIixmdW5jdGlvbih0KXtyZXR1cm4tLjUqKE1hdGguY29zKE1hdGguUEkqdCktMSl9KSksbChcImVhc2luZy5FYXNlTG9va3VwXCIse2ZpbmQ6ZnVuY3Rpb24oZSl7cmV0dXJuIHQubWFwW2VdfX0sITApLF8oci5TbG93TW8sXCJTbG93TW9cIixcImVhc2UsXCIpLF8oaSxcIlJvdWdoRWFzZVwiLFwiZWFzZSxcIiksXyhlLFwiU3RlcHBlZEVhc2VcIixcImVhc2UsXCIpLHB9LCEwKX0pLF9nc1Njb3BlLl9nc0RlZmluZSYmX2dzU2NvcGUuX2dzUXVldWUucG9wKCkoKSxmdW5jdGlvbih0LGUpe1widXNlIHN0cmljdFwiO3ZhciBpPXQuR3JlZW5Tb2NrR2xvYmFscz10LkdyZWVuU29ja0dsb2JhbHN8fHQ7aWYoIWkuVHdlZW5MaXRlKXt2YXIgcyxyLG4sYSxvLGw9ZnVuY3Rpb24odCl7dmFyIGUscz10LnNwbGl0KFwiLlwiKSxyPWk7Zm9yKGU9MDtzLmxlbmd0aD5lO2UrKylyW3NbZV1dPXI9cltzW2VdXXx8e307cmV0dXJuIHJ9LGg9bChcImNvbS5ncmVlbnNvY2tcIiksXz0xZS0xMCx1PWZ1bmN0aW9uKHQpe3ZhciBlLGk9W10scz10Lmxlbmd0aDtmb3IoZT0wO2UhPT1zO2kucHVzaCh0W2UrK10pKTtyZXR1cm4gaX0sYz1mdW5jdGlvbigpe30sZj1mdW5jdGlvbigpe3ZhciB0PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsZT10LmNhbGwoW10pO3JldHVybiBmdW5jdGlvbihpKXtyZXR1cm4gbnVsbCE9aSYmKGkgaW5zdGFuY2VvZiBBcnJheXx8XCJvYmplY3RcIj09dHlwZW9mIGkmJiEhaS5wdXNoJiZ0LmNhbGwoaSk9PT1lKX19KCkscD17fSxtPWZ1bmN0aW9uKHMscixuLGEpe3RoaXMuc2M9cFtzXT9wW3NdLnNjOltdLHBbc109dGhpcyx0aGlzLmdzQ2xhc3M9bnVsbCx0aGlzLmZ1bmM9bjt2YXIgbz1bXTt0aGlzLmNoZWNrPWZ1bmN0aW9uKGgpe2Zvcih2YXIgXyx1LGMsZixkLGc9ci5sZW5ndGgsdj1nOy0tZz4tMTspKF89cFtyW2ddXXx8bmV3IG0ocltnXSxbXSkpLmdzQ2xhc3M/KG9bZ109Xy5nc0NsYXNzLHYtLSk6aCYmXy5zYy5wdXNoKHRoaXMpO2lmKDA9PT12JiZuKWZvcih1PShcImNvbS5ncmVlbnNvY2suXCIrcykuc3BsaXQoXCIuXCIpLGM9dS5wb3AoKSxmPWwodS5qb2luKFwiLlwiKSlbY109dGhpcy5nc0NsYXNzPW4uYXBwbHkobixvKSxhJiYoaVtjXT1mLGQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHMsIWQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoKHQuR3JlZW5Tb2NrQU1EUGF0aD90LkdyZWVuU29ja0FNRFBhdGgrXCIvXCI6XCJcIikrcy5zcGxpdChcIi5cIikucG9wKCksW10sZnVuY3Rpb24oKXtyZXR1cm4gZn0pOnM9PT1lJiZkJiYobW9kdWxlLmV4cG9ydHM9ZikpLGc9MDt0aGlzLnNjLmxlbmd0aD5nO2crKyl0aGlzLnNjW2ddLmNoZWNrKCl9LHRoaXMuY2hlY2soITApfSxkPXQuX2dzRGVmaW5lPWZ1bmN0aW9uKHQsZSxpLHMpe3JldHVybiBuZXcgbSh0LGUsaSxzKX0sZz1oLl9jbGFzcz1mdW5jdGlvbih0LGUsaSl7cmV0dXJuIGU9ZXx8ZnVuY3Rpb24oKXt9LGQodCxbXSxmdW5jdGlvbigpe3JldHVybiBlfSxpKSxlfTtkLmdsb2JhbHM9aTt2YXIgdj1bMCwwLDEsMV0seT1bXSxUPWcoXCJlYXNpbmcuRWFzZVwiLGZ1bmN0aW9uKHQsZSxpLHMpe3RoaXMuX2Z1bmM9dCx0aGlzLl90eXBlPWl8fDAsdGhpcy5fcG93ZXI9c3x8MCx0aGlzLl9wYXJhbXM9ZT92LmNvbmNhdChlKTp2fSwhMCkseD1ULm1hcD17fSx3PVQucmVnaXN0ZXI9ZnVuY3Rpb24odCxlLGkscyl7Zm9yKHZhciByLG4sYSxvLGw9ZS5zcGxpdChcIixcIiksXz1sLmxlbmd0aCx1PShpfHxcImVhc2VJbixlYXNlT3V0LGVhc2VJbk91dFwiKS5zcGxpdChcIixcIik7LS1fPi0xOylmb3Iobj1sW19dLHI9cz9nKFwiZWFzaW5nLlwiK24sbnVsbCwhMCk6aC5lYXNpbmdbbl18fHt9LGE9dS5sZW5ndGg7LS1hPi0xOylvPXVbYV0seFtuK1wiLlwiK29dPXhbbytuXT1yW29dPXQuZ2V0UmF0aW8/dDp0W29dfHxuZXcgdH07Zm9yKG49VC5wcm90b3R5cGUsbi5fY2FsY0VuZD0hMSxuLmdldFJhdGlvPWZ1bmN0aW9uKHQpe2lmKHRoaXMuX2Z1bmMpcmV0dXJuIHRoaXMuX3BhcmFtc1swXT10LHRoaXMuX2Z1bmMuYXBwbHkobnVsbCx0aGlzLl9wYXJhbXMpO3ZhciBlPXRoaXMuX3R5cGUsaT10aGlzLl9wb3dlcixzPTE9PT1lPzEtdDoyPT09ZT90Oi41PnQ/Mip0OjIqKDEtdCk7cmV0dXJuIDE9PT1pP3MqPXM6Mj09PWk/cyo9cypzOjM9PT1pP3MqPXMqcypzOjQ9PT1pJiYocyo9cypzKnMqcyksMT09PWU/MS1zOjI9PT1lP3M6LjU+dD9zLzI6MS1zLzJ9LHM9W1wiTGluZWFyXCIsXCJRdWFkXCIsXCJDdWJpY1wiLFwiUXVhcnRcIixcIlF1aW50LFN0cm9uZ1wiXSxyPXMubGVuZ3RoOy0tcj4tMTspbj1zW3JdK1wiLFBvd2VyXCIrcix3KG5ldyBUKG51bGwsbnVsbCwxLHIpLG4sXCJlYXNlT3V0XCIsITApLHcobmV3IFQobnVsbCxudWxsLDIsciksbixcImVhc2VJblwiKygwPT09cj9cIixlYXNlTm9uZVwiOlwiXCIpKSx3KG5ldyBUKG51bGwsbnVsbCwzLHIpLG4sXCJlYXNlSW5PdXRcIik7eC5saW5lYXI9aC5lYXNpbmcuTGluZWFyLmVhc2VJbix4LnN3aW5nPWguZWFzaW5nLlF1YWQuZWFzZUluT3V0O3ZhciBiPWcoXCJldmVudHMuRXZlbnREaXNwYXRjaGVyXCIsZnVuY3Rpb24odCl7dGhpcy5fbGlzdGVuZXJzPXt9LHRoaXMuX2V2ZW50VGFyZ2V0PXR8fHRoaXN9KTtuPWIucHJvdG90eXBlLG4uYWRkRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbih0LGUsaSxzLHIpe3I9cnx8MDt2YXIgbixsLGg9dGhpcy5fbGlzdGVuZXJzW3RdLF89MDtmb3IobnVsbD09aCYmKHRoaXMuX2xpc3RlbmVyc1t0XT1oPVtdKSxsPWgubGVuZ3RoOy0tbD4tMTspbj1oW2xdLG4uYz09PWUmJm4ucz09PWk/aC5zcGxpY2UobCwxKTowPT09XyYmcj5uLnByJiYoXz1sKzEpO2guc3BsaWNlKF8sMCx7YzplLHM6aSx1cDpzLHByOnJ9KSx0aGlzIT09YXx8b3x8YS53YWtlKCl9LG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbih0LGUpe3ZhciBpLHM9dGhpcy5fbGlzdGVuZXJzW3RdO2lmKHMpZm9yKGk9cy5sZW5ndGg7LS1pPi0xOylpZihzW2ldLmM9PT1lKXJldHVybiBzLnNwbGljZShpLDEpLHZvaWQgMH0sbi5kaXNwYXRjaEV2ZW50PWZ1bmN0aW9uKHQpe3ZhciBlLGkscyxyPXRoaXMuX2xpc3RlbmVyc1t0XTtpZihyKWZvcihlPXIubGVuZ3RoLGk9dGhpcy5fZXZlbnRUYXJnZXQ7LS1lPi0xOylzPXJbZV0scyYmKHMudXA/cy5jLmNhbGwocy5zfHxpLHt0eXBlOnQsdGFyZ2V0Oml9KTpzLmMuY2FsbChzLnN8fGkpKX07dmFyIFA9dC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsaz10LmNhbmNlbEFuaW1hdGlvbkZyYW1lLFM9RGF0ZS5ub3d8fGZ1bmN0aW9uKCl7cmV0dXJuKG5ldyBEYXRlKS5nZXRUaW1lKCl9LFI9UygpO2ZvcihzPVtcIm1zXCIsXCJtb3pcIixcIndlYmtpdFwiLFwib1wiXSxyPXMubGVuZ3RoOy0tcj4tMSYmIVA7KVA9dFtzW3JdK1wiUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdLGs9dFtzW3JdK1wiQ2FuY2VsQW5pbWF0aW9uRnJhbWVcIl18fHRbc1tyXStcIkNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZVwiXTtnKFwiVGlja2VyXCIsZnVuY3Rpb24odCxlKXt2YXIgaSxzLHIsbixsLGg9dGhpcyx1PVMoKSxmPWUhPT0hMSYmUCxwPTUwMCxtPTMzLGQ9XCJ0aWNrXCIsZz1mdW5jdGlvbih0KXt2YXIgZSxhLG89UygpLVI7bz5wJiYodSs9by1tKSxSKz1vLGgudGltZT0oUi11KS8xZTMsZT1oLnRpbWUtbCwoIWl8fGU+MHx8dD09PSEwKSYmKGguZnJhbWUrKyxsKz1lKyhlPj1uPy4wMDQ6bi1lKSxhPSEwKSx0IT09ITAmJihyPXMoZykpLGEmJmguZGlzcGF0Y2hFdmVudChkKX07Yi5jYWxsKGgpLGgudGltZT1oLmZyYW1lPTAsaC50aWNrPWZ1bmN0aW9uKCl7ZyghMCl9LGgubGFnU21vb3RoaW5nPWZ1bmN0aW9uKHQsZSl7cD10fHwxL18sbT1NYXRoLm1pbihlLHAsMCl9LGguc2xlZXA9ZnVuY3Rpb24oKXtudWxsIT1yJiYoZiYmaz9rKHIpOmNsZWFyVGltZW91dChyKSxzPWMscj1udWxsLGg9PT1hJiYobz0hMSkpfSxoLndha2U9ZnVuY3Rpb24oKXtudWxsIT09cj9oLnNsZWVwKCk6aC5mcmFtZT4xMCYmKFI9UygpLXArNSkscz0wPT09aT9jOmYmJlA/UDpmdW5jdGlvbih0KXtyZXR1cm4gc2V0VGltZW91dCh0LDB8MWUzKihsLWgudGltZSkrMSl9LGg9PT1hJiYobz0hMCksZygyKX0saC5mcHM9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGk9dCxuPTEvKGl8fDYwKSxsPXRoaXMudGltZStuLGgud2FrZSgpLHZvaWQgMCk6aX0saC51c2VSQUY9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGguc2xlZXAoKSxmPXQsaC5mcHMoaSksdm9pZCAwKTpmfSxoLmZwcyh0KSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZiYmNT5oLmZyYW1lJiZoLnVzZVJBRighMSl9LDE1MDApfSksbj1oLlRpY2tlci5wcm90b3R5cGU9bmV3IGguZXZlbnRzLkV2ZW50RGlzcGF0Y2hlcixuLmNvbnN0cnVjdG9yPWguVGlja2VyO3ZhciBPPWcoXCJjb3JlLkFuaW1hdGlvblwiLGZ1bmN0aW9uKHQsZSl7aWYodGhpcy52YXJzPWU9ZXx8e30sdGhpcy5fZHVyYXRpb249dGhpcy5fdG90YWxEdXJhdGlvbj10fHwwLHRoaXMuX2RlbGF5PU51bWJlcihlLmRlbGF5KXx8MCx0aGlzLl90aW1lU2NhbGU9MSx0aGlzLl9hY3RpdmU9ZS5pbW1lZGlhdGVSZW5kZXI9PT0hMCx0aGlzLmRhdGE9ZS5kYXRhLHRoaXMuX3JldmVyc2VkPWUucmV2ZXJzZWQ9PT0hMCxXKXtvfHxhLndha2UoKTt2YXIgaT10aGlzLnZhcnMudXNlRnJhbWVzP0c6VztpLmFkZCh0aGlzLGkuX3RpbWUpLHRoaXMudmFycy5wYXVzZWQmJnRoaXMucGF1c2VkKCEwKX19KTthPU8udGlja2VyPW5ldyBoLlRpY2tlcixuPU8ucHJvdG90eXBlLG4uX2RpcnR5PW4uX2djPW4uX2luaXR0ZWQ9bi5fcGF1c2VkPSExLG4uX3RvdGFsVGltZT1uLl90aW1lPTAsbi5fcmF3UHJldlRpbWU9LTEsbi5fbmV4dD1uLl9sYXN0PW4uX29uVXBkYXRlPW4uX3RpbWVsaW5lPW4udGltZWxpbmU9bnVsbCxuLl9wYXVzZWQ9ITE7dmFyIEE9ZnVuY3Rpb24oKXtvJiZTKCktUj4yZTMmJmEud2FrZSgpLHNldFRpbWVvdXQoQSwyZTMpfTtBKCksbi5wbGF5PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG51bGwhPXQmJnRoaXMuc2Vlayh0LGUpLHRoaXMucmV2ZXJzZWQoITEpLnBhdXNlZCghMSl9LG4ucGF1c2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbCE9dCYmdGhpcy5zZWVrKHQsZSksdGhpcy5wYXVzZWQoITApfSxuLnJlc3VtZT1mdW5jdGlvbih0LGUpe3JldHVybiBudWxsIT10JiZ0aGlzLnNlZWsodCxlKSx0aGlzLnBhdXNlZCghMSl9LG4uc2Vlaz1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRvdGFsVGltZShOdW1iZXIodCksZSE9PSExKX0sbi5yZXN0YXJ0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMucmV2ZXJzZWQoITEpLnBhdXNlZCghMSkudG90YWxUaW1lKHQ/LXRoaXMuX2RlbGF5OjAsZSE9PSExLCEwKX0sbi5yZXZlcnNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG51bGwhPXQmJnRoaXMuc2Vlayh0fHx0aGlzLnRvdGFsRHVyYXRpb24oKSxlKSx0aGlzLnJldmVyc2VkKCEwKS5wYXVzZWQoITEpfSxuLnJlbmRlcj1mdW5jdGlvbigpe30sbi5pbnZhbGlkYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3RpbWU9dGhpcy5fdG90YWxUaW1lPTAsdGhpcy5faW5pdHRlZD10aGlzLl9nYz0hMSx0aGlzLl9yYXdQcmV2VGltZT0tMSwodGhpcy5fZ2N8fCF0aGlzLnRpbWVsaW5lKSYmdGhpcy5fZW5hYmxlZCghMCksdGhpc30sbi5pc0FjdGl2ZT1mdW5jdGlvbigpe3ZhciB0LGU9dGhpcy5fdGltZWxpbmUsaT10aGlzLl9zdGFydFRpbWU7cmV0dXJuIWV8fCF0aGlzLl9nYyYmIXRoaXMuX3BhdXNlZCYmZS5pc0FjdGl2ZSgpJiYodD1lLnJhd1RpbWUoKSk+PWkmJmkrdGhpcy50b3RhbER1cmF0aW9uKCkvdGhpcy5fdGltZVNjYWxlPnR9LG4uX2VuYWJsZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gb3x8YS53YWtlKCksdGhpcy5fZ2M9IXQsdGhpcy5fYWN0aXZlPXRoaXMuaXNBY3RpdmUoKSxlIT09ITAmJih0JiYhdGhpcy50aW1lbGluZT90aGlzLl90aW1lbGluZS5hZGQodGhpcyx0aGlzLl9zdGFydFRpbWUtdGhpcy5fZGVsYXkpOiF0JiZ0aGlzLnRpbWVsaW5lJiZ0aGlzLl90aW1lbGluZS5fcmVtb3ZlKHRoaXMsITApKSwhMX0sbi5fa2lsbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9lbmFibGVkKCExLCExKX0sbi5raWxsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2tpbGwodCxlKSx0aGlzfSxuLl91bmNhY2hlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10P3RoaXM6dGhpcy50aW1lbGluZTtlOyllLl9kaXJ0eT0hMCxlPWUudGltZWxpbmU7cmV0dXJuIHRoaXN9LG4uX3N3YXBTZWxmSW5QYXJhbXM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQubGVuZ3RoLGk9dC5jb25jYXQoKTstLWU+LTE7KVwie3NlbGZ9XCI9PT10W2VdJiYoaVtlXT10aGlzKTtyZXR1cm4gaX0sbi5fY2FsbGJhY2s9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy52YXJzO2VbdF0uYXBwbHkoZVt0K1wiU2NvcGVcIl18fGUuY2FsbGJhY2tTY29wZXx8dGhpcyxlW3QrXCJQYXJhbXNcIl18fHkpfSxuLmV2ZW50Q2FsbGJhY2s9ZnVuY3Rpb24odCxlLGkscyl7aWYoXCJvblwiPT09KHR8fFwiXCIpLnN1YnN0cigwLDIpKXt2YXIgcj10aGlzLnZhcnM7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHJbdF07bnVsbD09ZT9kZWxldGUgclt0XTooclt0XT1lLHJbdCtcIlBhcmFtc1wiXT1mKGkpJiYtMSE9PWkuam9pbihcIlwiKS5pbmRleE9mKFwie3NlbGZ9XCIpP3RoaXMuX3N3YXBTZWxmSW5QYXJhbXMoaSk6aSxyW3QrXCJTY29wZVwiXT1zKSxcIm9uVXBkYXRlXCI9PT10JiYodGhpcy5fb25VcGRhdGU9ZSl9cmV0dXJuIHRoaXN9LG4uZGVsYXk9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nJiZ0aGlzLnN0YXJ0VGltZSh0aGlzLl9zdGFydFRpbWUrdC10aGlzLl9kZWxheSksdGhpcy5fZGVsYXk9dCx0aGlzKTp0aGlzLl9kZWxheX0sbi5kdXJhdGlvbj1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odGhpcy5fZHVyYXRpb249dGhpcy5fdG90YWxEdXJhdGlvbj10LHRoaXMuX3VuY2FjaGUoITApLHRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nJiZ0aGlzLl90aW1lPjAmJnRoaXMuX3RpbWU8dGhpcy5fZHVyYXRpb24mJjAhPT10JiZ0aGlzLnRvdGFsVGltZSh0aGlzLl90b3RhbFRpbWUqKHQvdGhpcy5fZHVyYXRpb24pLCEwKSx0aGlzKToodGhpcy5fZGlydHk9ITEsdGhpcy5fZHVyYXRpb24pfSxuLnRvdGFsRHVyYXRpb249ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2RpcnR5PSExLGFyZ3VtZW50cy5sZW5ndGg/dGhpcy5kdXJhdGlvbih0KTp0aGlzLl90b3RhbER1cmF0aW9ufSxuLnRpbWU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odGhpcy5fZGlydHkmJnRoaXMudG90YWxEdXJhdGlvbigpLHRoaXMudG90YWxUaW1lKHQ+dGhpcy5fZHVyYXRpb24/dGhpcy5fZHVyYXRpb246dCxlKSk6dGhpcy5fdGltZX0sbi50b3RhbFRpbWU9ZnVuY3Rpb24odCxlLGkpe2lmKG98fGEud2FrZSgpLCFhcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLl90b3RhbFRpbWU7aWYodGhpcy5fdGltZWxpbmUpe2lmKDA+dCYmIWkmJih0Kz10aGlzLnRvdGFsRHVyYXRpb24oKSksdGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpe3RoaXMuX2RpcnR5JiZ0aGlzLnRvdGFsRHVyYXRpb24oKTt2YXIgcz10aGlzLl90b3RhbER1cmF0aW9uLHI9dGhpcy5fdGltZWxpbmU7aWYodD5zJiYhaSYmKHQ9cyksdGhpcy5fc3RhcnRUaW1lPSh0aGlzLl9wYXVzZWQ/dGhpcy5fcGF1c2VUaW1lOnIuX3RpbWUpLSh0aGlzLl9yZXZlcnNlZD9zLXQ6dCkvdGhpcy5fdGltZVNjYWxlLHIuX2RpcnR5fHx0aGlzLl91bmNhY2hlKCExKSxyLl90aW1lbGluZSlmb3IoO3IuX3RpbWVsaW5lOylyLl90aW1lbGluZS5fdGltZSE9PShyLl9zdGFydFRpbWUrci5fdG90YWxUaW1lKS9yLl90aW1lU2NhbGUmJnIudG90YWxUaW1lKHIuX3RvdGFsVGltZSwhMCkscj1yLl90aW1lbGluZX10aGlzLl9nYyYmdGhpcy5fZW5hYmxlZCghMCwhMSksKHRoaXMuX3RvdGFsVGltZSE9PXR8fDA9PT10aGlzLl9kdXJhdGlvbikmJihGLmxlbmd0aCYmUSgpLHRoaXMucmVuZGVyKHQsZSwhMSksRi5sZW5ndGgmJlEoKSl9cmV0dXJuIHRoaXN9LG4ucHJvZ3Jlc3M9bi50b3RhbFByb2dyZXNzPWZ1bmN0aW9uKHQsZSl7dmFyIGk9dGhpcy5kdXJhdGlvbigpO3JldHVybiBhcmd1bWVudHMubGVuZ3RoP3RoaXMudG90YWxUaW1lKGkqdCxlKTppP3RoaXMuX3RpbWUvaTp0aGlzLnJhdGlvfSxuLnN0YXJ0VGltZT1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odCE9PXRoaXMuX3N0YXJ0VGltZSYmKHRoaXMuX3N0YXJ0VGltZT10LHRoaXMudGltZWxpbmUmJnRoaXMudGltZWxpbmUuX3NvcnRDaGlsZHJlbiYmdGhpcy50aW1lbGluZS5hZGQodGhpcyx0LXRoaXMuX2RlbGF5KSksdGhpcyk6dGhpcy5fc3RhcnRUaW1lfSxuLmVuZFRpbWU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3N0YXJ0VGltZSsoMCE9dD90aGlzLnRvdGFsRHVyYXRpb24oKTp0aGlzLmR1cmF0aW9uKCkpL3RoaXMuX3RpbWVTY2FsZX0sbi50aW1lU2NhbGU9ZnVuY3Rpb24odCl7aWYoIWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuX3RpbWVTY2FsZTtpZih0PXR8fF8sdGhpcy5fdGltZWxpbmUmJnRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKXt2YXIgZT10aGlzLl9wYXVzZVRpbWUsaT1lfHwwPT09ZT9lOnRoaXMuX3RpbWVsaW5lLnRvdGFsVGltZSgpO3RoaXMuX3N0YXJ0VGltZT1pLShpLXRoaXMuX3N0YXJ0VGltZSkqdGhpcy5fdGltZVNjYWxlL3R9cmV0dXJuIHRoaXMuX3RpbWVTY2FsZT10LHRoaXMuX3VuY2FjaGUoITEpfSxuLnJldmVyc2VkPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh0IT10aGlzLl9yZXZlcnNlZCYmKHRoaXMuX3JldmVyc2VkPXQsdGhpcy50b3RhbFRpbWUodGhpcy5fdGltZWxpbmUmJiF0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZz90aGlzLnRvdGFsRHVyYXRpb24oKS10aGlzLl90b3RhbFRpbWU6dGhpcy5fdG90YWxUaW1lLCEwKSksdGhpcyk6dGhpcy5fcmV2ZXJzZWR9LG4ucGF1c2VkPWZ1bmN0aW9uKHQpe2lmKCFhcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLl9wYXVzZWQ7dmFyIGUsaSxzPXRoaXMuX3RpbWVsaW5lO3JldHVybiB0IT10aGlzLl9wYXVzZWQmJnMmJihvfHx0fHxhLndha2UoKSxlPXMucmF3VGltZSgpLGk9ZS10aGlzLl9wYXVzZVRpbWUsIXQmJnMuc21vb3RoQ2hpbGRUaW1pbmcmJih0aGlzLl9zdGFydFRpbWUrPWksdGhpcy5fdW5jYWNoZSghMSkpLHRoaXMuX3BhdXNlVGltZT10P2U6bnVsbCx0aGlzLl9wYXVzZWQ9dCx0aGlzLl9hY3RpdmU9dGhpcy5pc0FjdGl2ZSgpLCF0JiYwIT09aSYmdGhpcy5faW5pdHRlZCYmdGhpcy5kdXJhdGlvbigpJiYoZT1zLnNtb290aENoaWxkVGltaW5nP3RoaXMuX3RvdGFsVGltZTooZS10aGlzLl9zdGFydFRpbWUpL3RoaXMuX3RpbWVTY2FsZSx0aGlzLnJlbmRlcihlLGU9PT10aGlzLl90b3RhbFRpbWUsITApKSksdGhpcy5fZ2MmJiF0JiZ0aGlzLl9lbmFibGVkKCEwLCExKSx0aGlzfTt2YXIgQz1nKFwiY29yZS5TaW1wbGVUaW1lbGluZVwiLGZ1bmN0aW9uKHQpe08uY2FsbCh0aGlzLDAsdCksdGhpcy5hdXRvUmVtb3ZlQ2hpbGRyZW49dGhpcy5zbW9vdGhDaGlsZFRpbWluZz0hMH0pO249Qy5wcm90b3R5cGU9bmV3IE8sbi5jb25zdHJ1Y3Rvcj1DLG4ua2lsbCgpLl9nYz0hMSxuLl9maXJzdD1uLl9sYXN0PW4uX3JlY2VudD1udWxsLG4uX3NvcnRDaGlsZHJlbj0hMSxuLmFkZD1uLmluc2VydD1mdW5jdGlvbih0LGUpe3ZhciBpLHM7aWYodC5fc3RhcnRUaW1lPU51bWJlcihlfHwwKSt0Ll9kZWxheSx0Ll9wYXVzZWQmJnRoaXMhPT10Ll90aW1lbGluZSYmKHQuX3BhdXNlVGltZT10Ll9zdGFydFRpbWUrKHRoaXMucmF3VGltZSgpLXQuX3N0YXJ0VGltZSkvdC5fdGltZVNjYWxlKSx0LnRpbWVsaW5lJiZ0LnRpbWVsaW5lLl9yZW1vdmUodCwhMCksdC50aW1lbGluZT10Ll90aW1lbGluZT10aGlzLHQuX2djJiZ0Ll9lbmFibGVkKCEwLCEwKSxpPXRoaXMuX2xhc3QsdGhpcy5fc29ydENoaWxkcmVuKWZvcihzPXQuX3N0YXJ0VGltZTtpJiZpLl9zdGFydFRpbWU+czspaT1pLl9wcmV2O3JldHVybiBpPyh0Ll9uZXh0PWkuX25leHQsaS5fbmV4dD10KToodC5fbmV4dD10aGlzLl9maXJzdCx0aGlzLl9maXJzdD10KSx0Ll9uZXh0P3QuX25leHQuX3ByZXY9dDp0aGlzLl9sYXN0PXQsdC5fcHJldj1pLHRoaXMuX3JlY2VudD10LHRoaXMuX3RpbWVsaW5lJiZ0aGlzLl91bmNhY2hlKCEwKSx0aGlzfSxuLl9yZW1vdmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC50aW1lbGluZT09PXRoaXMmJihlfHx0Ll9lbmFibGVkKCExLCEwKSx0Ll9wcmV2P3QuX3ByZXYuX25leHQ9dC5fbmV4dDp0aGlzLl9maXJzdD09PXQmJih0aGlzLl9maXJzdD10Ll9uZXh0KSx0Ll9uZXh0P3QuX25leHQuX3ByZXY9dC5fcHJldjp0aGlzLl9sYXN0PT09dCYmKHRoaXMuX2xhc3Q9dC5fcHJldiksdC5fbmV4dD10Ll9wcmV2PXQudGltZWxpbmU9bnVsbCx0PT09dGhpcy5fcmVjZW50JiYodGhpcy5fcmVjZW50PXRoaXMuX2xhc3QpLHRoaXMuX3RpbWVsaW5lJiZ0aGlzLl91bmNhY2hlKCEwKSksdGhpc30sbi5yZW5kZXI9ZnVuY3Rpb24odCxlLGkpe3ZhciBzLHI9dGhpcy5fZmlyc3Q7Zm9yKHRoaXMuX3RvdGFsVGltZT10aGlzLl90aW1lPXRoaXMuX3Jhd1ByZXZUaW1lPXQ7cjspcz1yLl9uZXh0LChyLl9hY3RpdmV8fHQ+PXIuX3N0YXJ0VGltZSYmIXIuX3BhdXNlZCkmJihyLl9yZXZlcnNlZD9yLnJlbmRlcigoci5fZGlydHk/ci50b3RhbER1cmF0aW9uKCk6ci5fdG90YWxEdXJhdGlvbiktKHQtci5fc3RhcnRUaW1lKSpyLl90aW1lU2NhbGUsZSxpKTpyLnJlbmRlcigodC1yLl9zdGFydFRpbWUpKnIuX3RpbWVTY2FsZSxlLGkpKSxyPXN9LG4ucmF3VGltZT1mdW5jdGlvbigpe3JldHVybiBvfHxhLndha2UoKSx0aGlzLl90b3RhbFRpbWV9O3ZhciBEPWcoXCJUd2VlbkxpdGVcIixmdW5jdGlvbihlLGkscyl7aWYoTy5jYWxsKHRoaXMsaSxzKSx0aGlzLnJlbmRlcj1ELnByb3RvdHlwZS5yZW5kZXIsbnVsbD09ZSl0aHJvd1wiQ2Fubm90IHR3ZWVuIGEgbnVsbCB0YXJnZXQuXCI7dGhpcy50YXJnZXQ9ZT1cInN0cmluZ1wiIT10eXBlb2YgZT9lOkQuc2VsZWN0b3IoZSl8fGU7dmFyIHIsbixhLG89ZS5qcXVlcnl8fGUubGVuZ3RoJiZlIT09dCYmZVswXSYmKGVbMF09PT10fHxlWzBdLm5vZGVUeXBlJiZlWzBdLnN0eWxlJiYhZS5ub2RlVHlwZSksbD10aGlzLnZhcnMub3ZlcndyaXRlO2lmKHRoaXMuX292ZXJ3cml0ZT1sPW51bGw9PWw/VltELmRlZmF1bHRPdmVyd3JpdGVdOlwibnVtYmVyXCI9PXR5cGVvZiBsP2w+PjA6VltsXSwob3x8ZSBpbnN0YW5jZW9mIEFycmF5fHxlLnB1c2gmJmYoZSkpJiZcIm51bWJlclwiIT10eXBlb2YgZVswXSlmb3IodGhpcy5fdGFyZ2V0cz1hPXUoZSksdGhpcy5fcHJvcExvb2t1cD1bXSx0aGlzLl9zaWJsaW5ncz1bXSxyPTA7YS5sZW5ndGg+cjtyKyspbj1hW3JdLG4/XCJzdHJpbmdcIiE9dHlwZW9mIG4/bi5sZW5ndGgmJm4hPT10JiZuWzBdJiYoblswXT09PXR8fG5bMF0ubm9kZVR5cGUmJm5bMF0uc3R5bGUmJiFuLm5vZGVUeXBlKT8oYS5zcGxpY2Uoci0tLDEpLHRoaXMuX3RhcmdldHM9YT1hLmNvbmNhdCh1KG4pKSk6KHRoaXMuX3NpYmxpbmdzW3JdPSQobix0aGlzLCExKSwxPT09bCYmdGhpcy5fc2libGluZ3Nbcl0ubGVuZ3RoPjEmJksobix0aGlzLG51bGwsMSx0aGlzLl9zaWJsaW5nc1tyXSkpOihuPWFbci0tXT1ELnNlbGVjdG9yKG4pLFwic3RyaW5nXCI9PXR5cGVvZiBuJiZhLnNwbGljZShyKzEsMSkpOmEuc3BsaWNlKHItLSwxKTtlbHNlIHRoaXMuX3Byb3BMb29rdXA9e30sdGhpcy5fc2libGluZ3M9JChlLHRoaXMsITEpLDE9PT1sJiZ0aGlzLl9zaWJsaW5ncy5sZW5ndGg+MSYmSyhlLHRoaXMsbnVsbCwxLHRoaXMuX3NpYmxpbmdzKTsodGhpcy52YXJzLmltbWVkaWF0ZVJlbmRlcnx8MD09PWkmJjA9PT10aGlzLl9kZWxheSYmdGhpcy52YXJzLmltbWVkaWF0ZVJlbmRlciE9PSExKSYmKHRoaXMuX3RpbWU9LV8sdGhpcy5yZW5kZXIoLXRoaXMuX2RlbGF5KSl9LCEwKSxNPWZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLmxlbmd0aCYmZSE9PXQmJmVbMF0mJihlWzBdPT09dHx8ZVswXS5ub2RlVHlwZSYmZVswXS5zdHlsZSYmIWUubm9kZVR5cGUpfSx6PWZ1bmN0aW9uKHQsZSl7dmFyIGkscz17fTtmb3IoaSBpbiB0KXFbaV18fGkgaW4gZSYmXCJ0cmFuc2Zvcm1cIiE9PWkmJlwieFwiIT09aSYmXCJ5XCIhPT1pJiZcIndpZHRoXCIhPT1pJiZcImhlaWdodFwiIT09aSYmXCJjbGFzc05hbWVcIiE9PWkmJlwiYm9yZGVyXCIhPT1pfHwhKCFqW2ldfHxqW2ldJiZqW2ldLl9hdXRvQ1NTKXx8KHNbaV09dFtpXSxkZWxldGUgdFtpXSk7dC5jc3M9c307bj1ELnByb3RvdHlwZT1uZXcgTyxuLmNvbnN0cnVjdG9yPUQsbi5raWxsKCkuX2djPSExLG4ucmF0aW89MCxuLl9maXJzdFBUPW4uX3RhcmdldHM9bi5fb3ZlcndyaXR0ZW5Qcm9wcz1uLl9zdGFydEF0PW51bGwsbi5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZD1uLl9sYXp5PSExLEQudmVyc2lvbj1cIjEuMTguMFwiLEQuZGVmYXVsdEVhc2U9bi5fZWFzZT1uZXcgVChudWxsLG51bGwsMSwxKSxELmRlZmF1bHRPdmVyd3JpdGU9XCJhdXRvXCIsRC50aWNrZXI9YSxELmF1dG9TbGVlcD0xMjAsRC5sYWdTbW9vdGhpbmc9ZnVuY3Rpb24odCxlKXthLmxhZ1Ntb290aGluZyh0LGUpfSxELnNlbGVjdG9yPXQuJHx8dC5qUXVlcnl8fGZ1bmN0aW9uKGUpe3ZhciBpPXQuJHx8dC5qUXVlcnk7cmV0dXJuIGk/KEQuc2VsZWN0b3I9aSxpKGUpKTpcInVuZGVmaW5lZFwiPT10eXBlb2YgZG9jdW1lbnQ/ZTpkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsP2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZSk6ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCIjXCI9PT1lLmNoYXJBdCgwKT9lLnN1YnN0cigxKTplKX07dmFyIEY9W10sST17fSxFPS8oPzooLXwtPXxcXCs9KT9cXGQqXFwuP1xcZCooPzplW1xcLStdP1xcZCspPylbMC05XS9naSxOPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxpPXRoaXMuX2ZpcnN0UFQscz0xZS02O2k7KWU9aS5ibG9iP3Q/dGhpcy5qb2luKFwiXCIpOnRoaXMuc3RhcnQ6aS5jKnQraS5zLGkucj9lPU1hdGgucm91bmQoZSk6cz5lJiZlPi1zJiYoZT0wKSxpLmY/aS5mcD9pLnRbaS5wXShpLmZwLGUpOmkudFtpLnBdKGUpOmkudFtpLnBdPWUsaT1pLl9uZXh0fSxMPWZ1bmN0aW9uKHQsZSxpLHMpe3ZhciByLG4sYSxvLGwsaCxfLHU9W3QsZV0sYz0wLGY9XCJcIixwPTA7Zm9yKHUuc3RhcnQ9dCxpJiYoaSh1KSx0PXVbMF0sZT11WzFdKSx1Lmxlbmd0aD0wLHI9dC5tYXRjaChFKXx8W10sbj1lLm1hdGNoKEUpfHxbXSxzJiYocy5fbmV4dD1udWxsLHMuYmxvYj0xLHUuX2ZpcnN0UFQ9cyksbD1uLmxlbmd0aCxvPTA7bD5vO28rKylfPW5bb10saD1lLnN1YnN0cihjLGUuaW5kZXhPZihfLGMpLWMpLGYrPWh8fCFvP2g6XCIsXCIsYys9aC5sZW5ndGgscD9wPShwKzEpJTU6XCJyZ2JhKFwiPT09aC5zdWJzdHIoLTUpJiYocD0xKSxfPT09cltvXXx8bz49ci5sZW5ndGg/Zis9XzooZiYmKHUucHVzaChmKSxmPVwiXCIpLGE9cGFyc2VGbG9hdChyW29dKSx1LnB1c2goYSksdS5fZmlyc3RQVD17X25leHQ6dS5fZmlyc3RQVCx0OnUscDp1Lmxlbmd0aC0xLHM6YSxjOihcIj1cIj09PV8uY2hhckF0KDEpP3BhcnNlSW50KF8uY2hhckF0KDApK1wiMVwiLDEwKSpwYXJzZUZsb2F0KF8uc3Vic3RyKDIpKTpwYXJzZUZsb2F0KF8pLWEpfHwwLGY6MCxyOnAmJjQ+cH0pLGMrPV8ubGVuZ3RoO3JldHVybiBmKz1lLnN1YnN0cihjKSxmJiZ1LnB1c2goZiksdS5zZXRSYXRpbz1OLHV9LFg9ZnVuY3Rpb24odCxlLGkscyxyLG4sYSxvKXt2YXIgbCxoLF89XCJnZXRcIj09PWk/dFtlXTppLHU9dHlwZW9mIHRbZV0sYz1cInN0cmluZ1wiPT10eXBlb2YgcyYmXCI9XCI9PT1zLmNoYXJBdCgxKSxmPXt0OnQscDplLHM6XyxmOlwiZnVuY3Rpb25cIj09PXUscGc6MCxuOnJ8fGUscjpuLHByOjAsYzpjP3BhcnNlSW50KHMuY2hhckF0KDApK1wiMVwiLDEwKSpwYXJzZUZsb2F0KHMuc3Vic3RyKDIpKTpwYXJzZUZsb2F0KHMpLV98fDB9O3JldHVyblwibnVtYmVyXCIhPT11JiYoXCJmdW5jdGlvblwiPT09dSYmXCJnZXRcIj09PWkmJihoPWUuaW5kZXhPZihcInNldFwiKXx8XCJmdW5jdGlvblwiIT10eXBlb2YgdFtcImdldFwiK2Uuc3Vic3RyKDMpXT9lOlwiZ2V0XCIrZS5zdWJzdHIoMyksZi5zPV89YT90W2hdKGEpOnRbaF0oKSksXCJzdHJpbmdcIj09dHlwZW9mIF8mJihhfHxpc05hTihfKSk/KGYuZnA9YSxsPUwoXyxzLG98fEQuZGVmYXVsdFN0cmluZ0ZpbHRlcixmKSxmPXt0OmwscDpcInNldFJhdGlvXCIsczowLGM6MSxmOjIscGc6MCxuOnJ8fGUscHI6MH0pOmN8fChmLmM9cGFyc2VGbG9hdChzKS1wYXJzZUZsb2F0KF8pfHwwKSksZi5jPygoZi5fbmV4dD10aGlzLl9maXJzdFBUKSYmKGYuX25leHQuX3ByZXY9ZiksdGhpcy5fZmlyc3RQVD1mLGYpOnZvaWQgMH0sQj1ELl9pbnRlcm5hbHM9e2lzQXJyYXk6Zixpc1NlbGVjdG9yOk0sbGF6eVR3ZWVuczpGLGJsb2JEaWY6TH0saj1ELl9wbHVnaW5zPXt9LFk9Qi50d2Vlbkxvb2t1cD17fSxVPTAscT1CLnJlc2VydmVkUHJvcHM9e2Vhc2U6MSxkZWxheToxLG92ZXJ3cml0ZToxLG9uQ29tcGxldGU6MSxvbkNvbXBsZXRlUGFyYW1zOjEsb25Db21wbGV0ZVNjb3BlOjEsdXNlRnJhbWVzOjEscnVuQmFja3dhcmRzOjEsc3RhcnRBdDoxLG9uVXBkYXRlOjEsb25VcGRhdGVQYXJhbXM6MSxvblVwZGF0ZVNjb3BlOjEsb25TdGFydDoxLG9uU3RhcnRQYXJhbXM6MSxvblN0YXJ0U2NvcGU6MSxvblJldmVyc2VDb21wbGV0ZToxLG9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zOjEsb25SZXZlcnNlQ29tcGxldGVTY29wZToxLG9uUmVwZWF0OjEsb25SZXBlYXRQYXJhbXM6MSxvblJlcGVhdFNjb3BlOjEsZWFzZVBhcmFtczoxLHlveW86MSxpbW1lZGlhdGVSZW5kZXI6MSxyZXBlYXQ6MSxyZXBlYXREZWxheToxLGRhdGE6MSxwYXVzZWQ6MSxyZXZlcnNlZDoxLGF1dG9DU1M6MSxsYXp5OjEsb25PdmVyd3JpdGU6MSxjYWxsYmFja1Njb3BlOjEsc3RyaW5nRmlsdGVyOjF9LFY9e25vbmU6MCxhbGw6MSxhdXRvOjIsY29uY3VycmVudDozLGFsbE9uU3RhcnQ6NCxwcmVleGlzdGluZzo1LFwidHJ1ZVwiOjEsXCJmYWxzZVwiOjB9LEc9Ty5fcm9vdEZyYW1lc1RpbWVsaW5lPW5ldyBDLFc9Ty5fcm9vdFRpbWVsaW5lPW5ldyBDLFo9MzAsUT1CLmxhenlSZW5kZXI9ZnVuY3Rpb24oKXt2YXIgdCxlPUYubGVuZ3RoO2ZvcihJPXt9Oy0tZT4tMTspdD1GW2VdLHQmJnQuX2xhenkhPT0hMSYmKHQucmVuZGVyKHQuX2xhenlbMF0sdC5fbGF6eVsxXSwhMCksdC5fbGF6eT0hMSk7Ri5sZW5ndGg9MH07Vy5fc3RhcnRUaW1lPWEudGltZSxHLl9zdGFydFRpbWU9YS5mcmFtZSxXLl9hY3RpdmU9Ry5fYWN0aXZlPSEwLHNldFRpbWVvdXQoUSwxKSxPLl91cGRhdGVSb290PUQucmVuZGVyPWZ1bmN0aW9uKCl7dmFyIHQsZSxpO2lmKEYubGVuZ3RoJiZRKCksVy5yZW5kZXIoKGEudGltZS1XLl9zdGFydFRpbWUpKlcuX3RpbWVTY2FsZSwhMSwhMSksRy5yZW5kZXIoKGEuZnJhbWUtRy5fc3RhcnRUaW1lKSpHLl90aW1lU2NhbGUsITEsITEpLEYubGVuZ3RoJiZRKCksYS5mcmFtZT49Wil7Wj1hLmZyYW1lKyhwYXJzZUludChELmF1dG9TbGVlcCwxMCl8fDEyMCk7XG5mb3IoaSBpbiBZKXtmb3IoZT1ZW2ldLnR3ZWVucyx0PWUubGVuZ3RoOy0tdD4tMTspZVt0XS5fZ2MmJmUuc3BsaWNlKHQsMSk7MD09PWUubGVuZ3RoJiZkZWxldGUgWVtpXX1pZihpPVcuX2ZpcnN0LCghaXx8aS5fcGF1c2VkKSYmRC5hdXRvU2xlZXAmJiFHLl9maXJzdCYmMT09PWEuX2xpc3RlbmVycy50aWNrLmxlbmd0aCl7Zm9yKDtpJiZpLl9wYXVzZWQ7KWk9aS5fbmV4dDtpfHxhLnNsZWVwKCl9fX0sYS5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLE8uX3VwZGF0ZVJvb3QpO3ZhciAkPWZ1bmN0aW9uKHQsZSxpKXt2YXIgcyxyLG49dC5fZ3NUd2VlbklEO2lmKFlbbnx8KHQuX2dzVHdlZW5JRD1uPVwidFwiK1UrKyldfHwoWVtuXT17dGFyZ2V0OnQsdHdlZW5zOltdfSksZSYmKHM9WVtuXS50d2VlbnMsc1tyPXMubGVuZ3RoXT1lLGkpKWZvcig7LS1yPi0xOylzW3JdPT09ZSYmcy5zcGxpY2UociwxKTtyZXR1cm4gWVtuXS50d2VlbnN9LEg9ZnVuY3Rpb24odCxlLGkscyl7dmFyIHIsbixhPXQudmFycy5vbk92ZXJ3cml0ZTtyZXR1cm4gYSYmKHI9YSh0LGUsaSxzKSksYT1ELm9uT3ZlcndyaXRlLGEmJihuPWEodCxlLGkscykpLHIhPT0hMSYmbiE9PSExfSxLPWZ1bmN0aW9uKHQsZSxpLHMscil7dmFyIG4sYSxvLGw7aWYoMT09PXN8fHM+PTQpe2ZvcihsPXIubGVuZ3RoLG49MDtsPm47bisrKWlmKChvPXJbbl0pIT09ZSlvLl9nY3x8by5fa2lsbChudWxsLHQsZSkmJihhPSEwKTtlbHNlIGlmKDU9PT1zKWJyZWFrO3JldHVybiBhfXZhciBoLHU9ZS5fc3RhcnRUaW1lK18sYz1bXSxmPTAscD0wPT09ZS5fZHVyYXRpb247Zm9yKG49ci5sZW5ndGg7LS1uPi0xOykobz1yW25dKT09PWV8fG8uX2djfHxvLl9wYXVzZWR8fChvLl90aW1lbGluZSE9PWUuX3RpbWVsaW5lPyhoPWh8fEooZSwwLHApLDA9PT1KKG8saCxwKSYmKGNbZisrXT1vKSk6dT49by5fc3RhcnRUaW1lJiZvLl9zdGFydFRpbWUrby50b3RhbER1cmF0aW9uKCkvby5fdGltZVNjYWxlPnUmJigocHx8IW8uX2luaXR0ZWQpJiYyZS0xMD49dS1vLl9zdGFydFRpbWV8fChjW2YrK109bykpKTtmb3Iobj1mOy0tbj4tMTspaWYobz1jW25dLDI9PT1zJiZvLl9raWxsKGksdCxlKSYmKGE9ITApLDIhPT1zfHwhby5fZmlyc3RQVCYmby5faW5pdHRlZCl7aWYoMiE9PXMmJiFIKG8sZSkpY29udGludWU7by5fZW5hYmxlZCghMSwhMSkmJihhPSEwKX1yZXR1cm4gYX0sSj1mdW5jdGlvbih0LGUsaSl7Zm9yKHZhciBzPXQuX3RpbWVsaW5lLHI9cy5fdGltZVNjYWxlLG49dC5fc3RhcnRUaW1lO3MuX3RpbWVsaW5lOyl7aWYobis9cy5fc3RhcnRUaW1lLHIqPXMuX3RpbWVTY2FsZSxzLl9wYXVzZWQpcmV0dXJuLTEwMDtzPXMuX3RpbWVsaW5lfXJldHVybiBuLz1yLG4+ZT9uLWU6aSYmbj09PWV8fCF0Ll9pbml0dGVkJiYyKl8+bi1lP186KG4rPXQudG90YWxEdXJhdGlvbigpL3QuX3RpbWVTY2FsZS9yKT5lK18/MDpuLWUtX307bi5faW5pdD1mdW5jdGlvbigpe3ZhciB0LGUsaSxzLHIsbj10aGlzLnZhcnMsYT10aGlzLl9vdmVyd3JpdHRlblByb3BzLG89dGhpcy5fZHVyYXRpb24sbD0hIW4uaW1tZWRpYXRlUmVuZGVyLGg9bi5lYXNlO2lmKG4uc3RhcnRBdCl7dGhpcy5fc3RhcnRBdCYmKHRoaXMuX3N0YXJ0QXQucmVuZGVyKC0xLCEwKSx0aGlzLl9zdGFydEF0LmtpbGwoKSkscj17fTtmb3IocyBpbiBuLnN0YXJ0QXQpcltzXT1uLnN0YXJ0QXRbc107aWYoci5vdmVyd3JpdGU9ITEsci5pbW1lZGlhdGVSZW5kZXI9ITAsci5sYXp5PWwmJm4ubGF6eSE9PSExLHIuc3RhcnRBdD1yLmRlbGF5PW51bGwsdGhpcy5fc3RhcnRBdD1ELnRvKHRoaXMudGFyZ2V0LDAsciksbClpZih0aGlzLl90aW1lPjApdGhpcy5fc3RhcnRBdD1udWxsO2Vsc2UgaWYoMCE9PW8pcmV0dXJufWVsc2UgaWYobi5ydW5CYWNrd2FyZHMmJjAhPT1vKWlmKHRoaXMuX3N0YXJ0QXQpdGhpcy5fc3RhcnRBdC5yZW5kZXIoLTEsITApLHRoaXMuX3N0YXJ0QXQua2lsbCgpLHRoaXMuX3N0YXJ0QXQ9bnVsbDtlbHNlezAhPT10aGlzLl90aW1lJiYobD0hMSksaT17fTtmb3IocyBpbiBuKXFbc10mJlwiYXV0b0NTU1wiIT09c3x8KGlbc109bltzXSk7aWYoaS5vdmVyd3JpdGU9MCxpLmRhdGE9XCJpc0Zyb21TdGFydFwiLGkubGF6eT1sJiZuLmxhenkhPT0hMSxpLmltbWVkaWF0ZVJlbmRlcj1sLHRoaXMuX3N0YXJ0QXQ9RC50byh0aGlzLnRhcmdldCwwLGkpLGwpe2lmKDA9PT10aGlzLl90aW1lKXJldHVybn1lbHNlIHRoaXMuX3N0YXJ0QXQuX2luaXQoKSx0aGlzLl9zdGFydEF0Ll9lbmFibGVkKCExKSx0aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyJiYodGhpcy5fc3RhcnRBdD1udWxsKX1pZih0aGlzLl9lYXNlPWg9aD9oIGluc3RhbmNlb2YgVD9oOlwiZnVuY3Rpb25cIj09dHlwZW9mIGg/bmV3IFQoaCxuLmVhc2VQYXJhbXMpOnhbaF18fEQuZGVmYXVsdEVhc2U6RC5kZWZhdWx0RWFzZSxuLmVhc2VQYXJhbXMgaW5zdGFuY2VvZiBBcnJheSYmaC5jb25maWcmJih0aGlzLl9lYXNlPWguY29uZmlnLmFwcGx5KGgsbi5lYXNlUGFyYW1zKSksdGhpcy5fZWFzZVR5cGU9dGhpcy5fZWFzZS5fdHlwZSx0aGlzLl9lYXNlUG93ZXI9dGhpcy5fZWFzZS5fcG93ZXIsdGhpcy5fZmlyc3RQVD1udWxsLHRoaXMuX3RhcmdldHMpZm9yKHQ9dGhpcy5fdGFyZ2V0cy5sZW5ndGg7LS10Pi0xOyl0aGlzLl9pbml0UHJvcHModGhpcy5fdGFyZ2V0c1t0XSx0aGlzLl9wcm9wTG9va3VwW3RdPXt9LHRoaXMuX3NpYmxpbmdzW3RdLGE/YVt0XTpudWxsKSYmKGU9ITApO2Vsc2UgZT10aGlzLl9pbml0UHJvcHModGhpcy50YXJnZXQsdGhpcy5fcHJvcExvb2t1cCx0aGlzLl9zaWJsaW5ncyxhKTtpZihlJiZELl9vblBsdWdpbkV2ZW50KFwiX29uSW5pdEFsbFByb3BzXCIsdGhpcyksYSYmKHRoaXMuX2ZpcnN0UFR8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIHRoaXMudGFyZ2V0JiZ0aGlzLl9lbmFibGVkKCExLCExKSksbi5ydW5CYWNrd2FyZHMpZm9yKGk9dGhpcy5fZmlyc3RQVDtpOylpLnMrPWkuYyxpLmM9LWkuYyxpPWkuX25leHQ7dGhpcy5fb25VcGRhdGU9bi5vblVwZGF0ZSx0aGlzLl9pbml0dGVkPSEwfSxuLl9pbml0UHJvcHM9ZnVuY3Rpb24oZSxpLHMscil7dmFyIG4sYSxvLGwsaCxfO2lmKG51bGw9PWUpcmV0dXJuITE7SVtlLl9nc1R3ZWVuSURdJiZRKCksdGhpcy52YXJzLmNzc3x8ZS5zdHlsZSYmZSE9PXQmJmUubm9kZVR5cGUmJmouY3NzJiZ0aGlzLnZhcnMuYXV0b0NTUyE9PSExJiZ6KHRoaXMudmFycyxlKTtmb3IobiBpbiB0aGlzLnZhcnMpaWYoXz10aGlzLnZhcnNbbl0scVtuXSlfJiYoXyBpbnN0YW5jZW9mIEFycmF5fHxfLnB1c2gmJmYoXykpJiYtMSE9PV8uam9pbihcIlwiKS5pbmRleE9mKFwie3NlbGZ9XCIpJiYodGhpcy52YXJzW25dPV89dGhpcy5fc3dhcFNlbGZJblBhcmFtcyhfLHRoaXMpKTtlbHNlIGlmKGpbbl0mJihsPW5ldyBqW25dKS5fb25Jbml0VHdlZW4oZSx0aGlzLnZhcnNbbl0sdGhpcykpe2Zvcih0aGlzLl9maXJzdFBUPWg9e19uZXh0OnRoaXMuX2ZpcnN0UFQsdDpsLHA6XCJzZXRSYXRpb1wiLHM6MCxjOjEsZjoxLG46bixwZzoxLHByOmwuX3ByaW9yaXR5fSxhPWwuX292ZXJ3cml0ZVByb3BzLmxlbmd0aDstLWE+LTE7KWlbbC5fb3ZlcndyaXRlUHJvcHNbYV1dPXRoaXMuX2ZpcnN0UFQ7KGwuX3ByaW9yaXR5fHxsLl9vbkluaXRBbGxQcm9wcykmJihvPSEwKSwobC5fb25EaXNhYmxlfHxsLl9vbkVuYWJsZSkmJih0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkPSEwKSxoLl9uZXh0JiYoaC5fbmV4dC5fcHJldj1oKX1lbHNlIGlbbl09WC5jYWxsKHRoaXMsZSxuLFwiZ2V0XCIsXyxuLDAsbnVsbCx0aGlzLnZhcnMuc3RyaW5nRmlsdGVyKTtyZXR1cm4gciYmdGhpcy5fa2lsbChyLGUpP3RoaXMuX2luaXRQcm9wcyhlLGkscyxyKTp0aGlzLl9vdmVyd3JpdGU+MSYmdGhpcy5fZmlyc3RQVCYmcy5sZW5ndGg+MSYmSyhlLHRoaXMsaSx0aGlzLl9vdmVyd3JpdGUscyk/KHRoaXMuX2tpbGwoaSxlKSx0aGlzLl9pbml0UHJvcHMoZSxpLHMscikpOih0aGlzLl9maXJzdFBUJiYodGhpcy52YXJzLmxhenkhPT0hMSYmdGhpcy5fZHVyYXRpb258fHRoaXMudmFycy5sYXp5JiYhdGhpcy5fZHVyYXRpb24pJiYoSVtlLl9nc1R3ZWVuSURdPSEwKSxvKX0sbi5yZW5kZXI9ZnVuY3Rpb24odCxlLGkpe3ZhciBzLHIsbixhLG89dGhpcy5fdGltZSxsPXRoaXMuX2R1cmF0aW9uLGg9dGhpcy5fcmF3UHJldlRpbWU7aWYodD49bCl0aGlzLl90b3RhbFRpbWU9dGhpcy5fdGltZT1sLHRoaXMucmF0aW89dGhpcy5fZWFzZS5fY2FsY0VuZD90aGlzLl9lYXNlLmdldFJhdGlvKDEpOjEsdGhpcy5fcmV2ZXJzZWR8fChzPSEwLHI9XCJvbkNvbXBsZXRlXCIsaT1pfHx0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pLDA9PT1sJiYodGhpcy5faW5pdHRlZHx8IXRoaXMudmFycy5sYXp5fHxpKSYmKHRoaXMuX3N0YXJ0VGltZT09PXRoaXMuX3RpbWVsaW5lLl9kdXJhdGlvbiYmKHQ9MCksKDA9PT10fHwwPmh8fGg9PT1fJiZcImlzUGF1c2VcIiE9PXRoaXMuZGF0YSkmJmghPT10JiYoaT0hMCxoPl8mJihyPVwib25SZXZlcnNlQ29tcGxldGVcIikpLHRoaXMuX3Jhd1ByZXZUaW1lPWE9IWV8fHR8fGg9PT10P3Q6Xyk7ZWxzZSBpZigxZS03PnQpdGhpcy5fdG90YWxUaW1lPXRoaXMuX3RpbWU9MCx0aGlzLnJhdGlvPXRoaXMuX2Vhc2UuX2NhbGNFbmQ/dGhpcy5fZWFzZS5nZXRSYXRpbygwKTowLCgwIT09b3x8MD09PWwmJmg+MCkmJihyPVwib25SZXZlcnNlQ29tcGxldGVcIixzPXRoaXMuX3JldmVyc2VkKSwwPnQmJih0aGlzLl9hY3RpdmU9ITEsMD09PWwmJih0aGlzLl9pbml0dGVkfHwhdGhpcy52YXJzLmxhenl8fGkpJiYoaD49MCYmKGghPT1ffHxcImlzUGF1c2VcIiE9PXRoaXMuZGF0YSkmJihpPSEwKSx0aGlzLl9yYXdQcmV2VGltZT1hPSFlfHx0fHxoPT09dD90Ol8pKSx0aGlzLl9pbml0dGVkfHwoaT0hMCk7ZWxzZSBpZih0aGlzLl90b3RhbFRpbWU9dGhpcy5fdGltZT10LHRoaXMuX2Vhc2VUeXBlKXt2YXIgdT10L2wsYz10aGlzLl9lYXNlVHlwZSxmPXRoaXMuX2Vhc2VQb3dlcjsoMT09PWN8fDM9PT1jJiZ1Pj0uNSkmJih1PTEtdSksMz09PWMmJih1Kj0yKSwxPT09Zj91Kj11OjI9PT1mP3UqPXUqdTozPT09Zj91Kj11KnUqdTo0PT09ZiYmKHUqPXUqdSp1KnUpLHRoaXMucmF0aW89MT09PWM/MS11OjI9PT1jP3U6LjU+dC9sP3UvMjoxLXUvMn1lbHNlIHRoaXMucmF0aW89dGhpcy5fZWFzZS5nZXRSYXRpbyh0L2wpO2lmKHRoaXMuX3RpbWUhPT1vfHxpKXtpZighdGhpcy5faW5pdHRlZCl7aWYodGhpcy5faW5pdCgpLCF0aGlzLl9pbml0dGVkfHx0aGlzLl9nYylyZXR1cm47aWYoIWkmJnRoaXMuX2ZpcnN0UFQmJih0aGlzLnZhcnMubGF6eSE9PSExJiZ0aGlzLl9kdXJhdGlvbnx8dGhpcy52YXJzLmxhenkmJiF0aGlzLl9kdXJhdGlvbikpcmV0dXJuIHRoaXMuX3RpbWU9dGhpcy5fdG90YWxUaW1lPW8sdGhpcy5fcmF3UHJldlRpbWU9aCxGLnB1c2godGhpcyksdGhpcy5fbGF6eT1bdCxlXSx2b2lkIDA7dGhpcy5fdGltZSYmIXM/dGhpcy5yYXRpbz10aGlzLl9lYXNlLmdldFJhdGlvKHRoaXMuX3RpbWUvbCk6cyYmdGhpcy5fZWFzZS5fY2FsY0VuZCYmKHRoaXMucmF0aW89dGhpcy5fZWFzZS5nZXRSYXRpbygwPT09dGhpcy5fdGltZT8wOjEpKX1mb3IodGhpcy5fbGF6eSE9PSExJiYodGhpcy5fbGF6eT0hMSksdGhpcy5fYWN0aXZlfHwhdGhpcy5fcGF1c2VkJiZ0aGlzLl90aW1lIT09byYmdD49MCYmKHRoaXMuX2FjdGl2ZT0hMCksMD09PW8mJih0aGlzLl9zdGFydEF0JiYodD49MD90aGlzLl9zdGFydEF0LnJlbmRlcih0LGUsaSk6cnx8KHI9XCJfZHVtbXlHU1wiKSksdGhpcy52YXJzLm9uU3RhcnQmJigwIT09dGhpcy5fdGltZXx8MD09PWwpJiYoZXx8dGhpcy5fY2FsbGJhY2soXCJvblN0YXJ0XCIpKSksbj10aGlzLl9maXJzdFBUO247KW4uZj9uLnRbbi5wXShuLmMqdGhpcy5yYXRpbytuLnMpOm4udFtuLnBdPW4uYyp0aGlzLnJhdGlvK24ucyxuPW4uX25leHQ7dGhpcy5fb25VcGRhdGUmJigwPnQmJnRoaXMuX3N0YXJ0QXQmJnQhPT0tMWUtNCYmdGhpcy5fc3RhcnRBdC5yZW5kZXIodCxlLGkpLGV8fCh0aGlzLl90aW1lIT09b3x8cykmJnRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIikpLHImJighdGhpcy5fZ2N8fGkpJiYoMD50JiZ0aGlzLl9zdGFydEF0JiYhdGhpcy5fb25VcGRhdGUmJnQhPT0tMWUtNCYmdGhpcy5fc3RhcnRBdC5yZW5kZXIodCxlLGkpLHMmJih0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4mJnRoaXMuX2VuYWJsZWQoITEsITEpLHRoaXMuX2FjdGl2ZT0hMSksIWUmJnRoaXMudmFyc1tyXSYmdGhpcy5fY2FsbGJhY2sociksMD09PWwmJnRoaXMuX3Jhd1ByZXZUaW1lPT09XyYmYSE9PV8mJih0aGlzLl9yYXdQcmV2VGltZT0wKSl9fSxuLl9raWxsPWZ1bmN0aW9uKHQsZSxpKXtpZihcImFsbFwiPT09dCYmKHQ9bnVsbCksbnVsbD09dCYmKG51bGw9PWV8fGU9PT10aGlzLnRhcmdldCkpcmV0dXJuIHRoaXMuX2xhenk9ITEsdGhpcy5fZW5hYmxlZCghMSwhMSk7ZT1cInN0cmluZ1wiIT10eXBlb2YgZT9lfHx0aGlzLl90YXJnZXRzfHx0aGlzLnRhcmdldDpELnNlbGVjdG9yKGUpfHxlO3ZhciBzLHIsbixhLG8sbCxoLF8sdSxjPWkmJnRoaXMuX3RpbWUmJmkuX3N0YXJ0VGltZT09PXRoaXMuX3N0YXJ0VGltZSYmdGhpcy5fdGltZWxpbmU9PT1pLl90aW1lbGluZTtpZigoZihlKXx8TShlKSkmJlwibnVtYmVyXCIhPXR5cGVvZiBlWzBdKWZvcihzPWUubGVuZ3RoOy0tcz4tMTspdGhpcy5fa2lsbCh0LGVbc10saSkmJihsPSEwKTtlbHNle2lmKHRoaXMuX3RhcmdldHMpe2ZvcihzPXRoaXMuX3RhcmdldHMubGVuZ3RoOy0tcz4tMTspaWYoZT09PXRoaXMuX3RhcmdldHNbc10pe289dGhpcy5fcHJvcExvb2t1cFtzXXx8e30sdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcz10aGlzLl9vdmVyd3JpdHRlblByb3BzfHxbXSxyPXRoaXMuX292ZXJ3cml0dGVuUHJvcHNbc109dD90aGlzLl9vdmVyd3JpdHRlblByb3BzW3NdfHx7fTpcImFsbFwiO2JyZWFrfX1lbHNle2lmKGUhPT10aGlzLnRhcmdldClyZXR1cm4hMTtvPXRoaXMuX3Byb3BMb29rdXAscj10aGlzLl9vdmVyd3JpdHRlblByb3BzPXQ/dGhpcy5fb3ZlcndyaXR0ZW5Qcm9wc3x8e306XCJhbGxcIn1pZihvKXtpZihoPXR8fG8sXz10IT09ciYmXCJhbGxcIiE9PXImJnQhPT1vJiYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fCF0Ll90ZW1wS2lsbCksaSYmKEQub25PdmVyd3JpdGV8fHRoaXMudmFycy5vbk92ZXJ3cml0ZSkpe2ZvcihuIGluIGgpb1tuXSYmKHV8fCh1PVtdKSx1LnB1c2gobikpO2lmKCh1fHwhdCkmJiFIKHRoaXMsaSxlLHUpKXJldHVybiExfWZvcihuIGluIGgpKGE9b1tuXSkmJihjJiYoYS5mP2EudFthLnBdKGEucyk6YS50W2EucF09YS5zLGw9ITApLGEucGcmJmEudC5fa2lsbChoKSYmKGw9ITApLGEucGcmJjAhPT1hLnQuX292ZXJ3cml0ZVByb3BzLmxlbmd0aHx8KGEuX3ByZXY/YS5fcHJldi5fbmV4dD1hLl9uZXh0OmE9PT10aGlzLl9maXJzdFBUJiYodGhpcy5fZmlyc3RQVD1hLl9uZXh0KSxhLl9uZXh0JiYoYS5fbmV4dC5fcHJldj1hLl9wcmV2KSxhLl9uZXh0PWEuX3ByZXY9bnVsbCksZGVsZXRlIG9bbl0pLF8mJihyW25dPTEpOyF0aGlzLl9maXJzdFBUJiZ0aGlzLl9pbml0dGVkJiZ0aGlzLl9lbmFibGVkKCExLCExKX19cmV0dXJuIGx9LG4uaW52YWxpZGF0ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkJiZELl9vblBsdWdpbkV2ZW50KFwiX29uRGlzYWJsZVwiLHRoaXMpLHRoaXMuX2ZpcnN0UFQ9dGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcz10aGlzLl9zdGFydEF0PXRoaXMuX29uVXBkYXRlPW51bGwsdGhpcy5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZD10aGlzLl9hY3RpdmU9dGhpcy5fbGF6eT0hMSx0aGlzLl9wcm9wTG9va3VwPXRoaXMuX3RhcmdldHM/e306W10sTy5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMpLHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXImJih0aGlzLl90aW1lPS1fLHRoaXMucmVuZGVyKC10aGlzLl9kZWxheSkpLHRoaXN9LG4uX2VuYWJsZWQ9ZnVuY3Rpb24odCxlKXtpZihvfHxhLndha2UoKSx0JiZ0aGlzLl9nYyl7dmFyIGkscz10aGlzLl90YXJnZXRzO2lmKHMpZm9yKGk9cy5sZW5ndGg7LS1pPi0xOyl0aGlzLl9zaWJsaW5nc1tpXT0kKHNbaV0sdGhpcywhMCk7ZWxzZSB0aGlzLl9zaWJsaW5ncz0kKHRoaXMudGFyZ2V0LHRoaXMsITApfXJldHVybiBPLnByb3RvdHlwZS5fZW5hYmxlZC5jYWxsKHRoaXMsdCxlKSx0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkJiZ0aGlzLl9maXJzdFBUP0QuX29uUGx1Z2luRXZlbnQodD9cIl9vbkVuYWJsZVwiOlwiX29uRGlzYWJsZVwiLHRoaXMpOiExfSxELnRvPWZ1bmN0aW9uKHQsZSxpKXtyZXR1cm4gbmV3IEQodCxlLGkpfSxELmZyb209ZnVuY3Rpb24odCxlLGkpe3JldHVybiBpLnJ1bkJhY2t3YXJkcz0hMCxpLmltbWVkaWF0ZVJlbmRlcj0wIT1pLmltbWVkaWF0ZVJlbmRlcixuZXcgRCh0LGUsaSl9LEQuZnJvbVRvPWZ1bmN0aW9uKHQsZSxpLHMpe3JldHVybiBzLnN0YXJ0QXQ9aSxzLmltbWVkaWF0ZVJlbmRlcj0wIT1zLmltbWVkaWF0ZVJlbmRlciYmMCE9aS5pbW1lZGlhdGVSZW5kZXIsbmV3IEQodCxlLHMpfSxELmRlbGF5ZWRDYWxsPWZ1bmN0aW9uKHQsZSxpLHMscil7cmV0dXJuIG5ldyBEKGUsMCx7ZGVsYXk6dCxvbkNvbXBsZXRlOmUsb25Db21wbGV0ZVBhcmFtczppLGNhbGxiYWNrU2NvcGU6cyxvblJldmVyc2VDb21wbGV0ZTplLG9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zOmksaW1tZWRpYXRlUmVuZGVyOiExLGxhenk6ITEsdXNlRnJhbWVzOnIsb3ZlcndyaXRlOjB9KX0sRC5zZXQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IEQodCwwLGUpfSxELmdldFR3ZWVuc09mPWZ1bmN0aW9uKHQsZSl7aWYobnVsbD09dClyZXR1cm5bXTt0PVwic3RyaW5nXCIhPXR5cGVvZiB0P3Q6RC5zZWxlY3Rvcih0KXx8dDt2YXIgaSxzLHIsbjtpZigoZih0KXx8TSh0KSkmJlwibnVtYmVyXCIhPXR5cGVvZiB0WzBdKXtmb3IoaT10Lmxlbmd0aCxzPVtdOy0taT4tMTspcz1zLmNvbmNhdChELmdldFR3ZWVuc09mKHRbaV0sZSkpO2ZvcihpPXMubGVuZ3RoOy0taT4tMTspZm9yKG49c1tpXSxyPWk7LS1yPi0xOyluPT09c1tyXSYmcy5zcGxpY2UoaSwxKX1lbHNlIGZvcihzPSQodCkuY29uY2F0KCksaT1zLmxlbmd0aDstLWk+LTE7KShzW2ldLl9nY3x8ZSYmIXNbaV0uaXNBY3RpdmUoKSkmJnMuc3BsaWNlKGksMSk7cmV0dXJuIHN9LEQua2lsbFR3ZWVuc09mPUQua2lsbERlbGF5ZWRDYWxsc1RvPWZ1bmN0aW9uKHQsZSxpKXtcIm9iamVjdFwiPT10eXBlb2YgZSYmKGk9ZSxlPSExKTtmb3IodmFyIHM9RC5nZXRUd2VlbnNPZih0LGUpLHI9cy5sZW5ndGg7LS1yPi0xOylzW3JdLl9raWxsKGksdCl9O3ZhciB0ZT1nKFwicGx1Z2lucy5Ud2VlblBsdWdpblwiLGZ1bmN0aW9uKHQsZSl7dGhpcy5fb3ZlcndyaXRlUHJvcHM9KHR8fFwiXCIpLnNwbGl0KFwiLFwiKSx0aGlzLl9wcm9wTmFtZT10aGlzLl9vdmVyd3JpdGVQcm9wc1swXSx0aGlzLl9wcmlvcml0eT1lfHwwLHRoaXMuX3N1cGVyPXRlLnByb3RvdHlwZX0sITApO2lmKG49dGUucHJvdG90eXBlLHRlLnZlcnNpb249XCIxLjE4LjBcIix0ZS5BUEk9MixuLl9maXJzdFBUPW51bGwsbi5fYWRkVHdlZW49WCxuLnNldFJhdGlvPU4sbi5fa2lsbD1mdW5jdGlvbih0KXt2YXIgZSxpPXRoaXMuX292ZXJ3cml0ZVByb3BzLHM9dGhpcy5fZmlyc3RQVDtpZihudWxsIT10W3RoaXMuX3Byb3BOYW1lXSl0aGlzLl9vdmVyd3JpdGVQcm9wcz1bXTtlbHNlIGZvcihlPWkubGVuZ3RoOy0tZT4tMTspbnVsbCE9dFtpW2VdXSYmaS5zcGxpY2UoZSwxKTtmb3IoO3M7KW51bGwhPXRbcy5uXSYmKHMuX25leHQmJihzLl9uZXh0Ll9wcmV2PXMuX3ByZXYpLHMuX3ByZXY/KHMuX3ByZXYuX25leHQ9cy5fbmV4dCxzLl9wcmV2PW51bGwpOnRoaXMuX2ZpcnN0UFQ9PT1zJiYodGhpcy5fZmlyc3RQVD1zLl9uZXh0KSkscz1zLl9uZXh0O3JldHVybiExfSxuLl9yb3VuZFByb3BzPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBpPXRoaXMuX2ZpcnN0UFQ7aTspKHRbdGhpcy5fcHJvcE5hbWVdfHxudWxsIT1pLm4mJnRbaS5uLnNwbGl0KHRoaXMuX3Byb3BOYW1lK1wiX1wiKS5qb2luKFwiXCIpXSkmJihpLnI9ZSksaT1pLl9uZXh0fSxELl9vblBsdWdpbkV2ZW50PWZ1bmN0aW9uKHQsZSl7dmFyIGkscyxyLG4sYSxvPWUuX2ZpcnN0UFQ7aWYoXCJfb25Jbml0QWxsUHJvcHNcIj09PXQpe2Zvcig7bzspe2ZvcihhPW8uX25leHQscz1yO3MmJnMucHI+by5wcjspcz1zLl9uZXh0OyhvLl9wcmV2PXM/cy5fcHJldjpuKT9vLl9wcmV2Ll9uZXh0PW86cj1vLChvLl9uZXh0PXMpP3MuX3ByZXY9bzpuPW8sbz1hfW89ZS5fZmlyc3RQVD1yfWZvcig7bzspby5wZyYmXCJmdW5jdGlvblwiPT10eXBlb2Ygby50W3RdJiZvLnRbdF0oKSYmKGk9ITApLG89by5fbmV4dDtyZXR1cm4gaX0sdGUuYWN0aXZhdGU9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQubGVuZ3RoOy0tZT4tMTspdFtlXS5BUEk9PT10ZS5BUEkmJihqWyhuZXcgdFtlXSkuX3Byb3BOYW1lXT10W2VdKTtyZXR1cm4hMH0sZC5wbHVnaW49ZnVuY3Rpb24odCl7aWYoISh0JiZ0LnByb3BOYW1lJiZ0LmluaXQmJnQuQVBJKSl0aHJvd1wiaWxsZWdhbCBwbHVnaW4gZGVmaW5pdGlvbi5cIjt2YXIgZSxpPXQucHJvcE5hbWUscz10LnByaW9yaXR5fHwwLHI9dC5vdmVyd3JpdGVQcm9wcyxuPXtpbml0OlwiX29uSW5pdFR3ZWVuXCIsc2V0Olwic2V0UmF0aW9cIixraWxsOlwiX2tpbGxcIixyb3VuZDpcIl9yb3VuZFByb3BzXCIsaW5pdEFsbDpcIl9vbkluaXRBbGxQcm9wc1wifSxhPWcoXCJwbHVnaW5zLlwiK2kuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkraS5zdWJzdHIoMSkrXCJQbHVnaW5cIixmdW5jdGlvbigpe3RlLmNhbGwodGhpcyxpLHMpLHRoaXMuX292ZXJ3cml0ZVByb3BzPXJ8fFtdfSx0Lmdsb2JhbD09PSEwKSxvPWEucHJvdG90eXBlPW5ldyB0ZShpKTtvLmNvbnN0cnVjdG9yPWEsYS5BUEk9dC5BUEk7Zm9yKGUgaW4gbilcImZ1bmN0aW9uXCI9PXR5cGVvZiB0W2VdJiYob1tuW2VdXT10W2VdKTtyZXR1cm4gYS52ZXJzaW9uPXQudmVyc2lvbix0ZS5hY3RpdmF0ZShbYV0pLGF9LHM9dC5fZ3NRdWV1ZSl7Zm9yKHI9MDtzLmxlbmd0aD5yO3IrKylzW3JdKCk7Zm9yKG4gaW4gcClwW25dLmZ1bmN8fHQuY29uc29sZS5sb2coXCJHU0FQIGVuY291bnRlcmVkIG1pc3NpbmcgZGVwZW5kZW5jeTogY29tLmdyZWVuc29jay5cIituKX1vPSExfX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOnRoaXN8fHdpbmRvdyxcIlR3ZWVuTWF4XCIpOyJdfQ==
},{}],40:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper, alias1=helpers.helperMissing, alias2="function";

  return "<div class=\"index-item-content\">\n\n    <div class=\"project-cover-container\" style=\"background-image: url('"
    + ((stack1 = ((helper = (helper = helpers.cover || (depth0 != null ? depth0.cover : depth0)) != null ? helper : alias1),(typeof helper === alias2 ? helper.call(depth0,{"name":"cover","hash":{},"data":data}) : helper))) != null ? stack1 : "")
    + "');\">\n        \n    </div>\n    <div class=\"project-infos-container\">\n        <span class=\"project-year\">2016</span>\n        <h3 class=\"project-name\">"
    + ((stack1 = ((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : alias1),(typeof helper === alias2 ? helper.call(depth0,{"name":"title","hash":{},"data":data}) : helper))) != null ? stack1 : "")
    + "</h3>\n        <div class=\"projcet-description-container\">\n            <p class=\"project-description\">Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod\n            tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam.</p>\n        </div>\n    </div>\n</div>";
},"useData":true});

},{"hbsfy/runtime":16}],41:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<span class=\"prev-arrow index-arrow index-arrow-js\"></span>\n<span class=\"next-arrow index-arrow index-arrow-js\"></span>\n<ul class=\"index-list index-list-js\"></ul>";
},"useData":true});

},{"hbsfy/runtime":16}],42:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<div class=\"region-nav\"></div>\n<div class=\"region-content\"></div>";
},"useData":true});

},{"hbsfy/runtime":16}],43:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    return "<h1 class=\"name title\">Marine Amoros</h1>\n\n<ul class=\"nav-list nav-list-js\">\n    <li class=\"nav-item\">\n        <h2 class=\"part-title title\">Work</h2>\n        <div class=\"sub-nav-list-container work-list-js\">\n        </div>\n    </li>\n    <li class=\"nav-item\">\n        <h2 class=\"part-title title\">About</h2>\n        <div class=\"sub-nav-list-container about-list-js\">\n        </div>\n    </li>\n</ul>";
},"useData":true});

},{"hbsfy/runtime":16}],44:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template({"1":function(depth0,helpers,partials,data) {
    var stack1;

  return "<div class=\"inner-project-nav-list-container\">\n    <ul class=\"inner-project-nav-list\">\n"
    + ((stack1 = helpers.each.call(depth0,(depth0 != null ? depth0.subpart : depth0),{"name":"each","hash":{},"fn":this.program(2, data, 0),"inverse":this.noop,"data":data})) != null ? stack1 : "")
    + "    </ul>\n</div>\n";
},"2":function(depth0,helpers,partials,data) {
    var helper, alias1=this.escapeExpression;

  return "        <li class=\"inner-project-nav-item\" data-slug=\""
    + alias1(((helper = (helper = helpers.key || (data && data.key)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"key","hash":{},"data":data}) : helper)))
    + "\">"
    + alias1(this.lambda(depth0, depth0))
    + "</li>\n";
},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {
    var stack1, helper;

  return "<h3 class=\"project-name sub-part-name sub-part-name-js\">"
    + ((stack1 = ((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === "function" ? helper.call(depth0,{"name":"title","hash":{},"data":data}) : helper))) != null ? stack1 : "")
    + "</h3>\n"
    + ((stack1 = helpers['if'].call(depth0,(depth0 != null ? depth0.subpart : depth0),{"name":"if","hash":{},"fn":this.program(1, data, 0),"inverse":this.noop,"data":data})) != null ? stack1 : "");
},"useData":true});

},{"hbsfy/runtime":16}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvamF2YXNjcmlwdC9tYWluLmpzIiwibm9kZV9tb2R1bGVzL2JhY2tib25lLm1hcmlvbmV0dGUvbGliL2NvcmUvYmFja2JvbmUubWFyaW9uZXR0ZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWNrYm9uZS5tYXJpb25ldHRlL25vZGVfbW9kdWxlcy9iYWNrYm9uZS5iYWJ5c2l0dGVyL2xpYi9iYWNrYm9uZS5iYWJ5c2l0dGVyLmpzIiwibm9kZV9tb2R1bGVzL2JhY2tib25lLm1hcmlvbmV0dGUvbm9kZV9tb2R1bGVzL2JhY2tib25lLndyZXFyL2xpYi9iYWNrYm9uZS53cmVxci5qcyIsIm5vZGVfbW9kdWxlcy9iYWNrYm9uZS5yYWRpby9idWlsZC9iYWNrYm9uZS5yYWRpby5qcyIsIm5vZGVfbW9kdWxlcy9iYWNrYm9uZS9iYWNrYm9uZS5qcyIsIm5vZGVfbW9kdWxlcy9mYXN0Y2xpY2svbGliL2Zhc3RjbGljay5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMucnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvZXhjZXB0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy9uby1jb25mbGljdC5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvcnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvc2FmZS1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvcnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy9oYnNmeS9ydW50aW1lLmpzIiwibm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcyIsIm5vZGVfbW9kdWxlcy91bmRlcnNjb3JlL3VuZGVyc2NvcmUuanMiLCJzcmMvamF2YXNjcmlwdC9hcHAvYXBwLmpzIiwic3JjL2phdmFzY3JpcHQvYXBwL2JlaGF2aW9ycy9OYXZpZ2F0b3IuanMiLCJzcmMvamF2YXNjcmlwdC9hcHAvY2hhbm5lbHMuanMiLCJzcmMvamF2YXNjcmlwdC9hcHAvY29sbGVjdGlvbnMvV29ya0NvbGxlY3Rpb24uanMiLCJzcmMvamF2YXNjcmlwdC9hcHAvY29udHJvbGxlcnMvQXBwQ29udHJvbGxlci5qcyIsInNyYy9qYXZhc2NyaXB0L2FwcC9kYXRhcy93b3JrRGF0YS5qcyIsInNyYy9qYXZhc2NyaXB0L2FwcC9tb2RlbHMvV29ya01vZGVsLmpzIiwic3JjL2phdmFzY3JpcHQvYXBwL3JvdXRlcnMvQXBwUm91dGVyLmpzIiwic3JjL2phdmFzY3JpcHQvYXBwL3V0aWxzL2NvbnN0YW50cy5qcyIsInNyYy9qYXZhc2NyaXB0L2FwcC92aWV3cy9CYXNlVmlldy5qcyIsInNyYy9qYXZhc2NyaXB0L2FwcC92aWV3cy9Db250ZW50Vmlldy5qcyIsInNyYy9qYXZhc2NyaXB0L2FwcC92aWV3cy9HbG9iYWxWaWV3LmpzIiwic3JjL2phdmFzY3JpcHQvYXBwL3ZpZXdzL0luZGV4SXRlbVZpZXcuanMiLCJzcmMvamF2YXNjcmlwdC9hcHAvdmlld3MvSW5kZXhWaWV3LmpzIiwic3JjL2phdmFzY3JpcHQvYXBwL3ZpZXdzL05hdlZpZXcuanMiLCJzcmMvamF2YXNjcmlwdC9hcHAvdmlld3MvV29ya0l0ZW1WaWV3LmpzIiwic3JjL2phdmFzY3JpcHQvYXBwL3ZpZXdzL1dvcmtMaXN0Vmlldy5qcyIsInNyYy9qYXZhc2NyaXB0L2xpYnMvVHdlZW5NYXgvVGltZWxpbmVMaXRlLmpzIiwic3JjL2phdmFzY3JpcHQvbGlicy9Ud2Vlbk1heC9Ud2VlbkxpdGUuanMiLCJzcmMvamF2YXNjcmlwdC9saWJzL1R3ZWVuTWF4L1R3ZWVuTWF4LmpzIiwic3JjL2phdmFzY3JpcHQvdGVtcGxhdGVzL2luZGV4LWl0ZW0uaGJzIiwic3JjL2phdmFzY3JpcHQvdGVtcGxhdGVzL2luZGV4LWxpc3QuaGJzIiwic3JjL2phdmFzY3JpcHQvdGVtcGxhdGVzL2luZGV4LmhicyIsInNyYy9qYXZhc2NyaXB0L3RlbXBsYXRlcy9uYXYuaGJzIiwic3JjL2phdmFzY3JpcHQvdGVtcGxhdGVzL3dvcmstaXRlbS5oYnMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzcyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDejBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMS9SQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Z0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ2YXIgYXBwID0gcmVxdWlyZSgnLi9hcHAvYXBwJyk7XG52YXIgQXBwUm91dGVyID0gcmVxdWlyZSgnLi9hcHAvcm91dGVycy9BcHBSb3V0ZXInKTtcblxuYXBwLmFwcFJvdXRlciA9IG5ldyBBcHBSb3V0ZXIoKTtcbmFwcC5zdGFydCgpO1xuIiwiLy8gTWFyaW9uZXR0ZUpTIChCYWNrYm9uZS5NYXJpb25ldHRlKVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdjIuNC4yXG4vL1xuLy8gQ29weXJpZ2h0IChjKTIwMTUgRGVyaWNrIEJhaWxleSwgTXV0ZWQgU29sdXRpb25zLCBMTEMuXG4vLyBEaXN0cmlidXRlZCB1bmRlciBNSVQgbGljZW5zZVxuLy9cbi8vIGh0dHA6Ly9tYXJpb25ldHRlanMuY29tXG5cbihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJ2JhY2tib25lJywgJ3VuZGVyc2NvcmUnLCAnYmFja2JvbmUud3JlcXInLCAnYmFja2JvbmUuYmFieXNpdHRlciddLCBmdW5jdGlvbihCYWNrYm9uZSwgXykge1xuICAgICAgcmV0dXJuIChyb290Lk1hcmlvbmV0dGUgPSByb290Lk1uID0gZmFjdG9yeShyb290LCBCYWNrYm9uZSwgXykpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG4gICAgdmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG4gICAgdmFyIFdyZXFyID0gcmVxdWlyZSgnYmFja2JvbmUud3JlcXInKTtcbiAgICB2YXIgQmFieVNpdHRlciA9IHJlcXVpcmUoJ2JhY2tib25lLmJhYnlzaXR0ZXInKTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnkocm9vdCwgQmFja2JvbmUsIF8pO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuTWFyaW9uZXR0ZSA9IHJvb3QuTW4gPSBmYWN0b3J5KHJvb3QsIHJvb3QuQmFja2JvbmUsIHJvb3QuXyk7XG4gIH1cblxufSh0aGlzLCBmdW5jdGlvbihyb290LCBCYWNrYm9uZSwgXykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHByZXZpb3VzTWFyaW9uZXR0ZSA9IHJvb3QuTWFyaW9uZXR0ZTtcbiAgdmFyIHByZXZpb3VzTW4gPSByb290Lk1uO1xuXG4gIHZhciBNYXJpb25ldHRlID0gQmFja2JvbmUuTWFyaW9uZXR0ZSA9IHt9O1xuXG4gIE1hcmlvbmV0dGUuVkVSU0lPTiA9ICcyLjQuMic7XG5cbiAgTWFyaW9uZXR0ZS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5NYXJpb25ldHRlID0gcHJldmlvdXNNYXJpb25ldHRlO1xuICAgIHJvb3QuTW4gPSBwcmV2aW91c01uO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEdldCB0aGUgRGVmZXJyZWQgY3JlYXRvciBmb3IgbGF0ZXIgdXNlXG4gIE1hcmlvbmV0dGUuRGVmZXJyZWQgPSBCYWNrYm9uZS4kLkRlZmVycmVkO1xuXG4gIE1hcmlvbmV0dGUuRkVBVFVSRVMgPSB7XG4gIH07XG4gIFxuICBNYXJpb25ldHRlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gISFNYXJpb25ldHRlLkZFQVRVUkVTW25hbWVdO1xuICB9O1xuICBcbiAgLyoganNoaW50IHVudXNlZDogZmFsc2UgKi8vKiBnbG9iYWwgY29uc29sZSAqL1xuICBcbiAgLy8gSGVscGVyc1xuICAvLyAtLS0tLS0tXG4gIFxuICAvLyBNYXJpb25ldHRlLmV4dGVuZFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuICBcbiAgLy8gQm9ycm93IHRoZSBCYWNrYm9uZSBgZXh0ZW5kYCBtZXRob2Qgc28gd2UgY2FuIHVzZSBpdCBhcyBuZWVkZWRcbiAgTWFyaW9uZXR0ZS5leHRlbmQgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQ7XG4gIFxuICAvLyBNYXJpb25ldHRlLmlzTm9kZUF0dGFjaGVkXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgXG4gIC8vIERldGVybWluZSBpZiBgZWxgIGlzIGEgY2hpbGQgb2YgdGhlIGRvY3VtZW50XG4gIE1hcmlvbmV0dGUuaXNOb2RlQXR0YWNoZWQgPSBmdW5jdGlvbihlbCkge1xuICAgIHJldHVybiBCYWNrYm9uZS4kLmNvbnRhaW5zKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZWwpO1xuICB9O1xuICBcbiAgLy8gTWVyZ2UgYGtleXNgIGZyb20gYG9wdGlvbnNgIG9udG8gYHRoaXNgXG4gIE1hcmlvbmV0dGUubWVyZ2VPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucywga2V5cykge1xuICAgIGlmICghb3B0aW9ucykgeyByZXR1cm47IH1cbiAgICBfLmV4dGVuZCh0aGlzLCBfLnBpY2sob3B0aW9ucywga2V5cykpO1xuICB9O1xuICBcbiAgLy8gTWFyaW9uZXR0ZS5nZXRPcHRpb25cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgXG4gIC8vIFJldHJpZXZlIGFuIG9iamVjdCwgZnVuY3Rpb24gb3Igb3RoZXIgdmFsdWUgZnJvbSBhIHRhcmdldFxuICAvLyBvYmplY3Qgb3IgaXRzIGBvcHRpb25zYCwgd2l0aCBgb3B0aW9uc2AgdGFraW5nIHByZWNlZGVuY2UuXG4gIE1hcmlvbmV0dGUuZ2V0T3B0aW9uID0gZnVuY3Rpb24odGFyZ2V0LCBvcHRpb25OYW1lKSB7XG4gICAgaWYgKCF0YXJnZXQgfHwgIW9wdGlvbk5hbWUpIHsgcmV0dXJuOyB9XG4gICAgaWYgKHRhcmdldC5vcHRpb25zICYmICh0YXJnZXQub3B0aW9uc1tvcHRpb25OYW1lXSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgcmV0dXJuIHRhcmdldC5vcHRpb25zW29wdGlvbk5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGFyZ2V0W29wdGlvbk5hbWVdO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIFByb3h5IGBNYXJpb25ldHRlLmdldE9wdGlvbmBcbiAgTWFyaW9uZXR0ZS5wcm94eUdldE9wdGlvbiA9IGZ1bmN0aW9uKG9wdGlvbk5hbWUpIHtcbiAgICByZXR1cm4gTWFyaW9uZXR0ZS5nZXRPcHRpb24odGhpcywgb3B0aW9uTmFtZSk7XG4gIH07XG4gIFxuICAvLyBTaW1pbGFyIHRvIGBfLnJlc3VsdGAsIHRoaXMgaXMgYSBzaW1wbGUgaGVscGVyXG4gIC8vIElmIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgd2UgY2FsbCBpdCB3aXRoIGNvbnRleHRcbiAgLy8gb3RoZXJ3aXNlIGp1c3QgcmV0dXJuIHRoZSB2YWx1ZS4gSWYgdGhlIHZhbHVlIGlzXG4gIC8vIHVuZGVmaW5lZCByZXR1cm4gYSBkZWZhdWx0IHZhbHVlXG4gIE1hcmlvbmV0dGUuX2dldFZhbHVlID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQsIHBhcmFtcykge1xuICAgIGlmIChfLmlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHBhcmFtcyA/IHZhbHVlLmFwcGx5KGNvbnRleHQsIHBhcmFtcykgOiB2YWx1ZS5jYWxsKGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG4gIFxuICAvLyBNYXJpb25ldHRlLm5vcm1hbGl6ZU1ldGhvZHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBcbiAgLy8gUGFzcyBpbiBhIG1hcHBpbmcgb2YgZXZlbnRzID0+IGZ1bmN0aW9ucyBvciBmdW5jdGlvbiBuYW1lc1xuICAvLyBhbmQgcmV0dXJuIGEgbWFwcGluZyBvZiBldmVudHMgPT4gZnVuY3Rpb25zXG4gIE1hcmlvbmV0dGUubm9ybWFsaXplTWV0aG9kcyA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICByZXR1cm4gXy5yZWR1Y2UoaGFzaCwgZnVuY3Rpb24obm9ybWFsaXplZEhhc2gsIG1ldGhvZCwgbmFtZSkge1xuICAgICAgaWYgKCFfLmlzRnVuY3Rpb24obWV0aG9kKSkge1xuICAgICAgICBtZXRob2QgPSB0aGlzW21ldGhvZF07XG4gICAgICB9XG4gICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRIYXNoW25hbWVdID0gbWV0aG9kO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRIYXNoO1xuICAgIH0sIHt9LCB0aGlzKTtcbiAgfTtcbiAgXG4gIC8vIHV0aWxpdHkgbWV0aG9kIGZvciBwYXJzaW5nIEB1aS4gc3ludGF4IHN0cmluZ3NcbiAgLy8gaW50byBhc3NvY2lhdGVkIHNlbGVjdG9yXG4gIE1hcmlvbmV0dGUubm9ybWFsaXplVUlTdHJpbmcgPSBmdW5jdGlvbih1aVN0cmluZywgdWkpIHtcbiAgICByZXR1cm4gdWlTdHJpbmcucmVwbGFjZSgvQHVpXFwuW2EtekEtWl8kMC05XSovZywgZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuIHVpW3Iuc2xpY2UoNCldO1xuICAgIH0pO1xuICB9O1xuICBcbiAgLy8gYWxsb3dzIGZvciB0aGUgdXNlIG9mIHRoZSBAdWkuIHN5bnRheCB3aXRoaW5cbiAgLy8gYSBnaXZlbiBrZXkgZm9yIHRyaWdnZXJzIGFuZCBldmVudHNcbiAgLy8gc3dhcHMgdGhlIEB1aSB3aXRoIHRoZSBhc3NvY2lhdGVkIHNlbGVjdG9yLlxuICAvLyBSZXR1cm5zIGEgbmV3LCBub24tbXV0YXRlZCwgcGFyc2VkIGV2ZW50cyBoYXNoLlxuICBNYXJpb25ldHRlLm5vcm1hbGl6ZVVJS2V5cyA9IGZ1bmN0aW9uKGhhc2gsIHVpKSB7XG4gICAgcmV0dXJuIF8ucmVkdWNlKGhhc2gsIGZ1bmN0aW9uKG1lbW8sIHZhbCwga2V5KSB7XG4gICAgICB2YXIgbm9ybWFsaXplZEtleSA9IE1hcmlvbmV0dGUubm9ybWFsaXplVUlTdHJpbmcoa2V5LCB1aSk7XG4gICAgICBtZW1vW25vcm1hbGl6ZWRLZXldID0gdmFsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSwge30pO1xuICB9O1xuICBcbiAgLy8gYWxsb3dzIGZvciB0aGUgdXNlIG9mIHRoZSBAdWkuIHN5bnRheCB3aXRoaW5cbiAgLy8gYSBnaXZlbiB2YWx1ZSBmb3IgcmVnaW9uc1xuICAvLyBzd2FwcyB0aGUgQHVpIHdpdGggdGhlIGFzc29jaWF0ZWQgc2VsZWN0b3JcbiAgTWFyaW9uZXR0ZS5ub3JtYWxpemVVSVZhbHVlcyA9IGZ1bmN0aW9uKGhhc2gsIHVpLCBwcm9wZXJ0aWVzKSB7XG4gICAgXy5lYWNoKGhhc2gsIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICBpZiAoXy5pc1N0cmluZyh2YWwpKSB7XG4gICAgICAgIGhhc2hba2V5XSA9IE1hcmlvbmV0dGUubm9ybWFsaXplVUlTdHJpbmcodmFsLCB1aSk7XG4gICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QodmFsKSAmJiBfLmlzQXJyYXkocHJvcGVydGllcykpIHtcbiAgICAgICAgXy5leHRlbmQodmFsLCBNYXJpb25ldHRlLm5vcm1hbGl6ZVVJVmFsdWVzKF8ucGljayh2YWwsIHByb3BlcnRpZXMpLCB1aSkpO1xuICAgICAgICAvKiBWYWx1ZSBpcyBhbiBvYmplY3QsIGFuZCB3ZSBnb3QgYW4gYXJyYXkgb2YgZW1iZWRkZWQgcHJvcGVydHkgbmFtZXMgdG8gbm9ybWFsaXplLiAqL1xuICAgICAgICBfLmVhY2gocHJvcGVydGllcywgZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgICB2YXIgcHJvcGVydHlWYWwgPSB2YWxbcHJvcGVydHldO1xuICAgICAgICAgIGlmIChfLmlzU3RyaW5nKHByb3BlcnR5VmFsKSkge1xuICAgICAgICAgICAgdmFsW3Byb3BlcnR5XSA9IE1hcmlvbmV0dGUubm9ybWFsaXplVUlTdHJpbmcocHJvcGVydHlWYWwsIHVpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBoYXNoO1xuICB9O1xuICBcbiAgLy8gTWl4IGluIG1ldGhvZHMgZnJvbSBVbmRlcnNjb3JlLCBmb3IgaXRlcmF0aW9uLCBhbmQgb3RoZXJcbiAgLy8gY29sbGVjdGlvbiByZWxhdGVkIGZlYXR1cmVzLlxuICAvLyBCb3Jyb3dpbmcgdGhpcyBjb2RlIGZyb20gQmFja2JvbmUuQ29sbGVjdGlvbjpcbiAgLy8gaHR0cDovL2JhY2tib25lanMub3JnL2RvY3MvYmFja2JvbmUuaHRtbCNzZWN0aW9uLTEyMVxuICBNYXJpb25ldHRlLmFjdEFzQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKG9iamVjdCwgbGlzdFByb3BlcnR5KSB7XG4gICAgdmFyIG1ldGhvZHMgPSBbJ2ZvckVhY2gnLCAnZWFjaCcsICdtYXAnLCAnZmluZCcsICdkZXRlY3QnLCAnZmlsdGVyJyxcbiAgICAgICdzZWxlY3QnLCAncmVqZWN0JywgJ2V2ZXJ5JywgJ2FsbCcsICdzb21lJywgJ2FueScsICdpbmNsdWRlJyxcbiAgICAgICdjb250YWlucycsICdpbnZva2UnLCAndG9BcnJheScsICdmaXJzdCcsICdpbml0aWFsJywgJ3Jlc3QnLFxuICAgICAgJ2xhc3QnLCAnd2l0aG91dCcsICdpc0VtcHR5JywgJ3BsdWNrJ107XG4gIFxuICAgIF8uZWFjaChtZXRob2RzLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIG9iamVjdFttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsaXN0ID0gXy52YWx1ZXMoXy5yZXN1bHQodGhpcywgbGlzdFByb3BlcnR5KSk7XG4gICAgICAgIHZhciBhcmdzID0gW2xpc3RdLmNvbmNhdChfLnRvQXJyYXkoYXJndW1lbnRzKSk7XG4gICAgICAgIHJldHVybiBfW21ldGhvZF0uYXBwbHkoXywgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuICBcbiAgdmFyIGRlcHJlY2F0ZSA9IE1hcmlvbmV0dGUuZGVwcmVjYXRlID0gZnVuY3Rpb24obWVzc2FnZSwgdGVzdCkge1xuICAgIGlmIChfLmlzT2JqZWN0KG1lc3NhZ2UpKSB7XG4gICAgICBtZXNzYWdlID0gKFxuICAgICAgICBtZXNzYWdlLnByZXYgKyAnIGlzIGdvaW5nIHRvIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS4gJyArXG4gICAgICAgICdQbGVhc2UgdXNlICcgKyBtZXNzYWdlLm5leHQgKyAnIGluc3RlYWQuJyArXG4gICAgICAgIChtZXNzYWdlLnVybCA/ICcgU2VlOiAnICsgbWVzc2FnZS51cmwgOiAnJylcbiAgICAgICk7XG4gICAgfVxuICBcbiAgICBpZiAoKHRlc3QgPT09IHVuZGVmaW5lZCB8fCAhdGVzdCkgJiYgIWRlcHJlY2F0ZS5fY2FjaGVbbWVzc2FnZV0pIHtcbiAgICAgIGRlcHJlY2F0ZS5fd2FybignRGVwcmVjYXRpb24gd2FybmluZzogJyArIG1lc3NhZ2UpO1xuICAgICAgZGVwcmVjYXRlLl9jYWNoZVttZXNzYWdlXSA9IHRydWU7XG4gICAgfVxuICB9O1xuICBcbiAgZGVwcmVjYXRlLl93YXJuID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIChjb25zb2xlLndhcm4gfHwgY29uc29sZS5sb2cpIHx8IGZ1bmN0aW9uKCkge307XG4gIGRlcHJlY2F0ZS5fY2FjaGUgPSB7fTtcbiAgXG4gIC8qIGpzaGludCBtYXhzdGF0ZW1lbnRzOiAxNCwgbWF4Y29tcGxleGl0eTogNyAqL1xuICBcbiAgLy8gVHJpZ2dlciBNZXRob2RcbiAgLy8gLS0tLS0tLS0tLS0tLS1cbiAgXG4gIE1hcmlvbmV0dGUuX3RyaWdnZXJNZXRob2QgPSAoZnVuY3Rpb24oKSB7XG4gICAgLy8gc3BsaXQgdGhlIGV2ZW50IG5hbWUgb24gdGhlIFwiOlwiXG4gICAgdmFyIHNwbGl0dGVyID0gLyhefDopKFxcdykvZ2k7XG4gIFxuICAgIC8vIHRha2UgdGhlIGV2ZW50IHNlY3Rpb24gKFwic2VjdGlvbjE6c2VjdGlvbjI6c2VjdGlvbjNcIilcbiAgICAvLyBhbmQgdHVybiBpdCBpbiB0byB1cHBlcmNhc2UgbmFtZVxuICAgIGZ1bmN0aW9uIGdldEV2ZW50TmFtZShtYXRjaCwgcHJlZml4LCBldmVudE5hbWUpIHtcbiAgICAgIHJldHVybiBldmVudE5hbWUudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gIFxuICAgIHJldHVybiBmdW5jdGlvbihjb250ZXh0LCBldmVudCwgYXJncykge1xuICAgICAgdmFyIG5vRXZlbnRBcmcgPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcbiAgICAgIGlmIChub0V2ZW50QXJnKSB7XG4gICAgICAgIGFyZ3MgPSBldmVudDtcbiAgICAgICAgZXZlbnQgPSBhcmdzWzBdO1xuICAgICAgfVxuICBcbiAgICAgIC8vIGdldCB0aGUgbWV0aG9kIG5hbWUgZnJvbSB0aGUgZXZlbnQgbmFtZVxuICAgICAgdmFyIG1ldGhvZE5hbWUgPSAnb24nICsgZXZlbnQucmVwbGFjZShzcGxpdHRlciwgZ2V0RXZlbnROYW1lKTtcbiAgICAgIHZhciBtZXRob2QgPSBjb250ZXh0W21ldGhvZE5hbWVdO1xuICAgICAgdmFyIHJlc3VsdDtcbiAgXG4gICAgICAvLyBjYWxsIHRoZSBvbk1ldGhvZE5hbWUgaWYgaXQgZXhpc3RzXG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG1ldGhvZCkpIHtcbiAgICAgICAgLy8gcGFzcyBhbGwgYXJncywgZXhjZXB0IHRoZSBldmVudCBuYW1lXG4gICAgICAgIHJlc3VsdCA9IG1ldGhvZC5hcHBseShjb250ZXh0LCBub0V2ZW50QXJnID8gXy5yZXN0KGFyZ3MpIDogYXJncyk7XG4gICAgICB9XG4gIFxuICAgICAgLy8gdHJpZ2dlciB0aGUgZXZlbnQsIGlmIGEgdHJpZ2dlciBtZXRob2QgZXhpc3RzXG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKGNvbnRleHQudHJpZ2dlcikpIHtcbiAgICAgICAgaWYgKG5vRXZlbnRBcmcgKyBhcmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBjb250ZXh0LnRyaWdnZXIuYXBwbHkoY29udGV4dCwgbm9FdmVudEFyZyA/IGFyZ3MgOiBbZXZlbnRdLmNvbmNhdChfLmRyb3AoYXJncywgMCkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LnRyaWdnZXIoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gIFxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9KSgpO1xuICBcbiAgLy8gVHJpZ2dlciBhbiBldmVudCBhbmQvb3IgYSBjb3JyZXNwb25kaW5nIG1ldGhvZCBuYW1lLiBFeGFtcGxlczpcbiAgLy9cbiAgLy8gYHRoaXMudHJpZ2dlck1ldGhvZChcImZvb1wiKWAgd2lsbCB0cmlnZ2VyIHRoZSBcImZvb1wiIGV2ZW50IGFuZFxuICAvLyBjYWxsIHRoZSBcIm9uRm9vXCIgbWV0aG9kLlxuICAvL1xuICAvLyBgdGhpcy50cmlnZ2VyTWV0aG9kKFwiZm9vOmJhclwiKWAgd2lsbCB0cmlnZ2VyIHRoZSBcImZvbzpiYXJcIiBldmVudCBhbmRcbiAgLy8gY2FsbCB0aGUgXCJvbkZvb0JhclwiIG1ldGhvZC5cbiAgTWFyaW9uZXR0ZS50cmlnZ2VyTWV0aG9kID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICByZXR1cm4gTWFyaW9uZXR0ZS5fdHJpZ2dlck1ldGhvZCh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICBcbiAgLy8gdHJpZ2dlck1ldGhvZE9uIGludm9rZXMgdHJpZ2dlck1ldGhvZCBvbiBhIHNwZWNpZmljIGNvbnRleHRcbiAgLy9cbiAgLy8gZS5nLiBgTWFyaW9uZXR0ZS50cmlnZ2VyTWV0aG9kT24odmlldywgJ3Nob3cnKWBcbiAgLy8gd2lsbCB0cmlnZ2VyIGEgXCJzaG93XCIgZXZlbnQgb3IgaW52b2tlIG9uU2hvdyB0aGUgdmlldy5cbiAgTWFyaW9uZXR0ZS50cmlnZ2VyTWV0aG9kT24gPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIGZuYyA9IF8uaXNGdW5jdGlvbihjb250ZXh0LnRyaWdnZXJNZXRob2QpID9cbiAgICAgICAgICAgICAgICAgIGNvbnRleHQudHJpZ2dlck1ldGhvZCA6XG4gICAgICAgICAgICAgICAgICBNYXJpb25ldHRlLnRyaWdnZXJNZXRob2Q7XG4gIFxuICAgIHJldHVybiBmbmMuYXBwbHkoY29udGV4dCwgXy5yZXN0KGFyZ3VtZW50cykpO1xuICB9O1xuICBcbiAgLy8gRE9NIFJlZnJlc2hcbiAgLy8gLS0tLS0tLS0tLS1cbiAgXG4gIC8vIE1vbml0b3IgYSB2aWV3J3Mgc3RhdGUsIGFuZCBhZnRlciBpdCBoYXMgYmVlbiByZW5kZXJlZCBhbmQgc2hvd25cbiAgLy8gaW4gdGhlIERPTSwgdHJpZ2dlciBhIFwiZG9tOnJlZnJlc2hcIiBldmVudCBldmVyeSB0aW1lIGl0IGlzXG4gIC8vIHJlLXJlbmRlcmVkLlxuICBcbiAgTWFyaW9uZXR0ZS5Nb25pdG9yRE9NUmVmcmVzaCA9IGZ1bmN0aW9uKHZpZXcpIHtcbiAgXG4gICAgLy8gdHJhY2sgd2hlbiB0aGUgdmlldyBoYXMgYmVlbiBzaG93biBpbiB0aGUgRE9NLFxuICAgIC8vIHVzaW5nIGEgTWFyaW9uZXR0ZS5SZWdpb24gKG9yIGJ5IG90aGVyIG1lYW5zIG9mIHRyaWdnZXJpbmcgXCJzaG93XCIpXG4gICAgZnVuY3Rpb24gaGFuZGxlU2hvdygpIHtcbiAgICAgIHZpZXcuX2lzU2hvd24gPSB0cnVlO1xuICAgICAgdHJpZ2dlckRPTVJlZnJlc2goKTtcbiAgICB9XG4gIFxuICAgIC8vIHRyYWNrIHdoZW4gdGhlIHZpZXcgaGFzIGJlZW4gcmVuZGVyZWRcbiAgICBmdW5jdGlvbiBoYW5kbGVSZW5kZXIoKSB7XG4gICAgICB2aWV3Ll9pc1JlbmRlcmVkID0gdHJ1ZTtcbiAgICAgIHRyaWdnZXJET01SZWZyZXNoKCk7XG4gICAgfVxuICBcbiAgICAvLyBUcmlnZ2VyIHRoZSBcImRvbTpyZWZyZXNoXCIgZXZlbnQgYW5kIGNvcnJlc3BvbmRpbmcgXCJvbkRvbVJlZnJlc2hcIiBtZXRob2RcbiAgICBmdW5jdGlvbiB0cmlnZ2VyRE9NUmVmcmVzaCgpIHtcbiAgICAgIGlmICh2aWV3Ll9pc1Nob3duICYmIHZpZXcuX2lzUmVuZGVyZWQgJiYgTWFyaW9uZXR0ZS5pc05vZGVBdHRhY2hlZCh2aWV3LmVsKSkge1xuICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHZpZXcudHJpZ2dlck1ldGhvZCkpIHtcbiAgICAgICAgICB2aWV3LnRyaWdnZXJNZXRob2QoJ2RvbTpyZWZyZXNoJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIFxuICAgIHZpZXcub24oe1xuICAgICAgc2hvdzogaGFuZGxlU2hvdyxcbiAgICAgIHJlbmRlcjogaGFuZGxlUmVuZGVyXG4gICAgfSk7XG4gIH07XG4gIFxuICAvKiBqc2hpbnQgbWF4cGFyYW1zOiA1ICovXG4gIFxuICAvLyBCaW5kIEVudGl0eSBFdmVudHMgJiBVbmJpbmQgRW50aXR5IEV2ZW50c1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvL1xuICAvLyBUaGVzZSBtZXRob2RzIGFyZSB1c2VkIHRvIGJpbmQvdW5iaW5kIGEgYmFja2JvbmUgXCJlbnRpdHlcIiAoZS5nLiBjb2xsZWN0aW9uL21vZGVsKVxuICAvLyB0byBtZXRob2RzIG9uIGEgdGFyZ2V0IG9iamVjdC5cbiAgLy9cbiAgLy8gVGhlIGZpcnN0IHBhcmFtZXRlciwgYHRhcmdldGAsIG11c3QgaGF2ZSB0aGUgQmFja2JvbmUuRXZlbnRzIG1vZHVsZSBtaXhlZCBpbi5cbiAgLy9cbiAgLy8gVGhlIHNlY29uZCBwYXJhbWV0ZXIgaXMgdGhlIGBlbnRpdHlgIChCYWNrYm9uZS5Nb2RlbCwgQmFja2JvbmUuQ29sbGVjdGlvbiBvclxuICAvLyBhbnkgb2JqZWN0IHRoYXQgaGFzIEJhY2tib25lLkV2ZW50cyBtaXhlZCBpbikgdG8gYmluZCB0aGUgZXZlbnRzIGZyb20uXG4gIC8vXG4gIC8vIFRoZSB0aGlyZCBwYXJhbWV0ZXIgaXMgYSBoYXNoIG9mIHsgXCJldmVudDpuYW1lXCI6IFwiZXZlbnRIYW5kbGVyXCIgfVxuICAvLyBjb25maWd1cmF0aW9uLiBNdWx0aXBsZSBoYW5kbGVycyBjYW4gYmUgc2VwYXJhdGVkIGJ5IGEgc3BhY2UuIEFcbiAgLy8gZnVuY3Rpb24gY2FuIGJlIHN1cHBsaWVkIGluc3RlYWQgb2YgYSBzdHJpbmcgaGFuZGxlciBuYW1lLlxuICBcbiAgKGZ1bmN0aW9uKE1hcmlvbmV0dGUpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gIFxuICAgIC8vIEJpbmQgdGhlIGV2ZW50IHRvIGhhbmRsZXJzIHNwZWNpZmllZCBhcyBhIHN0cmluZyBvZlxuICAgIC8vIGhhbmRsZXIgbmFtZXMgb24gdGhlIHRhcmdldCBvYmplY3RcbiAgICBmdW5jdGlvbiBiaW5kRnJvbVN0cmluZ3ModGFyZ2V0LCBlbnRpdHksIGV2dCwgbWV0aG9kcykge1xuICAgICAgdmFyIG1ldGhvZE5hbWVzID0gbWV0aG9kcy5zcGxpdCgvXFxzKy8pO1xuICBcbiAgICAgIF8uZWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICBcbiAgICAgICAgdmFyIG1ldGhvZCA9IHRhcmdldFttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKCFtZXRob2QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTWFyaW9uZXR0ZS5FcnJvcignTWV0aG9kIFwiJyArIG1ldGhvZE5hbWUgK1xuICAgICAgICAgICAgJ1wiIHdhcyBjb25maWd1cmVkIGFzIGFuIGV2ZW50IGhhbmRsZXIsIGJ1dCBkb2VzIG5vdCBleGlzdC4nKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgdGFyZ2V0Lmxpc3RlblRvKGVudGl0eSwgZXZ0LCBtZXRob2QpO1xuICAgICAgfSk7XG4gICAgfVxuICBcbiAgICAvLyBCaW5kIHRoZSBldmVudCB0byBhIHN1cHBsaWVkIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgZnVuY3Rpb24gYmluZFRvRnVuY3Rpb24odGFyZ2V0LCBlbnRpdHksIGV2dCwgbWV0aG9kKSB7XG4gICAgICB0YXJnZXQubGlzdGVuVG8oZW50aXR5LCBldnQsIG1ldGhvZCk7XG4gICAgfVxuICBcbiAgICAvLyBCaW5kIHRoZSBldmVudCB0byBoYW5kbGVycyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgb2ZcbiAgICAvLyBoYW5kbGVyIG5hbWVzIG9uIHRoZSB0YXJnZXQgb2JqZWN0XG4gICAgZnVuY3Rpb24gdW5iaW5kRnJvbVN0cmluZ3ModGFyZ2V0LCBlbnRpdHksIGV2dCwgbWV0aG9kcykge1xuICAgICAgdmFyIG1ldGhvZE5hbWVzID0gbWV0aG9kcy5zcGxpdCgvXFxzKy8pO1xuICBcbiAgICAgIF8uZWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gdGFyZ2V0W21ldGhvZE5hbWVdO1xuICAgICAgICB0YXJnZXQuc3RvcExpc3RlbmluZyhlbnRpdHksIGV2dCwgbWV0aG9kKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgXG4gICAgLy8gQmluZCB0aGUgZXZlbnQgdG8gYSBzdXBwbGllZCBjYWxsYmFjayBmdW5jdGlvblxuICAgIGZ1bmN0aW9uIHVuYmluZFRvRnVuY3Rpb24odGFyZ2V0LCBlbnRpdHksIGV2dCwgbWV0aG9kKSB7XG4gICAgICB0YXJnZXQuc3RvcExpc3RlbmluZyhlbnRpdHksIGV2dCwgbWV0aG9kKTtcbiAgICB9XG4gIFxuICAgIC8vIGdlbmVyaWMgbG9vcGluZyBmdW5jdGlvblxuICAgIGZ1bmN0aW9uIGl0ZXJhdGVFdmVudHModGFyZ2V0LCBlbnRpdHksIGJpbmRpbmdzLCBmdW5jdGlvbkNhbGxiYWNrLCBzdHJpbmdDYWxsYmFjaykge1xuICAgICAgaWYgKCFlbnRpdHkgfHwgIWJpbmRpbmdzKSB7IHJldHVybjsgfVxuICBcbiAgICAgIC8vIHR5cGUtY2hlY2sgYmluZGluZ3NcbiAgICAgIGlmICghXy5pc09iamVjdChiaW5kaW5ncykpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1hcmlvbmV0dGUuRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6ICdCaW5kaW5ncyBtdXN0IGJlIGFuIG9iamVjdCBvciBmdW5jdGlvbi4nLFxuICAgICAgICAgIHVybDogJ21hcmlvbmV0dGUuZnVuY3Rpb25zLmh0bWwjbWFyaW9uZXR0ZWJpbmRlbnRpdHlldmVudHMnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICBcbiAgICAgIC8vIGFsbG93IHRoZSBiaW5kaW5ncyB0byBiZSBhIGZ1bmN0aW9uXG4gICAgICBiaW5kaW5ncyA9IE1hcmlvbmV0dGUuX2dldFZhbHVlKGJpbmRpbmdzLCB0YXJnZXQpO1xuICBcbiAgICAgIC8vIGl0ZXJhdGUgdGhlIGJpbmRpbmdzIGFuZCBiaW5kIHRoZW1cbiAgICAgIF8uZWFjaChiaW5kaW5ncywgZnVuY3Rpb24obWV0aG9kcywgZXZ0KSB7XG4gIFxuICAgICAgICAvLyBhbGxvdyBmb3IgYSBmdW5jdGlvbiBhcyB0aGUgaGFuZGxlcixcbiAgICAgICAgLy8gb3IgYSBsaXN0IG9mIGV2ZW50IG5hbWVzIGFzIGEgc3RyaW5nXG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24obWV0aG9kcykpIHtcbiAgICAgICAgICBmdW5jdGlvbkNhbGxiYWNrKHRhcmdldCwgZW50aXR5LCBldnQsIG1ldGhvZHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmluZ0NhbGxiYWNrKHRhcmdldCwgZW50aXR5LCBldnQsIG1ldGhvZHMpO1xuICAgICAgICB9XG4gIFxuICAgICAgfSk7XG4gICAgfVxuICBcbiAgICAvLyBFeHBvcnQgUHVibGljIEFQSVxuICAgIE1hcmlvbmV0dGUuYmluZEVudGl0eUV2ZW50cyA9IGZ1bmN0aW9uKHRhcmdldCwgZW50aXR5LCBiaW5kaW5ncykge1xuICAgICAgaXRlcmF0ZUV2ZW50cyh0YXJnZXQsIGVudGl0eSwgYmluZGluZ3MsIGJpbmRUb0Z1bmN0aW9uLCBiaW5kRnJvbVN0cmluZ3MpO1xuICAgIH07XG4gIFxuICAgIE1hcmlvbmV0dGUudW5iaW5kRW50aXR5RXZlbnRzID0gZnVuY3Rpb24odGFyZ2V0LCBlbnRpdHksIGJpbmRpbmdzKSB7XG4gICAgICBpdGVyYXRlRXZlbnRzKHRhcmdldCwgZW50aXR5LCBiaW5kaW5ncywgdW5iaW5kVG9GdW5jdGlvbiwgdW5iaW5kRnJvbVN0cmluZ3MpO1xuICAgIH07XG4gIFxuICAgIC8vIFByb3h5IGBiaW5kRW50aXR5RXZlbnRzYFxuICAgIE1hcmlvbmV0dGUucHJveHlCaW5kRW50aXR5RXZlbnRzID0gZnVuY3Rpb24oZW50aXR5LCBiaW5kaW5ncykge1xuICAgICAgcmV0dXJuIE1hcmlvbmV0dGUuYmluZEVudGl0eUV2ZW50cyh0aGlzLCBlbnRpdHksIGJpbmRpbmdzKTtcbiAgICB9O1xuICBcbiAgICAvLyBQcm94eSBgdW5iaW5kRW50aXR5RXZlbnRzYFxuICAgIE1hcmlvbmV0dGUucHJveHlVbmJpbmRFbnRpdHlFdmVudHMgPSBmdW5jdGlvbihlbnRpdHksIGJpbmRpbmdzKSB7XG4gICAgICByZXR1cm4gTWFyaW9uZXR0ZS51bmJpbmRFbnRpdHlFdmVudHModGhpcywgZW50aXR5LCBiaW5kaW5ncyk7XG4gICAgfTtcbiAgfSkoTWFyaW9uZXR0ZSk7XG4gIFxuXG4gIC8vIEVycm9yXG4gIC8vIC0tLS0tXG4gIFxuICB2YXIgZXJyb3JQcm9wcyA9IFsnZGVzY3JpcHRpb24nLCAnZmlsZU5hbWUnLCAnbGluZU51bWJlcicsICduYW1lJywgJ21lc3NhZ2UnLCAnbnVtYmVyJ107XG4gIFxuICBNYXJpb25ldHRlLkVycm9yID0gTWFyaW9uZXR0ZS5leHRlbmQuY2FsbChFcnJvciwge1xuICAgIHVybFJvb3Q6ICdodHRwOi8vbWFyaW9uZXR0ZWpzLmNvbS9kb2NzL3YnICsgTWFyaW9uZXR0ZS5WRVJTSU9OICsgJy8nLFxuICBcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24obWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgaWYgKF8uaXNPYmplY3QobWVzc2FnZSkpIHtcbiAgICAgICAgb3B0aW9ucyA9IG1lc3NhZ2U7XG4gICAgICAgIG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgICB9IGVsc2UgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cbiAgXG4gICAgICB2YXIgZXJyb3IgPSBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgXy5leHRlbmQodGhpcywgXy5waWNrKGVycm9yLCBlcnJvclByb3BzKSwgXy5waWNrKG9wdGlvbnMsIGVycm9yUHJvcHMpKTtcbiAgXG4gICAgICB0aGlzLmNhcHR1cmVTdGFja1RyYWNlKCk7XG4gIFxuICAgICAgaWYgKG9wdGlvbnMudXJsKSB7XG4gICAgICAgIHRoaXMudXJsID0gdGhpcy51cmxSb290ICsgb3B0aW9ucy51cmw7XG4gICAgICB9XG4gICAgfSxcbiAgXG4gICAgY2FwdHVyZVN0YWNrVHJhY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIE1hcmlvbmV0dGUuRXJyb3IpO1xuICAgICAgfVxuICAgIH0sXG4gIFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5hbWUgKyAnOiAnICsgdGhpcy5tZXNzYWdlICsgKHRoaXMudXJsID8gJyBTZWU6ICcgKyB0aGlzLnVybCA6ICcnKTtcbiAgICB9XG4gIH0pO1xuICBcbiAgTWFyaW9uZXR0ZS5FcnJvci5leHRlbmQgPSBNYXJpb25ldHRlLmV4dGVuZDtcbiAgXG4gIC8vIENhbGxiYWNrc1xuICAvLyAtLS0tLS0tLS1cbiAgXG4gIC8vIEEgc2ltcGxlIHdheSBvZiBtYW5hZ2luZyBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzXG4gIC8vIGFuZCBleGVjdXRpbmcgdGhlbSBhdCBhIGxhdGVyIHBvaW50IGluIHRpbWUsIHVzaW5nIGpRdWVyeSdzXG4gIC8vIGBEZWZlcnJlZGAgb2JqZWN0LlxuICBNYXJpb25ldHRlLkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2RlZmVycmVkID0gTWFyaW9uZXR0ZS5EZWZlcnJlZCgpO1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xuICB9O1xuICBcbiAgXy5leHRlbmQoTWFyaW9uZXR0ZS5DYWxsYmFja3MucHJvdG90eXBlLCB7XG4gIFxuICAgIC8vIEFkZCBhIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkLiBDYWxsYmFja3MgYWRkZWQgaGVyZSBhcmVcbiAgICAvLyBndWFyYW50ZWVkIHRvIGV4ZWN1dGUsIGV2ZW4gaWYgdGhleSBhcmUgYWRkZWQgYWZ0ZXIgdGhlXG4gICAgLy8gYHJ1bmAgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICBhZGQ6IGZ1bmN0aW9uKGNhbGxiYWNrLCBjb250ZXh0T3ZlcnJpZGUpIHtcbiAgICAgIHZhciBwcm9taXNlID0gXy5yZXN1bHQodGhpcy5fZGVmZXJyZWQsICdwcm9taXNlJyk7XG4gIFxuICAgICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goe2NiOiBjYWxsYmFjaywgY3R4OiBjb250ZXh0T3ZlcnJpZGV9KTtcbiAgXG4gICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oYXJncykge1xuICAgICAgICBpZiAoY29udGV4dE92ZXJyaWRlKSB7IGFyZ3MuY29udGV4dCA9IGNvbnRleHRPdmVycmlkZTsgfVxuICAgICAgICBjYWxsYmFjay5jYWxsKGFyZ3MuY29udGV4dCwgYXJncy5vcHRpb25zKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gIFxuICAgIC8vIFJ1biBhbGwgcmVnaXN0ZXJlZCBjYWxsYmFja3Mgd2l0aCB0aGUgY29udGV4dCBzcGVjaWZpZWQuXG4gICAgLy8gQWRkaXRpb25hbCBjYWxsYmFja3MgY2FuIGJlIGFkZGVkIGFmdGVyIHRoaXMgaGFzIGJlZW4gcnVuXG4gICAgLy8gYW5kIHRoZXkgd2lsbCBzdGlsbCBiZSBleGVjdXRlZC5cbiAgICBydW46IGZ1bmN0aW9uKG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgIHRoaXMuX2RlZmVycmVkLnJlc29sdmUoe1xuICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgICB9KTtcbiAgICB9LFxuICBcbiAgICAvLyBSZXNldHMgdGhlIGxpc3Qgb2YgY2FsbGJhY2tzIHRvIGJlIHJ1biwgYWxsb3dpbmcgdGhlIHNhbWUgbGlzdFxuICAgIC8vIHRvIGJlIHJ1biBtdWx0aXBsZSB0aW1lcyAtIHdoZW5ldmVyIHRoZSBgcnVuYCBtZXRob2QgaXMgY2FsbGVkLlxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3M7XG4gICAgICB0aGlzLl9kZWZlcnJlZCA9IE1hcmlvbmV0dGUuRGVmZXJyZWQoKTtcbiAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xuICBcbiAgICAgIF8uZWFjaChjYWxsYmFja3MsIGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgIHRoaXMuYWRkKGNiLmNiLCBjYi5jdHgpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9KTtcbiAgXG4gIC8vIENvbnRyb2xsZXJcbiAgLy8gLS0tLS0tLS0tLVxuICBcbiAgLy8gQSBtdWx0aS1wdXJwb3NlIG9iamVjdCB0byB1c2UgYXMgYSBjb250cm9sbGVyIGZvclxuICAvLyBtb2R1bGVzIGFuZCByb3V0ZXJzLCBhbmQgYXMgYSBtZWRpYXRvciBmb3Igd29ya2Zsb3dcbiAgLy8gYW5kIGNvb3JkaW5hdGlvbiBvZiBvdGhlciBvYmplY3RzLCB2aWV3cywgYW5kIG1vcmUuXG4gIE1hcmlvbmV0dGUuQ29udHJvbGxlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHRoaXMuaW5pdGlhbGl6ZSkpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZSh0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgfTtcbiAgXG4gIE1hcmlvbmV0dGUuQ29udHJvbGxlci5leHRlbmQgPSBNYXJpb25ldHRlLmV4dGVuZDtcbiAgXG4gIC8vIENvbnRyb2xsZXIgTWV0aG9kc1xuICAvLyAtLS0tLS0tLS0tLS0tLVxuICBcbiAgLy8gRW5zdXJlIGl0IGNhbiB0cmlnZ2VyIGV2ZW50cyB3aXRoIEJhY2tib25lLkV2ZW50c1xuICBfLmV4dGVuZChNYXJpb25ldHRlLkNvbnRyb2xsZXIucHJvdG90eXBlLCBCYWNrYm9uZS5FdmVudHMsIHtcbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgIE1hcmlvbmV0dGUuX3RyaWdnZXJNZXRob2QodGhpcywgJ2JlZm9yZTpkZXN0cm95JywgYXJndW1lbnRzKTtcbiAgICAgIE1hcmlvbmV0dGUuX3RyaWdnZXJNZXRob2QodGhpcywgJ2Rlc3Ryb3knLCBhcmd1bWVudHMpO1xuICBcbiAgICAgIHRoaXMuc3RvcExpc3RlbmluZygpO1xuICAgICAgdGhpcy5vZmYoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gIFxuICAgIC8vIGltcG9ydCB0aGUgYHRyaWdnZXJNZXRob2RgIHRvIHRyaWdnZXIgZXZlbnRzIHdpdGggY29ycmVzcG9uZGluZ1xuICAgIC8vIG1ldGhvZHMgaWYgdGhlIG1ldGhvZCBleGlzdHNcbiAgICB0cmlnZ2VyTWV0aG9kOiBNYXJpb25ldHRlLnRyaWdnZXJNZXRob2QsXG4gIFxuICAgIC8vIEEgaGFuZHkgd2F5IHRvIG1lcmdlIG9wdGlvbnMgb250byB0aGUgaW5zdGFuY2VcbiAgICBtZXJnZU9wdGlvbnM6IE1hcmlvbmV0dGUubWVyZ2VPcHRpb25zLFxuICBcbiAgICAvLyBQcm94eSBgZ2V0T3B0aW9uYCB0byBlbmFibGUgZ2V0dGluZyBvcHRpb25zIGZyb20gdGhpcyBvciB0aGlzLm9wdGlvbnMgYnkgbmFtZS5cbiAgICBnZXRPcHRpb246IE1hcmlvbmV0dGUucHJveHlHZXRPcHRpb25cbiAgXG4gIH0pO1xuICBcbiAgLy8gT2JqZWN0XG4gIC8vIC0tLS0tLVxuICBcbiAgLy8gQSBCYXNlIENsYXNzIHRoYXQgb3RoZXIgQ2xhc3NlcyBzaG91bGQgZGVzY2VuZCBmcm9tLlxuICAvLyBPYmplY3QgYm9ycm93cyBtYW55IGNvbnZlbnRpb25zIGFuZCB1dGlsaXRpZXMgZnJvbSBCYWNrYm9uZS5cbiAgTWFyaW9uZXR0ZS5PYmplY3QgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gXy5leHRlbmQoe30sIF8ucmVzdWx0KHRoaXMsICdvcHRpb25zJyksIG9wdGlvbnMpO1xuICBcbiAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgXG4gIE1hcmlvbmV0dGUuT2JqZWN0LmV4dGVuZCA9IE1hcmlvbmV0dGUuZXh0ZW5kO1xuICBcbiAgLy8gT2JqZWN0IE1ldGhvZHNcbiAgLy8gLS0tLS0tLS0tLS0tLS1cbiAgXG4gIC8vIEVuc3VyZSBpdCBjYW4gdHJpZ2dlciBldmVudHMgd2l0aCBCYWNrYm9uZS5FdmVudHNcbiAgXy5leHRlbmQoTWFyaW9uZXR0ZS5PYmplY3QucHJvdG90eXBlLCBCYWNrYm9uZS5FdmVudHMsIHtcbiAgXG4gICAgLy90aGlzIGlzIGEgbm9vcCBtZXRob2QgaW50ZW5kZWQgdG8gYmUgb3ZlcnJpZGRlbiBieSBjbGFzc2VzIHRoYXQgZXh0ZW5kIGZyb20gdGhpcyBiYXNlXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7fSxcbiAgXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2JlZm9yZTpkZXN0cm95Jyk7XG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2Rlc3Ryb3knKTtcbiAgICAgIHRoaXMuc3RvcExpc3RlbmluZygpO1xuICBcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gIFxuICAgIC8vIEltcG9ydCB0aGUgYHRyaWdnZXJNZXRob2RgIHRvIHRyaWdnZXIgZXZlbnRzIHdpdGggY29ycmVzcG9uZGluZ1xuICAgIC8vIG1ldGhvZHMgaWYgdGhlIG1ldGhvZCBleGlzdHNcbiAgICB0cmlnZ2VyTWV0aG9kOiBNYXJpb25ldHRlLnRyaWdnZXJNZXRob2QsXG4gIFxuICAgIC8vIEEgaGFuZHkgd2F5IHRvIG1lcmdlIG9wdGlvbnMgb250byB0aGUgaW5zdGFuY2VcbiAgICBtZXJnZU9wdGlvbnM6IE1hcmlvbmV0dGUubWVyZ2VPcHRpb25zLFxuICBcbiAgICAvLyBQcm94eSBgZ2V0T3B0aW9uYCB0byBlbmFibGUgZ2V0dGluZyBvcHRpb25zIGZyb20gdGhpcyBvciB0aGlzLm9wdGlvbnMgYnkgbmFtZS5cbiAgICBnZXRPcHRpb246IE1hcmlvbmV0dGUucHJveHlHZXRPcHRpb24sXG4gIFxuICAgIC8vIFByb3h5IGBiaW5kRW50aXR5RXZlbnRzYCB0byBlbmFibGUgYmluZGluZyB2aWV3J3MgZXZlbnRzIGZyb20gYW5vdGhlciBlbnRpdHkuXG4gICAgYmluZEVudGl0eUV2ZW50czogTWFyaW9uZXR0ZS5wcm94eUJpbmRFbnRpdHlFdmVudHMsXG4gIFxuICAgIC8vIFByb3h5IGB1bmJpbmRFbnRpdHlFdmVudHNgIHRvIGVuYWJsZSB1bmJpbmRpbmcgdmlldydzIGV2ZW50cyBmcm9tIGFub3RoZXIgZW50aXR5LlxuICAgIHVuYmluZEVudGl0eUV2ZW50czogTWFyaW9uZXR0ZS5wcm94eVVuYmluZEVudGl0eUV2ZW50c1xuICB9KTtcbiAgXG4gIC8qIGpzaGludCBtYXhjb21wbGV4aXR5OiAxNiwgbWF4c3RhdGVtZW50czogNDUsIG1heGxlbjogMTIwICovXG4gIFxuICAvLyBSZWdpb25cbiAgLy8gLS0tLS0tXG4gIFxuICAvLyBNYW5hZ2UgdGhlIHZpc3VhbCByZWdpb25zIG9mIHlvdXIgY29tcG9zaXRlIGFwcGxpY2F0aW9uLiBTZWVcbiAgLy8gaHR0cDovL2xvc3RlY2hpZXMuY29tL2Rlcmlja2JhaWxleS8yMDExLzEyLzEyL2NvbXBvc2l0ZS1qcy1hcHBzLXJlZ2lvbnMtYW5kLXJlZ2lvbi1tYW5hZ2Vycy9cbiAgXG4gIE1hcmlvbmV0dGUuUmVnaW9uID0gTWFyaW9uZXR0ZS5PYmplY3QuZXh0ZW5kKHtcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICBcbiAgICAgIC8vIHNldCBvcHRpb25zIHRlbXBvcmFyaWx5IHNvIHRoYXQgd2UgY2FuIGdldCBgZWxgLlxuICAgICAgLy8gb3B0aW9ucyB3aWxsIGJlIG92ZXJyaWRlbiBieSBPYmplY3QuY29uc3RydWN0b3JcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB0aGlzLmVsID0gdGhpcy5nZXRPcHRpb24oJ2VsJyk7XG4gIFxuICAgICAgLy8gSGFuZGxlIHdoZW4gdGhpcy5lbCBpcyBwYXNzZWQgaW4gYXMgYSAkIHdyYXBwZWQgZWxlbWVudC5cbiAgICAgIHRoaXMuZWwgPSB0aGlzLmVsIGluc3RhbmNlb2YgQmFja2JvbmUuJCA/IHRoaXMuZWxbMF0gOiB0aGlzLmVsO1xuICBcbiAgICAgIGlmICghdGhpcy5lbCkge1xuICAgICAgICB0aHJvdyBuZXcgTWFyaW9uZXR0ZS5FcnJvcih7XG4gICAgICAgICAgbmFtZTogJ05vRWxFcnJvcicsXG4gICAgICAgICAgbWVzc2FnZTogJ0FuIFwiZWxcIiBtdXN0IGJlIHNwZWNpZmllZCBmb3IgYSByZWdpb24uJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgXG4gICAgICB0aGlzLiRlbCA9IHRoaXMuZ2V0RWwodGhpcy5lbCk7XG4gICAgICBNYXJpb25ldHRlLk9iamVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG4gIFxuICAgIC8vIERpc3BsYXlzIGEgYmFja2JvbmUgdmlldyBpbnN0YW5jZSBpbnNpZGUgb2YgdGhlIHJlZ2lvbi5cbiAgICAvLyBIYW5kbGVzIGNhbGxpbmcgdGhlIGByZW5kZXJgIG1ldGhvZCBmb3IgeW91LiBSZWFkcyBjb250ZW50XG4gICAgLy8gZGlyZWN0bHkgZnJvbSB0aGUgYGVsYCBhdHRyaWJ1dGUuIEFsc28gY2FsbHMgYW4gb3B0aW9uYWxcbiAgICAvLyBgb25TaG93YCBhbmQgYG9uRGVzdHJveWAgbWV0aG9kIG9uIHlvdXIgdmlldywganVzdCBhZnRlciBzaG93aW5nXG4gICAgLy8gb3IganVzdCBiZWZvcmUgZGVzdHJveWluZyB0aGUgdmlldywgcmVzcGVjdGl2ZWx5LlxuICAgIC8vIFRoZSBgcHJldmVudERlc3Ryb3lgIG9wdGlvbiBjYW4gYmUgdXNlZCB0byBwcmV2ZW50IGEgdmlldyBmcm9tXG4gICAgLy8gdGhlIG9sZCB2aWV3IGJlaW5nIGRlc3Ryb3llZCBvbiBzaG93LlxuICAgIC8vIFRoZSBgZm9yY2VTaG93YCBvcHRpb24gY2FuIGJlIHVzZWQgdG8gZm9yY2UgYSB2aWV3IHRvIGJlXG4gICAgLy8gcmUtcmVuZGVyZWQgaWYgaXQncyBhbHJlYWR5IHNob3duIGluIHRoZSByZWdpb24uXG4gICAgc2hvdzogZnVuY3Rpb24odmlldywgb3B0aW9ucykge1xuICAgICAgaWYgKCF0aGlzLl9lbnN1cmVFbGVtZW50KCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICBcbiAgICAgIHRoaXMuX2Vuc3VyZVZpZXdJc0ludGFjdCh2aWV3KTtcbiAgXG4gICAgICB2YXIgc2hvd09wdGlvbnMgICAgID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBpc0RpZmZlcmVudFZpZXcgPSB2aWV3ICE9PSB0aGlzLmN1cnJlbnRWaWV3O1xuICAgICAgdmFyIHByZXZlbnREZXN0cm95ICA9ICEhc2hvd09wdGlvbnMucHJldmVudERlc3Ryb3k7XG4gICAgICB2YXIgZm9yY2VTaG93ICAgICAgID0gISFzaG93T3B0aW9ucy5mb3JjZVNob3c7XG4gIFxuICAgICAgLy8gV2UgYXJlIG9ubHkgY2hhbmdpbmcgdGhlIHZpZXcgaWYgdGhlcmUgaXMgYSBjdXJyZW50IHZpZXcgdG8gY2hhbmdlIHRvIGJlZ2luIHdpdGhcbiAgICAgIHZhciBpc0NoYW5naW5nVmlldyA9ICEhdGhpcy5jdXJyZW50VmlldztcbiAgXG4gICAgICAvLyBPbmx5IGRlc3Ryb3kgdGhlIGN1cnJlbnQgdmlldyBpZiB3ZSBkb24ndCB3YW50IHRvIGBwcmV2ZW50RGVzdHJveWAgYW5kIGlmXG4gICAgICAvLyB0aGUgdmlldyBnaXZlbiBpbiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgZGlmZmVyZW50IHRoYW4gYGN1cnJlbnRWaWV3YFxuICAgICAgdmFyIF9zaG91bGREZXN0cm95VmlldyA9IGlzRGlmZmVyZW50VmlldyAmJiAhcHJldmVudERlc3Ryb3k7XG4gIFxuICAgICAgLy8gT25seSBzaG93IHRoZSB2aWV3IGdpdmVuIGluIHRoZSBmaXJzdCBhcmd1bWVudCBpZiBpdCBpcyBkaWZmZXJlbnQgdGhhblxuICAgICAgLy8gdGhlIGN1cnJlbnQgdmlldyBvciBpZiB3ZSB3YW50IHRvIHJlLXNob3cgdGhlIHZpZXcuIE5vdGUgdGhhdCBpZlxuICAgICAgLy8gYF9zaG91bGREZXN0cm95Vmlld2AgaXMgdHJ1ZSwgdGhlbiBgX3Nob3VsZFNob3dWaWV3YCBpcyBhbHNvIG5lY2Vzc2FyaWx5IHRydWUuXG4gICAgICB2YXIgX3Nob3VsZFNob3dWaWV3ID0gaXNEaWZmZXJlbnRWaWV3IHx8IGZvcmNlU2hvdztcbiAgXG4gICAgICBpZiAoaXNDaGFuZ2luZ1ZpZXcpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6c3dhcE91dCcsIHRoaXMuY3VycmVudFZpZXcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgfVxuICBcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRWaWV3KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRWaWV3Ll9wYXJlbnQ7XG4gICAgICB9XG4gIFxuICAgICAgaWYgKF9zaG91bGREZXN0cm95Vmlldykge1xuICAgICAgICB0aGlzLmVtcHR5KCk7XG4gIFxuICAgICAgLy8gQSBgZGVzdHJveWAgZXZlbnQgaXMgYXR0YWNoZWQgdG8gdGhlIGNsZWFuIHVwIG1hbnVhbGx5IHJlbW92ZWQgdmlld3MuXG4gICAgICAvLyBXZSBuZWVkIHRvIGRldGFjaCB0aGlzIGV2ZW50IHdoZW4gYSBuZXcgdmlldyBpcyBnb2luZyB0byBiZSBzaG93biBhcyBpdFxuICAgICAgLy8gaXMgbm8gbG9uZ2VyIHJlbGV2YW50LlxuICAgICAgfSBlbHNlIGlmIChpc0NoYW5naW5nVmlldyAmJiBfc2hvdWxkU2hvd1ZpZXcpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50Vmlldy5vZmYoJ2Rlc3Ryb3knLCB0aGlzLmVtcHR5LCB0aGlzKTtcbiAgICAgIH1cbiAgXG4gICAgICBpZiAoX3Nob3VsZFNob3dWaWV3KSB7XG4gIFxuICAgICAgICAvLyBXZSBuZWVkIHRvIGxpc3RlbiBmb3IgaWYgYSB2aWV3IGlzIGRlc3Ryb3llZFxuICAgICAgICAvLyBpbiBhIHdheSBvdGhlciB0aGFuIHRocm91Z2ggdGhlIHJlZ2lvbi5cbiAgICAgICAgLy8gSWYgdGhpcyBoYXBwZW5zIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSByZWZlcmVuY2VcbiAgICAgICAgLy8gdG8gdGhlIGN1cnJlbnRWaWV3IHNpbmNlIG9uY2UgYSB2aWV3IGhhcyBiZWVuIGRlc3Ryb3llZFxuICAgICAgICAvLyB3ZSBjYW4gbm90IHJldXNlIGl0LlxuICAgICAgICB2aWV3Lm9uY2UoJ2Rlc3Ryb3knLCB0aGlzLmVtcHR5LCB0aGlzKTtcbiAgICAgICAgdmlldy5yZW5kZXIoKTtcbiAgXG4gICAgICAgIHZpZXcuX3BhcmVudCA9IHRoaXM7XG4gIFxuICAgICAgICBpZiAoaXNDaGFuZ2luZ1ZpZXcpIHtcbiAgICAgICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2JlZm9yZTpzd2FwJywgdmlldywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgnYmVmb3JlOnNob3cnLCB2aWV3LCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgTWFyaW9uZXR0ZS50cmlnZ2VyTWV0aG9kT24odmlldywgJ2JlZm9yZTpzaG93JywgdmlldywgdGhpcywgb3B0aW9ucyk7XG4gIFxuICAgICAgICBpZiAoaXNDaGFuZ2luZ1ZpZXcpIHtcbiAgICAgICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ3N3YXBPdXQnLCB0aGlzLmN1cnJlbnRWaWV3LCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgLy8gQW4gYXJyYXkgb2Ygdmlld3MgdGhhdCB3ZSdyZSBhYm91dCB0byBkaXNwbGF5XG4gICAgICAgIHZhciBhdHRhY2hlZFJlZ2lvbiA9IE1hcmlvbmV0dGUuaXNOb2RlQXR0YWNoZWQodGhpcy5lbCk7XG4gIFxuICAgICAgICAvLyBUaGUgdmlld3MgdGhhdCB3ZSdyZSBhYm91dCB0byBhdHRhY2ggdG8gdGhlIGRvY3VtZW50XG4gICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgd2UgcHJldmVudCBfZ2V0TmVzdGVkVmlld3MgZnJvbSBiZWluZyBleGVjdXRlZCB1bm5lY2Vzc2FyaWx5XG4gICAgICAgIC8vIGFzIGl0J3MgYSBwb3RlbnRpYWxseS1zbG93IG1ldGhvZFxuICAgICAgICB2YXIgZGlzcGxheWVkVmlld3MgPSBbXTtcbiAgXG4gICAgICAgIHZhciBhdHRhY2hPcHRpb25zID0gXy5leHRlbmQoe1xuICAgICAgICAgIHRyaWdnZXJCZWZvcmVBdHRhY2g6IHRoaXMudHJpZ2dlckJlZm9yZUF0dGFjaCxcbiAgICAgICAgICB0cmlnZ2VyQXR0YWNoOiB0aGlzLnRyaWdnZXJBdHRhY2hcbiAgICAgICAgfSwgc2hvd09wdGlvbnMpO1xuICBcbiAgICAgICAgaWYgKGF0dGFjaGVkUmVnaW9uICYmIGF0dGFjaE9wdGlvbnMudHJpZ2dlckJlZm9yZUF0dGFjaCkge1xuICAgICAgICAgIGRpc3BsYXllZFZpZXdzID0gdGhpcy5fZGlzcGxheWVkVmlld3Modmlldyk7XG4gICAgICAgICAgdGhpcy5fdHJpZ2dlckF0dGFjaChkaXNwbGF5ZWRWaWV3cywgJ2JlZm9yZTonKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgdGhpcy5hdHRhY2hIdG1sKHZpZXcpO1xuICAgICAgICB0aGlzLmN1cnJlbnRWaWV3ID0gdmlldztcbiAgXG4gICAgICAgIGlmIChhdHRhY2hlZFJlZ2lvbiAmJiBhdHRhY2hPcHRpb25zLnRyaWdnZXJBdHRhY2gpIHtcbiAgICAgICAgICBkaXNwbGF5ZWRWaWV3cyA9IHRoaXMuX2Rpc3BsYXllZFZpZXdzKHZpZXcpO1xuICAgICAgICAgIHRoaXMuX3RyaWdnZXJBdHRhY2goZGlzcGxheWVkVmlld3MpO1xuICAgICAgICB9XG4gIFxuICAgICAgICBpZiAoaXNDaGFuZ2luZ1ZpZXcpIHtcbiAgICAgICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ3N3YXAnLCB2aWV3LCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdzaG93JywgdmlldywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIE1hcmlvbmV0dGUudHJpZ2dlck1ldGhvZE9uKHZpZXcsICdzaG93JywgdmlldywgdGhpcywgb3B0aW9ucyk7XG4gIFxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICBcbiAgICB0cmlnZ2VyQmVmb3JlQXR0YWNoOiB0cnVlLFxuICAgIHRyaWdnZXJBdHRhY2g6IHRydWUsXG4gIFxuICAgIF90cmlnZ2VyQXR0YWNoOiBmdW5jdGlvbih2aWV3cywgcHJlZml4KSB7XG4gICAgICB2YXIgZXZlbnROYW1lID0gKHByZWZpeCB8fCAnJykgKyAnYXR0YWNoJztcbiAgICAgIF8uZWFjaCh2aWV3cywgZnVuY3Rpb24odmlldykge1xuICAgICAgICBNYXJpb25ldHRlLnRyaWdnZXJNZXRob2RPbih2aWV3LCBldmVudE5hbWUsIHZpZXcsIHRoaXMpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSxcbiAgXG4gICAgX2Rpc3BsYXllZFZpZXdzOiBmdW5jdGlvbih2aWV3KSB7XG4gICAgICByZXR1cm4gXy51bmlvbihbdmlld10sIF8ucmVzdWx0KHZpZXcsICdfZ2V0TmVzdGVkVmlld3MnKSB8fCBbXSk7XG4gICAgfSxcbiAgXG4gICAgX2Vuc3VyZUVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFfLmlzT2JqZWN0KHRoaXMuZWwpKSB7XG4gICAgICAgIHRoaXMuJGVsID0gdGhpcy5nZXRFbCh0aGlzLmVsKTtcbiAgICAgICAgdGhpcy5lbCA9IHRoaXMuJGVsWzBdO1xuICAgICAgfVxuICBcbiAgICAgIGlmICghdGhpcy4kZWwgfHwgdGhpcy4kZWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbignYWxsb3dNaXNzaW5nRWwnKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTWFyaW9uZXR0ZS5FcnJvcignQW4gXCJlbFwiICcgKyB0aGlzLiRlbC5zZWxlY3RvciArICcgbXVzdCBleGlzdCBpbiBET00nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgXG4gICAgX2Vuc3VyZVZpZXdJc0ludGFjdDogZnVuY3Rpb24odmlldykge1xuICAgICAgaWYgKCF2aWV3KSB7XG4gICAgICAgIHRocm93IG5ldyBNYXJpb25ldHRlLkVycm9yKHtcbiAgICAgICAgICBuYW1lOiAnVmlld05vdFZhbGlkJyxcbiAgICAgICAgICBtZXNzYWdlOiAnVGhlIHZpZXcgcGFzc2VkIGlzIHVuZGVmaW5lZCBhbmQgdGhlcmVmb3JlIGludmFsaWQuIFlvdSBtdXN0IHBhc3MgYSB2aWV3IGluc3RhbmNlIHRvIHNob3cuJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgXG4gICAgICBpZiAodmlldy5pc0Rlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgTWFyaW9uZXR0ZS5FcnJvcih7XG4gICAgICAgICAgbmFtZTogJ1ZpZXdEZXN0cm95ZWRFcnJvcicsXG4gICAgICAgICAgbWVzc2FnZTogJ1ZpZXcgKGNpZDogXCInICsgdmlldy5jaWQgKyAnXCIpIGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkIGFuZCBjYW5ub3QgYmUgdXNlZC4nXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gIFxuICAgIC8vIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSBob3cgdGhlIHJlZ2lvbiBmaW5kcyB0aGUgRE9NXG4gICAgLy8gZWxlbWVudCB0aGF0IGl0IG1hbmFnZXMuIFJldHVybiBhIGpRdWVyeSBzZWxlY3RvciBvYmplY3Qgc2NvcGVkXG4gICAgLy8gdG8gYSBwcm92aWRlZCBwYXJlbnQgZWwgb3IgdGhlIGRvY3VtZW50IGlmIG5vbmUgZXhpc3RzLlxuICAgIGdldEVsOiBmdW5jdGlvbihlbCkge1xuICAgICAgcmV0dXJuIEJhY2tib25lLiQoZWwsIE1hcmlvbmV0dGUuX2dldFZhbHVlKHRoaXMub3B0aW9ucy5wYXJlbnRFbCwgdGhpcykpO1xuICAgIH0sXG4gIFxuICAgIC8vIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSBob3cgdGhlIG5ldyB2aWV3IGlzXG4gICAgLy8gYXBwZW5kZWQgdG8gdGhlIGAkZWxgIHRoYXQgdGhlIHJlZ2lvbiBpcyBtYW5hZ2luZ1xuICAgIGF0dGFjaEh0bWw6IGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgIHRoaXMuJGVsLmNvbnRlbnRzKCkuZGV0YWNoKCk7XG4gIFxuICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh2aWV3LmVsKTtcbiAgICB9LFxuICBcbiAgICAvLyBEZXN0cm95IHRoZSBjdXJyZW50IHZpZXcsIGlmIHRoZXJlIGlzIG9uZS4gSWYgdGhlcmUgaXMgbm9cbiAgICAvLyBjdXJyZW50IHZpZXcsIGl0IGRvZXMgbm90aGluZyBhbmQgcmV0dXJucyBpbW1lZGlhdGVseS5cbiAgICBlbXB0eTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIHZpZXcgPSB0aGlzLmN1cnJlbnRWaWV3O1xuICBcbiAgICAgIHZhciBwcmV2ZW50RGVzdHJveSA9IE1hcmlvbmV0dGUuX2dldFZhbHVlKG9wdGlvbnMsICdwcmV2ZW50RGVzdHJveScsIHRoaXMpO1xuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gdmlldyBpbiB0aGUgcmVnaW9uXG4gICAgICAvLyB3ZSBzaG91bGQgbm90IHJlbW92ZSBhbnl0aGluZ1xuICAgICAgaWYgKCF2aWV3KSB7IHJldHVybjsgfVxuICBcbiAgICAgIHZpZXcub2ZmKCdkZXN0cm95JywgdGhpcy5lbXB0eSwgdGhpcyk7XG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2JlZm9yZTplbXB0eScsIHZpZXcpO1xuICAgICAgaWYgKCFwcmV2ZW50RGVzdHJveSkge1xuICAgICAgICB0aGlzLl9kZXN0cm95VmlldygpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdlbXB0eScsIHZpZXcpO1xuICBcbiAgICAgIC8vIFJlbW92ZSByZWdpb24gcG9pbnRlciB0byB0aGUgY3VycmVudFZpZXdcbiAgICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRWaWV3O1xuICBcbiAgICAgIGlmIChwcmV2ZW50RGVzdHJveSkge1xuICAgICAgICB0aGlzLiRlbC5jb250ZW50cygpLmRldGFjaCgpO1xuICAgICAgfVxuICBcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gIFxuICAgIC8vIGNhbGwgJ2Rlc3Ryb3knIG9yICdyZW1vdmUnLCBkZXBlbmRpbmcgb24gd2hpY2ggaXMgZm91bmRcbiAgICAvLyBvbiB0aGUgdmlldyAoaWYgc2hvd2luZyBhIHJhdyBCYWNrYm9uZSB2aWV3IG9yIGEgTWFyaW9uZXR0ZSBWaWV3KVxuICAgIF9kZXN0cm95VmlldzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdmlldyA9IHRoaXMuY3VycmVudFZpZXc7XG4gIFxuICAgICAgaWYgKHZpZXcuZGVzdHJveSAmJiAhdmlldy5pc0Rlc3Ryb3llZCkge1xuICAgICAgICB2aWV3LmRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSBpZiAodmlldy5yZW1vdmUpIHtcbiAgICAgICAgdmlldy5yZW1vdmUoKTtcbiAgXG4gICAgICAgIC8vIGFwcGVuZGluZyBpc0Rlc3Ryb3llZCB0byByYXcgQmFja2JvbmUgVmlldyBhbGxvd3MgcmVnaW9uc1xuICAgICAgICAvLyB0byB0aHJvdyBhIFZpZXdEZXN0cm95ZWRFcnJvciBmb3IgdGhpcyB2aWV3XG4gICAgICAgIHZpZXcuaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gIFxuICAgIC8vIEF0dGFjaCBhbiBleGlzdGluZyB2aWV3IHRvIHRoZSByZWdpb24uIFRoaXNcbiAgICAvLyB3aWxsIG5vdCBjYWxsIGByZW5kZXJgIG9yIGBvblNob3dgIGZvciB0aGUgbmV3IHZpZXcsXG4gICAgLy8gYW5kIHdpbGwgbm90IHJlcGxhY2UgdGhlIGN1cnJlbnQgSFRNTCBmb3IgdGhlIGBlbGBcbiAgICAvLyBvZiB0aGUgcmVnaW9uLlxuICAgIGF0dGFjaFZpZXc6IGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgIHRoaXMuY3VycmVudFZpZXcgPSB2aWV3O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgXG4gICAgLy8gQ2hlY2tzIHdoZXRoZXIgYSB2aWV3IGlzIGN1cnJlbnRseSBwcmVzZW50IHdpdGhpblxuICAgIC8vIHRoZSByZWdpb24uIFJldHVybnMgYHRydWVgIGlmIHRoZXJlIGlzIGFuZCBgZmFsc2VgIGlmXG4gICAgLy8gbm8gdmlldyBpcyBwcmVzZW50LlxuICAgIGhhc1ZpZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5jdXJyZW50VmlldztcbiAgICB9LFxuICBcbiAgICAvLyBSZXNldCB0aGUgcmVnaW9uIGJ5IGRlc3Ryb3lpbmcgYW55IGV4aXN0aW5nIHZpZXcgYW5kXG4gICAgLy8gY2xlYXJpbmcgb3V0IHRoZSBjYWNoZWQgYCRlbGAuIFRoZSBuZXh0IHRpbWUgYSB2aWV3XG4gICAgLy8gaXMgc2hvd24gdmlhIHRoaXMgcmVnaW9uLCB0aGUgcmVnaW9uIHdpbGwgcmUtcXVlcnkgdGhlXG4gICAgLy8gRE9NIGZvciB0aGUgcmVnaW9uJ3MgYGVsYC5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmVtcHR5KCk7XG4gIFxuICAgICAgaWYgKHRoaXMuJGVsKSB7XG4gICAgICAgIHRoaXMuZWwgPSB0aGlzLiRlbC5zZWxlY3RvcjtcbiAgICAgIH1cbiAgXG4gICAgICBkZWxldGUgdGhpcy4kZWw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIFxuICB9LFxuICBcbiAgLy8gU3RhdGljIE1ldGhvZHNcbiAge1xuICBcbiAgICAvLyBCdWlsZCBhbiBpbnN0YW5jZSBvZiBhIHJlZ2lvbiBieSBwYXNzaW5nIGluIGEgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAvLyBhbmQgYSBkZWZhdWx0IHJlZ2lvbiBjbGFzcyB0byB1c2UgaWYgbm9uZSBpcyBzcGVjaWZpZWQgaW4gdGhlIGNvbmZpZy5cbiAgICAvL1xuICAgIC8vIFRoZSBjb25maWcgb2JqZWN0IHNob3VsZCBlaXRoZXIgYmUgYSBzdHJpbmcgYXMgYSBqUXVlcnkgRE9NIHNlbGVjdG9yLFxuICAgIC8vIGEgUmVnaW9uIGNsYXNzIGRpcmVjdGx5LCBvciBhbiBvYmplY3QgbGl0ZXJhbCB0aGF0IHNwZWNpZmllcyBhIHNlbGVjdG9yLFxuICAgIC8vIGEgY3VzdG9tIHJlZ2lvbkNsYXNzLCBhbmQgYW55IG9wdGlvbnMgdG8gYmUgc3VwcGxpZWQgdG8gdGhlIHJlZ2lvbjpcbiAgICAvL1xuICAgIC8vIGBgYGpzXG4gICAgLy8ge1xuICAgIC8vICAgc2VsZWN0b3I6IFwiI2Zvb1wiLFxuICAgIC8vICAgcmVnaW9uQ2xhc3M6IE15Q3VzdG9tUmVnaW9uLFxuICAgIC8vICAgYWxsb3dNaXNzaW5nRWw6IGZhbHNlXG4gICAgLy8gfVxuICAgIC8vIGBgYFxuICAgIC8vXG4gICAgYnVpbGRSZWdpb246IGZ1bmN0aW9uKHJlZ2lvbkNvbmZpZywgRGVmYXVsdFJlZ2lvbkNsYXNzKSB7XG4gICAgICBpZiAoXy5pc1N0cmluZyhyZWdpb25Db25maWcpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWlsZFJlZ2lvbkZyb21TZWxlY3RvcihyZWdpb25Db25maWcsIERlZmF1bHRSZWdpb25DbGFzcyk7XG4gICAgICB9XG4gIFxuICAgICAgaWYgKHJlZ2lvbkNvbmZpZy5zZWxlY3RvciB8fCByZWdpb25Db25maWcuZWwgfHwgcmVnaW9uQ29uZmlnLnJlZ2lvbkNsYXNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWlsZFJlZ2lvbkZyb21PYmplY3QocmVnaW9uQ29uZmlnLCBEZWZhdWx0UmVnaW9uQ2xhc3MpO1xuICAgICAgfVxuICBcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ocmVnaW9uQ29uZmlnKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRSZWdpb25Gcm9tUmVnaW9uQ2xhc3MocmVnaW9uQ29uZmlnKTtcbiAgICAgIH1cbiAgXG4gICAgICB0aHJvdyBuZXcgTWFyaW9uZXR0ZS5FcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6ICdJbXByb3BlciByZWdpb24gY29uZmlndXJhdGlvbiB0eXBlLicsXG4gICAgICAgIHVybDogJ21hcmlvbmV0dGUucmVnaW9uLmh0bWwjcmVnaW9uLWNvbmZpZ3VyYXRpb24tdHlwZXMnXG4gICAgICB9KTtcbiAgICB9LFxuICBcbiAgICAvLyBCdWlsZCB0aGUgcmVnaW9uIGZyb20gYSBzdHJpbmcgc2VsZWN0b3IgbGlrZSAnI2Zvby1yZWdpb24nXG4gICAgX2J1aWxkUmVnaW9uRnJvbVNlbGVjdG9yOiBmdW5jdGlvbihzZWxlY3RvciwgRGVmYXVsdFJlZ2lvbkNsYXNzKSB7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRSZWdpb25DbGFzcyh7ZWw6IHNlbGVjdG9yfSk7XG4gICAgfSxcbiAgXG4gICAgLy8gQnVpbGQgdGhlIHJlZ2lvbiBmcm9tIGEgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAvLyBgYGBqc1xuICAgIC8vIHsgc2VsZWN0b3I6ICcjZm9vJywgcmVnaW9uQ2xhc3M6IEZvb1JlZ2lvbiwgYWxsb3dNaXNzaW5nRWw6IGZhbHNlIH1cbiAgICAvLyBgYGBcbiAgICBfYnVpbGRSZWdpb25Gcm9tT2JqZWN0OiBmdW5jdGlvbihyZWdpb25Db25maWcsIERlZmF1bHRSZWdpb25DbGFzcykge1xuICAgICAgdmFyIFJlZ2lvbkNsYXNzID0gcmVnaW9uQ29uZmlnLnJlZ2lvbkNsYXNzIHx8IERlZmF1bHRSZWdpb25DbGFzcztcbiAgICAgIHZhciBvcHRpb25zID0gXy5vbWl0KHJlZ2lvbkNvbmZpZywgJ3NlbGVjdG9yJywgJ3JlZ2lvbkNsYXNzJyk7XG4gIFxuICAgICAgaWYgKHJlZ2lvbkNvbmZpZy5zZWxlY3RvciAmJiAhb3B0aW9ucy5lbCkge1xuICAgICAgICBvcHRpb25zLmVsID0gcmVnaW9uQ29uZmlnLnNlbGVjdG9yO1xuICAgICAgfVxuICBcbiAgICAgIHJldHVybiBuZXcgUmVnaW9uQ2xhc3Mob3B0aW9ucyk7XG4gICAgfSxcbiAgXG4gICAgLy8gQnVpbGQgdGhlIHJlZ2lvbiBkaXJlY3RseSBmcm9tIGEgZ2l2ZW4gYFJlZ2lvbkNsYXNzYFxuICAgIF9idWlsZFJlZ2lvbkZyb21SZWdpb25DbGFzczogZnVuY3Rpb24oUmVnaW9uQ2xhc3MpIHtcbiAgICAgIHJldHVybiBuZXcgUmVnaW9uQ2xhc3MoKTtcbiAgICB9XG4gIH0pO1xuICBcbiAgLy8gUmVnaW9uIE1hbmFnZXJcbiAgLy8gLS0tLS0tLS0tLS0tLS1cbiAgXG4gIC8vIE1hbmFnZSBvbmUgb3IgbW9yZSByZWxhdGVkIGBNYXJpb25ldHRlLlJlZ2lvbmAgb2JqZWN0cy5cbiAgTWFyaW9uZXR0ZS5SZWdpb25NYW5hZ2VyID0gTWFyaW9uZXR0ZS5Db250cm9sbGVyLmV4dGVuZCh7XG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX3JlZ2lvbnMgPSB7fTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgXG4gICAgICBNYXJpb25ldHRlLkNvbnRyb2xsZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgXG4gICAgICB0aGlzLmFkZFJlZ2lvbnModGhpcy5nZXRPcHRpb24oJ3JlZ2lvbnMnKSk7XG4gICAgfSxcbiAgXG4gICAgLy8gQWRkIG11bHRpcGxlIHJlZ2lvbnMgdXNpbmcgYW4gb2JqZWN0IGxpdGVyYWwgb3IgYVxuICAgIC8vIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYmplY3QgbGl0ZXJhbCwgd2hlcmVcbiAgICAvLyBlYWNoIGtleSBiZWNvbWVzIHRoZSByZWdpb24gbmFtZSwgYW5kIGVhY2ggdmFsdWUgaXNcbiAgICAvLyB0aGUgcmVnaW9uIGRlZmluaXRpb24uXG4gICAgYWRkUmVnaW9uczogZnVuY3Rpb24ocmVnaW9uRGVmaW5pdGlvbnMsIGRlZmF1bHRzKSB7XG4gICAgICByZWdpb25EZWZpbml0aW9ucyA9IE1hcmlvbmV0dGUuX2dldFZhbHVlKHJlZ2lvbkRlZmluaXRpb25zLCB0aGlzLCBhcmd1bWVudHMpO1xuICBcbiAgICAgIHJldHVybiBfLnJlZHVjZShyZWdpb25EZWZpbml0aW9ucywgZnVuY3Rpb24ocmVnaW9ucywgZGVmaW5pdGlvbiwgbmFtZSkge1xuICAgICAgICBpZiAoXy5pc1N0cmluZyhkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7c2VsZWN0b3I6IGRlZmluaXRpb259O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWZpbml0aW9uLnNlbGVjdG9yKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IF8uZGVmYXVsdHMoe30sIGRlZmluaXRpb24sIGRlZmF1bHRzKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgcmVnaW9uc1tuYW1lXSA9IHRoaXMuYWRkUmVnaW9uKG5hbWUsIGRlZmluaXRpb24pO1xuICAgICAgICByZXR1cm4gcmVnaW9ucztcbiAgICAgIH0sIHt9LCB0aGlzKTtcbiAgICB9LFxuICBcbiAgICAvLyBBZGQgYW4gaW5kaXZpZHVhbCByZWdpb24gdG8gdGhlIHJlZ2lvbiBtYW5hZ2VyLFxuICAgIC8vIGFuZCByZXR1cm4gdGhlIHJlZ2lvbiBpbnN0YW5jZVxuICAgIGFkZFJlZ2lvbjogZnVuY3Rpb24obmFtZSwgZGVmaW5pdGlvbikge1xuICAgICAgdmFyIHJlZ2lvbjtcbiAgXG4gICAgICBpZiAoZGVmaW5pdGlvbiBpbnN0YW5jZW9mIE1hcmlvbmV0dGUuUmVnaW9uKSB7XG4gICAgICAgIHJlZ2lvbiA9IGRlZmluaXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWdpb24gPSBNYXJpb25ldHRlLlJlZ2lvbi5idWlsZFJlZ2lvbihkZWZpbml0aW9uLCBNYXJpb25ldHRlLlJlZ2lvbik7XG4gICAgICB9XG4gIFxuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6YWRkOnJlZ2lvbicsIG5hbWUsIHJlZ2lvbik7XG4gIFxuICAgICAgcmVnaW9uLl9wYXJlbnQgPSB0aGlzO1xuICAgICAgdGhpcy5fc3RvcmUobmFtZSwgcmVnaW9uKTtcbiAgXG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2FkZDpyZWdpb24nLCBuYW1lLCByZWdpb24pO1xuICAgICAgcmV0dXJuIHJlZ2lvbjtcbiAgICB9LFxuICBcbiAgICAvLyBHZXQgYSByZWdpb24gYnkgbmFtZVxuICAgIGdldDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lvbnNbbmFtZV07XG4gICAgfSxcbiAgXG4gICAgLy8gR2V0cyBhbGwgdGhlIHJlZ2lvbnMgY29udGFpbmVkIHdpdGhpblxuICAgIC8vIHRoZSBgcmVnaW9uTWFuYWdlcmAgaW5zdGFuY2UuXG4gICAgZ2V0UmVnaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXy5jbG9uZSh0aGlzLl9yZWdpb25zKTtcbiAgICB9LFxuICBcbiAgICAvLyBSZW1vdmUgYSByZWdpb24gYnkgbmFtZVxuICAgIHJlbW92ZVJlZ2lvbjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIHJlZ2lvbiA9IHRoaXMuX3JlZ2lvbnNbbmFtZV07XG4gICAgICB0aGlzLl9yZW1vdmUobmFtZSwgcmVnaW9uKTtcbiAgXG4gICAgICByZXR1cm4gcmVnaW9uO1xuICAgIH0sXG4gIFxuICAgIC8vIEVtcHR5IGFsbCByZWdpb25zIGluIHRoZSByZWdpb24gbWFuYWdlciwgYW5kXG4gICAgLy8gcmVtb3ZlIHRoZW1cbiAgICByZW1vdmVSZWdpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZWdpb25zID0gdGhpcy5nZXRSZWdpb25zKCk7XG4gICAgICBfLmVhY2godGhpcy5fcmVnaW9ucywgZnVuY3Rpb24ocmVnaW9uLCBuYW1lKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZShuYW1lLCByZWdpb24pO1xuICAgICAgfSwgdGhpcyk7XG4gIFxuICAgICAgcmV0dXJuIHJlZ2lvbnM7XG4gICAgfSxcbiAgXG4gICAgLy8gRW1wdHkgYWxsIHJlZ2lvbnMgaW4gdGhlIHJlZ2lvbiBtYW5hZ2VyLCBidXRcbiAgICAvLyBsZWF2ZSB0aGVtIGF0dGFjaGVkXG4gICAgZW1wdHlSZWdpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZWdpb25zID0gdGhpcy5nZXRSZWdpb25zKCk7XG4gICAgICBfLmludm9rZShyZWdpb25zLCAnZW1wdHknKTtcbiAgICAgIHJldHVybiByZWdpb25zO1xuICAgIH0sXG4gIFxuICAgIC8vIERlc3Ryb3kgYWxsIHJlZ2lvbnMgYW5kIHNodXQgZG93biB0aGUgcmVnaW9uXG4gICAgLy8gbWFuYWdlciBlbnRpcmVseVxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5yZW1vdmVSZWdpb25zKCk7XG4gICAgICByZXR1cm4gTWFyaW9uZXR0ZS5Db250cm9sbGVyLnByb3RvdHlwZS5kZXN0cm95LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgXG4gICAgLy8gaW50ZXJuYWwgbWV0aG9kIHRvIHN0b3JlIHJlZ2lvbnNcbiAgICBfc3RvcmU6IGZ1bmN0aW9uKG5hbWUsIHJlZ2lvbikge1xuICAgICAgaWYgKCF0aGlzLl9yZWdpb25zW25hbWVdKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICB9XG4gIFxuICAgICAgdGhpcy5fcmVnaW9uc1tuYW1lXSA9IHJlZ2lvbjtcbiAgICB9LFxuICBcbiAgICAvLyBpbnRlcm5hbCBtZXRob2QgdG8gcmVtb3ZlIGEgcmVnaW9uXG4gICAgX3JlbW92ZTogZnVuY3Rpb24obmFtZSwgcmVnaW9uKSB7XG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2JlZm9yZTpyZW1vdmU6cmVnaW9uJywgbmFtZSwgcmVnaW9uKTtcbiAgICAgIHJlZ2lvbi5lbXB0eSgpO1xuICAgICAgcmVnaW9uLnN0b3BMaXN0ZW5pbmcoKTtcbiAgXG4gICAgICBkZWxldGUgcmVnaW9uLl9wYXJlbnQ7XG4gICAgICBkZWxldGUgdGhpcy5fcmVnaW9uc1tuYW1lXTtcbiAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ3JlbW92ZTpyZWdpb24nLCBuYW1lLCByZWdpb24pO1xuICAgIH1cbiAgfSk7XG4gIFxuICBNYXJpb25ldHRlLmFjdEFzQ29sbGVjdGlvbihNYXJpb25ldHRlLlJlZ2lvbk1hbmFnZXIucHJvdG90eXBlLCAnX3JlZ2lvbnMnKTtcbiAgXG5cbiAgLy8gVGVtcGxhdGUgQ2FjaGVcbiAgLy8gLS0tLS0tLS0tLS0tLS1cbiAgXG4gIC8vIE1hbmFnZSB0ZW1wbGF0ZXMgc3RvcmVkIGluIGA8c2NyaXB0PmAgYmxvY2tzLFxuICAvLyBjYWNoaW5nIHRoZW0gZm9yIGZhc3RlciBhY2Nlc3MuXG4gIE1hcmlvbmV0dGUuVGVtcGxhdGVDYWNoZSA9IGZ1bmN0aW9uKHRlbXBsYXRlSWQpIHtcbiAgICB0aGlzLnRlbXBsYXRlSWQgPSB0ZW1wbGF0ZUlkO1xuICB9O1xuICBcbiAgLy8gVGVtcGxhdGVDYWNoZSBvYmplY3QtbGV2ZWwgbWV0aG9kcy4gTWFuYWdlIHRoZSB0ZW1wbGF0ZVxuICAvLyBjYWNoZXMgZnJvbSB0aGVzZSBtZXRob2QgY2FsbHMgaW5zdGVhZCBvZiBjcmVhdGluZ1xuICAvLyB5b3VyIG93biBUZW1wbGF0ZUNhY2hlIGluc3RhbmNlc1xuICBfLmV4dGVuZChNYXJpb25ldHRlLlRlbXBsYXRlQ2FjaGUsIHtcbiAgICB0ZW1wbGF0ZUNhY2hlczoge30sXG4gIFxuICAgIC8vIEdldCB0aGUgc3BlY2lmaWVkIHRlbXBsYXRlIGJ5IGlkLiBFaXRoZXJcbiAgICAvLyByZXRyaWV2ZXMgdGhlIGNhY2hlZCB2ZXJzaW9uLCBvciBsb2FkcyBpdFxuICAgIC8vIGZyb20gdGhlIERPTS5cbiAgICBnZXQ6IGZ1bmN0aW9uKHRlbXBsYXRlSWQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjYWNoZWRUZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGVDYWNoZXNbdGVtcGxhdGVJZF07XG4gIFxuICAgICAgaWYgKCFjYWNoZWRUZW1wbGF0ZSkge1xuICAgICAgICBjYWNoZWRUZW1wbGF0ZSA9IG5ldyBNYXJpb25ldHRlLlRlbXBsYXRlQ2FjaGUodGVtcGxhdGVJZCk7XG4gICAgICAgIHRoaXMudGVtcGxhdGVDYWNoZXNbdGVtcGxhdGVJZF0gPSBjYWNoZWRUZW1wbGF0ZTtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gY2FjaGVkVGVtcGxhdGUubG9hZChvcHRpb25zKTtcbiAgICB9LFxuICBcbiAgICAvLyBDbGVhciB0ZW1wbGF0ZXMgZnJvbSB0aGUgY2FjaGUuIElmIG5vIGFyZ3VtZW50c1xuICAgIC8vIGFyZSBzcGVjaWZpZWQsIGNsZWFycyBhbGwgdGVtcGxhdGVzOlxuICAgIC8vIGBjbGVhcigpYFxuICAgIC8vXG4gICAgLy8gSWYgYXJndW1lbnRzIGFyZSBzcGVjaWZpZWQsIGNsZWFycyBlYWNoIG9mIHRoZVxuICAgIC8vIHNwZWNpZmllZCB0ZW1wbGF0ZXMgZnJvbSB0aGUgY2FjaGU6XG4gICAgLy8gYGNsZWFyKFwiI3QxXCIsIFwiI3QyXCIsIFwiLi4uXCIpYFxuICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGFyZ3MgPSBfLnRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgIHZhciBsZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgXG4gICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy50ZW1wbGF0ZUNhY2hlc1thcmdzW2ldXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZUNhY2hlcyA9IHt9O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFxuICAvLyBUZW1wbGF0ZUNhY2hlIGluc3RhbmNlIG1ldGhvZHMsIGFsbG93aW5nIGVhY2hcbiAgLy8gdGVtcGxhdGUgY2FjaGUgb2JqZWN0IHRvIG1hbmFnZSBpdHMgb3duIHN0YXRlXG4gIC8vIGFuZCBrbm93IHdoZXRoZXIgb3Igbm90IGl0IGhhcyBiZWVuIGxvYWRlZFxuICBfLmV4dGVuZChNYXJpb25ldHRlLlRlbXBsYXRlQ2FjaGUucHJvdG90eXBlLCB7XG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBsb2FkIHRoZSB0ZW1wbGF0ZVxuICAgIGxvYWQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIC8vIEd1YXJkIGNsYXVzZSB0byBwcmV2ZW50IGxvYWRpbmcgdGhpcyB0ZW1wbGF0ZSBtb3JlIHRoYW4gb25jZVxuICAgICAgaWYgKHRoaXMuY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlZFRlbXBsYXRlO1xuICAgICAgfVxuICBcbiAgICAgIC8vIExvYWQgdGhlIHRlbXBsYXRlIGFuZCBjb21waWxlIGl0XG4gICAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLmxvYWRUZW1wbGF0ZSh0aGlzLnRlbXBsYXRlSWQsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5jb21waWxlZFRlbXBsYXRlID0gdGhpcy5jb21waWxlVGVtcGxhdGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuICBcbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVkVGVtcGxhdGU7XG4gICAgfSxcbiAgXG4gICAgLy8gTG9hZCBhIHRlbXBsYXRlIGZyb20gdGhlIERPTSwgYnkgZGVmYXVsdC4gT3ZlcnJpZGVcbiAgICAvLyB0aGlzIG1ldGhvZCB0byBwcm92aWRlIHlvdXIgb3duIHRlbXBsYXRlIHJldHJpZXZhbFxuICAgIC8vIEZvciBhc3luY2hyb25vdXMgbG9hZGluZyB3aXRoIEFNRC9SZXF1aXJlSlMsIGNvbnNpZGVyXG4gICAgLy8gdXNpbmcgYSB0ZW1wbGF0ZS1sb2FkZXIgcGx1Z2luIGFzIGRlc2NyaWJlZCBoZXJlOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpb25ldHRlanMvYmFja2JvbmUubWFyaW9uZXR0ZS93aWtpL1VzaW5nLW1hcmlvbmV0dGUtd2l0aC1yZXF1aXJlanNcbiAgICBsb2FkVGVtcGxhdGU6IGZ1bmN0aW9uKHRlbXBsYXRlSWQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB0ZW1wbGF0ZSA9IEJhY2tib25lLiQodGVtcGxhdGVJZCkuaHRtbCgpO1xuICBcbiAgICAgIGlmICghdGVtcGxhdGUgfHwgdGVtcGxhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBNYXJpb25ldHRlLkVycm9yKHtcbiAgICAgICAgICBuYW1lOiAnTm9UZW1wbGF0ZUVycm9yJyxcbiAgICAgICAgICBtZXNzYWdlOiAnQ291bGQgbm90IGZpbmQgdGVtcGxhdGU6IFwiJyArIHRlbXBsYXRlSWQgKyAnXCInXG4gICAgICAgIH0pO1xuICAgICAgfVxuICBcbiAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICB9LFxuICBcbiAgICAvLyBQcmUtY29tcGlsZSB0aGUgdGVtcGxhdGUgYmVmb3JlIGNhY2hpbmcgaXQuIE92ZXJyaWRlXG4gICAgLy8gdGhpcyBtZXRob2QgaWYgeW91IGRvIG5vdCBuZWVkIHRvIHByZS1jb21waWxlIGEgdGVtcGxhdGVcbiAgICAvLyAoSlNUIC8gUmVxdWlyZUpTIGZvciBleGFtcGxlKSBvciBpZiB5b3Ugd2FudCB0byBjaGFuZ2VcbiAgICAvLyB0aGUgdGVtcGxhdGUgZW5naW5lIHVzZWQgKEhhbmRlYmFycywgZXRjKS5cbiAgICBjb21waWxlVGVtcGxhdGU6IGZ1bmN0aW9uKHJhd1RlbXBsYXRlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gXy50ZW1wbGF0ZShyYXdUZW1wbGF0ZSwgb3B0aW9ucyk7XG4gICAgfVxuICB9KTtcbiAgXG4gIC8vIFJlbmRlcmVyXG4gIC8vIC0tLS0tLS0tXG4gIFxuICAvLyBSZW5kZXIgYSB0ZW1wbGF0ZSB3aXRoIGRhdGEgYnkgcGFzc2luZyBpbiB0aGUgdGVtcGxhdGVcbiAgLy8gc2VsZWN0b3IgYW5kIHRoZSBkYXRhIHRvIHJlbmRlci5cbiAgTWFyaW9uZXR0ZS5SZW5kZXJlciA9IHtcbiAgXG4gICAgLy8gUmVuZGVyIGEgdGVtcGxhdGUgd2l0aCBkYXRhLiBUaGUgYHRlbXBsYXRlYCBwYXJhbWV0ZXIgaXNcbiAgICAvLyBwYXNzZWQgdG8gdGhlIGBUZW1wbGF0ZUNhY2hlYCBvYmplY3QgdG8gcmV0cmlldmUgdGhlXG4gICAgLy8gdGVtcGxhdGUgZnVuY3Rpb24uIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHByb3ZpZGUgeW91ciBvd25cbiAgICAvLyBjdXN0b20gcmVuZGVyaW5nIGFuZCB0ZW1wbGF0ZSBoYW5kbGluZyBmb3IgYWxsIG9mIE1hcmlvbmV0dGUuXG4gICAgcmVuZGVyOiBmdW5jdGlvbih0ZW1wbGF0ZSwgZGF0YSkge1xuICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICB0aHJvdyBuZXcgTWFyaW9uZXR0ZS5FcnJvcih7XG4gICAgICAgICAgbmFtZTogJ1RlbXBsYXRlTm90Rm91bmRFcnJvcicsXG4gICAgICAgICAgbWVzc2FnZTogJ0Nhbm5vdCByZW5kZXIgdGhlIHRlbXBsYXRlIHNpbmNlIGl0cyBmYWxzZSwgbnVsbCBvciB1bmRlZmluZWQuJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgXG4gICAgICB2YXIgdGVtcGxhdGVGdW5jID0gXy5pc0Z1bmN0aW9uKHRlbXBsYXRlKSA/IHRlbXBsYXRlIDogTWFyaW9uZXR0ZS5UZW1wbGF0ZUNhY2hlLmdldCh0ZW1wbGF0ZSk7XG4gIFxuICAgICAgcmV0dXJuIHRlbXBsYXRlRnVuYyhkYXRhKTtcbiAgICB9XG4gIH07XG4gIFxuXG4gIC8qIGpzaGludCBtYXhsZW46IDExNCwgbm9uZXc6IGZhbHNlICovXG4gIC8vIFZpZXdcbiAgLy8gLS0tLVxuICBcbiAgLy8gVGhlIGNvcmUgdmlldyBjbGFzcyB0aGF0IG90aGVyIE1hcmlvbmV0dGUgdmlld3MgZXh0ZW5kIGZyb20uXG4gIE1hcmlvbmV0dGUuVmlldyA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcbiAgICBpc0Rlc3Ryb3llZDogZmFsc2UsXG4gIFxuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBfLmJpbmRBbGwodGhpcywgJ3JlbmRlcicpO1xuICBcbiAgICAgIG9wdGlvbnMgPSBNYXJpb25ldHRlLl9nZXRWYWx1ZShvcHRpb25zLCB0aGlzKTtcbiAgXG4gICAgICAvLyB0aGlzIGV4cG9zZXMgdmlldyBvcHRpb25zIHRvIHRoZSB2aWV3IGluaXRpYWxpemVyXG4gICAgICAvLyB0aGlzIGlzIGEgYmFja2ZpbGwgc2luY2UgYmFja2JvbmUgcmVtb3ZlZCB0aGUgYXNzaWdubWVudFxuICAgICAgLy8gb2YgdGhpcy5vcHRpb25zXG4gICAgICAvLyBhdCBzb21lIHBvaW50IGhvd2V2ZXIgdGhpcyBtYXkgYmUgcmVtb3ZlZFxuICAgICAgdGhpcy5vcHRpb25zID0gXy5leHRlbmQoe30sIF8ucmVzdWx0KHRoaXMsICdvcHRpb25zJyksIG9wdGlvbnMpO1xuICBcbiAgICAgIHRoaXMuX2JlaGF2aW9ycyA9IE1hcmlvbmV0dGUuQmVoYXZpb3JzKHRoaXMpO1xuICBcbiAgICAgIEJhY2tib25lLlZpZXcuY2FsbCh0aGlzLCB0aGlzLm9wdGlvbnMpO1xuICBcbiAgICAgIE1hcmlvbmV0dGUuTW9uaXRvckRPTVJlZnJlc2godGhpcyk7XG4gICAgfSxcbiAgXG4gICAgLy8gR2V0IHRoZSB0ZW1wbGF0ZSBmb3IgdGhpcyB2aWV3XG4gICAgLy8gaW5zdGFuY2UuIFlvdSBjYW4gc2V0IGEgYHRlbXBsYXRlYCBhdHRyaWJ1dGUgaW4gdGhlIHZpZXdcbiAgICAvLyBkZWZpbml0aW9uIG9yIHBhc3MgYSBgdGVtcGxhdGU6IFwid2hhdGV2ZXJcImAgcGFyYW1ldGVyIGluXG4gICAgLy8gdG8gdGhlIGNvbnN0cnVjdG9yIG9wdGlvbnMuXG4gICAgZ2V0VGVtcGxhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKCd0ZW1wbGF0ZScpO1xuICAgIH0sXG4gIFxuICAgIC8vIFNlcmlhbGl6ZSBhIG1vZGVsIGJ5IHJldHVybmluZyBpdHMgYXR0cmlidXRlcy4gQ2xvbmVzXG4gICAgLy8gdGhlIGF0dHJpYnV0ZXMgdG8gYWxsb3cgbW9kaWZpY2F0aW9uLlxuICAgIHNlcmlhbGl6ZU1vZGVsOiBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgcmV0dXJuIG1vZGVsLnRvSlNPTi5hcHBseShtb2RlbCwgXy5yZXN0KGFyZ3VtZW50cykpO1xuICAgIH0sXG4gIFxuICAgIC8vIE1peCBpbiB0ZW1wbGF0ZSBoZWxwZXIgbWV0aG9kcy4gTG9va3MgZm9yIGFcbiAgICAvLyBgdGVtcGxhdGVIZWxwZXJzYCBhdHRyaWJ1dGUsIHdoaWNoIGNhbiBlaXRoZXIgYmUgYW5cbiAgICAvLyBvYmplY3QgbGl0ZXJhbCwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gb2JqZWN0XG4gICAgLy8gbGl0ZXJhbC4gQWxsIG1ldGhvZHMgYW5kIGF0dHJpYnV0ZXMgZnJvbSB0aGlzIG9iamVjdFxuICAgIC8vIGFyZSBjb3BpZXMgdG8gdGhlIG9iamVjdCBwYXNzZWQgaW4uXG4gICAgbWl4aW5UZW1wbGF0ZUhlbHBlcnM6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IHt9O1xuICAgICAgdmFyIHRlbXBsYXRlSGVscGVycyA9IHRoaXMuZ2V0T3B0aW9uKCd0ZW1wbGF0ZUhlbHBlcnMnKTtcbiAgICAgIHRlbXBsYXRlSGVscGVycyA9IE1hcmlvbmV0dGUuX2dldFZhbHVlKHRlbXBsYXRlSGVscGVycywgdGhpcyk7XG4gICAgICByZXR1cm4gXy5leHRlbmQodGFyZ2V0LCB0ZW1wbGF0ZUhlbHBlcnMpO1xuICAgIH0sXG4gIFxuICAgIC8vIG5vcm1hbGl6ZSB0aGUga2V5cyBvZiBwYXNzZWQgaGFzaCB3aXRoIHRoZSB2aWV3cyBgdWlgIHNlbGVjdG9ycy5cbiAgICAvLyBge1wiQHVpLmZvb1wiOiBcImJhclwifWBcbiAgICBub3JtYWxpemVVSUtleXM6IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICAgIHZhciB1aUJpbmRpbmdzID0gXy5yZXN1bHQodGhpcywgJ191aUJpbmRpbmdzJyk7XG4gICAgICByZXR1cm4gTWFyaW9uZXR0ZS5ub3JtYWxpemVVSUtleXMoaGFzaCwgdWlCaW5kaW5ncyB8fCBfLnJlc3VsdCh0aGlzLCAndWknKSk7XG4gICAgfSxcbiAgXG4gICAgLy8gbm9ybWFsaXplIHRoZSB2YWx1ZXMgb2YgcGFzc2VkIGhhc2ggd2l0aCB0aGUgdmlld3MgYHVpYCBzZWxlY3RvcnMuXG4gICAgLy8gYHtmb286IFwiQHVpLmJhclwifWBcbiAgICBub3JtYWxpemVVSVZhbHVlczogZnVuY3Rpb24oaGFzaCwgcHJvcGVydGllcykge1xuICAgICAgdmFyIHVpID0gXy5yZXN1bHQodGhpcywgJ3VpJyk7XG4gICAgICB2YXIgdWlCaW5kaW5ncyA9IF8ucmVzdWx0KHRoaXMsICdfdWlCaW5kaW5ncycpO1xuICAgICAgcmV0dXJuIE1hcmlvbmV0dGUubm9ybWFsaXplVUlWYWx1ZXMoaGFzaCwgdWlCaW5kaW5ncyB8fCB1aSwgcHJvcGVydGllcyk7XG4gICAgfSxcbiAgXG4gICAgLy8gQ29uZmlndXJlIGB0cmlnZ2Vyc2AgdG8gZm9yd2FyZCBET00gZXZlbnRzIHRvIHZpZXdcbiAgICAvLyBldmVudHMuIGB0cmlnZ2Vyczoge1wiY2xpY2sgLmZvb1wiOiBcImRvOmZvb1wifWBcbiAgICBjb25maWd1cmVUcmlnZ2VyczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMudHJpZ2dlcnMpIHsgcmV0dXJuOyB9XG4gIFxuICAgICAgLy8gQWxsb3cgYHRyaWdnZXJzYCB0byBiZSBjb25maWd1cmVkIGFzIGEgZnVuY3Rpb25cbiAgICAgIHZhciB0cmlnZ2VycyA9IHRoaXMubm9ybWFsaXplVUlLZXlzKF8ucmVzdWx0KHRoaXMsICd0cmlnZ2VycycpKTtcbiAgXG4gICAgICAvLyBDb25maWd1cmUgdGhlIHRyaWdnZXJzLCBwcmV2ZW50IGRlZmF1bHRcbiAgICAgIC8vIGFjdGlvbiBhbmQgc3RvcCBwcm9wYWdhdGlvbiBvZiBET00gZXZlbnRzXG4gICAgICByZXR1cm4gXy5yZWR1Y2UodHJpZ2dlcnMsIGZ1bmN0aW9uKGV2ZW50cywgdmFsdWUsIGtleSkge1xuICAgICAgICBldmVudHNba2V5XSA9IHRoaXMuX2J1aWxkVmlld1RyaWdnZXIodmFsdWUpO1xuICAgICAgICByZXR1cm4gZXZlbnRzO1xuICAgICAgfSwge30sIHRoaXMpO1xuICAgIH0sXG4gIFxuICAgIC8vIE92ZXJyaWRpbmcgQmFja2JvbmUuVmlldydzIGRlbGVnYXRlRXZlbnRzIHRvIGhhbmRsZVxuICAgIC8vIHRoZSBgdHJpZ2dlcnNgLCBgbW9kZWxFdmVudHNgLCBhbmQgYGNvbGxlY3Rpb25FdmVudHNgIGNvbmZpZ3VyYXRpb25cbiAgICBkZWxlZ2F0ZUV2ZW50czogZnVuY3Rpb24oZXZlbnRzKSB7XG4gICAgICB0aGlzLl9kZWxlZ2F0ZURPTUV2ZW50cyhldmVudHMpO1xuICAgICAgdGhpcy5iaW5kRW50aXR5RXZlbnRzKHRoaXMubW9kZWwsIHRoaXMuZ2V0T3B0aW9uKCdtb2RlbEV2ZW50cycpKTtcbiAgICAgIHRoaXMuYmluZEVudGl0eUV2ZW50cyh0aGlzLmNvbGxlY3Rpb24sIHRoaXMuZ2V0T3B0aW9uKCdjb2xsZWN0aW9uRXZlbnRzJykpO1xuICBcbiAgICAgIF8uZWFjaCh0aGlzLl9iZWhhdmlvcnMsIGZ1bmN0aW9uKGJlaGF2aW9yKSB7XG4gICAgICAgIGJlaGF2aW9yLmJpbmRFbnRpdHlFdmVudHModGhpcy5tb2RlbCwgYmVoYXZpb3IuZ2V0T3B0aW9uKCdtb2RlbEV2ZW50cycpKTtcbiAgICAgICAgYmVoYXZpb3IuYmluZEVudGl0eUV2ZW50cyh0aGlzLmNvbGxlY3Rpb24sIGJlaGF2aW9yLmdldE9wdGlvbignY29sbGVjdGlvbkV2ZW50cycpKTtcbiAgICAgIH0sIHRoaXMpO1xuICBcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gIFxuICAgIC8vIGludGVybmFsIG1ldGhvZCB0byBkZWxlZ2F0ZSBET00gZXZlbnRzIGFuZCB0cmlnZ2Vyc1xuICAgIF9kZWxlZ2F0ZURPTUV2ZW50czogZnVuY3Rpb24oZXZlbnRzQXJnKSB7XG4gICAgICB2YXIgZXZlbnRzID0gTWFyaW9uZXR0ZS5fZ2V0VmFsdWUoZXZlbnRzQXJnIHx8IHRoaXMuZXZlbnRzLCB0aGlzKTtcbiAgXG4gICAgICAvLyBub3JtYWxpemUgdWkga2V5c1xuICAgICAgZXZlbnRzID0gdGhpcy5ub3JtYWxpemVVSUtleXMoZXZlbnRzKTtcbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKGV2ZW50c0FyZykpIHt0aGlzLmV2ZW50cyA9IGV2ZW50czt9XG4gIFxuICAgICAgdmFyIGNvbWJpbmVkRXZlbnRzID0ge307XG4gIFxuICAgICAgLy8gbG9vayB1cCBpZiB0aGlzIHZpZXcgaGFzIGJlaGF2aW9yIGV2ZW50c1xuICAgICAgdmFyIGJlaGF2aW9yRXZlbnRzID0gXy5yZXN1bHQodGhpcywgJ2JlaGF2aW9yRXZlbnRzJykgfHwge307XG4gICAgICB2YXIgdHJpZ2dlcnMgPSB0aGlzLmNvbmZpZ3VyZVRyaWdnZXJzKCk7XG4gICAgICB2YXIgYmVoYXZpb3JUcmlnZ2VycyA9IF8ucmVzdWx0KHRoaXMsICdiZWhhdmlvclRyaWdnZXJzJykgfHwge307XG4gIFxuICAgICAgLy8gYmVoYXZpb3IgZXZlbnRzIHdpbGwgYmUgb3ZlcnJpZGVuIGJ5IHZpZXcgZXZlbnRzIGFuZCBvciB0cmlnZ2Vyc1xuICAgICAgXy5leHRlbmQoY29tYmluZWRFdmVudHMsIGJlaGF2aW9yRXZlbnRzLCBldmVudHMsIHRyaWdnZXJzLCBiZWhhdmlvclRyaWdnZXJzKTtcbiAgXG4gICAgICBCYWNrYm9uZS5WaWV3LnByb3RvdHlwZS5kZWxlZ2F0ZUV2ZW50cy5jYWxsKHRoaXMsIGNvbWJpbmVkRXZlbnRzKTtcbiAgICB9LFxuICBcbiAgICAvLyBPdmVycmlkaW5nIEJhY2tib25lLlZpZXcncyB1bmRlbGVnYXRlRXZlbnRzIHRvIGhhbmRsZSB1bmJpbmRpbmdcbiAgICAvLyB0aGUgYHRyaWdnZXJzYCwgYG1vZGVsRXZlbnRzYCwgYW5kIGBjb2xsZWN0aW9uRXZlbnRzYCBjb25maWdcbiAgICB1bmRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIEJhY2tib25lLlZpZXcucHJvdG90eXBlLnVuZGVsZWdhdGVFdmVudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgXG4gICAgICB0aGlzLnVuYmluZEVudGl0eUV2ZW50cyh0aGlzLm1vZGVsLCB0aGlzLmdldE9wdGlvbignbW9kZWxFdmVudHMnKSk7XG4gICAgICB0aGlzLnVuYmluZEVudGl0eUV2ZW50cyh0aGlzLmNvbGxlY3Rpb24sIHRoaXMuZ2V0T3B0aW9uKCdjb2xsZWN0aW9uRXZlbnRzJykpO1xuICBcbiAgICAgIF8uZWFjaCh0aGlzLl9iZWhhdmlvcnMsIGZ1bmN0aW9uKGJlaGF2aW9yKSB7XG4gICAgICAgIGJlaGF2aW9yLnVuYmluZEVudGl0eUV2ZW50cyh0aGlzLm1vZGVsLCBiZWhhdmlvci5nZXRPcHRpb24oJ21vZGVsRXZlbnRzJykpO1xuICAgICAgICBiZWhhdmlvci51bmJpbmRFbnRpdHlFdmVudHModGhpcy5jb2xsZWN0aW9uLCBiZWhhdmlvci5nZXRPcHRpb24oJ2NvbGxlY3Rpb25FdmVudHMnKSk7XG4gICAgICB9LCB0aGlzKTtcbiAgXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICBcbiAgICAvLyBJbnRlcm5hbCBoZWxwZXIgbWV0aG9kIHRvIHZlcmlmeSB3aGV0aGVyIHRoZSB2aWV3IGhhc24ndCBiZWVuIGRlc3Ryb3llZFxuICAgIF9lbnN1cmVWaWV3SXNJbnRhY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1hcmlvbmV0dGUuRXJyb3Ioe1xuICAgICAgICAgIG5hbWU6ICdWaWV3RGVzdHJveWVkRXJyb3InLFxuICAgICAgICAgIG1lc3NhZ2U6ICdWaWV3IChjaWQ6IFwiJyArIHRoaXMuY2lkICsgJ1wiKSBoYXMgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZCBhbmQgY2Fubm90IGJlIHVzZWQuJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICBcbiAgICAvLyBEZWZhdWx0IGBkZXN0cm95YCBpbXBsZW1lbnRhdGlvbiwgZm9yIHJlbW92aW5nIGEgdmlldyBmcm9tIHRoZVxuICAgIC8vIERPTSBhbmQgdW5iaW5kaW5nIGl0LiBSZWdpb25zIHdpbGwgY2FsbCB0aGlzIG1ldGhvZFxuICAgIC8vIGZvciB5b3UuIFlvdSBjYW4gc3BlY2lmeSBhbiBgb25EZXN0cm95YCBtZXRob2QgaW4geW91ciB2aWV3IHRvXG4gICAgLy8gYWRkIGN1c3RvbSBjb2RlIHRoYXQgaXMgY2FsbGVkIGFmdGVyIHRoZSB2aWV3IGlzIGRlc3Ryb3llZC5cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSB7IHJldHVybiB0aGlzOyB9XG4gIFxuICAgICAgdmFyIGFyZ3MgPSBfLnRvQXJyYXkoYXJndW1lbnRzKTtcbiAgXG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QuYXBwbHkodGhpcywgWydiZWZvcmU6ZGVzdHJveSddLmNvbmNhdChhcmdzKSk7XG4gIFxuICAgICAgLy8gbWFyayBhcyBkZXN0cm95ZWQgYmVmb3JlIGRvaW5nIHRoZSBhY3R1YWwgZGVzdHJveSwgdG9cbiAgICAgIC8vIHByZXZlbnQgaW5maW5pdGUgbG9vcHMgd2l0aGluIFwiZGVzdHJveVwiIGV2ZW50IGhhbmRsZXJzXG4gICAgICAvLyB0aGF0IGFyZSB0cnlpbmcgdG8gZGVzdHJveSBvdGhlciB2aWV3c1xuICAgICAgdGhpcy5pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QuYXBwbHkodGhpcywgWydkZXN0cm95J10uY29uY2F0KGFyZ3MpKTtcbiAgXG4gICAgICAvLyB1bmJpbmQgVUkgZWxlbWVudHNcbiAgICAgIHRoaXMudW5iaW5kVUlFbGVtZW50cygpO1xuICBcbiAgICAgIHRoaXMuaXNSZW5kZXJlZCA9IGZhbHNlO1xuICBcbiAgICAgIC8vIHJlbW92ZSB0aGUgdmlldyBmcm9tIHRoZSBET01cbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gIFxuICAgICAgLy8gQ2FsbCBkZXN0cm95IG9uIGVhY2ggYmVoYXZpb3IgYWZ0ZXJcbiAgICAgIC8vIGRlc3Ryb3lpbmcgdGhlIHZpZXcuXG4gICAgICAvLyBUaGlzIHVuYmluZHMgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAvLyB0aGF0IGJlaGF2aW9ycyBoYXZlIHJlZ2lzdGVyZWQgZm9yLlxuICAgICAgXy5pbnZva2UodGhpcy5fYmVoYXZpb3JzLCAnZGVzdHJveScsIGFyZ3MpO1xuICBcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gIFxuICAgIGJpbmRVSUVsZW1lbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2JpbmRVSUVsZW1lbnRzKCk7XG4gICAgICBfLmludm9rZSh0aGlzLl9iZWhhdmlvcnMsIHRoaXMuX2JpbmRVSUVsZW1lbnRzKTtcbiAgICB9LFxuICBcbiAgICAvLyBUaGlzIG1ldGhvZCBiaW5kcyB0aGUgZWxlbWVudHMgc3BlY2lmaWVkIGluIHRoZSBcInVpXCIgaGFzaCBpbnNpZGUgdGhlIHZpZXcncyBjb2RlIHdpdGhcbiAgICAvLyB0aGUgYXNzb2NpYXRlZCBqUXVlcnkgc2VsZWN0b3JzLlxuICAgIF9iaW5kVUlFbGVtZW50czogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMudWkpIHsgcmV0dXJuOyB9XG4gIFxuICAgICAgLy8gc3RvcmUgdGhlIHVpIGhhc2ggaW4gX3VpQmluZGluZ3Mgc28gdGhleSBjYW4gYmUgcmVzZXQgbGF0ZXJcbiAgICAgIC8vIGFuZCBzbyByZS1yZW5kZXJpbmcgdGhlIHZpZXcgd2lsbCBiZSBhYmxlIHRvIGZpbmQgdGhlIGJpbmRpbmdzXG4gICAgICBpZiAoIXRoaXMuX3VpQmluZGluZ3MpIHtcbiAgICAgICAgdGhpcy5fdWlCaW5kaW5ncyA9IHRoaXMudWk7XG4gICAgICB9XG4gIFxuICAgICAgLy8gZ2V0IHRoZSBiaW5kaW5ncyByZXN1bHQsIGFzIGEgZnVuY3Rpb24gb3Igb3RoZXJ3aXNlXG4gICAgICB2YXIgYmluZGluZ3MgPSBfLnJlc3VsdCh0aGlzLCAnX3VpQmluZGluZ3MnKTtcbiAgXG4gICAgICAvLyBlbXB0eSB0aGUgdWkgc28gd2UgZG9uJ3QgaGF2ZSBhbnl0aGluZyB0byBzdGFydCB3aXRoXG4gICAgICB0aGlzLnVpID0ge307XG4gIFxuICAgICAgLy8gYmluZCBlYWNoIG9mIHRoZSBzZWxlY3RvcnNcbiAgICAgIF8uZWFjaChiaW5kaW5ncywgZnVuY3Rpb24oc2VsZWN0b3IsIGtleSkge1xuICAgICAgICB0aGlzLnVpW2tleV0gPSB0aGlzLiQoc2VsZWN0b3IpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSxcbiAgXG4gICAgLy8gVGhpcyBtZXRob2QgdW5iaW5kcyB0aGUgZWxlbWVudHMgc3BlY2lmaWVkIGluIHRoZSBcInVpXCIgaGFzaFxuICAgIHVuYmluZFVJRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fdW5iaW5kVUlFbGVtZW50cygpO1xuICAgICAgXy5pbnZva2UodGhpcy5fYmVoYXZpb3JzLCB0aGlzLl91bmJpbmRVSUVsZW1lbnRzKTtcbiAgICB9LFxuICBcbiAgICBfdW5iaW5kVUlFbGVtZW50czogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMudWkgfHwgIXRoaXMuX3VpQmluZGluZ3MpIHsgcmV0dXJuOyB9XG4gIFxuICAgICAgLy8gZGVsZXRlIGFsbCBvZiB0aGUgZXhpc3RpbmcgdWkgYmluZGluZ3NcbiAgICAgIF8uZWFjaCh0aGlzLnVpLCBmdW5jdGlvbigkZWwsIG5hbWUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudWlbbmFtZV07XG4gICAgICB9LCB0aGlzKTtcbiAgXG4gICAgICAvLyByZXNldCB0aGUgdWkgZWxlbWVudCB0byB0aGUgb3JpZ2luYWwgYmluZGluZ3MgY29uZmlndXJhdGlvblxuICAgICAgdGhpcy51aSA9IHRoaXMuX3VpQmluZGluZ3M7XG4gICAgICBkZWxldGUgdGhpcy5fdWlCaW5kaW5ncztcbiAgICB9LFxuICBcbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gY3JlYXRlIGFuIGV2ZW50IGhhbmRsZXIgZm9yIGEgZ2l2ZW4gYHRyaWdnZXJEZWZgIGxpa2VcbiAgICAvLyAnY2xpY2s6Zm9vJ1xuICAgIF9idWlsZFZpZXdUcmlnZ2VyOiBmdW5jdGlvbih0cmlnZ2VyRGVmKSB7XG4gICAgICB2YXIgaGFzT3B0aW9ucyA9IF8uaXNPYmplY3QodHJpZ2dlckRlZik7XG4gIFxuICAgICAgdmFyIG9wdGlvbnMgPSBfLmRlZmF1bHRzKHt9LCAoaGFzT3B0aW9ucyA/IHRyaWdnZXJEZWYgOiB7fSksIHtcbiAgICAgICAgcHJldmVudERlZmF1bHQ6IHRydWUsXG4gICAgICAgIHN0b3BQcm9wYWdhdGlvbjogdHJ1ZVxuICAgICAgfSk7XG4gIFxuICAgICAgdmFyIGV2ZW50TmFtZSA9IGhhc09wdGlvbnMgPyBvcHRpb25zLmV2ZW50IDogdHJpZ2dlckRlZjtcbiAgXG4gICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0ICYmIG9wdGlvbnMucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbiAmJiBvcHRpb25zLnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHZhciBhcmdzID0ge1xuICAgICAgICAgIHZpZXc6IHRoaXMsXG4gICAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgICAgY29sbGVjdGlvbjogdGhpcy5jb2xsZWN0aW9uXG4gICAgICAgIH07XG4gIFxuICAgICAgICB0aGlzLnRyaWdnZXJNZXRob2QoZXZlbnROYW1lLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSxcbiAgXG4gICAgc2V0RWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmV0ID0gQmFja2JvbmUuVmlldy5wcm90b3R5cGUuc2V0RWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBcbiAgICAgIC8vIHByb3h5IGJlaGF2aW9yICRlbCB0byB0aGUgdmlldydzICRlbC5cbiAgICAgIC8vIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2UgYSB2aWV3J3MgJGVsIHByb3h5XG4gICAgICAvLyBpcyBub3Qgc2V0IHVudGlsIGFmdGVyIHNldEVsZW1lbnQgaXMgY2FsbGVkLlxuICAgICAgXy5pbnZva2UodGhpcy5fYmVoYXZpb3JzLCAncHJveHlWaWV3UHJvcGVydGllcycsIHRoaXMpO1xuICBcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcbiAgXG4gICAgLy8gaW1wb3J0IHRoZSBgdHJpZ2dlck1ldGhvZGAgdG8gdHJpZ2dlciBldmVudHMgd2l0aCBjb3JyZXNwb25kaW5nXG4gICAgLy8gbWV0aG9kcyBpZiB0aGUgbWV0aG9kIGV4aXN0c1xuICAgIHRyaWdnZXJNZXRob2Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJldCA9IE1hcmlvbmV0dGUuX3RyaWdnZXJNZXRob2QodGhpcywgYXJndW1lbnRzKTtcbiAgXG4gICAgICB0aGlzLl90cmlnZ2VyRXZlbnRPbkJlaGF2aW9ycyhhcmd1bWVudHMpO1xuICAgICAgdGhpcy5fdHJpZ2dlckV2ZW50T25QYXJlbnRMYXlvdXQoYXJndW1lbnRzWzBdLCBfLnJlc3QoYXJndW1lbnRzKSk7XG4gIFxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuICBcbiAgICBfdHJpZ2dlckV2ZW50T25CZWhhdmlvcnM6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIHZhciB0cmlnZ2VyTWV0aG9kID0gTWFyaW9uZXR0ZS5fdHJpZ2dlck1ldGhvZDtcbiAgICAgIHZhciBiZWhhdmlvcnMgPSB0aGlzLl9iZWhhdmlvcnM7XG4gICAgICAvLyBVc2UgZ29vZCBvbCcgZm9yIGFzIHRoaXMgaXMgYSB2ZXJ5IGhvdCBmdW5jdGlvblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGJlaGF2aW9ycyAmJiBiZWhhdmlvcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJpZ2dlck1ldGhvZChiZWhhdmlvcnNbaV0sIGFyZ3MpO1xuICAgICAgfVxuICAgIH0sXG4gIFxuICAgIF90cmlnZ2VyRXZlbnRPblBhcmVudExheW91dDogZnVuY3Rpb24oZXZlbnROYW1lLCBhcmdzKSB7XG4gICAgICB2YXIgbGF5b3V0VmlldyA9IHRoaXMuX3BhcmVudExheW91dFZpZXcoKTtcbiAgICAgIGlmICghbGF5b3V0Vmlldykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIFxuICAgICAgLy8gaW52b2tlIHRyaWdnZXJNZXRob2Qgb24gcGFyZW50IHZpZXdcbiAgICAgIHZhciBldmVudFByZWZpeCA9IE1hcmlvbmV0dGUuZ2V0T3B0aW9uKGxheW91dFZpZXcsICdjaGlsZFZpZXdFdmVudFByZWZpeCcpO1xuICAgICAgdmFyIHByZWZpeGVkRXZlbnROYW1lID0gZXZlbnRQcmVmaXggKyAnOicgKyBldmVudE5hbWU7XG4gIFxuICAgICAgTWFyaW9uZXR0ZS5fdHJpZ2dlck1ldGhvZChsYXlvdXRWaWV3LCBbcHJlZml4ZWRFdmVudE5hbWUsIHRoaXNdLmNvbmNhdChhcmdzKSk7XG4gIFxuICAgICAgLy8gY2FsbCB0aGUgcGFyZW50IHZpZXcncyBjaGlsZEV2ZW50cyBoYW5kbGVyXG4gICAgICB2YXIgY2hpbGRFdmVudHMgPSBNYXJpb25ldHRlLmdldE9wdGlvbihsYXlvdXRWaWV3LCAnY2hpbGRFdmVudHMnKTtcbiAgICAgIHZhciBub3JtYWxpemVkQ2hpbGRFdmVudHMgPSBsYXlvdXRWaWV3Lm5vcm1hbGl6ZU1ldGhvZHMoY2hpbGRFdmVudHMpO1xuICBcbiAgICAgIGlmICghIW5vcm1hbGl6ZWRDaGlsZEV2ZW50cyAmJiBfLmlzRnVuY3Rpb24obm9ybWFsaXplZENoaWxkRXZlbnRzW2V2ZW50TmFtZV0pKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRDaGlsZEV2ZW50c1tldmVudE5hbWVdLmFwcGx5KGxheW91dFZpZXcsIFt0aGlzXS5jb25jYXQoYXJncykpO1xuICAgICAgfVxuICAgIH0sXG4gIFxuICAgIC8vIFRoaXMgbWV0aG9kIHJldHVybnMgYW55IHZpZXdzIHRoYXQgYXJlIGltbWVkaWF0ZVxuICAgIC8vIGNoaWxkcmVuIG9mIHRoaXMgdmlld1xuICAgIF9nZXRJbW1lZGlhdGVDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgXG4gICAgLy8gUmV0dXJucyBhbiBhcnJheSBvZiBldmVyeSBuZXN0ZWQgdmlldyB3aXRoaW4gdGhpcyB2aWV3XG4gICAgX2dldE5lc3RlZFZpZXdzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2dldEltbWVkaWF0ZUNoaWxkcmVuKCk7XG4gIFxuICAgICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHsgcmV0dXJuIGNoaWxkcmVuOyB9XG4gIFxuICAgICAgcmV0dXJuIF8ucmVkdWNlKGNoaWxkcmVuLCBmdW5jdGlvbihtZW1vLCB2aWV3KSB7XG4gICAgICAgIGlmICghdmlldy5fZ2V0TmVzdGVkVmlld3MpIHsgcmV0dXJuIG1lbW87IH1cbiAgICAgICAgcmV0dXJuIG1lbW8uY29uY2F0KHZpZXcuX2dldE5lc3RlZFZpZXdzKCkpO1xuICAgICAgfSwgY2hpbGRyZW4pO1xuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIHV0aWxpdHkgZm9yIGJ1aWxkaW5nIGFuIGFuY2VzdG9yXG4gICAgLy8gdmlldyB0cmVlIGxpc3QuXG4gICAgX2dldEFuY2VzdG9yczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYW5jZXN0b3JzID0gW107XG4gICAgICB2YXIgcGFyZW50ICA9IHRoaXMuX3BhcmVudDtcbiAgXG4gICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGFuY2VzdG9ycy5wdXNoKHBhcmVudCk7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuICAgICAgfVxuICBcbiAgICAgIHJldHVybiBhbmNlc3RvcnM7XG4gICAgfSxcbiAgXG4gICAgLy8gUmV0dXJucyB0aGUgY29udGFpbmluZyBwYXJlbnQgdmlldy5cbiAgICBfcGFyZW50TGF5b3V0VmlldzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYW5jZXN0b3JzID0gdGhpcy5fZ2V0QW5jZXN0b3JzKCk7XG4gICAgICByZXR1cm4gXy5maW5kKGFuY2VzdG9ycywgZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQgaW5zdGFuY2VvZiBNYXJpb25ldHRlLkxheW91dFZpZXc7XG4gICAgICB9KTtcbiAgICB9LFxuICBcbiAgICAvLyBJbXBvcnRzIHRoZSBcIm5vcm1hbGl6ZU1ldGhvZHNcIiB0byB0cmFuc2Zvcm0gaGFzaGVzIG9mXG4gICAgLy8gZXZlbnRzPT5mdW5jdGlvbiByZWZlcmVuY2VzL25hbWVzIHRvIGEgaGFzaCBvZiBldmVudHM9PmZ1bmN0aW9uIHJlZmVyZW5jZXNcbiAgICBub3JtYWxpemVNZXRob2RzOiBNYXJpb25ldHRlLm5vcm1hbGl6ZU1ldGhvZHMsXG4gIFxuICAgIC8vIEEgaGFuZHkgd2F5IHRvIG1lcmdlIHBhc3NlZC1pbiBvcHRpb25zIG9udG8gdGhlIGluc3RhbmNlXG4gICAgbWVyZ2VPcHRpb25zOiBNYXJpb25ldHRlLm1lcmdlT3B0aW9ucyxcbiAgXG4gICAgLy8gUHJveHkgYGdldE9wdGlvbmAgdG8gZW5hYmxlIGdldHRpbmcgb3B0aW9ucyBmcm9tIHRoaXMgb3IgdGhpcy5vcHRpb25zIGJ5IG5hbWUuXG4gICAgZ2V0T3B0aW9uOiBNYXJpb25ldHRlLnByb3h5R2V0T3B0aW9uLFxuICBcbiAgICAvLyBQcm94eSBgYmluZEVudGl0eUV2ZW50c2AgdG8gZW5hYmxlIGJpbmRpbmcgdmlldydzIGV2ZW50cyBmcm9tIGFub3RoZXIgZW50aXR5LlxuICAgIGJpbmRFbnRpdHlFdmVudHM6IE1hcmlvbmV0dGUucHJveHlCaW5kRW50aXR5RXZlbnRzLFxuICBcbiAgICAvLyBQcm94eSBgdW5iaW5kRW50aXR5RXZlbnRzYCB0byBlbmFibGUgdW5iaW5kaW5nIHZpZXcncyBldmVudHMgZnJvbSBhbm90aGVyIGVudGl0eS5cbiAgICB1bmJpbmRFbnRpdHlFdmVudHM6IE1hcmlvbmV0dGUucHJveHlVbmJpbmRFbnRpdHlFdmVudHNcbiAgfSk7XG4gIFxuICAvLyBJdGVtIFZpZXdcbiAgLy8gLS0tLS0tLS0tXG4gIFxuICAvLyBBIHNpbmdsZSBpdGVtIHZpZXcgaW1wbGVtZW50YXRpb24gdGhhdCBjb250YWlucyBjb2RlIGZvciByZW5kZXJpbmdcbiAgLy8gd2l0aCB1bmRlcnNjb3JlLmpzIHRlbXBsYXRlcywgc2VyaWFsaXppbmcgdGhlIHZpZXcncyBtb2RlbCBvciBjb2xsZWN0aW9uLFxuICAvLyBhbmQgY2FsbGluZyBzZXZlcmFsIG1ldGhvZHMgb24gZXh0ZW5kZWQgdmlld3MsIHN1Y2ggYXMgYG9uUmVuZGVyYC5cbiAgTWFyaW9uZXR0ZS5JdGVtVmlldyA9IE1hcmlvbmV0dGUuVmlldy5leHRlbmQoe1xuICBcbiAgICAvLyBTZXR0aW5nIHVwIHRoZSBpbmhlcml0YW5jZSBjaGFpbiB3aGljaCBhbGxvd3MgY2hhbmdlcyB0b1xuICAgIC8vIE1hcmlvbmV0dGUuVmlldy5wcm90b3R5cGUuY29uc3RydWN0b3Igd2hpY2ggYWxsb3dzIG92ZXJyaWRpbmdcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG4gICAgICBNYXJpb25ldHRlLlZpZXcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuICBcbiAgICAvLyBTZXJpYWxpemUgdGhlIG1vZGVsIG9yIGNvbGxlY3Rpb24gZm9yIHRoZSB2aWV3LiBJZiBhIG1vZGVsIGlzXG4gICAgLy8gZm91bmQsIHRoZSB2aWV3J3MgYHNlcmlhbGl6ZU1vZGVsYCBpcyBjYWxsZWQuIElmIGEgY29sbGVjdGlvbiBpcyBmb3VuZCxcbiAgICAvLyBlYWNoIG1vZGVsIGluIHRoZSBjb2xsZWN0aW9uIGlzIHNlcmlhbGl6ZWQgYnkgY2FsbGluZ1xuICAgIC8vIHRoZSB2aWV3J3MgYHNlcmlhbGl6ZUNvbGxlY3Rpb25gIGFuZCBwdXQgaW50byBhbiBgaXRlbXNgIGFycmF5IGluXG4gICAgLy8gdGhlIHJlc3VsdGluZyBkYXRhLiBJZiBib3RoIGFyZSBmb3VuZCwgZGVmYXVsdHMgdG8gdGhlIG1vZGVsLlxuICAgIC8vIFlvdSBjYW4gb3ZlcnJpZGUgdGhlIGBzZXJpYWxpemVEYXRhYCBtZXRob2QgaW4geW91ciBvd24gdmlldyBkZWZpbml0aW9uLFxuICAgIC8vIHRvIHByb3ZpZGUgY3VzdG9tIHNlcmlhbGl6YXRpb24gZm9yIHlvdXIgdmlldydzIGRhdGEuXG4gICAgc2VyaWFsaXplRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMubW9kZWwgJiYgIXRoaXMuY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gIFxuICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5tb2RlbCB8fCB0aGlzLmNvbGxlY3Rpb25dO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgYXJncy5wdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gIFxuICAgICAgaWYgKHRoaXMubW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplTW9kZWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGl0ZW1zOiB0aGlzLnNlcmlhbGl6ZUNvbGxlY3Rpb24uYXBwbHkodGhpcywgYXJncylcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICBcbiAgICAvLyBTZXJpYWxpemUgYSBjb2xsZWN0aW9uIGJ5IHNlcmlhbGl6aW5nIGVhY2ggb2YgaXRzIG1vZGVscy5cbiAgICBzZXJpYWxpemVDb2xsZWN0aW9uOiBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi50b0pTT04uYXBwbHkoY29sbGVjdGlvbiwgXy5yZXN0KGFyZ3VtZW50cykpO1xuICAgIH0sXG4gIFxuICAgIC8vIFJlbmRlciB0aGUgdmlldywgZGVmYXVsdGluZyB0byB1bmRlcnNjb3JlLmpzIHRlbXBsYXRlcy5cbiAgICAvLyBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgaW4geW91ciB2aWV3IGRlZmluaXRpb24gdG8gcHJvdmlkZVxuICAgIC8vIGEgdmVyeSBzcGVjaWZpYyByZW5kZXJpbmcgZm9yIHlvdXIgdmlldy4gSW4gZ2VuZXJhbCwgdGhvdWdoLFxuICAgIC8vIHlvdSBzaG91bGQgb3ZlcnJpZGUgdGhlIGBNYXJpb25ldHRlLlJlbmRlcmVyYCBvYmplY3QgdG9cbiAgICAvLyBjaGFuZ2UgaG93IE1hcmlvbmV0dGUgcmVuZGVycyB2aWV3cy5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fZW5zdXJlVmlld0lzSW50YWN0KCk7XG4gIFxuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6cmVuZGVyJywgdGhpcyk7XG4gIFxuICAgICAgdGhpcy5fcmVuZGVyVGVtcGxhdGUoKTtcbiAgICAgIHRoaXMuaXNSZW5kZXJlZCA9IHRydWU7XG4gICAgICB0aGlzLmJpbmRVSUVsZW1lbnRzKCk7XG4gIFxuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdyZW5kZXInLCB0aGlzKTtcbiAgXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICBcbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gcmVuZGVyIHRoZSB0ZW1wbGF0ZSB3aXRoIHRoZSBzZXJpYWxpemVkIGRhdGFcbiAgICAvLyBhbmQgdGVtcGxhdGUgaGVscGVycyB2aWEgdGhlIGBNYXJpb25ldHRlLlJlbmRlcmVyYCBvYmplY3QuXG4gICAgLy8gVGhyb3dzIGFuIGBVbmRlZmluZWRUZW1wbGF0ZUVycm9yYCBlcnJvciBpZiB0aGUgdGVtcGxhdGUgaXNcbiAgICAvLyBhbnkgZmFsc2VseSB2YWx1ZSBidXQgbGl0ZXJhbCBgZmFsc2VgLlxuICAgIF9yZW5kZXJUZW1wbGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLmdldFRlbXBsYXRlKCk7XG4gIFxuICAgICAgLy8gQWxsb3cgdGVtcGxhdGUtbGVzcyBpdGVtIHZpZXdzXG4gICAgICBpZiAodGVtcGxhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgXG4gICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBNYXJpb25ldHRlLkVycm9yKHtcbiAgICAgICAgICBuYW1lOiAnVW5kZWZpbmVkVGVtcGxhdGVFcnJvcicsXG4gICAgICAgICAgbWVzc2FnZTogJ0Nhbm5vdCByZW5kZXIgdGhlIHRlbXBsYXRlIHNpbmNlIGl0IGlzIG51bGwgb3IgdW5kZWZpbmVkLidcbiAgICAgICAgfSk7XG4gICAgICB9XG4gIFxuICAgICAgLy8gQWRkIGluIGVudGl0eSBkYXRhIGFuZCB0ZW1wbGF0ZSBoZWxwZXJzXG4gICAgICB2YXIgZGF0YSA9IHRoaXMubWl4aW5UZW1wbGF0ZUhlbHBlcnModGhpcy5zZXJpYWxpemVEYXRhKCkpO1xuICBcbiAgICAgIC8vIFJlbmRlciBhbmQgYWRkIHRvIGVsXG4gICAgICB2YXIgaHRtbCA9IE1hcmlvbmV0dGUuUmVuZGVyZXIucmVuZGVyKHRlbXBsYXRlLCBkYXRhLCB0aGlzKTtcbiAgICAgIHRoaXMuYXR0YWNoRWxDb250ZW50KGh0bWwpO1xuICBcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gIFxuICAgIC8vIEF0dGFjaGVzIHRoZSBjb250ZW50IG9mIGEgZ2l2ZW4gdmlldy5cbiAgICAvLyBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiB0byBvcHRpbWl6ZSByZW5kZXJpbmcsXG4gICAgLy8gb3IgdG8gcmVuZGVyIGluIGEgbm9uIHN0YW5kYXJkIHdheS5cbiAgICAvL1xuICAgIC8vIEZvciBleGFtcGxlLCB1c2luZyBgaW5uZXJIVE1MYCBpbnN0ZWFkIG9mIGAkZWwuaHRtbGBcbiAgICAvL1xuICAgIC8vIGBgYGpzXG4gICAgLy8gYXR0YWNoRWxDb250ZW50OiBmdW5jdGlvbihodG1sKSB7XG4gICAgLy8gICB0aGlzLmVsLmlubmVySFRNTCA9IGh0bWw7XG4gICAgLy8gICByZXR1cm4gdGhpcztcbiAgICAvLyB9XG4gICAgLy8gYGBgXG4gICAgYXR0YWNoRWxDb250ZW50OiBmdW5jdGlvbihodG1sKSB7XG4gICAgICB0aGlzLiRlbC5odG1sKGh0bWwpO1xuICBcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG4gIFxuICAvKiBqc2hpbnQgbWF4c3RhdGVtZW50czogMjAsIG1heGNvbXBsZXhpdHk6IDcgKi9cbiAgXG4gIC8vIENvbGxlY3Rpb24gVmlld1xuICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgXG4gIC8vIEEgdmlldyB0aGF0IGl0ZXJhdGVzIG92ZXIgYSBCYWNrYm9uZS5Db2xsZWN0aW9uXG4gIC8vIGFuZCByZW5kZXJzIGFuIGluZGl2aWR1YWwgY2hpbGQgdmlldyBmb3IgZWFjaCBtb2RlbC5cbiAgTWFyaW9uZXR0ZS5Db2xsZWN0aW9uVmlldyA9IE1hcmlvbmV0dGUuVmlldy5leHRlbmQoe1xuICBcbiAgICAvLyB1c2VkIGFzIHRoZSBwcmVmaXggZm9yIGNoaWxkIHZpZXcgZXZlbnRzXG4gICAgLy8gdGhhdCBhcmUgZm9yd2FyZGVkIHRocm91Z2ggdGhlIGNvbGxlY3Rpb252aWV3XG4gICAgY2hpbGRWaWV3RXZlbnRQcmVmaXg6ICdjaGlsZHZpZXcnLFxuICBcbiAgICAvLyBmbGFnIGZvciBtYWludGFpbmluZyB0aGUgc29ydGVkIG9yZGVyIG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgc29ydDogdHJ1ZSxcbiAgXG4gICAgLy8gY29uc3RydWN0b3JcbiAgICAvLyBvcHRpb24gdG8gcGFzcyBge3NvcnQ6IGZhbHNlfWAgdG8gcHJldmVudCB0aGUgYENvbGxlY3Rpb25WaWV3YCBmcm9tXG4gICAgLy8gbWFpbnRhaW5pbmcgdGhlIHNvcnRlZCBvcmRlciBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICAvLyBUaGlzIHdpbGwgZmFsbGJhY2sgb250byBhcHBlbmRpbmcgY2hpbGRWaWV3J3MgdG8gdGhlIGVuZC5cbiAgICAvL1xuICAgIC8vIG9wdGlvbiB0byBwYXNzIGB7Y29tcGFyYXRvcjogY29tcEZ1bmN0aW9uKCl9YCB0byBhbGxvdyB0aGUgYENvbGxlY3Rpb25WaWV3YFxuICAgIC8vIHRvIHVzZSBhIGN1c3RvbSBzb3J0IG9yZGVyIGZvciB0aGUgY29sbGVjdGlvbi5cbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5vbmNlKCdyZW5kZXInLCB0aGlzLl9pbml0aWFsRXZlbnRzKTtcbiAgICAgIHRoaXMuX2luaXRDaGlsZFZpZXdTdG9yYWdlKCk7XG4gIFxuICAgICAgTWFyaW9uZXR0ZS5WaWV3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIFxuICAgICAgdGhpcy5vbih7XG4gICAgICAgICdiZWZvcmU6c2hvdyc6ICAgdGhpcy5fb25CZWZvcmVTaG93Q2FsbGVkLFxuICAgICAgICAnc2hvdyc6ICAgICAgICAgIHRoaXMuX29uU2hvd0NhbGxlZCxcbiAgICAgICAgJ2JlZm9yZTphdHRhY2gnOiB0aGlzLl9vbkJlZm9yZUF0dGFjaENhbGxlZCxcbiAgICAgICAgJ2F0dGFjaCc6ICAgICAgICB0aGlzLl9vbkF0dGFjaENhbGxlZFxuICAgICAgfSk7XG4gICAgICB0aGlzLmluaXRSZW5kZXJCdWZmZXIoKTtcbiAgICB9LFxuICBcbiAgICAvLyBJbnN0ZWFkIG9mIGluc2VydGluZyBlbGVtZW50cyBvbmUgYnkgb25lIGludG8gdGhlIHBhZ2UsXG4gICAgLy8gaXQncyBtdWNoIG1vcmUgcGVyZm9ybWFudCB0byBpbnNlcnQgZWxlbWVudHMgaW50byBhIGRvY3VtZW50XG4gICAgLy8gZnJhZ21lbnQgYW5kIHRoZW4gaW5zZXJ0IHRoYXQgZG9jdW1lbnQgZnJhZ21lbnQgaW50byB0aGUgcGFnZVxuICAgIGluaXRSZW5kZXJCdWZmZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fYnVmZmVyZWRDaGlsZHJlbiA9IFtdO1xuICAgIH0sXG4gIFxuICAgIHN0YXJ0QnVmZmVyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaW5pdFJlbmRlckJ1ZmZlcigpO1xuICAgICAgdGhpcy5pc0J1ZmZlcmluZyA9IHRydWU7XG4gICAgfSxcbiAgXG4gICAgZW5kQnVmZmVyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIE9ubHkgdHJpZ2dlciBhdHRhY2ggaWYgYWxyZWFkeSBzaG93biBhbmQgYXR0YWNoZWQsIG90aGVyd2lzZSBSZWdpb24jc2hvdygpIGhhbmRsZXMgdGhpcy5cbiAgICAgIHZhciBjYW5UcmlnZ2VyQXR0YWNoID0gdGhpcy5faXNTaG93biAmJiBNYXJpb25ldHRlLmlzTm9kZUF0dGFjaGVkKHRoaXMuZWwpO1xuICAgICAgdmFyIG5lc3RlZFZpZXdzO1xuICBcbiAgICAgIHRoaXMuaXNCdWZmZXJpbmcgPSBmYWxzZTtcbiAgXG4gICAgICBpZiAodGhpcy5faXNTaG93bikge1xuICAgICAgICB0aGlzLl90cmlnZ2VyTWV0aG9kTWFueSh0aGlzLl9idWZmZXJlZENoaWxkcmVuLCB0aGlzLCAnYmVmb3JlOnNob3cnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5UcmlnZ2VyQXR0YWNoICYmIHRoaXMuX3RyaWdnZXJCZWZvcmVBdHRhY2gpIHtcbiAgICAgICAgbmVzdGVkVmlld3MgPSB0aGlzLl9nZXROZXN0ZWRWaWV3cygpO1xuICAgICAgICB0aGlzLl90cmlnZ2VyTWV0aG9kTWFueShuZXN0ZWRWaWV3cywgdGhpcywgJ2JlZm9yZTphdHRhY2gnKTtcbiAgICAgIH1cbiAgXG4gICAgICB0aGlzLmF0dGFjaEJ1ZmZlcih0aGlzLCB0aGlzLl9jcmVhdGVCdWZmZXIoKSk7XG4gIFxuICAgICAgaWYgKGNhblRyaWdnZXJBdHRhY2ggJiYgdGhpcy5fdHJpZ2dlckF0dGFjaCkge1xuICAgICAgICBuZXN0ZWRWaWV3cyA9IHRoaXMuX2dldE5lc3RlZFZpZXdzKCk7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJNZXRob2RNYW55KG5lc3RlZFZpZXdzLCB0aGlzLCAnYXR0YWNoJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faXNTaG93bikge1xuICAgICAgICB0aGlzLl90cmlnZ2VyTWV0aG9kTWFueSh0aGlzLl9idWZmZXJlZENoaWxkcmVuLCB0aGlzLCAnc2hvdycpO1xuICAgICAgfVxuICAgICAgdGhpcy5pbml0UmVuZGVyQnVmZmVyKCk7XG4gICAgfSxcbiAgXG4gICAgX3RyaWdnZXJNZXRob2RNYW55OiBmdW5jdGlvbih0YXJnZXRzLCBzb3VyY2UsIGV2ZW50TmFtZSkge1xuICAgICAgdmFyIGFyZ3MgPSBfLmRyb3AoYXJndW1lbnRzLCAzKTtcbiAgXG4gICAgICBfLmVhY2godGFyZ2V0cywgZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIE1hcmlvbmV0dGUudHJpZ2dlck1ldGhvZE9uLmFwcGx5KHRhcmdldCwgW3RhcmdldCwgZXZlbnROYW1lLCB0YXJnZXQsIHNvdXJjZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gIFxuICAgIC8vIENvbmZpZ3VyZWQgdGhlIGluaXRpYWwgZXZlbnRzIHRoYXQgdGhlIGNvbGxlY3Rpb24gdmlld1xuICAgIC8vIGJpbmRzIHRvLlxuICAgIF9pbml0aWFsRXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNvbGxlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbGxlY3Rpb24sICdhZGQnLCB0aGlzLl9vbkNvbGxlY3Rpb25BZGQpO1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29sbGVjdGlvbiwgJ3JlbW92ZScsIHRoaXMuX29uQ29sbGVjdGlvblJlbW92ZSk7XG4gICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb2xsZWN0aW9uLCAncmVzZXQnLCB0aGlzLnJlbmRlcik7XG4gIFxuICAgICAgICBpZiAodGhpcy5nZXRPcHRpb24oJ3NvcnQnKSkge1xuICAgICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb2xsZWN0aW9uLCAnc29ydCcsIHRoaXMuX3NvcnRWaWV3cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICBcbiAgICAvLyBIYW5kbGUgYSBjaGlsZCBhZGRlZCB0byB0aGUgY29sbGVjdGlvblxuICAgIF9vbkNvbGxlY3Rpb25BZGQ6IGZ1bmN0aW9uKGNoaWxkLCBjb2xsZWN0aW9uLCBvcHRzKSB7XG4gICAgICB2YXIgaW5kZXg7XG4gICAgICBpZiAob3B0cy5hdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluZGV4ID0gb3B0cy5hdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4ID0gXy5pbmRleE9mKHRoaXMuX2ZpbHRlcmVkU29ydGVkTW9kZWxzKCksIGNoaWxkKTtcbiAgICAgIH1cbiAgXG4gICAgICBpZiAodGhpcy5fc2hvdWxkQWRkQ2hpbGQoY2hpbGQsIGluZGV4KSkge1xuICAgICAgICB0aGlzLmRlc3Ryb3lFbXB0eVZpZXcoKTtcbiAgICAgICAgdmFyIENoaWxkVmlldyA9IHRoaXMuZ2V0Q2hpbGRWaWV3KGNoaWxkKTtcbiAgICAgICAgdGhpcy5hZGRDaGlsZChjaGlsZCwgQ2hpbGRWaWV3LCBpbmRleCk7XG4gICAgICB9XG4gICAgfSxcbiAgXG4gICAgLy8gZ2V0IHRoZSBjaGlsZCB2aWV3IGJ5IG1vZGVsIGl0IGhvbGRzLCBhbmQgcmVtb3ZlIGl0XG4gICAgX29uQ29sbGVjdGlvblJlbW92ZTogZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgIHZhciB2aWV3ID0gdGhpcy5jaGlsZHJlbi5maW5kQnlNb2RlbChtb2RlbCk7XG4gICAgICB0aGlzLnJlbW92ZUNoaWxkVmlldyh2aWV3KTtcbiAgICAgIHRoaXMuY2hlY2tFbXB0eSgpO1xuICAgIH0sXG4gIFxuICAgIF9vbkJlZm9yZVNob3dDYWxsZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gUmVzZXQgYXR0YWNoIGV2ZW50IGZsYWdzIGF0IHRoZSB0b3Agb2YgdGhlIFJlZ2lvbiNzaG93KCkgZXZlbnQgbGlmZWN5Y2xlOyBpZiB0aGUgUmVnaW9uJ3NcbiAgICAgIC8vIHNob3coKSBvcHRpb25zIHBlcm1pdCBvbkJlZm9yZUF0dGFjaC9vbkF0dGFjaCBldmVudHMsIHRoZXNlIGZsYWdzIHdpbGwgYmUgc2V0IHRydWUgYWdhaW4uXG4gICAgICB0aGlzLl90cmlnZ2VyQmVmb3JlQXR0YWNoID0gdGhpcy5fdHJpZ2dlckF0dGFjaCA9IGZhbHNlO1xuICAgICAgdGhpcy5jaGlsZHJlbi5lYWNoKGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgICBNYXJpb25ldHRlLnRyaWdnZXJNZXRob2RPbihjaGlsZFZpZXcsICdiZWZvcmU6c2hvdycsIGNoaWxkVmlldyk7XG4gICAgICB9KTtcbiAgICB9LFxuICBcbiAgICBfb25TaG93Q2FsbGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4uZWFjaChmdW5jdGlvbihjaGlsZFZpZXcpIHtcbiAgICAgICAgTWFyaW9uZXR0ZS50cmlnZ2VyTWV0aG9kT24oY2hpbGRWaWV3LCAnc2hvdycsIGNoaWxkVmlldyk7XG4gICAgICB9KTtcbiAgICB9LFxuICBcbiAgICAvLyBJZiBkdXJpbmcgUmVnaW9uI3Nob3coKSBvbkJlZm9yZUF0dGFjaCB3YXMgZmlyZWQsIGNvbnRpbnVlIGZpcmluZyBpdCBmb3IgY2hpbGQgdmlld3NcbiAgICBfb25CZWZvcmVBdHRhY2hDYWxsZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fdHJpZ2dlckJlZm9yZUF0dGFjaCA9IHRydWU7XG4gICAgfSxcbiAgXG4gICAgLy8gSWYgZHVyaW5nIFJlZ2lvbiNzaG93KCkgb25BdHRhY2ggd2FzIGZpcmVkLCBjb250aW51ZSBmaXJpbmcgaXQgZm9yIGNoaWxkIHZpZXdzXG4gICAgX29uQXR0YWNoQ2FsbGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3RyaWdnZXJBdHRhY2ggPSB0cnVlO1xuICAgIH0sXG4gIFxuICAgIC8vIFJlbmRlciBjaGlsZHJlbiB2aWV3cy4gT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG9cbiAgICAvLyBwcm92aWRlIHlvdXIgb3duIGltcGxlbWVudGF0aW9uIG9mIGEgcmVuZGVyIGZ1bmN0aW9uIGZvclxuICAgIC8vIHRoZSBjb2xsZWN0aW9uIHZpZXcuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2Vuc3VyZVZpZXdJc0ludGFjdCgpO1xuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6cmVuZGVyJywgdGhpcyk7XG4gICAgICB0aGlzLl9yZW5kZXJDaGlsZHJlbigpO1xuICAgICAgdGhpcy5pc1JlbmRlcmVkID0gdHJ1ZTtcbiAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgncmVuZGVyJywgdGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICBcbiAgICAvLyBSZW9yZGVyIERPTSBhZnRlciBzb3J0aW5nLiBXaGVuIHlvdXIgZWxlbWVudCdzIHJlbmRlcmluZ1xuICAgIC8vIGRvIG5vdCB1c2UgdGhlaXIgaW5kZXgsIHlvdSBjYW4gcGFzcyByZW9yZGVyT25Tb3J0OiB0cnVlXG4gICAgLy8gdG8gb25seSByZW9yZGVyIHRoZSBET00gYWZ0ZXIgYSBzb3J0IGluc3RlYWQgb2YgcmVuZGVyaW5nXG4gICAgLy8gYWxsIHRoZSBjb2xsZWN0aW9uVmlld1xuICAgIHJlb3JkZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgIHZhciBtb2RlbHMgPSB0aGlzLl9maWx0ZXJlZFNvcnRlZE1vZGVscygpO1xuICAgICAgdmFyIG1vZGVsc0NoYW5nZWQgPSBfLmZpbmQobW9kZWxzLCBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICByZXR1cm4gIWNoaWxkcmVuLmZpbmRCeU1vZGVsKG1vZGVsKTtcbiAgICAgIH0pO1xuICBcbiAgICAgIC8vIElmIHRoZSBtb2RlbHMgd2UncmUgZGlzcGxheWluZyBoYXZlIGNoYW5nZWQgZHVlIHRvIGZpbHRlcmluZ1xuICAgICAgLy8gV2UgbmVlZCB0byBhZGQgYW5kL29yIHJlbW92ZSBjaGlsZCB2aWV3c1xuICAgICAgLy8gU28gcmVuZGVyIGFzIG5vcm1hbFxuICAgICAgaWYgKG1vZGVsc0NoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGdldCB0aGUgRE9NIG5vZGVzIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSBtb2RlbHNcbiAgICAgICAgdmFyIGVscyA9IF8ubWFwKG1vZGVscywgZnVuY3Rpb24obW9kZWwsIGluZGV4KSB7XG4gICAgICAgICAgdmFyIHZpZXcgPSBjaGlsZHJlbi5maW5kQnlNb2RlbChtb2RlbCk7XG4gICAgICAgICAgdmlldy5faW5kZXggPSBpbmRleDtcbiAgICAgICAgICByZXR1cm4gdmlldy5lbDtcbiAgICAgICAgfSk7XG4gIFxuICAgICAgICAvLyBzaW5jZSBhcHBlbmQgbW92ZXMgZWxlbWVudHMgdGhhdCBhcmUgYWxyZWFkeSBpbiB0aGUgRE9NLFxuICAgICAgICAvLyBhcHBlbmRpbmcgdGhlIGVsZW1lbnRzIHdpbGwgZWZmZWN0aXZlbHkgcmVvcmRlciB0aGVtXG4gICAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgnYmVmb3JlOnJlb3JkZXInKTtcbiAgICAgICAgdGhpcy5fYXBwZW5kUmVvcmRlcmVkQ2hpbGRyZW4oZWxzKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdyZW9yZGVyJyk7XG4gICAgICB9XG4gICAgfSxcbiAgXG4gICAgLy8gUmVuZGVyIHZpZXcgYWZ0ZXIgc29ydGluZy4gT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG9cbiAgICAvLyBjaGFuZ2UgaG93IHRoZSB2aWV3IHJlbmRlcnMgYWZ0ZXIgYSBgc29ydGAgb24gdGhlIGNvbGxlY3Rpb24uXG4gICAgLy8gQW4gZXhhbXBsZSBvZiB0aGlzIHdvdWxkIGJlIHRvIG9ubHkgYHJlbmRlckNoaWxkcmVuYCBpbiBhIGBDb21wb3NpdGVWaWV3YFxuICAgIC8vIHJhdGhlciB0aGFuIHRoZSBmdWxsIHZpZXcuXG4gICAgcmVzb3J0VmlldzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoTWFyaW9uZXR0ZS5nZXRPcHRpb24odGhpcywgJ3Jlb3JkZXJPblNvcnQnKSkge1xuICAgICAgICB0aGlzLnJlb3JkZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kLiBUaGlzIGNoZWNrcyBmb3IgYW55IGNoYW5nZXMgaW4gdGhlIG9yZGVyIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIC8vIElmIHRoZSBpbmRleCBvZiBhbnkgdmlldyBkb2Vzbid0IG1hdGNoLCBpdCB3aWxsIHJlbmRlci5cbiAgICBfc29ydFZpZXdzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtb2RlbHMgPSB0aGlzLl9maWx0ZXJlZFNvcnRlZE1vZGVscygpO1xuICBcbiAgICAgIC8vIGNoZWNrIGZvciBhbnkgY2hhbmdlcyBpbiBzb3J0IG9yZGVyIG9mIHZpZXdzXG4gICAgICB2YXIgb3JkZXJDaGFuZ2VkID0gXy5maW5kKG1vZGVscywgZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLmNoaWxkcmVuLmZpbmRCeU1vZGVsKGl0ZW0pO1xuICAgICAgICByZXR1cm4gIXZpZXcgfHwgdmlldy5faW5kZXggIT09IGluZGV4O1xuICAgICAgfSwgdGhpcyk7XG4gIFxuICAgICAgaWYgKG9yZGVyQ2hhbmdlZCkge1xuICAgICAgICB0aGlzLnJlc29ydFZpZXcoKTtcbiAgICAgIH1cbiAgICB9LFxuICBcbiAgICAvLyBJbnRlcm5hbCByZWZlcmVuY2UgdG8gd2hhdCBpbmRleCBhIGBlbXB0eVZpZXdgIGlzLlxuICAgIF9lbXB0eVZpZXdJbmRleDogLTEsXG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZC4gU2VwYXJhdGVkIHNvIHRoYXQgQ29tcG9zaXRlVmlldyBjYW4gYXBwZW5kIHRvIHRoZSBjaGlsZFZpZXdDb250YWluZXJcbiAgICAvLyBpZiBuZWNlc3NhcnlcbiAgICBfYXBwZW5kUmVvcmRlcmVkQ2hpbGRyZW46IGZ1bmN0aW9uKGNoaWxkcmVuKSB7XG4gICAgICB0aGlzLiRlbC5hcHBlbmQoY2hpbGRyZW4pO1xuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZC4gU2VwYXJhdGVkIHNvIHRoYXQgQ29tcG9zaXRlVmlldyBjYW4gaGF2ZVxuICAgIC8vIG1vcmUgY29udHJvbCBvdmVyIGV2ZW50cyBiZWluZyB0cmlnZ2VyZWQsIGFyb3VuZCB0aGUgcmVuZGVyaW5nXG4gICAgLy8gcHJvY2Vzc1xuICAgIF9yZW5kZXJDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRlc3Ryb3lFbXB0eVZpZXcoKTtcbiAgICAgIHRoaXMuZGVzdHJveUNoaWxkcmVuKHtjaGVja0VtcHR5OiBmYWxzZX0pO1xuICBcbiAgICAgIGlmICh0aGlzLmlzRW1wdHkodGhpcy5jb2xsZWN0aW9uKSkge1xuICAgICAgICB0aGlzLnNob3dFbXB0eVZpZXcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgnYmVmb3JlOnJlbmRlcjpjb2xsZWN0aW9uJywgdGhpcyk7XG4gICAgICAgIHRoaXMuc3RhcnRCdWZmZXJpbmcoKTtcbiAgICAgICAgdGhpcy5zaG93Q29sbGVjdGlvbigpO1xuICAgICAgICB0aGlzLmVuZEJ1ZmZlcmluZygpO1xuICAgICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ3JlbmRlcjpjb2xsZWN0aW9uJywgdGhpcyk7XG4gIFxuICAgICAgICAvLyBJZiB3ZSBoYXZlIHNob3duIGNoaWxkcmVuIGFuZCBub25lIGhhdmUgcGFzc2VkIHRoZSBmaWx0ZXIsIHNob3cgdGhlIGVtcHR5IHZpZXdcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgdGhpcy5zaG93RW1wdHlWaWV3KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICBcbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gbG9vcCB0aHJvdWdoIGNvbGxlY3Rpb24gYW5kIHNob3cgZWFjaCBjaGlsZCB2aWV3LlxuICAgIHNob3dDb2xsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBDaGlsZFZpZXc7XG4gIFxuICAgICAgdmFyIG1vZGVscyA9IHRoaXMuX2ZpbHRlcmVkU29ydGVkTW9kZWxzKCk7XG4gIFxuICAgICAgXy5lYWNoKG1vZGVscywgZnVuY3Rpb24oY2hpbGQsIGluZGV4KSB7XG4gICAgICAgIENoaWxkVmlldyA9IHRoaXMuZ2V0Q2hpbGRWaWV3KGNoaWxkKTtcbiAgICAgICAgdGhpcy5hZGRDaGlsZChjaGlsZCwgQ2hpbGRWaWV3LCBpbmRleCk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LFxuICBcbiAgICAvLyBBbGxvdyB0aGUgY29sbGVjdGlvbiB0byBiZSBzb3J0ZWQgYnkgYSBjdXN0b20gdmlldyBjb21wYXJhdG9yXG4gICAgX2ZpbHRlcmVkU29ydGVkTW9kZWxzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtb2RlbHM7XG4gICAgICB2YXIgdmlld0NvbXBhcmF0b3IgPSB0aGlzLmdldFZpZXdDb21wYXJhdG9yKCk7XG4gIFxuICAgICAgaWYgKHZpZXdDb21wYXJhdG9yKSB7XG4gICAgICAgIGlmIChfLmlzU3RyaW5nKHZpZXdDb21wYXJhdG9yKSB8fCB2aWV3Q29tcGFyYXRvci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBtb2RlbHMgPSB0aGlzLmNvbGxlY3Rpb24uc29ydEJ5KHZpZXdDb21wYXJhdG9yLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RlbHMgPSBfLmNsb25lKHRoaXMuY29sbGVjdGlvbi5tb2RlbHMpLnNvcnQoXy5iaW5kKHZpZXdDb21wYXJhdG9yLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZGVscyA9IHRoaXMuY29sbGVjdGlvbi5tb2RlbHM7XG4gICAgICB9XG4gIFxuICAgICAgLy8gRmlsdGVyIGFmdGVyIHNvcnRpbmcgaW4gY2FzZSB0aGUgZmlsdGVyIHVzZXMgdGhlIGluZGV4XG4gICAgICBpZiAodGhpcy5nZXRPcHRpb24oJ2ZpbHRlcicpKSB7XG4gICAgICAgIG1vZGVscyA9IF8uZmlsdGVyKG1vZGVscywgZnVuY3Rpb24obW9kZWwsIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3VsZEFkZENoaWxkKG1vZGVsLCBpbmRleCk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICBcbiAgICAgIHJldHVybiBtb2RlbHM7XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIHNob3cgYW4gZW1wdHkgdmlldyBpbiBwbGFjZSBvZlxuICAgIC8vIGEgY29sbGVjdGlvbiBvZiBjaGlsZCB2aWV3cywgd2hlbiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eVxuICAgIHNob3dFbXB0eVZpZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIEVtcHR5VmlldyA9IHRoaXMuZ2V0RW1wdHlWaWV3KCk7XG4gIFxuICAgICAgaWYgKEVtcHR5VmlldyAmJiAhdGhpcy5fc2hvd2luZ0VtcHR5Vmlldykge1xuICAgICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2JlZm9yZTpyZW5kZXI6ZW1wdHknKTtcbiAgXG4gICAgICAgIHRoaXMuX3Nob3dpbmdFbXB0eVZpZXcgPSB0cnVlO1xuICAgICAgICB2YXIgbW9kZWwgPSBuZXcgQmFja2JvbmUuTW9kZWwoKTtcbiAgICAgICAgdGhpcy5hZGRFbXB0eVZpZXcobW9kZWwsIEVtcHR5Vmlldyk7XG4gIFxuICAgICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ3JlbmRlcjplbXB0eScpO1xuICAgICAgfVxuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBkZXN0cm95IGFuIGV4aXN0aW5nIGVtcHR5VmlldyBpbnN0YW5jZVxuICAgIC8vIGlmIG9uZSBleGlzdHMuIENhbGxlZCB3aGVuIGEgY29sbGVjdGlvbiB2aWV3IGhhcyBiZWVuXG4gICAgLy8gcmVuZGVyZWQgZW1wdHksIGFuZCB0aGVuIGEgY2hpbGQgaXMgYWRkZWQgdG8gdGhlIGNvbGxlY3Rpb24uXG4gICAgZGVzdHJveUVtcHR5VmlldzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fc2hvd2luZ0VtcHR5Vmlldykge1xuICAgICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2JlZm9yZTpyZW1vdmU6ZW1wdHknKTtcbiAgXG4gICAgICAgIHRoaXMuZGVzdHJveUNoaWxkcmVuKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zaG93aW5nRW1wdHlWaWV3O1xuICBcbiAgICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdyZW1vdmU6ZW1wdHknKTtcbiAgICAgIH1cbiAgICB9LFxuICBcbiAgICAvLyBSZXRyaWV2ZSB0aGUgZW1wdHkgdmlldyBjbGFzc1xuICAgIGdldEVtcHR5VmlldzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oJ2VtcHR5VmlldycpO1xuICAgIH0sXG4gIFxuICAgIC8vIFJlbmRlciBhbmQgc2hvdyB0aGUgZW1wdHlWaWV3LiBTaW1pbGFyIHRvIGFkZENoaWxkIG1ldGhvZFxuICAgIC8vIGJ1dCBcImFkZDpjaGlsZFwiIGV2ZW50cyBhcmUgbm90IGZpcmVkLCBhbmQgdGhlIGV2ZW50IGZyb21cbiAgICAvLyBlbXB0eVZpZXcgYXJlIG5vdCBmb3J3YXJkZWRcbiAgICBhZGRFbXB0eVZpZXc6IGZ1bmN0aW9uKGNoaWxkLCBFbXB0eVZpZXcpIHtcbiAgICAgIC8vIE9ubHkgdHJpZ2dlciBhdHRhY2ggaWYgYWxyZWFkeSBzaG93biwgYXR0YWNoZWQsIGFuZCBub3QgYnVmZmVyaW5nLCBvdGhlcndpc2UgZW5kQnVmZmVyKCkgb3JcbiAgICAgIC8vIFJlZ2lvbiNzaG93KCkgaGFuZGxlcyB0aGlzLlxuICAgICAgdmFyIGNhblRyaWdnZXJBdHRhY2ggPSB0aGlzLl9pc1Nob3duICYmICF0aGlzLmlzQnVmZmVyaW5nICYmIE1hcmlvbmV0dGUuaXNOb2RlQXR0YWNoZWQodGhpcy5lbCk7XG4gICAgICB2YXIgbmVzdGVkVmlld3M7XG4gIFxuICAgICAgLy8gZ2V0IHRoZSBlbXB0eVZpZXdPcHRpb25zLCBmYWxsaW5nIGJhY2sgdG8gY2hpbGRWaWV3T3B0aW9uc1xuICAgICAgdmFyIGVtcHR5Vmlld09wdGlvbnMgPSB0aGlzLmdldE9wdGlvbignZW1wdHlWaWV3T3B0aW9ucycpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRPcHRpb24oJ2NoaWxkVmlld09wdGlvbnMnKTtcbiAgXG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKGVtcHR5Vmlld09wdGlvbnMpKSB7XG4gICAgICAgIGVtcHR5Vmlld09wdGlvbnMgPSBlbXB0eVZpZXdPcHRpb25zLmNhbGwodGhpcywgY2hpbGQsIHRoaXMuX2VtcHR5Vmlld0luZGV4KTtcbiAgICAgIH1cbiAgXG4gICAgICAvLyBidWlsZCB0aGUgZW1wdHkgdmlld1xuICAgICAgdmFyIHZpZXcgPSB0aGlzLmJ1aWxkQ2hpbGRWaWV3KGNoaWxkLCBFbXB0eVZpZXcsIGVtcHR5Vmlld09wdGlvbnMpO1xuICBcbiAgICAgIHZpZXcuX3BhcmVudCA9IHRoaXM7XG4gIFxuICAgICAgLy8gUHJveHkgZW1wdHlWaWV3IGV2ZW50c1xuICAgICAgdGhpcy5wcm94eUNoaWxkRXZlbnRzKHZpZXcpO1xuICBcbiAgICAgIC8vIHRyaWdnZXIgdGhlICdiZWZvcmU6c2hvdycgZXZlbnQgb24gYHZpZXdgIGlmIHRoZSBjb2xsZWN0aW9uIHZpZXcgaGFzIGFscmVhZHkgYmVlbiBzaG93blxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcbiAgICAgICAgTWFyaW9uZXR0ZS50cmlnZ2VyTWV0aG9kT24odmlldywgJ2JlZm9yZTpzaG93Jywgdmlldyk7XG4gICAgICB9XG4gIFxuICAgICAgLy8gU3RvcmUgdGhlIGBlbXB0eVZpZXdgIGxpa2UgYSBgY2hpbGRWaWV3YCBzbyB3ZSBjYW4gcHJvcGVybHlcbiAgICAgIC8vIHJlbW92ZSBhbmQvb3IgY2xvc2UgaXQgbGF0ZXJcbiAgICAgIHRoaXMuY2hpbGRyZW4uYWRkKHZpZXcpO1xuICBcbiAgICAgIC8vIFRyaWdnZXIgYGJlZm9yZTphdHRhY2hgIGZvbGxvd2luZyBgcmVuZGVyYCB0byBhdm9pZCBhZGRpbmcgbG9naWMgYW5kIGV2ZW50IHRyaWdnZXJzXG4gICAgICAvLyB0byBwdWJsaWMgbWV0aG9kIGByZW5kZXJDaGlsZFZpZXcoKWAuXG4gICAgICBpZiAoY2FuVHJpZ2dlckF0dGFjaCAmJiB0aGlzLl90cmlnZ2VyQmVmb3JlQXR0YWNoKSB7XG4gICAgICAgIG5lc3RlZFZpZXdzID0gW3ZpZXddLmNvbmNhdCh2aWV3Ll9nZXROZXN0ZWRWaWV3cygpKTtcbiAgICAgICAgdmlldy5vbmNlKCdyZW5kZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLl90cmlnZ2VyTWV0aG9kTWFueShuZXN0ZWRWaWV3cywgdGhpcywgJ2JlZm9yZTphdHRhY2gnKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gIFxuICAgICAgLy8gUmVuZGVyIGl0IGFuZCBzaG93IGl0XG4gICAgICB0aGlzLnJlbmRlckNoaWxkVmlldyh2aWV3LCB0aGlzLl9lbXB0eVZpZXdJbmRleCk7XG4gIFxuICAgICAgLy8gVHJpZ2dlciBgYXR0YWNoYFxuICAgICAgaWYgKGNhblRyaWdnZXJBdHRhY2ggJiYgdGhpcy5fdHJpZ2dlckF0dGFjaCkge1xuICAgICAgICBuZXN0ZWRWaWV3cyA9IFt2aWV3XS5jb25jYXQodmlldy5fZ2V0TmVzdGVkVmlld3MoKSk7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJNZXRob2RNYW55KG5lc3RlZFZpZXdzLCB0aGlzLCAnYXR0YWNoJyk7XG4gICAgICB9XG4gICAgICAvLyBjYWxsIHRoZSAnc2hvdycgbWV0aG9kIGlmIHRoZSBjb2xsZWN0aW9uIHZpZXcgaGFzIGFscmVhZHkgYmVlbiBzaG93blxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcbiAgICAgICAgTWFyaW9uZXR0ZS50cmlnZ2VyTWV0aG9kT24odmlldywgJ3Nob3cnLCB2aWV3KTtcbiAgICAgIH1cbiAgICB9LFxuICBcbiAgICAvLyBSZXRyaWV2ZSB0aGUgYGNoaWxkVmlld2AgY2xhc3MsIGVpdGhlciBmcm9tIGB0aGlzLm9wdGlvbnMuY2hpbGRWaWV3YFxuICAgIC8vIG9yIGZyb20gdGhlIGBjaGlsZFZpZXdgIGluIHRoZSBvYmplY3QgZGVmaW5pdGlvbi4gVGhlIFwib3B0aW9uc1wiXG4gICAgLy8gdGFrZXMgcHJlY2VkZW5jZS5cbiAgICAvLyBUaGlzIG1ldGhvZCByZWNlaXZlcyB0aGUgbW9kZWwgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgaW5zdGFuY2VcbiAgICAvLyBjcmVhdGVkIGZyb20gdGhpcyBgY2hpbGRWaWV3YC4gT3ZlcnJpZGluZyBtZXRob2RzIG1heSB1c2UgdGhlIGNoaWxkXG4gICAgLy8gdG8gZGV0ZXJtaW5lIHdoYXQgYGNoaWxkVmlld2AgY2xhc3MgdG8gcmV0dXJuLlxuICAgIGdldENoaWxkVmlldzogZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZFZpZXcgPSB0aGlzLmdldE9wdGlvbignY2hpbGRWaWV3Jyk7XG4gIFxuICAgICAgaWYgKCFjaGlsZFZpZXcpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1hcmlvbmV0dGUuRXJyb3Ioe1xuICAgICAgICAgIG5hbWU6ICdOb0NoaWxkVmlld0Vycm9yJyxcbiAgICAgICAgICBtZXNzYWdlOiAnQSBcImNoaWxkVmlld1wiIG11c3QgYmUgc3BlY2lmaWVkJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gY2hpbGRWaWV3O1xuICAgIH0sXG4gIFxuICAgIC8vIFJlbmRlciB0aGUgY2hpbGQncyB2aWV3IGFuZCBhZGQgaXQgdG8gdGhlXG4gICAgLy8gSFRNTCBmb3IgdGhlIGNvbGxlY3Rpb24gdmlldyBhdCBhIGdpdmVuIGluZGV4LlxuICAgIC8vIFRoaXMgd2lsbCBhbHNvIHVwZGF0ZSB0aGUgaW5kaWNlcyBvZiBsYXRlciB2aWV3cyBpbiB0aGUgY29sbGVjdGlvblxuICAgIC8vIGluIG9yZGVyIHRvIGtlZXAgdGhlIGNoaWxkcmVuIGluIHN5bmMgd2l0aCB0aGUgY29sbGVjdGlvbi5cbiAgICBhZGRDaGlsZDogZnVuY3Rpb24oY2hpbGQsIENoaWxkVmlldywgaW5kZXgpIHtcbiAgICAgIHZhciBjaGlsZFZpZXdPcHRpb25zID0gdGhpcy5nZXRPcHRpb24oJ2NoaWxkVmlld09wdGlvbnMnKTtcbiAgICAgIGNoaWxkVmlld09wdGlvbnMgPSBNYXJpb25ldHRlLl9nZXRWYWx1ZShjaGlsZFZpZXdPcHRpb25zLCB0aGlzLCBbY2hpbGQsIGluZGV4XSk7XG4gIFxuICAgICAgdmFyIHZpZXcgPSB0aGlzLmJ1aWxkQ2hpbGRWaWV3KGNoaWxkLCBDaGlsZFZpZXcsIGNoaWxkVmlld09wdGlvbnMpO1xuICBcbiAgICAgIC8vIGluY3JlbWVudCBpbmRpY2VzIG9mIHZpZXdzIGFmdGVyIHRoaXMgb25lXG4gICAgICB0aGlzLl91cGRhdGVJbmRpY2VzKHZpZXcsIHRydWUsIGluZGV4KTtcbiAgXG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2JlZm9yZTphZGQ6Y2hpbGQnLCB2aWV3KTtcbiAgICAgIHRoaXMuX2FkZENoaWxkVmlldyh2aWV3LCBpbmRleCk7XG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2FkZDpjaGlsZCcsIHZpZXcpO1xuICBcbiAgICAgIHZpZXcuX3BhcmVudCA9IHRoaXM7XG4gIFxuICAgICAgcmV0dXJuIHZpZXc7XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kLiBUaGlzIGRlY3JlbWVudHMgb3IgaW5jcmVtZW50cyB0aGUgaW5kaWNlcyBvZiB2aWV3cyBhZnRlciB0aGVcbiAgICAvLyBhZGRlZC9yZW1vdmVkIHZpZXcgdG8ga2VlcCBpbiBzeW5jIHdpdGggdGhlIGNvbGxlY3Rpb24uXG4gICAgX3VwZGF0ZUluZGljZXM6IGZ1bmN0aW9uKHZpZXcsIGluY3JlbWVudCwgaW5kZXgpIHtcbiAgICAgIGlmICghdGhpcy5nZXRPcHRpb24oJ3NvcnQnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIFxuICAgICAgaWYgKGluY3JlbWVudCkge1xuICAgICAgICAvLyBhc3NpZ24gdGhlIGluZGV4IHRvIHRoZSB2aWV3XG4gICAgICAgIHZpZXcuX2luZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gIFxuICAgICAgLy8gdXBkYXRlIHRoZSBpbmRleGVzIG9mIHZpZXdzIGFmdGVyIHRoaXMgb25lXG4gICAgICB0aGlzLmNoaWxkcmVuLmVhY2goZnVuY3Rpb24obGF0ZXJWaWV3KSB7XG4gICAgICAgIGlmIChsYXRlclZpZXcuX2luZGV4ID49IHZpZXcuX2luZGV4KSB7XG4gICAgICAgICAgbGF0ZXJWaWV3Ll9pbmRleCArPSBpbmNyZW1lbnQgPyAxIDogLTE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIE1ldGhvZC4gQWRkIHRoZSB2aWV3IHRvIGNoaWxkcmVuIGFuZCByZW5kZXIgaXQgYXRcbiAgICAvLyB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgX2FkZENoaWxkVmlldzogZnVuY3Rpb24odmlldywgaW5kZXgpIHtcbiAgICAgIC8vIE9ubHkgdHJpZ2dlciBhdHRhY2ggaWYgYWxyZWFkeSBzaG93biwgYXR0YWNoZWQsIGFuZCBub3QgYnVmZmVyaW5nLCBvdGhlcndpc2UgZW5kQnVmZmVyKCkgb3JcbiAgICAgIC8vIFJlZ2lvbiNzaG93KCkgaGFuZGxlcyB0aGlzLlxuICAgICAgdmFyIGNhblRyaWdnZXJBdHRhY2ggPSB0aGlzLl9pc1Nob3duICYmICF0aGlzLmlzQnVmZmVyaW5nICYmIE1hcmlvbmV0dGUuaXNOb2RlQXR0YWNoZWQodGhpcy5lbCk7XG4gICAgICB2YXIgbmVzdGVkVmlld3M7XG4gIFxuICAgICAgLy8gc2V0IHVwIHRoZSBjaGlsZCB2aWV3IGV2ZW50IGZvcndhcmRpbmdcbiAgICAgIHRoaXMucHJveHlDaGlsZEV2ZW50cyh2aWV3KTtcbiAgXG4gICAgICAvLyB0cmlnZ2VyIHRoZSAnYmVmb3JlOnNob3cnIGV2ZW50IG9uIGB2aWV3YCBpZiB0aGUgY29sbGVjdGlvbiB2aWV3IGhhcyBhbHJlYWR5IGJlZW4gc2hvd25cbiAgICAgIGlmICh0aGlzLl9pc1Nob3duICYmICF0aGlzLmlzQnVmZmVyaW5nKSB7XG4gICAgICAgIE1hcmlvbmV0dGUudHJpZ2dlck1ldGhvZE9uKHZpZXcsICdiZWZvcmU6c2hvdycsIHZpZXcpO1xuICAgICAgfVxuICBcbiAgICAgIC8vIFN0b3JlIHRoZSBjaGlsZCB2aWV3IGl0c2VsZiBzbyB3ZSBjYW4gcHJvcGVybHkgcmVtb3ZlIGFuZC9vciBkZXN0cm95IGl0IGxhdGVyXG4gICAgICB0aGlzLmNoaWxkcmVuLmFkZCh2aWV3KTtcbiAgXG4gICAgICAvLyBUcmlnZ2VyIGBiZWZvcmU6YXR0YWNoYCBmb2xsb3dpbmcgYHJlbmRlcmAgdG8gYXZvaWQgYWRkaW5nIGxvZ2ljIGFuZCBldmVudCB0cmlnZ2Vyc1xuICAgICAgLy8gdG8gcHVibGljIG1ldGhvZCBgcmVuZGVyQ2hpbGRWaWV3KClgLlxuICAgICAgaWYgKGNhblRyaWdnZXJBdHRhY2ggJiYgdGhpcy5fdHJpZ2dlckJlZm9yZUF0dGFjaCkge1xuICAgICAgICBuZXN0ZWRWaWV3cyA9IFt2aWV3XS5jb25jYXQodmlldy5fZ2V0TmVzdGVkVmlld3MoKSk7XG4gICAgICAgIHZpZXcub25jZSgncmVuZGVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5fdHJpZ2dlck1ldGhvZE1hbnkobmVzdGVkVmlld3MsIHRoaXMsICdiZWZvcmU6YXR0YWNoJyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICBcbiAgICAgIHRoaXMucmVuZGVyQ2hpbGRWaWV3KHZpZXcsIGluZGV4KTtcbiAgXG4gICAgICAvLyBUcmlnZ2VyIGBhdHRhY2hgXG4gICAgICBpZiAoY2FuVHJpZ2dlckF0dGFjaCAmJiB0aGlzLl90cmlnZ2VyQXR0YWNoKSB7XG4gICAgICAgIG5lc3RlZFZpZXdzID0gW3ZpZXddLmNvbmNhdCh2aWV3Ll9nZXROZXN0ZWRWaWV3cygpKTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlck1ldGhvZE1hbnkobmVzdGVkVmlld3MsIHRoaXMsICdhdHRhY2gnKTtcbiAgICAgIH1cbiAgICAgIC8vIFRyaWdnZXIgYHNob3dgXG4gICAgICBpZiAodGhpcy5faXNTaG93biAmJiAhdGhpcy5pc0J1ZmZlcmluZykge1xuICAgICAgICBNYXJpb25ldHRlLnRyaWdnZXJNZXRob2RPbih2aWV3LCAnc2hvdycsIHZpZXcpO1xuICAgICAgfVxuICAgIH0sXG4gIFxuICAgIC8vIHJlbmRlciB0aGUgY2hpbGQgdmlld1xuICAgIHJlbmRlckNoaWxkVmlldzogZnVuY3Rpb24odmlldywgaW5kZXgpIHtcbiAgICAgIHZpZXcucmVuZGVyKCk7XG4gICAgICB0aGlzLmF0dGFjaEh0bWwodGhpcywgdmlldywgaW5kZXgpO1xuICAgICAgcmV0dXJuIHZpZXc7XG4gICAgfSxcbiAgXG4gICAgLy8gQnVpbGQgYSBgY2hpbGRWaWV3YCBmb3IgYSBtb2RlbCBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICBidWlsZENoaWxkVmlldzogZnVuY3Rpb24oY2hpbGQsIENoaWxkVmlld0NsYXNzLCBjaGlsZFZpZXdPcHRpb25zKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IF8uZXh0ZW5kKHttb2RlbDogY2hpbGR9LCBjaGlsZFZpZXdPcHRpb25zKTtcbiAgICAgIHJldHVybiBuZXcgQ2hpbGRWaWV3Q2xhc3Mob3B0aW9ucyk7XG4gICAgfSxcbiAgXG4gICAgLy8gUmVtb3ZlIHRoZSBjaGlsZCB2aWV3IGFuZCBkZXN0cm95IGl0LlxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxzbyB1cGRhdGVzIHRoZSBpbmRpY2VzIG9mXG4gICAgLy8gbGF0ZXIgdmlld3MgaW4gdGhlIGNvbGxlY3Rpb24gaW4gb3JkZXIgdG8ga2VlcFxuICAgIC8vIHRoZSBjaGlsZHJlbiBpbiBzeW5jIHdpdGggdGhlIGNvbGxlY3Rpb24uXG4gICAgcmVtb3ZlQ2hpbGRWaWV3OiBmdW5jdGlvbih2aWV3KSB7XG4gIFxuICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6cmVtb3ZlOmNoaWxkJywgdmlldyk7XG4gIFxuICAgICAgICAvLyBjYWxsICdkZXN0cm95JyBvciAncmVtb3ZlJywgZGVwZW5kaW5nIG9uIHdoaWNoIGlzIGZvdW5kXG4gICAgICAgIGlmICh2aWV3LmRlc3Ryb3kpIHtcbiAgICAgICAgICB2aWV3LmRlc3Ryb3koKTtcbiAgICAgICAgfSBlbHNlIGlmICh2aWV3LnJlbW92ZSkge1xuICAgICAgICAgIHZpZXcucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIGRlbGV0ZSB2aWV3Ll9wYXJlbnQ7XG4gICAgICAgIHRoaXMuc3RvcExpc3RlbmluZyh2aWV3KTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5yZW1vdmUodmlldyk7XG4gICAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgncmVtb3ZlOmNoaWxkJywgdmlldyk7XG4gIFxuICAgICAgICAvLyBkZWNyZW1lbnQgdGhlIGluZGV4IG9mIHZpZXdzIGFmdGVyIHRoaXMgb25lXG4gICAgICAgIHRoaXMuX3VwZGF0ZUluZGljZXModmlldywgZmFsc2UpO1xuICAgICAgfVxuICBcbiAgICAgIHJldHVybiB2aWV3O1xuICAgIH0sXG4gIFxuICAgIC8vIGNoZWNrIGlmIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5XG4gICAgaXNFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXRoaXMuY29sbGVjdGlvbiB8fCB0aGlzLmNvbGxlY3Rpb24ubGVuZ3RoID09PSAwO1xuICAgIH0sXG4gIFxuICAgIC8vIElmIGVtcHR5LCBzaG93IHRoZSBlbXB0eSB2aWV3XG4gICAgY2hlY2tFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc0VtcHR5KHRoaXMuY29sbGVjdGlvbikpIHtcbiAgICAgICAgdGhpcy5zaG93RW1wdHlWaWV3KCk7XG4gICAgICB9XG4gICAgfSxcbiAgXG4gICAgLy8gWW91IG1pZ2h0IG5lZWQgdG8gb3ZlcnJpZGUgdGhpcyBpZiB5b3UndmUgb3ZlcnJpZGRlbiBhdHRhY2hIdG1sXG4gICAgYXR0YWNoQnVmZmVyOiBmdW5jdGlvbihjb2xsZWN0aW9uVmlldywgYnVmZmVyKSB7XG4gICAgICBjb2xsZWN0aW9uVmlldy4kZWwuYXBwZW5kKGJ1ZmZlcik7XG4gICAgfSxcbiAgXG4gICAgLy8gQ3JlYXRlIGEgZnJhZ21lbnQgYnVmZmVyIGZyb20gdGhlIGN1cnJlbnRseSBidWZmZXJlZCBjaGlsZHJlblxuICAgIF9jcmVhdGVCdWZmZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVsQnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgXy5lYWNoKHRoaXMuX2J1ZmZlcmVkQ2hpbGRyZW4sIGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgZWxCdWZmZXIuYXBwZW5kQ2hpbGQoYi5lbCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlbEJ1ZmZlcjtcbiAgICB9LFxuICBcbiAgICAvLyBBcHBlbmQgdGhlIEhUTUwgdG8gdGhlIGNvbGxlY3Rpb24ncyBgZWxgLlxuICAgIC8vIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGRvIHNvbWV0aGluZyBvdGhlclxuICAgIC8vIHRoYW4gYC5hcHBlbmRgLlxuICAgIGF0dGFjaEh0bWw6IGZ1bmN0aW9uKGNvbGxlY3Rpb25WaWV3LCBjaGlsZFZpZXcsIGluZGV4KSB7XG4gICAgICBpZiAoY29sbGVjdGlvblZpZXcuaXNCdWZmZXJpbmcpIHtcbiAgICAgICAgLy8gYnVmZmVyaW5nIGhhcHBlbnMgb24gcmVzZXQgZXZlbnRzIGFuZCBpbml0aWFsIHJlbmRlcnNcbiAgICAgICAgLy8gaW4gb3JkZXIgdG8gcmVkdWNlIHRoZSBudW1iZXIgb2YgaW5zZXJ0cyBpbnRvIHRoZVxuICAgICAgICAvLyBkb2N1bWVudCwgd2hpY2ggYXJlIGV4cGVuc2l2ZS5cbiAgICAgICAgY29sbGVjdGlvblZpZXcuX2J1ZmZlcmVkQ2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBjaGlsZFZpZXcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSByZW5kZXJlZCB0aGUgbWFpbiBjb2xsZWN0aW9uLCBhcHBlbmRcbiAgICAgICAgLy8gdGhlIG5ldyBjaGlsZCBpbnRvIHRoZSBjb3JyZWN0IG9yZGVyIGlmIHdlIG5lZWQgdG8uIE90aGVyd2lzZVxuICAgICAgICAvLyBhcHBlbmQgdG8gdGhlIGVuZC5cbiAgICAgICAgaWYgKCFjb2xsZWN0aW9uVmlldy5faW5zZXJ0QmVmb3JlKGNoaWxkVmlldywgaW5kZXgpKSB7XG4gICAgICAgICAgY29sbGVjdGlvblZpZXcuX2luc2VydEFmdGVyKGNoaWxkVmlldyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICBcbiAgICAvLyBJbnRlcm5hbCBtZXRob2QuIENoZWNrIHdoZXRoZXIgd2UgbmVlZCB0byBpbnNlcnQgdGhlIHZpZXcgaW50b1xuICAgIC8vIHRoZSBjb3JyZWN0IHBvc2l0aW9uLlxuICAgIF9pbnNlcnRCZWZvcmU6IGZ1bmN0aW9uKGNoaWxkVmlldywgaW5kZXgpIHtcbiAgICAgIHZhciBjdXJyZW50VmlldztcbiAgICAgIHZhciBmaW5kUG9zaXRpb24gPSB0aGlzLmdldE9wdGlvbignc29ydCcpICYmIChpbmRleCA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoZmluZFBvc2l0aW9uKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIHZpZXcgYWZ0ZXIgdGhpcyBvbmVcbiAgICAgICAgY3VycmVudFZpZXcgPSB0aGlzLmNoaWxkcmVuLmZpbmQoZnVuY3Rpb24odmlldykge1xuICAgICAgICAgIHJldHVybiB2aWV3Ll9pbmRleCA9PT0gaW5kZXggKyAxO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgXG4gICAgICBpZiAoY3VycmVudFZpZXcpIHtcbiAgICAgICAgY3VycmVudFZpZXcuJGVsLmJlZm9yZShjaGlsZFZpZXcuZWwpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kLiBBcHBlbmQgYSB2aWV3IHRvIHRoZSBlbmQgb2YgdGhlICRlbFxuICAgIF9pbnNlcnRBZnRlcjogZnVuY3Rpb24oY2hpbGRWaWV3KSB7XG4gICAgICB0aGlzLiRlbC5hcHBlbmQoY2hpbGRWaWV3LmVsKTtcbiAgICB9LFxuICBcbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gc2V0IHVwIHRoZSBgY2hpbGRyZW5gIG9iamVjdCBmb3JcbiAgICAvLyBzdG9yaW5nIGFsbCBvZiB0aGUgY2hpbGQgdmlld3NcbiAgICBfaW5pdENoaWxkVmlld1N0b3JhZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBCYWNrYm9uZS5DaGlsZFZpZXdDb250YWluZXIoKTtcbiAgICB9LFxuICBcbiAgICAvLyBIYW5kbGUgY2xlYW51cCBhbmQgb3RoZXIgZGVzdHJveWluZyBuZWVkcyBmb3IgdGhlIGNvbGxlY3Rpb24gb2Ygdmlld3NcbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSB7IHJldHVybiB0aGlzOyB9XG4gIFxuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6ZGVzdHJveTpjb2xsZWN0aW9uJyk7XG4gICAgICB0aGlzLmRlc3Ryb3lDaGlsZHJlbih7Y2hlY2tFbXB0eTogZmFsc2V9KTtcbiAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgnZGVzdHJveTpjb2xsZWN0aW9uJyk7XG4gIFxuICAgICAgcmV0dXJuIE1hcmlvbmV0dGUuVmlldy5wcm90b3R5cGUuZGVzdHJveS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gIFxuICAgIC8vIERlc3Ryb3kgdGhlIGNoaWxkIHZpZXdzIHRoYXQgdGhpcyBjb2xsZWN0aW9uIHZpZXdcbiAgICAvLyBpcyBob2xkaW5nIG9uIHRvLCBpZiBhbnlcbiAgICBkZXN0cm95Q2hpbGRyZW46IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBkZXN0cm95T3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgc2hvdWxkQ2hlY2tFbXB0eSA9IHRydWU7XG4gICAgICB2YXIgY2hpbGRWaWV3cyA9IHRoaXMuY2hpbGRyZW4ubWFwKF8uaWRlbnRpdHkpO1xuICBcbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZChkZXN0cm95T3B0aW9ucy5jaGVja0VtcHR5KSkge1xuICAgICAgICBzaG91bGRDaGVja0VtcHR5ID0gZGVzdHJveU9wdGlvbnMuY2hlY2tFbXB0eTtcbiAgICAgIH1cbiAgXG4gICAgICB0aGlzLmNoaWxkcmVuLmVhY2godGhpcy5yZW1vdmVDaGlsZFZpZXcsIHRoaXMpO1xuICBcbiAgICAgIGlmIChzaG91bGRDaGVja0VtcHR5KSB7XG4gICAgICAgIHRoaXMuY2hlY2tFbXB0eSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoaWxkVmlld3M7XG4gICAgfSxcbiAgXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIGdpdmVuIGNoaWxkIHNob3VsZCBiZSBzaG93blxuICAgIC8vIFJldHVybiBmYWxzZSBvdGhlcndpc2VcbiAgICAvLyBUaGUgZmlsdGVyIHdpbGwgYmUgcGFzc2VkIChjaGlsZCwgaW5kZXgsIGNvbGxlY3Rpb24pXG4gICAgLy8gV2hlcmVcbiAgICAvLyAgJ2NoaWxkJyBpcyB0aGUgZ2l2ZW4gbW9kZWxcbiAgICAvLyAgJ2luZGV4JyBpcyB0aGUgaW5kZXggb2YgdGhhdCBtb2RlbCBpbiB0aGUgY29sbGVjdGlvblxuICAgIC8vICAnY29sbGVjdGlvbicgaXMgdGhlIGNvbGxlY3Rpb24gcmVmZXJlbmNlZCBieSB0aGlzIENvbGxlY3Rpb25WaWV3XG4gICAgX3Nob3VsZEFkZENoaWxkOiBmdW5jdGlvbihjaGlsZCwgaW5kZXgpIHtcbiAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLmdldE9wdGlvbignZmlsdGVyJyk7XG4gICAgICByZXR1cm4gIV8uaXNGdW5jdGlvbihmaWx0ZXIpIHx8IGZpbHRlci5jYWxsKHRoaXMsIGNoaWxkLCBpbmRleCwgdGhpcy5jb2xsZWN0aW9uKTtcbiAgICB9LFxuICBcbiAgICAvLyBTZXQgdXAgdGhlIGNoaWxkIHZpZXcgZXZlbnQgZm9yd2FyZGluZy4gVXNlcyBhIFwiY2hpbGR2aWV3OlwiXG4gICAgLy8gcHJlZml4IGluIGZyb250IG9mIGFsbCBmb3J3YXJkZWQgZXZlbnRzLlxuICAgIHByb3h5Q2hpbGRFdmVudHM6IGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgIHZhciBwcmVmaXggPSB0aGlzLmdldE9wdGlvbignY2hpbGRWaWV3RXZlbnRQcmVmaXgnKTtcbiAgXG4gICAgICAvLyBGb3J3YXJkIGFsbCBjaGlsZCB2aWV3IGV2ZW50cyB0aHJvdWdoIHRoZSBwYXJlbnQsXG4gICAgICAvLyBwcmVwZW5kaW5nIFwiY2hpbGR2aWV3OlwiIHRvIHRoZSBldmVudCBuYW1lXG4gICAgICB0aGlzLmxpc3RlblRvKHZpZXcsICdhbGwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBfLnRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHJvb3RFdmVudCA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBjaGlsZEV2ZW50cyA9IHRoaXMubm9ybWFsaXplTWV0aG9kcyhfLnJlc3VsdCh0aGlzLCAnY2hpbGRFdmVudHMnKSk7XG4gIFxuICAgICAgICBhcmdzWzBdID0gcHJlZml4ICsgJzonICsgcm9vdEV2ZW50O1xuICAgICAgICBhcmdzLnNwbGljZSgxLCAwLCB2aWV3KTtcbiAgXG4gICAgICAgIC8vIGNhbGwgY29sbGVjdGlvblZpZXcgY2hpbGRFdmVudCBpZiBkZWZpbmVkXG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGRFdmVudHMgIT09ICd1bmRlZmluZWQnICYmIF8uaXNGdW5jdGlvbihjaGlsZEV2ZW50c1tyb290RXZlbnRdKSkge1xuICAgICAgICAgIGNoaWxkRXZlbnRzW3Jvb3RFdmVudF0uYXBwbHkodGhpcywgYXJncy5zbGljZSgxKSk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHRoaXMudHJpZ2dlck1ldGhvZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gIFxuICAgIF9nZXRJbW1lZGlhdGVDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXy52YWx1ZXModGhpcy5jaGlsZHJlbi5fdmlld3MpO1xuICAgIH0sXG4gIFxuICAgIGdldFZpZXdDb21wYXJhdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbigndmlld0NvbXBhcmF0b3InKTtcbiAgICB9XG4gIH0pO1xuICBcbiAgLyoganNoaW50IG1heHN0YXRlbWVudHM6IDE3LCBtYXhsZW46IDExNyAqL1xuICBcbiAgLy8gQ29tcG9zaXRlIFZpZXdcbiAgLy8gLS0tLS0tLS0tLS0tLS1cbiAgXG4gIC8vIFVzZWQgZm9yIHJlbmRlcmluZyBhIGJyYW5jaC1sZWFmLCBoaWVyYXJjaGljYWwgc3RydWN0dXJlLlxuICAvLyBFeHRlbmRzIGRpcmVjdGx5IGZyb20gQ29sbGVjdGlvblZpZXcgYW5kIGFsc28gcmVuZGVycyBhblxuICAvLyBhIGNoaWxkIHZpZXcgYXMgYG1vZGVsVmlld2AsIGZvciB0aGUgdG9wIGxlYWZcbiAgTWFyaW9uZXR0ZS5Db21wb3NpdGVWaWV3ID0gTWFyaW9uZXR0ZS5Db2xsZWN0aW9uVmlldy5leHRlbmQoe1xuICBcbiAgICAvLyBTZXR0aW5nIHVwIHRoZSBpbmhlcml0YW5jZSBjaGFpbiB3aGljaCBhbGxvd3MgY2hhbmdlcyB0b1xuICAgIC8vIE1hcmlvbmV0dGUuQ29sbGVjdGlvblZpZXcucHJvdG90eXBlLmNvbnN0cnVjdG9yIHdoaWNoIGFsbG93cyBvdmVycmlkaW5nXG4gICAgLy8gb3B0aW9uIHRvIHBhc3MgJ3tzb3J0OiBmYWxzZX0nIHRvIHByZXZlbnQgdGhlIENvbXBvc2l0ZVZpZXcgZnJvbVxuICAgIC8vIG1haW50YWluaW5nIHRoZSBzb3J0ZWQgb3JkZXIgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgLy8gVGhpcyB3aWxsIGZhbGxiYWNrIG9udG8gYXBwZW5kaW5nIGNoaWxkVmlldydzIHRvIHRoZSBlbmQuXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgTWFyaW9uZXR0ZS5Db2xsZWN0aW9uVmlldy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gIFxuICAgIC8vIENvbmZpZ3VyZWQgdGhlIGluaXRpYWwgZXZlbnRzIHRoYXQgdGhlIGNvbXBvc2l0ZSB2aWV3XG4gICAgLy8gYmluZHMgdG8uIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHByZXZlbnQgdGhlIGluaXRpYWxcbiAgICAvLyBldmVudHMsIG9yIHRvIGFkZCB5b3VyIG93biBpbml0aWFsIGV2ZW50cy5cbiAgICBfaW5pdGlhbEV2ZW50czogZnVuY3Rpb24oKSB7XG4gIFxuICAgICAgLy8gQmluZCBvbmx5IGFmdGVyIGNvbXBvc2l0ZSB2aWV3IGlzIHJlbmRlcmVkIHRvIGF2b2lkIGFkZGluZyBjaGlsZCB2aWV3c1xuICAgICAgLy8gdG8gbm9uZXhpc3RlbnQgY2hpbGRWaWV3Q29udGFpbmVyXG4gIFxuICAgICAgaWYgKHRoaXMuY29sbGVjdGlvbikge1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMuY29sbGVjdGlvbiwgJ2FkZCcsIHRoaXMuX29uQ29sbGVjdGlvbkFkZCk7XG4gICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb2xsZWN0aW9uLCAncmVtb3ZlJywgdGhpcy5fb25Db2xsZWN0aW9uUmVtb3ZlKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbGxlY3Rpb24sICdyZXNldCcsIHRoaXMuX3JlbmRlckNoaWxkcmVuKTtcbiAgXG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbignc29ydCcpKSB7XG4gICAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbGxlY3Rpb24sICdzb3J0JywgdGhpcy5fc29ydFZpZXdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gIFxuICAgIC8vIFJldHJpZXZlIHRoZSBgY2hpbGRWaWV3YCB0byBiZSB1c2VkIHdoZW4gcmVuZGVyaW5nIGVhY2ggb2ZcbiAgICAvLyB0aGUgaXRlbXMgaW4gdGhlIGNvbGxlY3Rpb24uIFRoZSBkZWZhdWx0IGlzIHRvIHJldHVyblxuICAgIC8vIGB0aGlzLmNoaWxkVmlld2Agb3IgTWFyaW9uZXR0ZS5Db21wb3NpdGVWaWV3IGlmIG5vIGBjaGlsZFZpZXdgXG4gICAgLy8gaGFzIGJlZW4gZGVmaW5lZFxuICAgIGdldENoaWxkVmlldzogZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZFZpZXcgPSB0aGlzLmdldE9wdGlvbignY2hpbGRWaWV3JykgfHwgdGhpcy5jb25zdHJ1Y3RvcjtcbiAgXG4gICAgICByZXR1cm4gY2hpbGRWaWV3O1xuICAgIH0sXG4gIFxuICAgIC8vIFNlcmlhbGl6ZSB0aGUgbW9kZWwgZm9yIHRoZSB2aWV3LlxuICAgIC8vIFlvdSBjYW4gb3ZlcnJpZGUgdGhlIGBzZXJpYWxpemVEYXRhYCBtZXRob2QgaW4geW91ciBvd24gdmlld1xuICAgIC8vIGRlZmluaXRpb24sIHRvIHByb3ZpZGUgY3VzdG9tIHNlcmlhbGl6YXRpb24gZm9yIHlvdXIgdmlldydzIGRhdGEuXG4gICAgc2VyaWFsaXplRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGF0YSA9IHt9O1xuICBcbiAgICAgIGlmICh0aGlzLm1vZGVsKSB7XG4gICAgICAgIGRhdGEgPSBfLnBhcnRpYWwodGhpcy5zZXJpYWxpemVNb2RlbCwgdGhpcy5tb2RlbCkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuICBcbiAgICAvLyBSZW5kZXJzIHRoZSBtb2RlbCBhbmQgdGhlIGNvbGxlY3Rpb24uXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2Vuc3VyZVZpZXdJc0ludGFjdCgpO1xuICAgICAgdGhpcy5faXNSZW5kZXJpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5yZXNldENoaWxkVmlld0NvbnRhaW5lcigpO1xuICBcbiAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgnYmVmb3JlOnJlbmRlcicsIHRoaXMpO1xuICBcbiAgICAgIHRoaXMuX3JlbmRlclRlbXBsYXRlKCk7XG4gICAgICB0aGlzLl9yZW5kZXJDaGlsZHJlbigpO1xuICBcbiAgICAgIHRoaXMuX2lzUmVuZGVyaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmlzUmVuZGVyZWQgPSB0cnVlO1xuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdyZW5kZXInLCB0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gIFxuICAgIF9yZW5kZXJDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc1JlbmRlcmVkIHx8IHRoaXMuX2lzUmVuZGVyaW5nKSB7XG4gICAgICAgIE1hcmlvbmV0dGUuQ29sbGVjdGlvblZpZXcucHJvdG90eXBlLl9yZW5kZXJDaGlsZHJlbi5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG4gIFxuICAgIC8vIFJlbmRlciB0aGUgcm9vdCB0ZW1wbGF0ZSB0aGF0IHRoZSBjaGlsZHJlblxuICAgIC8vIHZpZXdzIGFyZSBhcHBlbmRlZCB0b1xuICAgIF9yZW5kZXJUZW1wbGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgZGF0YSA9IHRoaXMuc2VyaWFsaXplRGF0YSgpO1xuICAgICAgZGF0YSA9IHRoaXMubWl4aW5UZW1wbGF0ZUhlbHBlcnMoZGF0YSk7XG4gIFxuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6cmVuZGVyOnRlbXBsYXRlJyk7XG4gIFxuICAgICAgdmFyIHRlbXBsYXRlID0gdGhpcy5nZXRUZW1wbGF0ZSgpO1xuICAgICAgdmFyIGh0bWwgPSBNYXJpb25ldHRlLlJlbmRlcmVyLnJlbmRlcih0ZW1wbGF0ZSwgZGF0YSwgdGhpcyk7XG4gICAgICB0aGlzLmF0dGFjaEVsQ29udGVudChodG1sKTtcbiAgXG4gICAgICAvLyB0aGUgdWkgYmluZGluZ3MgaXMgZG9uZSBoZXJlIGFuZCBub3QgYXQgdGhlIGVuZCBvZiByZW5kZXIgc2luY2UgdGhleVxuICAgICAgLy8gd2lsbCBub3QgYmUgYXZhaWxhYmxlIHVudGlsIGFmdGVyIHRoZSBtb2RlbCBpcyByZW5kZXJlZCwgYnV0IHNob3VsZCBiZVxuICAgICAgLy8gYXZhaWxhYmxlIGJlZm9yZSB0aGUgY29sbGVjdGlvbiBpcyByZW5kZXJlZC5cbiAgICAgIHRoaXMuYmluZFVJRWxlbWVudHMoKTtcbiAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgncmVuZGVyOnRlbXBsYXRlJyk7XG4gICAgfSxcbiAgXG4gICAgLy8gQXR0YWNoZXMgdGhlIGNvbnRlbnQgb2YgdGhlIHJvb3QuXG4gICAgLy8gVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gdG8gb3B0aW1pemUgcmVuZGVyaW5nLFxuICAgIC8vIG9yIHRvIHJlbmRlciBpbiBhIG5vbiBzdGFuZGFyZCB3YXkuXG4gICAgLy9cbiAgICAvLyBGb3IgZXhhbXBsZSwgdXNpbmcgYGlubmVySFRNTGAgaW5zdGVhZCBvZiBgJGVsLmh0bWxgXG4gICAgLy9cbiAgICAvLyBgYGBqc1xuICAgIC8vIGF0dGFjaEVsQ29udGVudDogZnVuY3Rpb24oaHRtbCkge1xuICAgIC8vICAgdGhpcy5lbC5pbm5lckhUTUwgPSBodG1sO1xuICAgIC8vICAgcmV0dXJuIHRoaXM7XG4gICAgLy8gfVxuICAgIC8vIGBgYFxuICAgIGF0dGFjaEVsQ29udGVudDogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgdGhpcy4kZWwuaHRtbChodG1sKTtcbiAgXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICBcbiAgICAvLyBZb3UgbWlnaHQgbmVlZCB0byBvdmVycmlkZSB0aGlzIGlmIHlvdSd2ZSBvdmVycmlkZGVuIGF0dGFjaEh0bWxcbiAgICBhdHRhY2hCdWZmZXI6IGZ1bmN0aW9uKGNvbXBvc2l0ZVZpZXcsIGJ1ZmZlcikge1xuICAgICAgdmFyICRjb250YWluZXIgPSB0aGlzLmdldENoaWxkVmlld0NvbnRhaW5lcihjb21wb3NpdGVWaWV3KTtcbiAgICAgICRjb250YWluZXIuYXBwZW5kKGJ1ZmZlcik7XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kLiBBcHBlbmQgYSB2aWV3IHRvIHRoZSBlbmQgb2YgdGhlICRlbC5cbiAgICAvLyBPdmVyaWRkZW4gZnJvbSBDb2xsZWN0aW9uVmlldyB0byBlbnN1cmUgdmlldyBpcyBhcHBlbmRlZCB0b1xuICAgIC8vIGNoaWxkVmlld0NvbnRhaW5lclxuICAgIF9pbnNlcnRBZnRlcjogZnVuY3Rpb24oY2hpbGRWaWV3KSB7XG4gICAgICB2YXIgJGNvbnRhaW5lciA9IHRoaXMuZ2V0Q2hpbGRWaWV3Q29udGFpbmVyKHRoaXMsIGNoaWxkVmlldyk7XG4gICAgICAkY29udGFpbmVyLmFwcGVuZChjaGlsZFZpZXcuZWwpO1xuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZC4gQXBwZW5kIHJlb3JkZXJlZCBjaGlsZFZpZXcnLlxuICAgIC8vIE92ZXJpZGRlbiBmcm9tIENvbGxlY3Rpb25WaWV3IHRvIGVuc3VyZSByZW9yZGVyZWQgdmlld3NcbiAgICAvLyBhcmUgYXBwZW5kZWQgdG8gY2hpbGRWaWV3Q29udGFpbmVyXG4gICAgX2FwcGVuZFJlb3JkZXJlZENoaWxkcmVuOiBmdW5jdGlvbihjaGlsZHJlbikge1xuICAgICAgdmFyICRjb250YWluZXIgPSB0aGlzLmdldENoaWxkVmlld0NvbnRhaW5lcih0aGlzKTtcbiAgICAgICRjb250YWluZXIuYXBwZW5kKGNoaWxkcmVuKTtcbiAgICB9LFxuICBcbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gZW5zdXJlIGFuIGAkY2hpbGRWaWV3Q29udGFpbmVyYCBleGlzdHMsIGZvciB0aGVcbiAgICAvLyBgYXR0YWNoSHRtbGAgbWV0aG9kIHRvIHVzZS5cbiAgICBnZXRDaGlsZFZpZXdDb250YWluZXI6IGZ1bmN0aW9uKGNvbnRhaW5lclZpZXcsIGNoaWxkVmlldykge1xuICAgICAgaWYgKCEhY29udGFpbmVyVmlldy4kY2hpbGRWaWV3Q29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBjb250YWluZXJWaWV3LiRjaGlsZFZpZXdDb250YWluZXI7XG4gICAgICB9XG4gIFxuICAgICAgdmFyIGNvbnRhaW5lcjtcbiAgICAgIHZhciBjaGlsZFZpZXdDb250YWluZXIgPSBNYXJpb25ldHRlLmdldE9wdGlvbihjb250YWluZXJWaWV3LCAnY2hpbGRWaWV3Q29udGFpbmVyJyk7XG4gICAgICBpZiAoY2hpbGRWaWV3Q29udGFpbmVyKSB7XG4gIFxuICAgICAgICB2YXIgc2VsZWN0b3IgPSBNYXJpb25ldHRlLl9nZXRWYWx1ZShjaGlsZFZpZXdDb250YWluZXIsIGNvbnRhaW5lclZpZXcpO1xuICBcbiAgICAgICAgaWYgKHNlbGVjdG9yLmNoYXJBdCgwKSA9PT0gJ0AnICYmIGNvbnRhaW5lclZpZXcudWkpIHtcbiAgICAgICAgICBjb250YWluZXIgPSBjb250YWluZXJWaWV3LnVpW3NlbGVjdG9yLnN1YnN0cig0KV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyVmlldy4kKHNlbGVjdG9yKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgaWYgKGNvbnRhaW5lci5sZW5ndGggPD0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBNYXJpb25ldHRlLkVycm9yKHtcbiAgICAgICAgICAgIG5hbWU6ICdDaGlsZFZpZXdDb250YWluZXJNaXNzaW5nRXJyb3InLFxuICAgICAgICAgICAgbWVzc2FnZTogJ1RoZSBzcGVjaWZpZWQgXCJjaGlsZFZpZXdDb250YWluZXJcIiB3YXMgbm90IGZvdW5kOiAnICsgY29udGFpbmVyVmlldy5jaGlsZFZpZXdDb250YWluZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lclZpZXcuJGVsO1xuICAgICAgfVxuICBcbiAgICAgIGNvbnRhaW5lclZpZXcuJGNoaWxkVmlld0NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIHJlc2V0IHRoZSBgJGNoaWxkVmlld0NvbnRhaW5lcmAgb24gcmVuZGVyXG4gICAgcmVzZXRDaGlsZFZpZXdDb250YWluZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuJGNoaWxkVmlld0NvbnRhaW5lcikge1xuICAgICAgICB0aGlzLiRjaGlsZFZpZXdDb250YWluZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgXG4gIC8vIExheW91dCBWaWV3XG4gIC8vIC0tLS0tLS0tLS0tXG4gIFxuICAvLyBVc2VkIGZvciBtYW5hZ2luZyBhcHBsaWNhdGlvbiBsYXlvdXRWaWV3cywgbmVzdGVkIGxheW91dFZpZXdzIGFuZFxuICAvLyBtdWx0aXBsZSByZWdpb25zIHdpdGhpbiBhbiBhcHBsaWNhdGlvbiBvciBzdWItYXBwbGljYXRpb24uXG4gIC8vXG4gIC8vIEEgc3BlY2lhbGl6ZWQgdmlldyBjbGFzcyB0aGF0IHJlbmRlcnMgYW4gYXJlYSBvZiBIVE1MIGFuZCB0aGVuXG4gIC8vIGF0dGFjaGVzIGBSZWdpb25gIGluc3RhbmNlcyB0byB0aGUgc3BlY2lmaWVkIGByZWdpb25zYC5cbiAgLy8gVXNlZCBmb3IgY29tcG9zaXRlIHZpZXcgbWFuYWdlbWVudCBhbmQgc3ViLWFwcGxpY2F0aW9uIGFyZWFzLlxuICBNYXJpb25ldHRlLkxheW91dFZpZXcgPSBNYXJpb25ldHRlLkl0ZW1WaWV3LmV4dGVuZCh7XG4gICAgcmVnaW9uQ2xhc3M6IE1hcmlvbmV0dGUuUmVnaW9uLFxuICBcbiAgICBvcHRpb25zOiB7XG4gICAgICBkZXN0cm95SW1tZWRpYXRlOiBmYWxzZVxuICAgIH0sXG4gIFxuICAgIC8vIHVzZWQgYXMgdGhlIHByZWZpeCBmb3IgY2hpbGQgdmlldyBldmVudHNcbiAgICAvLyB0aGF0IGFyZSBmb3J3YXJkZWQgdGhyb3VnaCB0aGUgbGF5b3V0dmlld1xuICAgIGNoaWxkVmlld0V2ZW50UHJlZml4OiAnY2hpbGR2aWV3JyxcbiAgXG4gICAgLy8gRW5zdXJlIHRoZSByZWdpb25zIGFyZSBhdmFpbGFibGUgd2hlbiB0aGUgYGluaXRpYWxpemVgIG1ldGhvZFxuICAgIC8vIGlzIGNhbGxlZC5cbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIFxuICAgICAgdGhpcy5fZmlyc3RSZW5kZXIgPSB0cnVlO1xuICAgICAgdGhpcy5faW5pdGlhbGl6ZVJlZ2lvbnMob3B0aW9ucyk7XG4gIFxuICAgICAgTWFyaW9uZXR0ZS5JdGVtVmlldy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG4gIFxuICAgIC8vIExheW91dFZpZXcncyByZW5kZXIgd2lsbCB1c2UgdGhlIGV4aXN0aW5nIHJlZ2lvbiBvYmplY3RzIHRoZVxuICAgIC8vIGZpcnN0IHRpbWUgaXQgaXMgY2FsbGVkLiBTdWJzZXF1ZW50IGNhbGxzIHdpbGwgZGVzdHJveSB0aGVcbiAgICAvLyB2aWV3cyB0aGF0IHRoZSByZWdpb25zIGFyZSBzaG93aW5nIGFuZCB0aGVuIHJlc2V0IHRoZSBgZWxgXG4gICAgLy8gZm9yIHRoZSByZWdpb25zIHRvIHRoZSBuZXdseSByZW5kZXJlZCBET00gZWxlbWVudHMuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2Vuc3VyZVZpZXdJc0ludGFjdCgpO1xuICBcbiAgICAgIGlmICh0aGlzLl9maXJzdFJlbmRlcikge1xuICAgICAgICAvLyBpZiB0aGlzIGlzIHRoZSBmaXJzdCByZW5kZXIsIGRvbid0IGRvIGFueXRoaW5nIHRvXG4gICAgICAgIC8vIHJlc2V0IHRoZSByZWdpb25zXG4gICAgICAgIHRoaXMuX2ZpcnN0UmVuZGVyID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCB0aGUgZmlyc3QgcmVuZGVyIGNhbGwsIHRoZW4gd2UgbmVlZCB0b1xuICAgICAgICAvLyByZS1pbml0aWFsaXplIHRoZSBgZWxgIGZvciBlYWNoIHJlZ2lvblxuICAgICAgICB0aGlzLl9yZUluaXRpYWxpemVSZWdpb25zKCk7XG4gICAgICB9XG4gIFxuICAgICAgcmV0dXJuIE1hcmlvbmV0dGUuSXRlbVZpZXcucHJvdG90eXBlLnJlbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gIFxuICAgIC8vIEhhbmRsZSBkZXN0cm95aW5nIHJlZ2lvbnMsIGFuZCB0aGVuIGRlc3Ryb3kgdGhlIHZpZXcgaXRzZWxmLlxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICAgIC8vICMyMTM0OiByZW1vdmUgcGFyZW50IGVsZW1lbnQgYmVmb3JlIGRlc3Ryb3lpbmcgdGhlIGNoaWxkIHZpZXdzLCBzb1xuICAgICAgLy8gcmVtb3ZpbmcgdGhlIGNoaWxkIHZpZXdzIGRvZXNuJ3QgcmV0cmlnZ2VyIHJlcGFpbnRzXG4gICAgICBpZiAodGhpcy5nZXRPcHRpb24oJ2Rlc3Ryb3lJbW1lZGlhdGUnKSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLiRlbC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVnaW9uTWFuYWdlci5kZXN0cm95KCk7XG4gICAgICByZXR1cm4gTWFyaW9uZXR0ZS5JdGVtVmlldy5wcm90b3R5cGUuZGVzdHJveS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gIFxuICAgIHNob3dDaGlsZFZpZXc6IGZ1bmN0aW9uKHJlZ2lvbk5hbWUsIHZpZXcpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJlZ2lvbihyZWdpb25OYW1lKS5zaG93KHZpZXcpO1xuICAgIH0sXG4gIFxuICAgIGdldENoaWxkVmlldzogZnVuY3Rpb24ocmVnaW9uTmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVnaW9uKHJlZ2lvbk5hbWUpLmN1cnJlbnRWaWV3O1xuICAgIH0sXG4gIFxuICAgIC8vIEFkZCBhIHNpbmdsZSByZWdpb24sIGJ5IG5hbWUsIHRvIHRoZSBsYXlvdXRWaWV3XG4gICAgYWRkUmVnaW9uOiBmdW5jdGlvbihuYW1lLCBkZWZpbml0aW9uKSB7XG4gICAgICB2YXIgcmVnaW9ucyA9IHt9O1xuICAgICAgcmVnaW9uc1tuYW1lXSA9IGRlZmluaXRpb247XG4gICAgICByZXR1cm4gdGhpcy5fYnVpbGRSZWdpb25zKHJlZ2lvbnMpW25hbWVdO1xuICAgIH0sXG4gIFxuICAgIC8vIEFkZCBtdWx0aXBsZSByZWdpb25zIGFzIGEge25hbWU6IGRlZmluaXRpb24sIG5hbWUyOiBkZWYyfSBvYmplY3QgbGl0ZXJhbFxuICAgIGFkZFJlZ2lvbnM6IGZ1bmN0aW9uKHJlZ2lvbnMpIHtcbiAgICAgIHRoaXMucmVnaW9ucyA9IF8uZXh0ZW5kKHt9LCB0aGlzLnJlZ2lvbnMsIHJlZ2lvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkUmVnaW9ucyhyZWdpb25zKTtcbiAgICB9LFxuICBcbiAgICAvLyBSZW1vdmUgYSBzaW5nbGUgcmVnaW9uIGZyb20gdGhlIExheW91dFZpZXcsIGJ5IG5hbWVcbiAgICByZW1vdmVSZWdpb246IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnJlZ2lvbnNbbmFtZV07XG4gICAgICByZXR1cm4gdGhpcy5yZWdpb25NYW5hZ2VyLnJlbW92ZVJlZ2lvbihuYW1lKTtcbiAgICB9LFxuICBcbiAgICAvLyBQcm92aWRlcyBhbHRlcm5hdGl2ZSBhY2Nlc3MgdG8gcmVnaW9uc1xuICAgIC8vIEFjY2VwdHMgdGhlIHJlZ2lvbiBuYW1lXG4gICAgLy8gZ2V0UmVnaW9uKCdtYWluJylcbiAgICBnZXRSZWdpb246IGZ1bmN0aW9uKHJlZ2lvbikge1xuICAgICAgcmV0dXJuIHRoaXMucmVnaW9uTWFuYWdlci5nZXQocmVnaW9uKTtcbiAgICB9LFxuICBcbiAgICAvLyBHZXQgYWxsIHJlZ2lvbnNcbiAgICBnZXRSZWdpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlZ2lvbk1hbmFnZXIuZ2V0UmVnaW9ucygpO1xuICAgIH0sXG4gIFxuICAgIC8vIGludGVybmFsIG1ldGhvZCB0byBidWlsZCByZWdpb25zXG4gICAgX2J1aWxkUmVnaW9uczogZnVuY3Rpb24ocmVnaW9ucykge1xuICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICByZWdpb25DbGFzczogdGhpcy5nZXRPcHRpb24oJ3JlZ2lvbkNsYXNzJyksXG4gICAgICAgIHBhcmVudEVsOiBfLnBhcnRpYWwoXy5yZXN1bHQsIHRoaXMsICdlbCcpXG4gICAgICB9O1xuICBcbiAgICAgIHJldHVybiB0aGlzLnJlZ2lvbk1hbmFnZXIuYWRkUmVnaW9ucyhyZWdpb25zLCBkZWZhdWx0cyk7XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIGluaXRpYWxpemUgdGhlIHJlZ2lvbnMgdGhhdCBoYXZlIGJlZW4gZGVmaW5lZCBpbiBhXG4gICAgLy8gYHJlZ2lvbnNgIGF0dHJpYnV0ZSBvbiB0aGlzIGxheW91dFZpZXcuXG4gICAgX2luaXRpYWxpemVSZWdpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgcmVnaW9ucztcbiAgICAgIHRoaXMuX2luaXRSZWdpb25NYW5hZ2VyKCk7XG4gIFxuICAgICAgcmVnaW9ucyA9IE1hcmlvbmV0dGUuX2dldFZhbHVlKHRoaXMucmVnaW9ucywgdGhpcywgW29wdGlvbnNdKSB8fCB7fTtcbiAgXG4gICAgICAvLyBFbmFibGUgdXNlcnMgdG8gZGVmaW5lIGByZWdpb25zYCBhcyBpbnN0YW5jZSBvcHRpb25zLlxuICAgICAgdmFyIHJlZ2lvbk9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbi5jYWxsKG9wdGlvbnMsICdyZWdpb25zJyk7XG4gIFxuICAgICAgLy8gZW5hYmxlIHJlZ2lvbiBvcHRpb25zIHRvIGJlIGEgZnVuY3Rpb25cbiAgICAgIHJlZ2lvbk9wdGlvbnMgPSBNYXJpb25ldHRlLl9nZXRWYWx1ZShyZWdpb25PcHRpb25zLCB0aGlzLCBbb3B0aW9uc10pO1xuICBcbiAgICAgIF8uZXh0ZW5kKHJlZ2lvbnMsIHJlZ2lvbk9wdGlvbnMpO1xuICBcbiAgICAgIC8vIE5vcm1hbGl6ZSByZWdpb24gc2VsZWN0b3JzIGhhc2ggdG8gYWxsb3dcbiAgICAgIC8vIGEgdXNlciB0byB1c2UgdGhlIEB1aS4gc3ludGF4LlxuICAgICAgcmVnaW9ucyA9IHRoaXMubm9ybWFsaXplVUlWYWx1ZXMocmVnaW9ucywgWydzZWxlY3RvcicsICdlbCddKTtcbiAgXG4gICAgICB0aGlzLmFkZFJlZ2lvbnMocmVnaW9ucyk7XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIHJlLWluaXRpYWxpemUgYWxsIG9mIHRoZSByZWdpb25zIGJ5IHVwZGF0aW5nIHRoZSBgZWxgIHRoYXRcbiAgICAvLyB0aGV5IHBvaW50IHRvXG4gICAgX3JlSW5pdGlhbGl6ZVJlZ2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5yZWdpb25NYW5hZ2VyLmludm9rZSgncmVzZXQnKTtcbiAgICB9LFxuICBcbiAgICAvLyBFbmFibGUgZWFzeSBvdmVycmlkaW5nIG9mIHRoZSBkZWZhdWx0IGBSZWdpb25NYW5hZ2VyYFxuICAgIC8vIGZvciBjdXN0b21pemVkIHJlZ2lvbiBpbnRlcmFjdGlvbnMgYW5kIGJ1c2luZXNzIHNwZWNpZmljXG4gICAgLy8gdmlldyBsb2dpYyBmb3IgYmV0dGVyIGNvbnRyb2wgb3ZlciBzaW5nbGUgcmVnaW9ucy5cbiAgICBnZXRSZWdpb25NYW5hZ2VyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgTWFyaW9uZXR0ZS5SZWdpb25NYW5hZ2VyKCk7XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIGluaXRpYWxpemUgdGhlIHJlZ2lvbiBtYW5hZ2VyXG4gICAgLy8gYW5kIGFsbCByZWdpb25zIGluIGl0XG4gICAgX2luaXRSZWdpb25NYW5hZ2VyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucmVnaW9uTWFuYWdlciA9IHRoaXMuZ2V0UmVnaW9uTWFuYWdlcigpO1xuICAgICAgdGhpcy5yZWdpb25NYW5hZ2VyLl9wYXJlbnQgPSB0aGlzO1xuICBcbiAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5yZWdpb25NYW5hZ2VyLCAnYmVmb3JlOmFkZDpyZWdpb24nLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlck1ldGhvZCgnYmVmb3JlOmFkZDpyZWdpb24nLCBuYW1lKTtcbiAgICAgIH0pO1xuICBcbiAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5yZWdpb25NYW5hZ2VyLCAnYWRkOnJlZ2lvbicsIGZ1bmN0aW9uKG5hbWUsIHJlZ2lvbikge1xuICAgICAgICB0aGlzW25hbWVdID0gcmVnaW9uO1xuICAgICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2FkZDpyZWdpb24nLCBuYW1lLCByZWdpb24pO1xuICAgICAgfSk7XG4gIFxuICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLnJlZ2lvbk1hbmFnZXIsICdiZWZvcmU6cmVtb3ZlOnJlZ2lvbicsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6cmVtb3ZlOnJlZ2lvbicsIG5hbWUpO1xuICAgICAgfSk7XG4gIFxuICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLnJlZ2lvbk1hbmFnZXIsICdyZW1vdmU6cmVnaW9uJywgZnVuY3Rpb24obmFtZSwgcmVnaW9uKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzW25hbWVdO1xuICAgICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ3JlbW92ZTpyZWdpb24nLCBuYW1lLCByZWdpb24pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgXG4gICAgX2dldEltbWVkaWF0ZUNoaWxkcmVuOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfLmNoYWluKHRoaXMucmVnaW9uTWFuYWdlci5nZXRSZWdpb25zKCkpXG4gICAgICAgIC5wbHVjaygnY3VycmVudFZpZXcnKVxuICAgICAgICAuY29tcGFjdCgpXG4gICAgICAgIC52YWx1ZSgpO1xuICAgIH1cbiAgfSk7XG4gIFxuXG4gIC8vIEJlaGF2aW9yXG4gIC8vIC0tLS0tLS0tXG4gIFxuICAvLyBBIEJlaGF2aW9yIGlzIGFuIGlzb2xhdGVkIHNldCBvZiBET00gL1xuICAvLyB1c2VyIGludGVyYWN0aW9ucyB0aGF0IGNhbiBiZSBtaXhlZCBpbnRvIGFueSBWaWV3LlxuICAvLyBCZWhhdmlvcnMgYWxsb3cgeW91IHRvIGJsYWNrYm94IFZpZXcgc3BlY2lmaWMgaW50ZXJhY3Rpb25zXG4gIC8vIGludG8gcG9ydGFibGUgbG9naWNhbCBjaHVua3MsIGtlZXBpbmcgeW91ciB2aWV3cyBzaW1wbGUgYW5kIHlvdXIgY29kZSBEUlkuXG4gIFxuICBNYXJpb25ldHRlLkJlaGF2aW9yID0gTWFyaW9uZXR0ZS5PYmplY3QuZXh0ZW5kKHtcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24ob3B0aW9ucywgdmlldykge1xuICAgICAgLy8gU2V0dXAgcmVmZXJlbmNlIHRvIHRoZSB2aWV3LlxuICAgICAgLy8gdGhpcyBjb21lcyBpbiBoYW5kbGUgd2hlbiBhIGJlaGF2aW9yXG4gICAgICAvLyB3YW50cyB0byBkaXJlY3RseSB0YWxrIHVwIHRoZSBjaGFpblxuICAgICAgLy8gdG8gdGhlIHZpZXcuXG4gICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgdGhpcy5kZWZhdWx0cyA9IF8ucmVzdWx0KHRoaXMsICdkZWZhdWx0cycpIHx8IHt9O1xuICAgICAgdGhpcy5vcHRpb25zICA9IF8uZXh0ZW5kKHt9LCB0aGlzLmRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgIC8vIENvbnN0cnVjdCBhbiBpbnRlcm5hbCBVSSBoYXNoIHVzaW5nXG4gICAgICAvLyB0aGUgdmlld3MgVUkgaGFzaCBhbmQgdGhlbiB0aGUgYmVoYXZpb3JzIFVJIGhhc2guXG4gICAgICAvLyBUaGlzIGFsbG93cyB0aGUgdXNlciB0byB1c2UgVUkgaGFzaCBlbGVtZW50c1xuICAgICAgLy8gZGVmaW5lZCBpbiB0aGUgcGFyZW50IHZpZXcgYXMgd2VsbCBhcyB0aG9zZVxuICAgICAgLy8gZGVmaW5lZCBpbiB0aGUgZ2l2ZW4gYmVoYXZpb3IuXG4gICAgICB0aGlzLnVpID0gXy5leHRlbmQoe30sIF8ucmVzdWx0KHZpZXcsICd1aScpLCBfLnJlc3VsdCh0aGlzLCAndWknKSk7XG4gIFxuICAgICAgTWFyaW9uZXR0ZS5PYmplY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuICBcbiAgICAvLyBwcm94eSBiZWhhdmlvciAkIG1ldGhvZCB0byB0aGUgdmlld1xuICAgIC8vIHRoaXMgaXMgdXNlZnVsIGZvciBkb2luZyBqcXVlcnkgRE9NIGxvb2t1cHNcbiAgICAvLyBzY29wZWQgdG8gYmVoYXZpb3JzIHZpZXcuXG4gICAgJDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy52aWV3LiQuYXBwbHkodGhpcy52aWV3LCBhcmd1bWVudHMpO1xuICAgIH0sXG4gIFxuICAgIC8vIFN0b3BzIHRoZSBiZWhhdmlvciBmcm9tIGxpc3RlbmluZyB0byBldmVudHMuXG4gICAgLy8gT3ZlcnJpZGVzIE9iamVjdCNkZXN0cm95IHRvIHByZXZlbnQgYWRkaXRpb25hbCBldmVudHMgZnJvbSBiZWluZyB0cmlnZ2VyZWQuXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoKTtcbiAgXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICBcbiAgICBwcm94eVZpZXdQcm9wZXJ0aWVzOiBmdW5jdGlvbih2aWV3KSB7XG4gICAgICB0aGlzLiRlbCA9IHZpZXcuJGVsO1xuICAgICAgdGhpcy5lbCA9IHZpZXcuZWw7XG4gICAgfVxuICB9KTtcbiAgXG4gIC8qIGpzaGludCBtYXhsZW46IDE0MyAqL1xuICAvLyBCZWhhdmlvcnNcbiAgLy8gLS0tLS0tLS0tXG4gIFxuICAvLyBCZWhhdmlvcnMgaXMgYSB1dGlsaXR5IGNsYXNzIHRoYXQgdGFrZXMgY2FyZSBvZlxuICAvLyBnbHVpbmcgeW91ciBiZWhhdmlvciBpbnN0YW5jZXMgdG8gdGhlaXIgZ2l2ZW4gVmlldy5cbiAgLy8gVGhlIG1vc3QgaW1wb3J0YW50IHBhcnQgb2YgdGhpcyBjbGFzcyBpcyB0aGF0IHlvdVxuICAvLyAqKk1VU1QqKiBvdmVycmlkZSB0aGUgY2xhc3MgbGV2ZWwgYmVoYXZpb3JzTG9va3VwXG4gIC8vIG1ldGhvZCBmb3IgdGhpbmdzIHRvIHdvcmsgcHJvcGVybHkuXG4gIFxuICBNYXJpb25ldHRlLkJlaGF2aW9ycyA9IChmdW5jdGlvbihNYXJpb25ldHRlLCBfKSB7XG4gICAgLy8gQm9ycm93IGV2ZW50IHNwbGl0dGVyIGZyb20gQmFja2JvbmVcbiAgICB2YXIgZGVsZWdhdGVFdmVudFNwbGl0dGVyID0gL14oXFxTKylcXHMqKC4qKSQvO1xuICBcbiAgICBmdW5jdGlvbiBCZWhhdmlvcnModmlldywgYmVoYXZpb3JzKSB7XG4gIFxuICAgICAgaWYgKCFfLmlzT2JqZWN0KHZpZXcuYmVoYXZpb3JzKSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gIFxuICAgICAgLy8gQmVoYXZpb3JzIGRlZmluZWQgb24gYSB2aWV3IGNhbiBiZSBhIGZsYXQgb2JqZWN0IGxpdGVyYWxcbiAgICAgIC8vIG9yIGl0IGNhbiBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYmplY3QuXG4gICAgICBiZWhhdmlvcnMgPSBCZWhhdmlvcnMucGFyc2VCZWhhdmlvcnModmlldywgYmVoYXZpb3JzIHx8IF8ucmVzdWx0KHZpZXcsICdiZWhhdmlvcnMnKSk7XG4gIFxuICAgICAgLy8gV3JhcHMgc2V2ZXJhbCBvZiB0aGUgdmlldydzIG1ldGhvZHNcbiAgICAgIC8vIGNhbGxpbmcgdGhlIG1ldGhvZHMgZmlyc3Qgb24gZWFjaCBiZWhhdmlvclxuICAgICAgLy8gYW5kIHRoZW4gZXZlbnR1YWxseSBjYWxsaW5nIHRoZSBtZXRob2Qgb24gdGhlIHZpZXcuXG4gICAgICBCZWhhdmlvcnMud3JhcCh2aWV3LCBiZWhhdmlvcnMsIF8ua2V5cyhtZXRob2RzKSk7XG4gICAgICByZXR1cm4gYmVoYXZpb3JzO1xuICAgIH1cbiAgXG4gICAgdmFyIG1ldGhvZHMgPSB7XG4gICAgICBiZWhhdmlvclRyaWdnZXJzOiBmdW5jdGlvbihiZWhhdmlvclRyaWdnZXJzLCBiZWhhdmlvcnMpIHtcbiAgICAgICAgdmFyIHRyaWdnZXJCdWlsZGVyID0gbmV3IEJlaGF2aW9yVHJpZ2dlcnNCdWlsZGVyKHRoaXMsIGJlaGF2aW9ycyk7XG4gICAgICAgIHJldHVybiB0cmlnZ2VyQnVpbGRlci5idWlsZEJlaGF2aW9yVHJpZ2dlcnMoKTtcbiAgICAgIH0sXG4gIFxuICAgICAgYmVoYXZpb3JFdmVudHM6IGZ1bmN0aW9uKGJlaGF2aW9yRXZlbnRzLCBiZWhhdmlvcnMpIHtcbiAgICAgICAgdmFyIF9iZWhhdmlvcnNFdmVudHMgPSB7fTtcbiAgXG4gICAgICAgIF8uZWFjaChiZWhhdmlvcnMsIGZ1bmN0aW9uKGIsIGkpIHtcbiAgICAgICAgICB2YXIgX2V2ZW50cyA9IHt9O1xuICAgICAgICAgIHZhciBiZWhhdmlvckV2ZW50cyA9IF8uY2xvbmUoXy5yZXN1bHQoYiwgJ2V2ZW50cycpKSB8fCB7fTtcbiAgXG4gICAgICAgICAgLy8gTm9ybWFsaXplIGJlaGF2aW9yIGV2ZW50cyBoYXNoIHRvIGFsbG93XG4gICAgICAgICAgLy8gYSB1c2VyIHRvIHVzZSB0aGUgQHVpLiBzeW50YXguXG4gICAgICAgICAgYmVoYXZpb3JFdmVudHMgPSBNYXJpb25ldHRlLm5vcm1hbGl6ZVVJS2V5cyhiZWhhdmlvckV2ZW50cywgZ2V0QmVoYXZpb3JzVUkoYikpO1xuICBcbiAgICAgICAgICB2YXIgaiA9IDA7XG4gICAgICAgICAgXy5lYWNoKGJlaGF2aW9yRXZlbnRzLCBmdW5jdGlvbihiZWhhdmlvdXIsIGtleSkge1xuICAgICAgICAgICAgdmFyIG1hdGNoICAgICA9IGtleS5tYXRjaChkZWxlZ2F0ZUV2ZW50U3BsaXR0ZXIpO1xuICBcbiAgICAgICAgICAgIC8vIFNldCBldmVudCBuYW1lIHRvIGJlIG5hbWVzcGFjZWQgdXNpbmcgdGhlIHZpZXcgY2lkLFxuICAgICAgICAgICAgLy8gdGhlIGJlaGF2aW9yIGluZGV4LCBhbmQgdGhlIGJlaGF2aW9yIGV2ZW50IGluZGV4XG4gICAgICAgICAgICAvLyB0byBnZW5lcmF0ZSBhIG5vbiBjb2xsaWRpbmcgZXZlbnQgbmFtZXNwYWNlXG4gICAgICAgICAgICAvLyBodHRwOi8vYXBpLmpxdWVyeS5jb20vZXZlbnQubmFtZXNwYWNlL1xuICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IG1hdGNoWzFdICsgJy4nICsgW3RoaXMuY2lkLCBpLCBqKyssICcgJ10uam9pbignJyk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0b3IgID0gbWF0Y2hbMl07XG4gIFxuICAgICAgICAgICAgdmFyIGV2ZW50S2V5ICA9IGV2ZW50TmFtZSArIHNlbGVjdG9yO1xuICAgICAgICAgICAgdmFyIGhhbmRsZXIgICA9IF8uaXNGdW5jdGlvbihiZWhhdmlvdXIpID8gYmVoYXZpb3VyIDogYltiZWhhdmlvdXJdO1xuICBcbiAgICAgICAgICAgIF9ldmVudHNbZXZlbnRLZXldID0gXy5iaW5kKGhhbmRsZXIsIGIpO1xuICAgICAgICAgIH0sIHRoaXMpO1xuICBcbiAgICAgICAgICBfYmVoYXZpb3JzRXZlbnRzID0gXy5leHRlbmQoX2JlaGF2aW9yc0V2ZW50cywgX2V2ZW50cyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICBcbiAgICAgICAgcmV0dXJuIF9iZWhhdmlvcnNFdmVudHM7XG4gICAgICB9XG4gICAgfTtcbiAgXG4gICAgXy5leHRlbmQoQmVoYXZpb3JzLCB7XG4gIFxuICAgICAgLy8gUGxhY2Vob2xkZXIgbWV0aG9kIHRvIGJlIGV4dGVuZGVkIGJ5IHRoZSB1c2VyLlxuICAgICAgLy8gVGhlIG1ldGhvZCBzaG91bGQgZGVmaW5lIHRoZSBvYmplY3QgdGhhdCBzdG9yZXMgdGhlIGJlaGF2aW9ycy5cbiAgICAgIC8vIGkuZS5cbiAgICAgIC8vXG4gICAgICAvLyBgYGBqc1xuICAgICAgLy8gTWFyaW9uZXR0ZS5CZWhhdmlvcnMuYmVoYXZpb3JzTG9va3VwOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vICAgcmV0dXJuIEFwcC5CZWhhdmlvcnNcbiAgICAgIC8vIH1cbiAgICAgIC8vIGBgYFxuICAgICAgYmVoYXZpb3JzTG9va3VwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1hcmlvbmV0dGUuRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6ICdZb3UgbXVzdCBkZWZpbmUgd2hlcmUgeW91ciBiZWhhdmlvcnMgYXJlIHN0b3JlZC4nLFxuICAgICAgICAgIHVybDogJ21hcmlvbmV0dGUuYmVoYXZpb3JzLmh0bWwjYmVoYXZpb3JzbG9va3VwJ1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gVGFrZXMgY2FyZSBvZiBnZXR0aW5nIHRoZSBiZWhhdmlvciBjbGFzc1xuICAgICAgLy8gZ2l2ZW4gb3B0aW9ucyBhbmQgYSBrZXkuXG4gICAgICAvLyBJZiBhIHVzZXIgcGFzc2VzIGluIG9wdGlvbnMuYmVoYXZpb3JDbGFzc1xuICAgICAgLy8gZGVmYXVsdCB0byB1c2luZyB0aGF0LiBPdGhlcndpc2UgZGVsZWdhdGVcbiAgICAgIC8vIHRoZSBsb29rdXAgdG8gdGhlIHVzZXJzIGBiZWhhdmlvcnNMb29rdXBgIGltcGxlbWVudGF0aW9uLlxuICAgICAgZ2V0QmVoYXZpb3JDbGFzczogZnVuY3Rpb24ob3B0aW9ucywga2V5KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmJlaGF2aW9yQ2xhc3MpIHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5iZWhhdmlvckNsYXNzO1xuICAgICAgICB9XG4gIFxuICAgICAgICAvLyBHZXQgYmVoYXZpb3IgY2xhc3MgY2FuIGJlIGVpdGhlciBhIGZsYXQgb2JqZWN0IG9yIGEgbWV0aG9kXG4gICAgICAgIHJldHVybiBNYXJpb25ldHRlLl9nZXRWYWx1ZShCZWhhdmlvcnMuYmVoYXZpb3JzTG9va3VwLCB0aGlzLCBbb3B0aW9ucywga2V5XSlba2V5XTtcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBiZWhhdmlvcnMgb2JqZWN0LCBmb3IgZWFjaCBiZWhhdmlvclxuICAgICAgLy8gaW5zdGFudGlhdGUgaXQgYW5kIGdldCBpdHMgZ3JvdXBlZCBiZWhhdmlvcnMuXG4gICAgICBwYXJzZUJlaGF2aW9yczogZnVuY3Rpb24odmlldywgYmVoYXZpb3JzKSB7XG4gICAgICAgIHJldHVybiBfLmNoYWluKGJlaGF2aW9ycykubWFwKGZ1bmN0aW9uKG9wdGlvbnMsIGtleSkge1xuICAgICAgICAgIHZhciBCZWhhdmlvckNsYXNzID0gQmVoYXZpb3JzLmdldEJlaGF2aW9yQ2xhc3Mob3B0aW9ucywga2V5KTtcbiAgXG4gICAgICAgICAgdmFyIGJlaGF2aW9yID0gbmV3IEJlaGF2aW9yQ2xhc3Mob3B0aW9ucywgdmlldyk7XG4gICAgICAgICAgdmFyIG5lc3RlZEJlaGF2aW9ycyA9IEJlaGF2aW9ycy5wYXJzZUJlaGF2aW9ycyh2aWV3LCBfLnJlc3VsdChiZWhhdmlvciwgJ2JlaGF2aW9ycycpKTtcbiAgXG4gICAgICAgICAgcmV0dXJuIFtiZWhhdmlvcl0uY29uY2F0KG5lc3RlZEJlaGF2aW9ycyk7XG4gICAgICAgIH0pLmZsYXR0ZW4oKS52YWx1ZSgpO1xuICAgICAgfSxcbiAgXG4gICAgICAvLyBXcmFwIHZpZXcgaW50ZXJuYWwgbWV0aG9kcyBzbyB0aGF0IHRoZXkgZGVsZWdhdGUgdG8gYmVoYXZpb3JzLiBGb3IgZXhhbXBsZSxcbiAgICAgIC8vIGBvbkRlc3Ryb3lgIHNob3VsZCB0cmlnZ2VyIGRlc3Ryb3kgb24gYWxsIG9mIHRoZSBiZWhhdmlvcnMgYW5kIHRoZW4gZGVzdHJveSBpdHNlbGYuXG4gICAgICAvLyBpLmUuXG4gICAgICAvL1xuICAgICAgLy8gYHZpZXcuZGVsZWdhdGVFdmVudHMgPSBfLnBhcnRpYWwobWV0aG9kcy5kZWxlZ2F0ZUV2ZW50cywgdmlldy5kZWxlZ2F0ZUV2ZW50cywgYmVoYXZpb3JzKTtgXG4gICAgICB3cmFwOiBmdW5jdGlvbih2aWV3LCBiZWhhdmlvcnMsIG1ldGhvZE5hbWVzKSB7XG4gICAgICAgIF8uZWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgICAgIHZpZXdbbWV0aG9kTmFtZV0gPSBfLnBhcnRpYWwobWV0aG9kc1ttZXRob2ROYW1lXSwgdmlld1ttZXRob2ROYW1lXSwgYmVoYXZpb3JzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIFxuICAgIC8vIENsYXNzIHRvIGJ1aWxkIGhhbmRsZXJzIGZvciBgdHJpZ2dlcnNgIG9uIGJlaGF2aW9yc1xuICAgIC8vIGZvciB2aWV3c1xuICAgIGZ1bmN0aW9uIEJlaGF2aW9yVHJpZ2dlcnNCdWlsZGVyKHZpZXcsIGJlaGF2aW9ycykge1xuICAgICAgdGhpcy5fdmlldyAgICAgID0gdmlldztcbiAgICAgIHRoaXMuX2JlaGF2aW9ycyA9IGJlaGF2aW9ycztcbiAgICAgIHRoaXMuX3RyaWdnZXJzICA9IHt9O1xuICAgIH1cbiAgXG4gICAgXy5leHRlbmQoQmVoYXZpb3JUcmlnZ2Vyc0J1aWxkZXIucHJvdG90eXBlLCB7XG4gICAgICAvLyBNYWluIG1ldGhvZCB0byBidWlsZCB0aGUgdHJpZ2dlcnMgaGFzaCB3aXRoIGV2ZW50IGtleXMgYW5kIGhhbmRsZXJzXG4gICAgICBidWlsZEJlaGF2aW9yVHJpZ2dlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBfLmVhY2godGhpcy5fYmVoYXZpb3JzLCB0aGlzLl9idWlsZFRyaWdnZXJIYW5kbGVyc0ZvckJlaGF2aW9yLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyaWdnZXJzO1xuICAgICAgfSxcbiAgXG4gICAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gYnVpbGQgYWxsIHRyaWdnZXIgaGFuZGxlcnMgZm9yIGEgZ2l2ZW4gYmVoYXZpb3JcbiAgICAgIF9idWlsZFRyaWdnZXJIYW5kbGVyc0ZvckJlaGF2aW9yOiBmdW5jdGlvbihiZWhhdmlvciwgaSkge1xuICAgICAgICB2YXIgdHJpZ2dlcnNIYXNoID0gXy5jbG9uZShfLnJlc3VsdChiZWhhdmlvciwgJ3RyaWdnZXJzJykpIHx8IHt9O1xuICBcbiAgICAgICAgdHJpZ2dlcnNIYXNoID0gTWFyaW9uZXR0ZS5ub3JtYWxpemVVSUtleXModHJpZ2dlcnNIYXNoLCBnZXRCZWhhdmlvcnNVSShiZWhhdmlvcikpO1xuICBcbiAgICAgICAgXy5lYWNoKHRyaWdnZXJzSGFzaCwgXy5iaW5kKHRoaXMuX3NldEhhbmRsZXJGb3JCZWhhdmlvciwgdGhpcywgYmVoYXZpb3IsIGkpKTtcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIGNyZWF0ZSBhbmQgYXNzaWduIHRoZSB0cmlnZ2VyIGhhbmRsZXIgZm9yIGEgZ2l2ZW5cbiAgICAgIC8vIGJlaGF2aW9yXG4gICAgICBfc2V0SGFuZGxlckZvckJlaGF2aW9yOiBmdW5jdGlvbihiZWhhdmlvciwgaSwgZXZlbnROYW1lLCB0cmlnZ2VyKSB7XG4gICAgICAgIC8vIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgYHRoaXMuX3RyaWdnZXJzYCBoYXNoXG4gICAgICAgIHZhciB0cmlnZ2VyS2V5ID0gdHJpZ2dlci5yZXBsYWNlKC9eXFxTKy8sIGZ1bmN0aW9uKHRyaWdnZXJOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRyaWdnZXJOYW1lICsgJy4nICsgJ2JlaGF2aW9ydHJpZ2dlcnMnICsgaTtcbiAgICAgICAgfSk7XG4gIFxuICAgICAgICB0aGlzLl90cmlnZ2Vyc1t0cmlnZ2VyS2V5XSA9IHRoaXMuX3ZpZXcuX2J1aWxkVmlld1RyaWdnZXIoZXZlbnROYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgXG4gICAgZnVuY3Rpb24gZ2V0QmVoYXZpb3JzVUkoYmVoYXZpb3IpIHtcbiAgICAgIHJldHVybiBiZWhhdmlvci5fdWlCaW5kaW5ncyB8fCBiZWhhdmlvci51aTtcbiAgICB9XG4gIFxuICAgIHJldHVybiBCZWhhdmlvcnM7XG4gIFxuICB9KShNYXJpb25ldHRlLCBfKTtcbiAgXG5cbiAgLy8gQXBwIFJvdXRlclxuICAvLyAtLS0tLS0tLS0tXG4gIFxuICAvLyBSZWR1Y2UgdGhlIGJvaWxlcnBsYXRlIGNvZGUgb2YgaGFuZGxpbmcgcm91dGUgZXZlbnRzXG4gIC8vIGFuZCB0aGVuIGNhbGxpbmcgYSBzaW5nbGUgbWV0aG9kIG9uIGFub3RoZXIgb2JqZWN0LlxuICAvLyBIYXZlIHlvdXIgcm91dGVycyBjb25maWd1cmVkIHRvIGNhbGwgdGhlIG1ldGhvZCBvblxuICAvLyB5b3VyIG9iamVjdCwgZGlyZWN0bHkuXG4gIC8vXG4gIC8vIENvbmZpZ3VyZSBhbiBBcHBSb3V0ZXIgd2l0aCBgYXBwUm91dGVzYC5cbiAgLy9cbiAgLy8gQXBwIHJvdXRlcnMgY2FuIG9ubHkgdGFrZSBvbmUgYGNvbnRyb2xsZXJgIG9iamVjdC5cbiAgLy8gSXQgaXMgcmVjb21tZW5kZWQgdGhhdCB5b3UgZGl2aWRlIHlvdXIgY29udHJvbGxlclxuICAvLyBvYmplY3RzIGluIHRvIHNtYWxsZXIgcGllY2VzIG9mIHJlbGF0ZWQgZnVuY3Rpb25hbGl0eVxuICAvLyBhbmQgaGF2ZSBtdWx0aXBsZSByb3V0ZXJzIC8gY29udHJvbGxlcnMsIGluc3RlYWQgb2ZcbiAgLy8ganVzdCBvbmUgZ2lhbnQgcm91dGVyIGFuZCBjb250cm9sbGVyLlxuICAvL1xuICAvLyBZb3UgY2FuIGFsc28gYWRkIHN0YW5kYXJkIHJvdXRlcyB0byBhbiBBcHBSb3V0ZXIuXG4gIFxuICBNYXJpb25ldHRlLkFwcFJvdXRlciA9IEJhY2tib25lLlJvdXRlci5leHRlbmQoe1xuICBcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgXG4gICAgICBCYWNrYm9uZS5Sb3V0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgXG4gICAgICB2YXIgYXBwUm91dGVzID0gdGhpcy5nZXRPcHRpb24oJ2FwcFJvdXRlcycpO1xuICAgICAgdmFyIGNvbnRyb2xsZXIgPSB0aGlzLl9nZXRDb250cm9sbGVyKCk7XG4gICAgICB0aGlzLnByb2Nlc3NBcHBSb3V0ZXMoY29udHJvbGxlciwgYXBwUm91dGVzKTtcbiAgICAgIHRoaXMub24oJ3JvdXRlJywgdGhpcy5fcHJvY2Vzc09uUm91dGUsIHRoaXMpO1xuICAgIH0sXG4gIFxuICAgIC8vIFNpbWlsYXIgdG8gcm91dGUgbWV0aG9kIG9uIGEgQmFja2JvbmUgUm91dGVyIGJ1dFxuICAgIC8vIG1ldGhvZCBpcyBjYWxsZWQgb24gdGhlIGNvbnRyb2xsZXJcbiAgICBhcHBSb3V0ZTogZnVuY3Rpb24ocm91dGUsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBjb250cm9sbGVyID0gdGhpcy5fZ2V0Q29udHJvbGxlcigpO1xuICAgICAgdGhpcy5fYWRkQXBwUm91dGUoY29udHJvbGxlciwgcm91dGUsIG1ldGhvZE5hbWUpO1xuICAgIH0sXG4gIFxuICAgIC8vIHByb2Nlc3MgdGhlIHJvdXRlIGV2ZW50IGFuZCB0cmlnZ2VyIHRoZSBvblJvdXRlXG4gICAgLy8gbWV0aG9kIGNhbGwsIGlmIGl0IGV4aXN0c1xuICAgIF9wcm9jZXNzT25Sb3V0ZTogZnVuY3Rpb24ocm91dGVOYW1lLCByb3V0ZUFyZ3MpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSBhbiBvblJvdXRlIGJlZm9yZSB0cnlpbmcgdG8gY2FsbCBpdFxuICAgICAgaWYgKF8uaXNGdW5jdGlvbih0aGlzLm9uUm91dGUpKSB7XG4gICAgICAgIC8vIGZpbmQgdGhlIHBhdGggdGhhdCBtYXRjaGVzIHRoZSBjdXJyZW50IHJvdXRlXG4gICAgICAgIHZhciByb3V0ZVBhdGggPSBfLmludmVydCh0aGlzLmdldE9wdGlvbignYXBwUm91dGVzJykpW3JvdXRlTmFtZV07XG4gICAgICAgIHRoaXMub25Sb3V0ZShyb3V0ZU5hbWUsIHJvdXRlUGF0aCwgcm91dGVBcmdzKTtcbiAgICAgIH1cbiAgICB9LFxuICBcbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gcHJvY2VzcyB0aGUgYGFwcFJvdXRlc2AgZm9yIHRoZVxuICAgIC8vIHJvdXRlciwgYW5kIHR1cm4gdGhlbSBpbiB0byByb3V0ZXMgdGhhdCB0cmlnZ2VyIHRoZVxuICAgIC8vIHNwZWNpZmllZCBtZXRob2Qgb24gdGhlIHNwZWNpZmllZCBgY29udHJvbGxlcmAuXG4gICAgcHJvY2Vzc0FwcFJvdXRlczogZnVuY3Rpb24oY29udHJvbGxlciwgYXBwUm91dGVzKSB7XG4gICAgICBpZiAoIWFwcFJvdXRlcykgeyByZXR1cm47IH1cbiAgXG4gICAgICB2YXIgcm91dGVOYW1lcyA9IF8ua2V5cyhhcHBSb3V0ZXMpLnJldmVyc2UoKTsgLy8gQmFja2JvbmUgcmVxdWlyZXMgcmV2ZXJ0ZWQgb3JkZXIgb2Ygcm91dGVzXG4gIFxuICAgICAgXy5lYWNoKHJvdXRlTmFtZXMsIGZ1bmN0aW9uKHJvdXRlKSB7XG4gICAgICAgIHRoaXMuX2FkZEFwcFJvdXRlKGNvbnRyb2xsZXIsIHJvdXRlLCBhcHBSb3V0ZXNbcm91dGVdKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG4gIFxuICAgIF9nZXRDb250cm9sbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE9wdGlvbignY29udHJvbGxlcicpO1xuICAgIH0sXG4gIFxuICAgIF9hZGRBcHBSb3V0ZTogZnVuY3Rpb24oY29udHJvbGxlciwgcm91dGUsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBtZXRob2QgPSBjb250cm9sbGVyW21ldGhvZE5hbWVdO1xuICBcbiAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgIHRocm93IG5ldyBNYXJpb25ldHRlLkVycm9yKCdNZXRob2QgXCInICsgbWV0aG9kTmFtZSArICdcIiB3YXMgbm90IGZvdW5kIG9uIHRoZSBjb250cm9sbGVyJyk7XG4gICAgICB9XG4gIFxuICAgICAgdGhpcy5yb3V0ZShyb3V0ZSwgbWV0aG9kTmFtZSwgXy5iaW5kKG1ldGhvZCwgY29udHJvbGxlcikpO1xuICAgIH0sXG4gIFxuICAgIG1lcmdlT3B0aW9uczogTWFyaW9uZXR0ZS5tZXJnZU9wdGlvbnMsXG4gIFxuICAgIC8vIFByb3h5IGBnZXRPcHRpb25gIHRvIGVuYWJsZSBnZXR0aW5nIG9wdGlvbnMgZnJvbSB0aGlzIG9yIHRoaXMub3B0aW9ucyBieSBuYW1lLlxuICAgIGdldE9wdGlvbjogTWFyaW9uZXR0ZS5wcm94eUdldE9wdGlvbixcbiAgXG4gICAgdHJpZ2dlck1ldGhvZDogTWFyaW9uZXR0ZS50cmlnZ2VyTWV0aG9kLFxuICBcbiAgICBiaW5kRW50aXR5RXZlbnRzOiBNYXJpb25ldHRlLnByb3h5QmluZEVudGl0eUV2ZW50cyxcbiAgXG4gICAgdW5iaW5kRW50aXR5RXZlbnRzOiBNYXJpb25ldHRlLnByb3h5VW5iaW5kRW50aXR5RXZlbnRzXG4gIH0pO1xuICBcbiAgLy8gQXBwbGljYXRpb25cbiAgLy8gLS0tLS0tLS0tLS1cbiAgXG4gIC8vIENvbnRhaW4gYW5kIG1hbmFnZSB0aGUgY29tcG9zaXRlIGFwcGxpY2F0aW9uIGFzIGEgd2hvbGUuXG4gIC8vIFN0b3JlcyBhbmQgc3RhcnRzIHVwIGBSZWdpb25gIG9iamVjdHMsIGluY2x1ZGVzIGFuXG4gIC8vIGV2ZW50IGFnZ3JlZ2F0b3IgYXMgYGFwcC52ZW50YFxuICBNYXJpb25ldHRlLkFwcGxpY2F0aW9uID0gTWFyaW9uZXR0ZS5PYmplY3QuZXh0ZW5kKHtcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdGlhbGl6ZVJlZ2lvbnMob3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0Q2FsbGJhY2tzID0gbmV3IE1hcmlvbmV0dGUuQ2FsbGJhY2tzKCk7XG4gICAgICB0aGlzLnN1Ym1vZHVsZXMgPSB7fTtcbiAgICAgIF8uZXh0ZW5kKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5faW5pdENoYW5uZWwoKTtcbiAgICAgIE1hcmlvbmV0dGUuT2JqZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfSxcbiAgXG4gICAgLy8gQ29tbWFuZCBleGVjdXRpb24sIGZhY2lsaXRhdGVkIGJ5IEJhY2tib25lLldyZXFyLkNvbW1hbmRzXG4gICAgZXhlY3V0ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNvbW1hbmRzLmV4ZWN1dGUuYXBwbHkodGhpcy5jb21tYW5kcywgYXJndW1lbnRzKTtcbiAgICB9LFxuICBcbiAgICAvLyBSZXF1ZXN0L3Jlc3BvbnNlLCBmYWNpbGl0YXRlZCBieSBCYWNrYm9uZS5XcmVxci5SZXF1ZXN0UmVzcG9uc2VcbiAgICByZXF1ZXN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXJlcy5yZXF1ZXN0LmFwcGx5KHRoaXMucmVxcmVzLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gIFxuICAgIC8vIEFkZCBhbiBpbml0aWFsaXplciB0aGF0IGlzIGVpdGhlciBydW4gYXQgd2hlbiB0aGUgYHN0YXJ0YFxuICAgIC8vIG1ldGhvZCBpcyBjYWxsZWQsIG9yIHJ1biBpbW1lZGlhdGVseSBpZiBhZGRlZCBhZnRlciBgc3RhcnRgXG4gICAgLy8gaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQuXG4gICAgYWRkSW5pdGlhbGl6ZXI6IGZ1bmN0aW9uKGluaXRpYWxpemVyKSB7XG4gICAgICB0aGlzLl9pbml0Q2FsbGJhY2tzLmFkZChpbml0aWFsaXplcik7XG4gICAgfSxcbiAgXG4gICAgLy8ga2ljayBvZmYgYWxsIG9mIHRoZSBhcHBsaWNhdGlvbidzIHByb2Nlc3Nlcy5cbiAgICAvLyBpbml0aWFsaXplcyBhbGwgb2YgdGhlIHJlZ2lvbnMgdGhhdCBoYXZlIGJlZW4gYWRkZWRcbiAgICAvLyB0byB0aGUgYXBwLCBhbmQgcnVucyBhbGwgb2YgdGhlIGluaXRpYWxpemVyIGZ1bmN0aW9uc1xuICAgIHN0YXJ0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2JlZm9yZTpzdGFydCcsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5faW5pdENhbGxiYWNrcy5ydW4ob3B0aW9ucywgdGhpcyk7XG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ3N0YXJ0Jywgb3B0aW9ucyk7XG4gICAgfSxcbiAgXG4gICAgLy8gQWRkIHJlZ2lvbnMgdG8geW91ciBhcHAuXG4gICAgLy8gQWNjZXB0cyBhIGhhc2ggb2YgbmFtZWQgc3RyaW5ncyBvciBSZWdpb24gb2JqZWN0c1xuICAgIC8vIGFkZFJlZ2lvbnMoe3NvbWV0aGluZzogXCIjc29tZVJlZ2lvblwifSlcbiAgICAvLyBhZGRSZWdpb25zKHtzb21ldGhpbmc6IFJlZ2lvbi5leHRlbmQoe2VsOiBcIiNzb21lUmVnaW9uXCJ9KSB9KTtcbiAgICBhZGRSZWdpb25zOiBmdW5jdGlvbihyZWdpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVnaW9uTWFuYWdlci5hZGRSZWdpb25zKHJlZ2lvbnMpO1xuICAgIH0sXG4gIFxuICAgIC8vIEVtcHR5IGFsbCByZWdpb25zIGluIHRoZSBhcHAsIHdpdGhvdXQgcmVtb3ZpbmcgdGhlbVxuICAgIGVtcHR5UmVnaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVnaW9uTWFuYWdlci5lbXB0eVJlZ2lvbnMoKTtcbiAgICB9LFxuICBcbiAgICAvLyBSZW1vdmVzIGEgcmVnaW9uIGZyb20geW91ciBhcHAsIGJ5IG5hbWVcbiAgICAvLyBBY2NlcHRzIHRoZSByZWdpb25zIG5hbWVcbiAgICAvLyByZW1vdmVSZWdpb24oJ215UmVnaW9uJylcbiAgICByZW1vdmVSZWdpb246IGZ1bmN0aW9uKHJlZ2lvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lvbk1hbmFnZXIucmVtb3ZlUmVnaW9uKHJlZ2lvbik7XG4gICAgfSxcbiAgXG4gICAgLy8gUHJvdmlkZXMgYWx0ZXJuYXRpdmUgYWNjZXNzIHRvIHJlZ2lvbnNcbiAgICAvLyBBY2NlcHRzIHRoZSByZWdpb24gbmFtZVxuICAgIC8vIGdldFJlZ2lvbignbWFpbicpXG4gICAgZ2V0UmVnaW9uOiBmdW5jdGlvbihyZWdpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWdpb25NYW5hZ2VyLmdldChyZWdpb24pO1xuICAgIH0sXG4gIFxuICAgIC8vIEdldCBhbGwgdGhlIHJlZ2lvbnMgZnJvbSB0aGUgcmVnaW9uIG1hbmFnZXJcbiAgICBnZXRSZWdpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWdpb25NYW5hZ2VyLmdldFJlZ2lvbnMoKTtcbiAgICB9LFxuICBcbiAgICAvLyBDcmVhdGUgYSBtb2R1bGUsIGF0dGFjaGVkIHRvIHRoZSBhcHBsaWNhdGlvblxuICAgIG1vZHVsZTogZnVuY3Rpb24obW9kdWxlTmFtZXMsIG1vZHVsZURlZmluaXRpb24pIHtcbiAgXG4gICAgICAvLyBPdmVyd3JpdGUgdGhlIG1vZHVsZSBjbGFzcyBpZiB0aGUgdXNlciBzcGVjaWZpZXMgb25lXG4gICAgICB2YXIgTW9kdWxlQ2xhc3MgPSBNYXJpb25ldHRlLk1vZHVsZS5nZXRDbGFzcyhtb2R1bGVEZWZpbml0aW9uKTtcbiAgXG4gICAgICB2YXIgYXJncyA9IF8udG9BcnJheShhcmd1bWVudHMpO1xuICAgICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICBcbiAgICAgIC8vIHNlZSB0aGUgTWFyaW9uZXR0ZS5Nb2R1bGUgb2JqZWN0IGZvciBtb3JlIGluZm9ybWF0aW9uXG4gICAgICByZXR1cm4gTW9kdWxlQ2xhc3MuY3JlYXRlLmFwcGx5KE1vZHVsZUNsYXNzLCBhcmdzKTtcbiAgICB9LFxuICBcbiAgICAvLyBFbmFibGUgZWFzeSBvdmVycmlkaW5nIG9mIHRoZSBkZWZhdWx0IGBSZWdpb25NYW5hZ2VyYFxuICAgIC8vIGZvciBjdXN0b21pemVkIHJlZ2lvbiBpbnRlcmFjdGlvbnMgYW5kIGJ1c2luZXNzLXNwZWNpZmljXG4gICAgLy8gdmlldyBsb2dpYyBmb3IgYmV0dGVyIGNvbnRyb2wgb3ZlciBzaW5nbGUgcmVnaW9ucy5cbiAgICBnZXRSZWdpb25NYW5hZ2VyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgTWFyaW9uZXR0ZS5SZWdpb25NYW5hZ2VyKCk7XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIGluaXRpYWxpemUgdGhlIHJlZ2lvbnMgdGhhdCBoYXZlIGJlZW4gZGVmaW5lZCBpbiBhXG4gICAgLy8gYHJlZ2lvbnNgIGF0dHJpYnV0ZSBvbiB0aGUgYXBwbGljYXRpb24gaW5zdGFuY2VcbiAgICBfaW5pdGlhbGl6ZVJlZ2lvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciByZWdpb25zID0gXy5pc0Z1bmN0aW9uKHRoaXMucmVnaW9ucykgPyB0aGlzLnJlZ2lvbnMob3B0aW9ucykgOiB0aGlzLnJlZ2lvbnMgfHwge307XG4gIFxuICAgICAgdGhpcy5faW5pdFJlZ2lvbk1hbmFnZXIoKTtcbiAgXG4gICAgICAvLyBFbmFibGUgdXNlcnMgdG8gZGVmaW5lIGByZWdpb25zYCBpbiBpbnN0YW5jZSBvcHRpb25zLlxuICAgICAgdmFyIG9wdGlvblJlZ2lvbnMgPSBNYXJpb25ldHRlLmdldE9wdGlvbihvcHRpb25zLCAncmVnaW9ucycpO1xuICBcbiAgICAgIC8vIEVuYWJsZSByZWdpb24gb3B0aW9ucyB0byBiZSBhIGZ1bmN0aW9uXG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9wdGlvblJlZ2lvbnMpKSB7XG4gICAgICAgIG9wdGlvblJlZ2lvbnMgPSBvcHRpb25SZWdpb25zLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICB9XG4gIFxuICAgICAgLy8gT3ZlcndyaXRlIGN1cnJlbnQgcmVnaW9ucyB3aXRoIHRob3NlIHBhc3NlZCBpbiBvcHRpb25zXG4gICAgICBfLmV4dGVuZChyZWdpb25zLCBvcHRpb25SZWdpb25zKTtcbiAgXG4gICAgICB0aGlzLmFkZFJlZ2lvbnMocmVnaW9ucyk7XG4gIFxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIHNldCB1cCB0aGUgcmVnaW9uIG1hbmFnZXJcbiAgICBfaW5pdFJlZ2lvbk1hbmFnZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fcmVnaW9uTWFuYWdlciA9IHRoaXMuZ2V0UmVnaW9uTWFuYWdlcigpO1xuICAgICAgdGhpcy5fcmVnaW9uTWFuYWdlci5fcGFyZW50ID0gdGhpcztcbiAgXG4gICAgICB0aGlzLmxpc3RlblRvKHRoaXMuX3JlZ2lvbk1hbmFnZXIsICdiZWZvcmU6YWRkOnJlZ2lvbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBNYXJpb25ldHRlLl90cmlnZ2VyTWV0aG9kKHRoaXMsICdiZWZvcmU6YWRkOnJlZ2lvbicsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcbiAgXG4gICAgICB0aGlzLmxpc3RlblRvKHRoaXMuX3JlZ2lvbk1hbmFnZXIsICdhZGQ6cmVnaW9uJywgZnVuY3Rpb24obmFtZSwgcmVnaW9uKSB7XG4gICAgICAgIHRoaXNbbmFtZV0gPSByZWdpb247XG4gICAgICAgIE1hcmlvbmV0dGUuX3RyaWdnZXJNZXRob2QodGhpcywgJ2FkZDpyZWdpb24nLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gIFxuICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLl9yZWdpb25NYW5hZ2VyLCAnYmVmb3JlOnJlbW92ZTpyZWdpb24nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgTWFyaW9uZXR0ZS5fdHJpZ2dlck1ldGhvZCh0aGlzLCAnYmVmb3JlOnJlbW92ZTpyZWdpb24nLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gIFxuICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLl9yZWdpb25NYW5hZ2VyLCAncmVtb3ZlOnJlZ2lvbicsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXNbbmFtZV07XG4gICAgICAgIE1hcmlvbmV0dGUuX3RyaWdnZXJNZXRob2QodGhpcywgJ3JlbW92ZTpyZWdpb24nLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIHNldHVwIHRoZSBXcmVxci5yYWRpbyBjaGFubmVsXG4gICAgX2luaXRDaGFubmVsOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY2hhbm5lbE5hbWUgPSBfLnJlc3VsdCh0aGlzLCAnY2hhbm5lbE5hbWUnKSB8fCAnZ2xvYmFsJztcbiAgICAgIHRoaXMuY2hhbm5lbCA9IF8ucmVzdWx0KHRoaXMsICdjaGFubmVsJykgfHwgQmFja2JvbmUuV3JlcXIucmFkaW8uY2hhbm5lbCh0aGlzLmNoYW5uZWxOYW1lKTtcbiAgICAgIHRoaXMudmVudCA9IF8ucmVzdWx0KHRoaXMsICd2ZW50JykgfHwgdGhpcy5jaGFubmVsLnZlbnQ7XG4gICAgICB0aGlzLmNvbW1hbmRzID0gXy5yZXN1bHQodGhpcywgJ2NvbW1hbmRzJykgfHwgdGhpcy5jaGFubmVsLmNvbW1hbmRzO1xuICAgICAgdGhpcy5yZXFyZXMgPSBfLnJlc3VsdCh0aGlzLCAncmVxcmVzJykgfHwgdGhpcy5jaGFubmVsLnJlcXJlcztcbiAgICB9XG4gIH0pO1xuICBcbiAgLyoganNoaW50IG1heHBhcmFtczogOSAqL1xuICBcbiAgLy8gTW9kdWxlXG4gIC8vIC0tLS0tLVxuICBcbiAgLy8gQSBzaW1wbGUgbW9kdWxlIHN5c3RlbSwgdXNlZCB0byBjcmVhdGUgcHJpdmFjeSBhbmQgZW5jYXBzdWxhdGlvbiBpblxuICAvLyBNYXJpb25ldHRlIGFwcGxpY2F0aW9uc1xuICBNYXJpb25ldHRlLk1vZHVsZSA9IGZ1bmN0aW9uKG1vZHVsZU5hbWUsIGFwcCwgb3B0aW9ucykge1xuICAgIHRoaXMubW9kdWxlTmFtZSA9IG1vZHVsZU5hbWU7XG4gICAgdGhpcy5vcHRpb25zID0gXy5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgLy8gQWxsb3cgZm9yIGEgdXNlciB0byBvdmVyaWRlIHRoZSBpbml0aWFsaXplXG4gICAgLy8gZm9yIGEgZ2l2ZW4gbW9kdWxlIGluc3RhbmNlLlxuICAgIHRoaXMuaW5pdGlhbGl6ZSA9IG9wdGlvbnMuaW5pdGlhbGl6ZSB8fCB0aGlzLmluaXRpYWxpemU7XG4gIFxuICAgIC8vIFNldCB1cCBhbiBpbnRlcm5hbCBzdG9yZSBmb3Igc3ViLW1vZHVsZXMuXG4gICAgdGhpcy5zdWJtb2R1bGVzID0ge307XG4gIFxuICAgIHRoaXMuX3NldHVwSW5pdGlhbGl6ZXJzQW5kRmluYWxpemVycygpO1xuICBcbiAgICAvLyBTZXQgYW4gaW50ZXJuYWwgcmVmZXJlbmNlIHRvIHRoZSBhcHBcbiAgICAvLyB3aXRoaW4gYSBtb2R1bGUuXG4gICAgdGhpcy5hcHAgPSBhcHA7XG4gIFxuICAgIGlmIChfLmlzRnVuY3Rpb24odGhpcy5pbml0aWFsaXplKSkge1xuICAgICAgdGhpcy5pbml0aWFsaXplKG1vZHVsZU5hbWUsIGFwcCwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gIH07XG4gIFxuICBNYXJpb25ldHRlLk1vZHVsZS5leHRlbmQgPSBNYXJpb25ldHRlLmV4dGVuZDtcbiAgXG4gIC8vIEV4dGVuZCB0aGUgTW9kdWxlIHByb3RvdHlwZSB3aXRoIGV2ZW50cyAvIGxpc3RlblRvLCBzbyB0aGF0IHRoZSBtb2R1bGVcbiAgLy8gY2FuIGJlIHVzZWQgYXMgYW4gZXZlbnQgYWdncmVnYXRvciBvciBwdWIvc3ViLlxuICBfLmV4dGVuZChNYXJpb25ldHRlLk1vZHVsZS5wcm90b3R5cGUsIEJhY2tib25lLkV2ZW50cywge1xuICBcbiAgICAvLyBCeSBkZWZhdWx0IG1vZHVsZXMgc3RhcnQgd2l0aCB0aGVpciBwYXJlbnRzLlxuICAgIHN0YXJ0V2l0aFBhcmVudDogdHJ1ZSxcbiAgXG4gICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMgd2hlbiBleHRlbmRpbmcgTWFyaW9uZXR0ZS5Nb2R1bGUuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7fSxcbiAgXG4gICAgLy8gSW5pdGlhbGl6ZXIgZm9yIGEgc3BlY2lmaWMgbW9kdWxlLiBJbml0aWFsaXplcnMgYXJlIHJ1biB3aGVuIHRoZVxuICAgIC8vIG1vZHVsZSdzIGBzdGFydGAgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICBhZGRJbml0aWFsaXplcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVyQ2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgfSxcbiAgXG4gICAgLy8gRmluYWxpemVycyBhcmUgcnVuIHdoZW4gYSBtb2R1bGUgaXMgc3RvcHBlZC4gVGhleSBhcmUgdXNlZCB0byB0ZWFyZG93blxuICAgIC8vIGFuZCBmaW5hbGl6ZSBhbnkgdmFyaWFibGVzLCByZWZlcmVuY2VzLCBldmVudHMgYW5kIG90aGVyIGNvZGUgdGhhdCB0aGVcbiAgICAvLyBtb2R1bGUgaGFkIHNldCB1cC5cbiAgICBhZGRGaW5hbGl6ZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLl9maW5hbGl6ZXJDYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcbiAgICB9LFxuICBcbiAgICAvLyBTdGFydCB0aGUgbW9kdWxlLCBhbmQgcnVuIGFsbCBvZiBpdHMgaW5pdGlhbGl6ZXJzXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIC8vIFByZXZlbnQgcmUtc3RhcnRpbmcgYSBtb2R1bGUgdGhhdCBpcyBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgIGlmICh0aGlzLl9pc0luaXRpYWxpemVkKSB7IHJldHVybjsgfVxuICBcbiAgICAgIC8vIHN0YXJ0IHRoZSBzdWItbW9kdWxlcyAoZGVwdGgtZmlyc3QgaGllcmFyY2h5KVxuICAgICAgXy5lYWNoKHRoaXMuc3VibW9kdWxlcywgZnVuY3Rpb24obW9kKSB7XG4gICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB3ZSBzaG91bGQgc3RhcnQgdGhlIHN1Yi1tb2R1bGUgd2l0aCB0aGlzIHBhcmVudFxuICAgICAgICBpZiAobW9kLnN0YXJ0V2l0aFBhcmVudCkge1xuICAgICAgICAgIG1vZC5zdGFydChvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIFxuICAgICAgLy8gcnVuIHRoZSBjYWxsYmFja3MgdG8gXCJzdGFydFwiIHRoZSBjdXJyZW50IG1vZHVsZVxuICAgICAgdGhpcy50cmlnZ2VyTWV0aG9kKCdiZWZvcmU6c3RhcnQnLCBvcHRpb25zKTtcbiAgXG4gICAgICB0aGlzLl9pbml0aWFsaXplckNhbGxiYWNrcy5ydW4ob3B0aW9ucywgdGhpcyk7XG4gICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgXG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ3N0YXJ0Jywgb3B0aW9ucyk7XG4gICAgfSxcbiAgXG4gICAgLy8gU3RvcCB0aGlzIG1vZHVsZSBieSBydW5uaW5nIGl0cyBmaW5hbGl6ZXJzIGFuZCB0aGVuIHN0b3AgYWxsIG9mXG4gICAgLy8gdGhlIHN1Yi1tb2R1bGVzIGZvciB0aGlzIG1vZHVsZVxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gaWYgd2UgYXJlIG5vdCBpbml0aWFsaXplZCwgZG9uJ3QgYm90aGVyIGZpbmFsaXppbmdcbiAgICAgIGlmICghdGhpcy5faXNJbml0aWFsaXplZCkgeyByZXR1cm47IH1cbiAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgXG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ2JlZm9yZTpzdG9wJyk7XG4gIFxuICAgICAgLy8gc3RvcCB0aGUgc3ViLW1vZHVsZXM7IGRlcHRoLWZpcnN0LCB0byBtYWtlIHN1cmUgdGhlXG4gICAgICAvLyBzdWItbW9kdWxlcyBhcmUgc3RvcHBlZCAvIGZpbmFsaXplZCBiZWZvcmUgcGFyZW50c1xuICAgICAgXy5pbnZva2UodGhpcy5zdWJtb2R1bGVzLCAnc3RvcCcpO1xuICBcbiAgICAgIC8vIHJ1biB0aGUgZmluYWxpemVyc1xuICAgICAgdGhpcy5fZmluYWxpemVyQ2FsbGJhY2tzLnJ1bih1bmRlZmluZWQsIHRoaXMpO1xuICBcbiAgICAgIC8vIHJlc2V0IHRoZSBpbml0aWFsaXplcnMgYW5kIGZpbmFsaXplcnNcbiAgICAgIHRoaXMuX2luaXRpYWxpemVyQ2FsbGJhY2tzLnJlc2V0KCk7XG4gICAgICB0aGlzLl9maW5hbGl6ZXJDYWxsYmFja3MucmVzZXQoKTtcbiAgXG4gICAgICB0aGlzLnRyaWdnZXJNZXRob2QoJ3N0b3AnKTtcbiAgICB9LFxuICBcbiAgICAvLyBDb25maWd1cmUgdGhlIG1vZHVsZSB3aXRoIGEgZGVmaW5pdGlvbiBmdW5jdGlvbiBhbmQgYW55IGN1c3RvbSBhcmdzXG4gICAgLy8gdGhhdCBhcmUgdG8gYmUgcGFzc2VkIGluIHRvIHRoZSBkZWZpbml0aW9uIGZ1bmN0aW9uXG4gICAgYWRkRGVmaW5pdGlvbjogZnVuY3Rpb24obW9kdWxlRGVmaW5pdGlvbiwgY3VzdG9tQXJncykge1xuICAgICAgdGhpcy5fcnVuTW9kdWxlRGVmaW5pdGlvbihtb2R1bGVEZWZpbml0aW9uLCBjdXN0b21BcmdzKTtcbiAgICB9LFxuICBcbiAgICAvLyBJbnRlcm5hbCBtZXRob2Q6IHJ1biB0aGUgbW9kdWxlIGRlZmluaXRpb24gZnVuY3Rpb24gd2l0aCB0aGUgY29ycmVjdFxuICAgIC8vIGFyZ3VtZW50c1xuICAgIF9ydW5Nb2R1bGVEZWZpbml0aW9uOiBmdW5jdGlvbihkZWZpbml0aW9uLCBjdXN0b21BcmdzKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBkZWZpbml0aW9uIHNob3J0IGNpcmN1dCB0aGUgbWV0aG9kLlxuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7IHJldHVybjsgfVxuICBcbiAgICAgIC8vIGJ1aWxkIHRoZSBjb3JyZWN0IGxpc3Qgb2YgYXJndW1lbnRzIGZvciB0aGUgbW9kdWxlIGRlZmluaXRpb25cbiAgICAgIHZhciBhcmdzID0gXy5mbGF0dGVuKFtcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy5hcHAsXG4gICAgICAgIEJhY2tib25lLFxuICAgICAgICBNYXJpb25ldHRlLFxuICAgICAgICBCYWNrYm9uZS4kLCBfLFxuICAgICAgICBjdXN0b21BcmdzXG4gICAgICBdKTtcbiAgXG4gICAgICBkZWZpbml0aW9uLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0sXG4gIFxuICAgIC8vIEludGVybmFsIG1ldGhvZDogc2V0IHVwIG5ldyBjb3BpZXMgb2YgaW5pdGlhbGl6ZXJzIGFuZCBmaW5hbGl6ZXJzLlxuICAgIC8vIENhbGxpbmcgdGhpcyBtZXRob2Qgd2lsbCB3aXBlIG91dCBhbGwgZXhpc3RpbmcgaW5pdGlhbGl6ZXJzIGFuZFxuICAgIC8vIGZpbmFsaXplcnMuXG4gICAgX3NldHVwSW5pdGlhbGl6ZXJzQW5kRmluYWxpemVyczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9pbml0aWFsaXplckNhbGxiYWNrcyA9IG5ldyBNYXJpb25ldHRlLkNhbGxiYWNrcygpO1xuICAgICAgdGhpcy5fZmluYWxpemVyQ2FsbGJhY2tzID0gbmV3IE1hcmlvbmV0dGUuQ2FsbGJhY2tzKCk7XG4gICAgfSxcbiAgXG4gICAgLy8gaW1wb3J0IHRoZSBgdHJpZ2dlck1ldGhvZGAgdG8gdHJpZ2dlciBldmVudHMgd2l0aCBjb3JyZXNwb25kaW5nXG4gICAgLy8gbWV0aG9kcyBpZiB0aGUgbWV0aG9kIGV4aXN0c1xuICAgIHRyaWdnZXJNZXRob2Q6IE1hcmlvbmV0dGUudHJpZ2dlck1ldGhvZFxuICB9KTtcbiAgXG4gIC8vIENsYXNzIG1ldGhvZHMgdG8gY3JlYXRlIG1vZHVsZXNcbiAgXy5leHRlbmQoTWFyaW9uZXR0ZS5Nb2R1bGUsIHtcbiAgXG4gICAgLy8gQ3JlYXRlIGEgbW9kdWxlLCBoYW5naW5nIG9mZiB0aGUgYXBwIHBhcmFtZXRlciBhcyB0aGUgcGFyZW50IG9iamVjdC5cbiAgICBjcmVhdGU6IGZ1bmN0aW9uKGFwcCwgbW9kdWxlTmFtZXMsIG1vZHVsZURlZmluaXRpb24pIHtcbiAgICAgIHZhciBtb2R1bGUgPSBhcHA7XG4gIFxuICAgICAgLy8gZ2V0IHRoZSBjdXN0b20gYXJncyBwYXNzZWQgaW4gYWZ0ZXIgdGhlIG1vZHVsZSBkZWZpbml0aW9uIGFuZFxuICAgICAgLy8gZ2V0IHJpZCBvZiB0aGUgbW9kdWxlIG5hbWUgYW5kIGRlZmluaXRpb24gZnVuY3Rpb25cbiAgICAgIHZhciBjdXN0b21BcmdzID0gXy5kcm9wKGFyZ3VtZW50cywgMyk7XG4gIFxuICAgICAgLy8gU3BsaXQgdGhlIG1vZHVsZSBuYW1lcyBhbmQgZ2V0IHRoZSBudW1iZXIgb2Ygc3VibW9kdWxlcy5cbiAgICAgIC8vIGkuZS4gYW4gZXhhbXBsZSBtb2R1bGUgbmFtZSBvZiBgRG9nZS5Xb3cuQW1hemVgIHdvdWxkXG4gICAgICAvLyB0aGVuIGhhdmUgdGhlIHBvdGVudGlhbCBmb3IgMyBtb2R1bGUgZGVmaW5pdGlvbnMuXG4gICAgICBtb2R1bGVOYW1lcyA9IG1vZHVsZU5hbWVzLnNwbGl0KCcuJyk7XG4gICAgICB2YXIgbGVuZ3RoID0gbW9kdWxlTmFtZXMubGVuZ3RoO1xuICBcbiAgICAgIC8vIHN0b3JlIHRoZSBtb2R1bGUgZGVmaW5pdGlvbiBmb3IgdGhlIGxhc3QgbW9kdWxlIGluIHRoZSBjaGFpblxuICAgICAgdmFyIG1vZHVsZURlZmluaXRpb25zID0gW107XG4gICAgICBtb2R1bGVEZWZpbml0aW9uc1tsZW5ndGggLSAxXSA9IG1vZHVsZURlZmluaXRpb247XG4gIFxuICAgICAgLy8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgcGFydHMgb2YgdGhlIG1vZHVsZSBkZWZpbml0aW9uXG4gICAgICBfLmVhY2gobW9kdWxlTmFtZXMsIGZ1bmN0aW9uKG1vZHVsZU5hbWUsIGkpIHtcbiAgICAgICAgdmFyIHBhcmVudE1vZHVsZSA9IG1vZHVsZTtcbiAgICAgICAgbW9kdWxlID0gdGhpcy5fZ2V0TW9kdWxlKHBhcmVudE1vZHVsZSwgbW9kdWxlTmFtZSwgYXBwLCBtb2R1bGVEZWZpbml0aW9uKTtcbiAgICAgICAgdGhpcy5fYWRkTW9kdWxlRGVmaW5pdGlvbihwYXJlbnRNb2R1bGUsIG1vZHVsZSwgbW9kdWxlRGVmaW5pdGlvbnNbaV0sIGN1c3RvbUFyZ3MpO1xuICAgICAgfSwgdGhpcyk7XG4gIFxuICAgICAgLy8gUmV0dXJuIHRoZSBsYXN0IG1vZHVsZSBpbiB0aGUgZGVmaW5pdGlvbiBjaGFpblxuICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICB9LFxuICBcbiAgICBfZ2V0TW9kdWxlOiBmdW5jdGlvbihwYXJlbnRNb2R1bGUsIG1vZHVsZU5hbWUsIGFwcCwgZGVmLCBhcmdzKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IF8uZXh0ZW5kKHt9LCBkZWYpO1xuICAgICAgdmFyIE1vZHVsZUNsYXNzID0gdGhpcy5nZXRDbGFzcyhkZWYpO1xuICBcbiAgICAgIC8vIEdldCBhbiBleGlzdGluZyBtb2R1bGUgb2YgdGhpcyBuYW1lIGlmIHdlIGhhdmUgb25lXG4gICAgICB2YXIgbW9kdWxlID0gcGFyZW50TW9kdWxlW21vZHVsZU5hbWVdO1xuICBcbiAgICAgIGlmICghbW9kdWxlKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgaWYgd2UgZG9uJ3QgaGF2ZSBvbmVcbiAgICAgICAgbW9kdWxlID0gbmV3IE1vZHVsZUNsYXNzKG1vZHVsZU5hbWUsIGFwcCwgb3B0aW9ucyk7XG4gICAgICAgIHBhcmVudE1vZHVsZVttb2R1bGVOYW1lXSA9IG1vZHVsZTtcbiAgICAgICAgLy8gc3RvcmUgdGhlIG1vZHVsZSBvbiB0aGUgcGFyZW50XG4gICAgICAgIHBhcmVudE1vZHVsZS5zdWJtb2R1bGVzW21vZHVsZU5hbWVdID0gbW9kdWxlO1xuICAgICAgfVxuICBcbiAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfSxcbiAgXG4gICAgLy8gIyMgTW9kdWxlIENsYXNzZXNcbiAgICAvL1xuICAgIC8vIE1vZHVsZSBjbGFzc2VzIGNhbiBiZSB1c2VkIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBkZWZpbmUgcGF0dGVybi5cbiAgICAvLyBUaGUgZXh0ZW5kIGZ1bmN0aW9uIG9mIGEgTW9kdWxlIGlzIGlkZW50aWNhbCB0byB0aGUgZXh0ZW5kIGZ1bmN0aW9uc1xuICAgIC8vIG9uIG90aGVyIEJhY2tib25lIGFuZCBNYXJpb25ldHRlIGNsYXNzZXMuXG4gICAgLy8gVGhpcyBhbGxvd3MgbW9kdWxlIGxpZmVjeWxlIGV2ZW50cyBsaWtlIGBvblN0YXJ0YCBhbmQgYG9uU3RvcGAgdG8gYmUgY2FsbGVkIGRpcmVjdGx5LlxuICAgIGdldENsYXNzOiBmdW5jdGlvbihtb2R1bGVEZWZpbml0aW9uKSB7XG4gICAgICB2YXIgTW9kdWxlQ2xhc3MgPSBNYXJpb25ldHRlLk1vZHVsZTtcbiAgXG4gICAgICBpZiAoIW1vZHVsZURlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIE1vZHVsZUNsYXNzO1xuICAgICAgfVxuICBcbiAgICAgIC8vIElmIGFsbCBvZiB0aGUgbW9kdWxlJ3MgZnVuY3Rpb25hbGl0eSBpcyBkZWZpbmVkIGluc2lkZSBpdHMgY2xhc3MsXG4gICAgICAvLyB0aGVuIHRoZSBjbGFzcyBjYW4gYmUgcGFzc2VkIGluIGRpcmVjdGx5LiBgTXlBcHAubW9kdWxlKFwiRm9vXCIsIEZvb01vZHVsZSlgLlxuICAgICAgaWYgKG1vZHVsZURlZmluaXRpb24ucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kdWxlQ2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZURlZmluaXRpb247XG4gICAgICB9XG4gIFxuICAgICAgcmV0dXJuIG1vZHVsZURlZmluaXRpb24ubW9kdWxlQ2xhc3MgfHwgTW9kdWxlQ2xhc3M7XG4gICAgfSxcbiAgXG4gICAgLy8gQWRkIHRoZSBtb2R1bGUgZGVmaW5pdGlvbiBhbmQgYWRkIGEgc3RhcnRXaXRoUGFyZW50IGluaXRpYWxpemVyIGZ1bmN0aW9uLlxuICAgIC8vIFRoaXMgaXMgY29tcGxpY2F0ZWQgYmVjYXVzZSBtb2R1bGUgZGVmaW5pdGlvbnMgYXJlIGhlYXZpbHkgb3ZlcmxvYWRlZFxuICAgIC8vIGFuZCBzdXBwb3J0IGFuIGFub255bW91cyBmdW5jdGlvbiwgbW9kdWxlIGNsYXNzLCBvciBvcHRpb25zIG9iamVjdFxuICAgIF9hZGRNb2R1bGVEZWZpbml0aW9uOiBmdW5jdGlvbihwYXJlbnRNb2R1bGUsIG1vZHVsZSwgZGVmLCBhcmdzKSB7XG4gICAgICB2YXIgZm4gPSB0aGlzLl9nZXREZWZpbmUoZGVmKTtcbiAgICAgIHZhciBzdGFydFdpdGhQYXJlbnQgPSB0aGlzLl9nZXRTdGFydFdpdGhQYXJlbnQoZGVmLCBtb2R1bGUpO1xuICBcbiAgICAgIGlmIChmbikge1xuICAgICAgICBtb2R1bGUuYWRkRGVmaW5pdGlvbihmbiwgYXJncyk7XG4gICAgICB9XG4gIFxuICAgICAgdGhpcy5fYWRkU3RhcnRXaXRoUGFyZW50KHBhcmVudE1vZHVsZSwgbW9kdWxlLCBzdGFydFdpdGhQYXJlbnQpO1xuICAgIH0sXG4gIFxuICAgIF9nZXRTdGFydFdpdGhQYXJlbnQ6IGZ1bmN0aW9uKGRlZiwgbW9kdWxlKSB7XG4gICAgICB2YXIgc3dwO1xuICBcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24oZGVmKSAmJiAoZGVmLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1hcmlvbmV0dGUuTW9kdWxlKSkge1xuICAgICAgICBzd3AgPSBtb2R1bGUuY29uc3RydWN0b3IucHJvdG90eXBlLnN0YXJ0V2l0aFBhcmVudDtcbiAgICAgICAgcmV0dXJuIF8uaXNVbmRlZmluZWQoc3dwKSA/IHRydWUgOiBzd3A7XG4gICAgICB9XG4gIFxuICAgICAgaWYgKF8uaXNPYmplY3QoZGVmKSkge1xuICAgICAgICBzd3AgPSBkZWYuc3RhcnRXaXRoUGFyZW50O1xuICAgICAgICByZXR1cm4gXy5pc1VuZGVmaW5lZChzd3ApID8gdHJ1ZSA6IHN3cDtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICBcbiAgICBfZ2V0RGVmaW5lOiBmdW5jdGlvbihkZWYpIHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24oZGVmKSAmJiAhKGRlZi5wcm90b3R5cGUgaW5zdGFuY2VvZiBNYXJpb25ldHRlLk1vZHVsZSkpIHtcbiAgICAgICAgcmV0dXJuIGRlZjtcbiAgICAgIH1cbiAgXG4gICAgICBpZiAoXy5pc09iamVjdChkZWYpKSB7XG4gICAgICAgIHJldHVybiBkZWYuZGVmaW5lO1xuICAgICAgfVxuICBcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gIFxuICAgIF9hZGRTdGFydFdpdGhQYXJlbnQ6IGZ1bmN0aW9uKHBhcmVudE1vZHVsZSwgbW9kdWxlLCBzdGFydFdpdGhQYXJlbnQpIHtcbiAgICAgIG1vZHVsZS5zdGFydFdpdGhQYXJlbnQgPSBtb2R1bGUuc3RhcnRXaXRoUGFyZW50ICYmIHN0YXJ0V2l0aFBhcmVudDtcbiAgXG4gICAgICBpZiAoIW1vZHVsZS5zdGFydFdpdGhQYXJlbnQgfHwgISFtb2R1bGUuc3RhcnRXaXRoUGFyZW50SXNDb25maWd1cmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgXG4gICAgICBtb2R1bGUuc3RhcnRXaXRoUGFyZW50SXNDb25maWd1cmVkID0gdHJ1ZTtcbiAgXG4gICAgICBwYXJlbnRNb2R1bGUuYWRkSW5pdGlhbGl6ZXIoZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBpZiAobW9kdWxlLnN0YXJ0V2l0aFBhcmVudCkge1xuICAgICAgICAgIG1vZHVsZS5zdGFydChvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgXG5cbiAgcmV0dXJuIE1hcmlvbmV0dGU7XG59KSk7XG4iLCIvLyBCYWNrYm9uZS5CYWJ5U2l0dGVyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB2MC4xLjhcbi8vXG4vLyBDb3B5cmlnaHQgKGMpMjAxNSBEZXJpY2sgQmFpbGV5LCBNdXRlZCBTb2x1dGlvbnMsIExMQy5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIE1JVCBsaWNlbnNlXG4vL1xuLy8gaHR0cDovL2dpdGh1Yi5jb20vbWFyaW9uZXR0ZWpzL2JhY2tib25lLmJhYnlzaXR0ZXJcblxuKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsnYmFja2JvbmUnLCAndW5kZXJzY29yZSddLCBmdW5jdGlvbihCYWNrYm9uZSwgXykge1xuICAgICAgcmV0dXJuIGZhY3RvcnkoQmFja2JvbmUsIF8pO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG4gICAgdmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KEJhY2tib25lLCBfKTtcbiAgfSBlbHNlIHtcbiAgICBmYWN0b3J5KHJvb3QuQmFja2JvbmUsIHJvb3QuXyk7XG4gIH1cblxufSh0aGlzLCBmdW5jdGlvbihCYWNrYm9uZSwgXykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHByZXZpb3VzQ2hpbGRWaWV3Q29udGFpbmVyID0gQmFja2JvbmUuQ2hpbGRWaWV3Q29udGFpbmVyO1xuXG4gIC8vIEJhYnlTaXR0ZXIuQ2hpbGRWaWV3Q29udGFpbmVyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vIFByb3ZpZGUgYSBjb250YWluZXIgdG8gc3RvcmUsIHJldHJpZXZlIGFuZFxuICAvLyBzaHV0IGRvd24gY2hpbGQgdmlld3MuXG4gIFxuICBCYWNrYm9uZS5DaGlsZFZpZXdDb250YWluZXIgPSAoZnVuY3Rpb24gKEJhY2tib25lLCBfKSB7XG4gIFxuICAgIC8vIENvbnRhaW5lciBDb25zdHJ1Y3RvclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBcbiAgICB2YXIgQ29udGFpbmVyID0gZnVuY3Rpb24odmlld3Mpe1xuICAgICAgdGhpcy5fdmlld3MgPSB7fTtcbiAgICAgIHRoaXMuX2luZGV4QnlNb2RlbCA9IHt9O1xuICAgICAgdGhpcy5faW5kZXhCeUN1c3RvbSA9IHt9O1xuICAgICAgdGhpcy5fdXBkYXRlTGVuZ3RoKCk7XG4gIFxuICAgICAgXy5lYWNoKHZpZXdzLCB0aGlzLmFkZCwgdGhpcyk7XG4gICAgfTtcbiAgXG4gICAgLy8gQ29udGFpbmVyIE1ldGhvZHNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuICBcbiAgICBfLmV4dGVuZChDb250YWluZXIucHJvdG90eXBlLCB7XG4gIFxuICAgICAgLy8gQWRkIGEgdmlldyB0byB0aGlzIGNvbnRhaW5lci4gU3RvcmVzIHRoZSB2aWV3XG4gICAgICAvLyBieSBgY2lkYCBhbmQgbWFrZXMgaXQgc2VhcmNoYWJsZSBieSB0aGUgbW9kZWxcbiAgICAgIC8vIGNpZCAoYW5kIG1vZGVsIGl0c2VsZikuIE9wdGlvbmFsbHkgc3BlY2lmeVxuICAgICAgLy8gYSBjdXN0b20ga2V5IHRvIHN0b3JlIGFuIHJldHJpZXZlIHRoZSB2aWV3LlxuICAgICAgYWRkOiBmdW5jdGlvbih2aWV3LCBjdXN0b21JbmRleCl7XG4gICAgICAgIHZhciB2aWV3Q2lkID0gdmlldy5jaWQ7XG4gIFxuICAgICAgICAvLyBzdG9yZSB0aGUgdmlld1xuICAgICAgICB0aGlzLl92aWV3c1t2aWV3Q2lkXSA9IHZpZXc7XG4gIFxuICAgICAgICAvLyBpbmRleCBpdCBieSBtb2RlbFxuICAgICAgICBpZiAodmlldy5tb2RlbCl7XG4gICAgICAgICAgdGhpcy5faW5kZXhCeU1vZGVsW3ZpZXcubW9kZWwuY2lkXSA9IHZpZXdDaWQ7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIC8vIGluZGV4IGJ5IGN1c3RvbVxuICAgICAgICBpZiAoY3VzdG9tSW5kZXgpe1xuICAgICAgICAgIHRoaXMuX2luZGV4QnlDdXN0b21bY3VzdG9tSW5kZXhdID0gdmlld0NpZDtcbiAgICAgICAgfVxuICBcbiAgICAgICAgdGhpcy5fdXBkYXRlTGVuZ3RoKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgXG4gICAgICAvLyBGaW5kIGEgdmlldyBieSB0aGUgbW9kZWwgdGhhdCB3YXMgYXR0YWNoZWQgdG9cbiAgICAgIC8vIGl0LiBVc2VzIHRoZSBtb2RlbCdzIGBjaWRgIHRvIGZpbmQgaXQuXG4gICAgICBmaW5kQnlNb2RlbDogZnVuY3Rpb24obW9kZWwpe1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kQnlNb2RlbENpZChtb2RlbC5jaWQpO1xuICAgICAgfSxcbiAgXG4gICAgICAvLyBGaW5kIGEgdmlldyBieSB0aGUgYGNpZGAgb2YgdGhlIG1vZGVsIHRoYXQgd2FzIGF0dGFjaGVkIHRvXG4gICAgICAvLyBpdC4gVXNlcyB0aGUgbW9kZWwncyBgY2lkYCB0byBmaW5kIHRoZSB2aWV3IGBjaWRgIGFuZFxuICAgICAgLy8gcmV0cmlldmUgdGhlIHZpZXcgdXNpbmcgaXQuXG4gICAgICBmaW5kQnlNb2RlbENpZDogZnVuY3Rpb24obW9kZWxDaWQpe1xuICAgICAgICB2YXIgdmlld0NpZCA9IHRoaXMuX2luZGV4QnlNb2RlbFttb2RlbENpZF07XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRCeUNpZCh2aWV3Q2lkKTtcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gRmluZCBhIHZpZXcgYnkgYSBjdXN0b20gaW5kZXhlci5cbiAgICAgIGZpbmRCeUN1c3RvbTogZnVuY3Rpb24oaW5kZXgpe1xuICAgICAgICB2YXIgdmlld0NpZCA9IHRoaXMuX2luZGV4QnlDdXN0b21baW5kZXhdO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kQnlDaWQodmlld0NpZCk7XG4gICAgICB9LFxuICBcbiAgICAgIC8vIEZpbmQgYnkgaW5kZXguIFRoaXMgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgYVxuICAgICAgLy8gc3RhYmxlIGluZGV4LlxuICAgICAgZmluZEJ5SW5kZXg6IGZ1bmN0aW9uKGluZGV4KXtcbiAgICAgICAgcmV0dXJuIF8udmFsdWVzKHRoaXMuX3ZpZXdzKVtpbmRleF07XG4gICAgICB9LFxuICBcbiAgICAgIC8vIHJldHJpZXZlIGEgdmlldyBieSBpdHMgYGNpZGAgZGlyZWN0bHlcbiAgICAgIGZpbmRCeUNpZDogZnVuY3Rpb24oY2lkKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdzW2NpZF07XG4gICAgICB9LFxuICBcbiAgICAgIC8vIFJlbW92ZSBhIHZpZXdcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24odmlldyl7XG4gICAgICAgIHZhciB2aWV3Q2lkID0gdmlldy5jaWQ7XG4gIFxuICAgICAgICAvLyBkZWxldGUgbW9kZWwgaW5kZXhcbiAgICAgICAgaWYgKHZpZXcubW9kZWwpe1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pbmRleEJ5TW9kZWxbdmlldy5tb2RlbC5jaWRdO1xuICAgICAgICB9XG4gIFxuICAgICAgICAvLyBkZWxldGUgY3VzdG9tIGluZGV4XG4gICAgICAgIF8uYW55KHRoaXMuX2luZGV4QnlDdXN0b20sIGZ1bmN0aW9uKGNpZCwga2V5KSB7XG4gICAgICAgICAgaWYgKGNpZCA9PT0gdmlld0NpZCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2luZGV4QnlDdXN0b21ba2V5XTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gIFxuICAgICAgICAvLyByZW1vdmUgdGhlIHZpZXcgZnJvbSB0aGUgY29udGFpbmVyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl92aWV3c1t2aWV3Q2lkXTtcbiAgXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgbGVuZ3RoXG4gICAgICAgIHRoaXMuX3VwZGF0ZUxlbmd0aCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gQ2FsbCBhIG1ldGhvZCBvbiBldmVyeSB2aWV3IGluIHRoZSBjb250YWluZXIsXG4gICAgICAvLyBwYXNzaW5nIHBhcmFtZXRlcnMgdG8gdGhlIGNhbGwgbWV0aG9kIG9uZSBhdCBhXG4gICAgICAvLyB0aW1lLCBsaWtlIGBmdW5jdGlvbi5jYWxsYC5cbiAgICAgIGNhbGw6IGZ1bmN0aW9uKG1ldGhvZCl7XG4gICAgICAgIHRoaXMuYXBwbHkobWV0aG9kLCBfLnRhaWwoYXJndW1lbnRzKSk7XG4gICAgICB9LFxuICBcbiAgICAgIC8vIEFwcGx5IGEgbWV0aG9kIG9uIGV2ZXJ5IHZpZXcgaW4gdGhlIGNvbnRhaW5lcixcbiAgICAgIC8vIHBhc3NpbmcgcGFyYW1ldGVycyB0byB0aGUgY2FsbCBtZXRob2Qgb25lIGF0IGFcbiAgICAgIC8vIHRpbWUsIGxpa2UgYGZ1bmN0aW9uLmFwcGx5YC5cbiAgICAgIGFwcGx5OiBmdW5jdGlvbihtZXRob2QsIGFyZ3Mpe1xuICAgICAgICBfLmVhY2godGhpcy5fdmlld3MsIGZ1bmN0aW9uKHZpZXcpe1xuICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24odmlld1ttZXRob2RdKSl7XG4gICAgICAgICAgICB2aWV3W21ldGhvZF0uYXBwbHkodmlldywgYXJncyB8fCBbXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gVXBkYXRlIHRoZSBgLmxlbmd0aGAgYXR0cmlidXRlIG9uIHRoaXMgY29udGFpbmVyXG4gICAgICBfdXBkYXRlTGVuZ3RoOiBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLmxlbmd0aCA9IF8uc2l6ZSh0aGlzLl92aWV3cyk7XG4gICAgICB9XG4gICAgfSk7XG4gIFxuICAgIC8vIEJvcnJvd2luZyB0aGlzIGNvZGUgZnJvbSBCYWNrYm9uZS5Db2xsZWN0aW9uOlxuICAgIC8vIGh0dHA6Ly9iYWNrYm9uZWpzLm9yZy9kb2NzL2JhY2tib25lLmh0bWwjc2VjdGlvbi0xMDZcbiAgICAvL1xuICAgIC8vIE1peCBpbiBtZXRob2RzIGZyb20gVW5kZXJzY29yZSwgZm9yIGl0ZXJhdGlvbiwgYW5kIG90aGVyXG4gICAgLy8gY29sbGVjdGlvbiByZWxhdGVkIGZlYXR1cmVzLlxuICAgIHZhciBtZXRob2RzID0gWydmb3JFYWNoJywgJ2VhY2gnLCAnbWFwJywgJ2ZpbmQnLCAnZGV0ZWN0JywgJ2ZpbHRlcicsXG4gICAgICAnc2VsZWN0JywgJ3JlamVjdCcsICdldmVyeScsICdhbGwnLCAnc29tZScsICdhbnknLCAnaW5jbHVkZScsXG4gICAgICAnY29udGFpbnMnLCAnaW52b2tlJywgJ3RvQXJyYXknLCAnZmlyc3QnLCAnaW5pdGlhbCcsICdyZXN0JyxcbiAgICAgICdsYXN0JywgJ3dpdGhvdXQnLCAnaXNFbXB0eScsICdwbHVjaycsICdyZWR1Y2UnXTtcbiAgXG4gICAgXy5lYWNoKG1ldGhvZHMsIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgQ29udGFpbmVyLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2aWV3cyA9IF8udmFsdWVzKHRoaXMuX3ZpZXdzKTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdmlld3NdLmNvbmNhdChfLnRvQXJyYXkoYXJndW1lbnRzKSk7XG4gICAgICAgIHJldHVybiBfW21ldGhvZF0uYXBwbHkoXywgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuICBcbiAgICAvLyByZXR1cm4gdGhlIHB1YmxpYyBBUElcbiAgICByZXR1cm4gQ29udGFpbmVyO1xuICB9KShCYWNrYm9uZSwgXyk7XG4gIFxuXG4gIEJhY2tib25lLkNoaWxkVmlld0NvbnRhaW5lci5WRVJTSU9OID0gJzAuMS44JztcblxuICBCYWNrYm9uZS5DaGlsZFZpZXdDb250YWluZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBCYWNrYm9uZS5DaGlsZFZpZXdDb250YWluZXIgPSBwcmV2aW91c0NoaWxkVmlld0NvbnRhaW5lcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gQmFja2JvbmUuQ2hpbGRWaWV3Q29udGFpbmVyO1xuXG59KSk7XG4iLCIvLyBCYWNrYm9uZS5XcmVxciAoQmFja2JvbmUuTWFyaW9uZXR0ZSlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHYxLjMuM1xuLy9cbi8vIENvcHlyaWdodCAoYykyMDE1IERlcmljayBCYWlsZXksIE11dGVkIFNvbHV0aW9ucywgTExDLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgTUlUIGxpY2Vuc2Vcbi8vXG4vLyBodHRwOi8vZ2l0aHViLmNvbS9tYXJpb25ldHRlanMvYmFja2JvbmUud3JlcXJcblxuXG4oZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWydiYWNrYm9uZScsICd1bmRlcnNjb3JlJ10sIGZ1bmN0aW9uKEJhY2tib25lLCBfKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeShCYWNrYm9uZSwgXyk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoQmFja2JvbmUsIF8pO1xuICB9IGVsc2Uge1xuICAgIGZhY3Rvcnkocm9vdC5CYWNrYm9uZSwgcm9vdC5fKTtcbiAgfVxuXG59KHRoaXMsIGZ1bmN0aW9uKEJhY2tib25lLCBfKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBwcmV2aW91c1dyZXFyID0gQmFja2JvbmUuV3JlcXI7XG5cbiAgdmFyIFdyZXFyID0gQmFja2JvbmUuV3JlcXIgPSB7fTtcblxuICBCYWNrYm9uZS5XcmVxci5WRVJTSU9OID0gJzEuMy4zJztcblxuICBCYWNrYm9uZS5XcmVxci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIEJhY2tib25lLldyZXFyID0gcHJldmlvdXNXcmVxcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBIYW5kbGVyc1xuICAvLyAtLS0tLS0tLVxuICAvLyBBIHJlZ2lzdHJ5IG9mIGZ1bmN0aW9ucyB0byBjYWxsLCBnaXZlbiBhIG5hbWVcbiAgXG4gIFdyZXFyLkhhbmRsZXJzID0gKGZ1bmN0aW9uKEJhY2tib25lLCBfKXtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBcbiAgICAvLyBDb25zdHJ1Y3RvclxuICAgIC8vIC0tLS0tLS0tLS0tXG4gIFxuICAgIHZhciBIYW5kbGVycyA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMuX3dyZXFySGFuZGxlcnMgPSB7fTtcbiAgICAgIFxuICAgICAgaWYgKF8uaXNGdW5jdGlvbih0aGlzLmluaXRpYWxpemUpKXtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH07XG4gIFxuICAgIEhhbmRsZXJzLmV4dGVuZCA9IEJhY2tib25lLk1vZGVsLmV4dGVuZDtcbiAgXG4gICAgLy8gSW5zdGFuY2UgTWVtYmVyc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS1cbiAgXG4gICAgXy5leHRlbmQoSGFuZGxlcnMucHJvdG90eXBlLCBCYWNrYm9uZS5FdmVudHMsIHtcbiAgXG4gICAgICAvLyBBZGQgbXVsdGlwbGUgaGFuZGxlcnMgdXNpbmcgYW4gb2JqZWN0IGxpdGVyYWwgY29uZmlndXJhdGlvblxuICAgICAgc2V0SGFuZGxlcnM6IGZ1bmN0aW9uKGhhbmRsZXJzKXtcbiAgICAgICAgXy5lYWNoKGhhbmRsZXJzLCBmdW5jdGlvbihoYW5kbGVyLCBuYW1lKXtcbiAgICAgICAgICB2YXIgY29udGV4dCA9IG51bGw7XG4gIFxuICAgICAgICAgIGlmIChfLmlzT2JqZWN0KGhhbmRsZXIpICYmICFfLmlzRnVuY3Rpb24oaGFuZGxlcikpe1xuICAgICAgICAgICAgY29udGV4dCA9IGhhbmRsZXIuY29udGV4dDtcbiAgICAgICAgICAgIGhhbmRsZXIgPSBoYW5kbGVyLmNhbGxiYWNrO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgdGhpcy5zZXRIYW5kbGVyKG5hbWUsIGhhbmRsZXIsIGNvbnRleHQpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gQWRkIGEgaGFuZGxlciBmb3IgdGhlIGdpdmVuIG5hbWUsIHdpdGggYW5cbiAgICAgIC8vIG9wdGlvbmFsIGNvbnRleHQgdG8gcnVuIHRoZSBoYW5kbGVyIHdpdGhpblxuICAgICAgc2V0SGFuZGxlcjogZnVuY3Rpb24obmFtZSwgaGFuZGxlciwgY29udGV4dCl7XG4gICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgY2FsbGJhY2s6IGhhbmRsZXIsXG4gICAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgICAgICB9O1xuICBcbiAgICAgICAgdGhpcy5fd3JlcXJIYW5kbGVyc1tuYW1lXSA9IGNvbmZpZztcbiAgXG4gICAgICAgIHRoaXMudHJpZ2dlcihcImhhbmRsZXI6YWRkXCIsIG5hbWUsIGhhbmRsZXIsIGNvbnRleHQpO1xuICAgICAgfSxcbiAgXG4gICAgICAvLyBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWRcbiAgICAgIGhhc0hhbmRsZXI6IGZ1bmN0aW9uKG5hbWUpe1xuICAgICAgICByZXR1cm4gISEgdGhpcy5fd3JlcXJIYW5kbGVyc1tuYW1lXTtcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gR2V0IHRoZSBjdXJyZW50bHkgcmVnaXN0ZXJlZCBoYW5kbGVyIGZvclxuICAgICAgLy8gdGhlIHNwZWNpZmllZCBuYW1lLiBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmXG4gICAgICAvLyBubyBoYW5kbGVyIGlzIGZvdW5kLlxuICAgICAgZ2V0SGFuZGxlcjogZnVuY3Rpb24obmFtZSl7XG4gICAgICAgIHZhciBjb25maWcgPSB0aGlzLl93cmVxckhhbmRsZXJzW25hbWVdO1xuICBcbiAgICAgICAgaWYgKCFjb25maWcpe1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICBcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgcmV0dXJuIGNvbmZpZy5jYWxsYmFjay5hcHBseShjb25maWcuY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gUmVtb3ZlIGEgaGFuZGxlciBmb3IgdGhlIHNwZWNpZmllZCBuYW1lXG4gICAgICByZW1vdmVIYW5kbGVyOiBmdW5jdGlvbihuYW1lKXtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3dyZXFySGFuZGxlcnNbbmFtZV07XG4gICAgICB9LFxuICBcbiAgICAgIC8vIFJlbW92ZSBhbGwgaGFuZGxlcnMgZnJvbSB0aGlzIHJlZ2lzdHJ5XG4gICAgICByZW1vdmVBbGxIYW5kbGVyczogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5fd3JlcXJIYW5kbGVycyA9IHt9O1xuICAgICAgfVxuICAgIH0pO1xuICBcbiAgICByZXR1cm4gSGFuZGxlcnM7XG4gIH0pKEJhY2tib25lLCBfKTtcbiAgXG4gIC8vIFdyZXFyLkNvbW1hbmRTdG9yYWdlXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vIFN0b3JlIGFuZCByZXRyaWV2ZSBjb21tYW5kcyBmb3IgZXhlY3V0aW9uLlxuICBXcmVxci5Db21tYW5kU3RvcmFnZSA9IChmdW5jdGlvbigpe1xuICAgIFwidXNlIHN0cmljdFwiO1xuICBcbiAgICAvLyBDb25zdHJ1Y3RvciBmdW5jdGlvblxuICAgIHZhciBDb21tYW5kU3RvcmFnZSA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMuX2NvbW1hbmRzID0ge307XG4gIFxuICAgICAgaWYgKF8uaXNGdW5jdGlvbih0aGlzLmluaXRpYWxpemUpKXtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH07XG4gIFxuICAgIC8vIEluc3RhbmNlIG1ldGhvZHNcbiAgICBfLmV4dGVuZChDb21tYW5kU3RvcmFnZS5wcm90b3R5cGUsIEJhY2tib25lLkV2ZW50cywge1xuICBcbiAgICAgIC8vIEdldCBhbiBvYmplY3QgbGl0ZXJhbCBieSBjb21tYW5kIG5hbWUsIHRoYXQgY29udGFpbnNcbiAgICAgIC8vIHRoZSBgY29tbWFuZE5hbWVgIGFuZCB0aGUgYGluc3RhbmNlc2Agb2YgYWxsIGNvbW1hbmRzXG4gICAgICAvLyByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gcHJvY2Vzc1xuICAgICAgZ2V0Q29tbWFuZHM6IGZ1bmN0aW9uKGNvbW1hbmROYW1lKXtcbiAgICAgICAgdmFyIGNvbW1hbmRzID0gdGhpcy5fY29tbWFuZHNbY29tbWFuZE5hbWVdO1xuICBcbiAgICAgICAgLy8gd2UgZG9uJ3QgaGF2ZSBpdCwgc28gYWRkIGl0XG4gICAgICAgIGlmICghY29tbWFuZHMpe1xuICBcbiAgICAgICAgICAvLyBidWlsZCB0aGUgY29uZmlndXJhdGlvblxuICAgICAgICAgIGNvbW1hbmRzID0ge1xuICAgICAgICAgICAgY29tbWFuZDogY29tbWFuZE5hbWUsIFxuICAgICAgICAgICAgaW5zdGFuY2VzOiBbXVxuICAgICAgICAgIH07XG4gIFxuICAgICAgICAgIC8vIHN0b3JlIGl0XG4gICAgICAgICAgdGhpcy5fY29tbWFuZHNbY29tbWFuZE5hbWVdID0gY29tbWFuZHM7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHJldHVybiBjb21tYW5kcztcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gQWRkIGEgY29tbWFuZCBieSBuYW1lLCB0byB0aGUgc3RvcmFnZSBhbmQgc3RvcmUgdGhlXG4gICAgICAvLyBhcmdzIGZvciB0aGUgY29tbWFuZFxuICAgICAgYWRkQ29tbWFuZDogZnVuY3Rpb24oY29tbWFuZE5hbWUsIGFyZ3Mpe1xuICAgICAgICB2YXIgY29tbWFuZCA9IHRoaXMuZ2V0Q29tbWFuZHMoY29tbWFuZE5hbWUpO1xuICAgICAgICBjb21tYW5kLmluc3RhbmNlcy5wdXNoKGFyZ3MpO1xuICAgICAgfSxcbiAgXG4gICAgICAvLyBDbGVhciBhbGwgY29tbWFuZHMgZm9yIHRoZSBnaXZlbiBgY29tbWFuZE5hbWVgXG4gICAgICBjbGVhckNvbW1hbmRzOiBmdW5jdGlvbihjb21tYW5kTmFtZSl7XG4gICAgICAgIHZhciBjb21tYW5kID0gdGhpcy5nZXRDb21tYW5kcyhjb21tYW5kTmFtZSk7XG4gICAgICAgIGNvbW1hbmQuaW5zdGFuY2VzID0gW107XG4gICAgICB9XG4gICAgfSk7XG4gIFxuICAgIHJldHVybiBDb21tYW5kU3RvcmFnZTtcbiAgfSkoKTtcbiAgXG4gIC8vIFdyZXFyLkNvbW1hbmRzXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vIEEgc2ltcGxlIGNvbW1hbmQgcGF0dGVybiBpbXBsZW1lbnRhdGlvbi4gUmVnaXN0ZXIgYSBjb21tYW5kXG4gIC8vIGhhbmRsZXIgYW5kIGV4ZWN1dGUgaXQuXG4gIFdyZXFyLkNvbW1hbmRzID0gKGZ1bmN0aW9uKFdyZXFyLCBfKXtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgXG4gICAgcmV0dXJuIFdyZXFyLkhhbmRsZXJzLmV4dGVuZCh7XG4gICAgICAvLyBkZWZhdWx0IHN0b3JhZ2UgdHlwZVxuICAgICAgc3RvcmFnZVR5cGU6IFdyZXFyLkNvbW1hbmRTdG9yYWdlLFxuICBcbiAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihvcHRpb25zKXtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVTdG9yYWdlKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIHRoaXMub24oXCJoYW5kbGVyOmFkZFwiLCB0aGlzLl9leGVjdXRlQ29tbWFuZHMsIHRoaXMpO1xuICBcbiAgICAgICAgV3JlcXIuSGFuZGxlcnMucHJvdG90eXBlLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9LFxuICBcbiAgICAgIC8vIEV4ZWN1dGUgYSBuYW1lZCBjb21tYW5kIHdpdGggdGhlIHN1cHBsaWVkIGFyZ3NcbiAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uKG5hbWUpe1xuICAgICAgICBuYW1lID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgYXJncyA9IF8ucmVzdChhcmd1bWVudHMpO1xuICBcbiAgICAgICAgaWYgKHRoaXMuaGFzSGFuZGxlcihuYW1lKSl7XG4gICAgICAgICAgdGhpcy5nZXRIYW5kbGVyKG5hbWUpLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RvcmFnZS5hZGRDb21tYW5kKG5hbWUsIGFyZ3MpO1xuICAgICAgICB9XG4gIFxuICAgICAgfSxcbiAgXG4gICAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gaGFuZGxlIGJ1bGsgZXhlY3V0aW9uIG9mIHN0b3JlZCBjb21tYW5kc1xuICAgICAgX2V4ZWN1dGVDb21tYW5kczogZnVuY3Rpb24obmFtZSwgaGFuZGxlciwgY29udGV4dCl7XG4gICAgICAgIHZhciBjb21tYW5kID0gdGhpcy5zdG9yYWdlLmdldENvbW1hbmRzKG5hbWUpO1xuICBcbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGFuZCBleGVjdXRlIGFsbCB0aGUgc3RvcmVkIGNvbW1hbmQgaW5zdGFuY2VzXG4gICAgICAgIF8uZWFjaChjb21tYW5kLmluc3RhbmNlcywgZnVuY3Rpb24oYXJncyl7XG4gICAgICAgICAgaGFuZGxlci5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgfSk7XG4gIFxuICAgICAgICB0aGlzLnN0b3JhZ2UuY2xlYXJDb21tYW5kcyhuYW1lKTtcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIGluaXRpYWxpemUgc3RvcmFnZSBlaXRoZXIgZnJvbSB0aGUgdHlwZSdzXG4gICAgICAvLyBgc3RvcmFnZVR5cGVgIG9yIHRoZSBpbnN0YW5jZSBgb3B0aW9ucy5zdG9yYWdlVHlwZWAuXG4gICAgICBfaW5pdGlhbGl6ZVN0b3JhZ2U6IGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgICAgICB2YXIgc3RvcmFnZTtcbiAgXG4gICAgICAgIHZhciBTdG9yYWdlVHlwZSA9IG9wdGlvbnMuc3RvcmFnZVR5cGUgfHwgdGhpcy5zdG9yYWdlVHlwZTtcbiAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihTdG9yYWdlVHlwZSkpe1xuICAgICAgICAgIHN0b3JhZ2UgPSBuZXcgU3RvcmFnZVR5cGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdG9yYWdlID0gU3RvcmFnZVR5cGU7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgICB9XG4gICAgfSk7XG4gIFxuICB9KShXcmVxciwgXyk7XG4gIFxuICAvLyBXcmVxci5SZXF1ZXN0UmVzcG9uc2VcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vIEEgc2ltcGxlIHJlcXVlc3QvcmVzcG9uc2UgaW1wbGVtZW50YXRpb24uIFJlZ2lzdGVyIGFcbiAgLy8gcmVxdWVzdCBoYW5kbGVyLCBhbmQgcmV0dXJuIGEgcmVzcG9uc2UgZnJvbSBpdFxuICBXcmVxci5SZXF1ZXN0UmVzcG9uc2UgPSAoZnVuY3Rpb24oV3JlcXIsIF8pe1xuICAgIFwidXNlIHN0cmljdFwiO1xuICBcbiAgICByZXR1cm4gV3JlcXIuSGFuZGxlcnMuZXh0ZW5kKHtcbiAgICAgIHJlcXVlc3Q6IGZ1bmN0aW9uKG5hbWUpe1xuICAgICAgICBpZiAodGhpcy5oYXNIYW5kbGVyKG5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SGFuZGxlcihuYW1lKS5hcHBseSh0aGlzLCBfLnJlc3QoYXJndW1lbnRzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgXG4gIH0pKFdyZXFyLCBfKTtcbiAgXG4gIC8vIEV2ZW50IEFnZ3JlZ2F0b3JcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBBIHB1Yi1zdWIgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gZGVjb3VwbGUgdmFyaW91cyBwYXJ0c1xuICAvLyBvZiBhbiBhcHBsaWNhdGlvbiB0aHJvdWdoIGV2ZW50LWRyaXZlbiBhcmNoaXRlY3R1cmUuXG4gIFxuICBXcmVxci5FdmVudEFnZ3JlZ2F0b3IgPSAoZnVuY3Rpb24oQmFja2JvbmUsIF8pe1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBFQSA9IGZ1bmN0aW9uKCl7fTtcbiAgXG4gICAgLy8gQ29weSB0aGUgYGV4dGVuZGAgZnVuY3Rpb24gdXNlZCBieSBCYWNrYm9uZSdzIGNsYXNzZXNcbiAgICBFQS5leHRlbmQgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQ7XG4gIFxuICAgIC8vIENvcHkgdGhlIGJhc2ljIEJhY2tib25lLkV2ZW50cyBvbiB0byB0aGUgZXZlbnQgYWdncmVnYXRvclxuICAgIF8uZXh0ZW5kKEVBLnByb3RvdHlwZSwgQmFja2JvbmUuRXZlbnRzKTtcbiAgXG4gICAgcmV0dXJuIEVBO1xuICB9KShCYWNrYm9uZSwgXyk7XG4gIFxuICAvLyBXcmVxci5DaGFubmVsXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vIEFuIG9iamVjdCB0aGF0IHdyYXBzIHRoZSB0aHJlZSBtZXNzYWdpbmcgc3lzdGVtczpcbiAgLy8gRXZlbnRBZ2dyZWdhdG9yLCBSZXF1ZXN0UmVzcG9uc2UsIENvbW1hbmRzXG4gIFdyZXFyLkNoYW5uZWwgPSAoZnVuY3Rpb24oV3JlcXIpe1xuICAgIFwidXNlIHN0cmljdFwiO1xuICBcbiAgICB2YXIgQ2hhbm5lbCA9IGZ1bmN0aW9uKGNoYW5uZWxOYW1lKSB7XG4gICAgICB0aGlzLnZlbnQgICAgICAgID0gbmV3IEJhY2tib25lLldyZXFyLkV2ZW50QWdncmVnYXRvcigpO1xuICAgICAgdGhpcy5yZXFyZXMgICAgICA9IG5ldyBCYWNrYm9uZS5XcmVxci5SZXF1ZXN0UmVzcG9uc2UoKTtcbiAgICAgIHRoaXMuY29tbWFuZHMgICAgPSBuZXcgQmFja2JvbmUuV3JlcXIuQ29tbWFuZHMoKTtcbiAgICAgIHRoaXMuY2hhbm5lbE5hbWUgPSBjaGFubmVsTmFtZTtcbiAgICB9O1xuICBcbiAgICBfLmV4dGVuZChDaGFubmVsLnByb3RvdHlwZSwge1xuICBcbiAgICAgIC8vIFJlbW92ZSBhbGwgaGFuZGxlcnMgZnJvbSB0aGUgbWVzc2FnaW5nIHN5c3RlbXMgb2YgdGhpcyBjaGFubmVsXG4gICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudmVudC5vZmYoKTtcbiAgICAgICAgdGhpcy52ZW50LnN0b3BMaXN0ZW5pbmcoKTtcbiAgICAgICAgdGhpcy5yZXFyZXMucmVtb3ZlQWxsSGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy5jb21tYW5kcy5yZW1vdmVBbGxIYW5kbGVycygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gIFxuICAgICAgLy8gQ29ubmVjdCBhIGhhc2ggb2YgZXZlbnRzOyBvbmUgZm9yIGVhY2ggbWVzc2FnaW5nIHN5c3RlbVxuICAgICAgY29ubmVjdEV2ZW50czogZnVuY3Rpb24oaGFzaCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLl9jb25uZWN0KCd2ZW50JywgaGFzaCwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgXG4gICAgICBjb25uZWN0Q29tbWFuZHM6IGZ1bmN0aW9uKGhhc2gsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdCgnY29tbWFuZHMnLCBoYXNoLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICBcbiAgICAgIGNvbm5lY3RSZXF1ZXN0czogZnVuY3Rpb24oaGFzaCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLl9jb25uZWN0KCdyZXFyZXMnLCBoYXNoLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICBcbiAgICAgIC8vIEF0dGFjaCB0aGUgaGFuZGxlcnMgdG8gYSBnaXZlbiBtZXNzYWdlIHN5c3RlbSBgdHlwZWBcbiAgICAgIF9jb25uZWN0OiBmdW5jdGlvbih0eXBlLCBoYXNoLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghaGFzaCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICBcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcztcbiAgICAgICAgdmFyIG1ldGhvZCA9ICh0eXBlID09PSAndmVudCcpID8gJ29uJyA6ICdzZXRIYW5kbGVyJztcbiAgXG4gICAgICAgIF8uZWFjaChoYXNoLCBmdW5jdGlvbihmbiwgZXZlbnROYW1lKSB7XG4gICAgICAgICAgdGhpc1t0eXBlXVttZXRob2RdKGV2ZW50TmFtZSwgXy5iaW5kKGZuLCBjb250ZXh0KSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICBcbiAgXG4gICAgcmV0dXJuIENoYW5uZWw7XG4gIH0pKFdyZXFyKTtcbiAgXG4gIC8vIFdyZXFyLlJhZGlvXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG4gIC8vXG4gIC8vIEFuIG9iamVjdCB0aGF0IGxldHMgeW91IGNvbW11bmljYXRlIHdpdGggbWFueSBjaGFubmVscy5cbiAgV3JlcXIucmFkaW8gPSAoZnVuY3Rpb24oV3JlcXIsIF8pe1xuICAgIFwidXNlIHN0cmljdFwiO1xuICBcbiAgICB2YXIgUmFkaW8gPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NoYW5uZWxzID0ge307XG4gICAgICB0aGlzLnZlbnQgPSB7fTtcbiAgICAgIHRoaXMuY29tbWFuZHMgPSB7fTtcbiAgICAgIHRoaXMucmVxcmVzID0ge307XG4gICAgICB0aGlzLl9wcm94eU1ldGhvZHMoKTtcbiAgICB9O1xuICBcbiAgICBfLmV4dGVuZChSYWRpby5wcm90b3R5cGUsIHtcbiAgXG4gICAgICBjaGFubmVsOiBmdW5jdGlvbihjaGFubmVsTmFtZSkge1xuICAgICAgICBpZiAoIWNoYW5uZWxOYW1lKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGFubmVsIG11c3QgcmVjZWl2ZSBhIG5hbWUnKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldENoYW5uZWwoIGNoYW5uZWxOYW1lICk7XG4gICAgICB9LFxuICBcbiAgICAgIF9nZXRDaGFubmVsOiBmdW5jdGlvbihjaGFubmVsTmFtZSkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuX2NoYW5uZWxzW2NoYW5uZWxOYW1lXTtcbiAgXG4gICAgICAgIGlmKCFjaGFubmVsKSB7XG4gICAgICAgICAgY2hhbm5lbCA9IG5ldyBXcmVxci5DaGFubmVsKGNoYW5uZWxOYW1lKTtcbiAgICAgICAgICB0aGlzLl9jaGFubmVsc1tjaGFubmVsTmFtZV0gPSBjaGFubmVsO1xuICAgICAgICB9XG4gIFxuICAgICAgICByZXR1cm4gY2hhbm5lbDtcbiAgICAgIH0sXG4gIFxuICAgICAgX3Byb3h5TWV0aG9kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIF8uZWFjaChbJ3ZlbnQnLCAnY29tbWFuZHMnLCAncmVxcmVzJ10sIGZ1bmN0aW9uKHN5c3RlbSkge1xuICAgICAgICAgIF8uZWFjaCggbWVzc2FnZVN5c3RlbXNbc3lzdGVtXSwgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICB0aGlzW3N5c3RlbV1bbWV0aG9kXSA9IHByb3h5TWV0aG9kKHRoaXMsIHN5c3RlbSwgbWV0aG9kKTtcbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIFxuICBcbiAgICB2YXIgbWVzc2FnZVN5c3RlbXMgPSB7XG4gICAgICB2ZW50OiBbXG4gICAgICAgICdvbicsXG4gICAgICAgICdvZmYnLFxuICAgICAgICAndHJpZ2dlcicsXG4gICAgICAgICdvbmNlJyxcbiAgICAgICAgJ3N0b3BMaXN0ZW5pbmcnLFxuICAgICAgICAnbGlzdGVuVG8nLFxuICAgICAgICAnbGlzdGVuVG9PbmNlJ1xuICAgICAgXSxcbiAgXG4gICAgICBjb21tYW5kczogW1xuICAgICAgICAnZXhlY3V0ZScsXG4gICAgICAgICdzZXRIYW5kbGVyJyxcbiAgICAgICAgJ3NldEhhbmRsZXJzJyxcbiAgICAgICAgJ3JlbW92ZUhhbmRsZXInLFxuICAgICAgICAncmVtb3ZlQWxsSGFuZGxlcnMnXG4gICAgICBdLFxuICBcbiAgICAgIHJlcXJlczogW1xuICAgICAgICAncmVxdWVzdCcsXG4gICAgICAgICdzZXRIYW5kbGVyJyxcbiAgICAgICAgJ3NldEhhbmRsZXJzJyxcbiAgICAgICAgJ3JlbW92ZUhhbmRsZXInLFxuICAgICAgICAncmVtb3ZlQWxsSGFuZGxlcnMnXG4gICAgICBdXG4gICAgfTtcbiAgXG4gICAgdmFyIHByb3h5TWV0aG9kID0gZnVuY3Rpb24ocmFkaW8sIHN5c3RlbSwgbWV0aG9kKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY2hhbm5lbE5hbWUpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2VTeXN0ZW0gPSByYWRpby5fZ2V0Q2hhbm5lbChjaGFubmVsTmFtZSlbc3lzdGVtXTtcbiAgXG4gICAgICAgIHJldHVybiBtZXNzYWdlU3lzdGVtW21ldGhvZF0uYXBwbHkobWVzc2FnZVN5c3RlbSwgXy5yZXN0KGFyZ3VtZW50cykpO1xuICAgICAgfTtcbiAgICB9O1xuICBcbiAgICByZXR1cm4gbmV3IFJhZGlvKCk7XG4gIFxuICB9KShXcmVxciwgXyk7XG4gIFxuXG4gIHJldHVybiBCYWNrYm9uZS5XcmVxcjtcblxufSkpO1xuIiwiLy8gQmFja2JvbmUuUmFkaW8gdjAuOS4xXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpLCByZXF1aXJlKFwiYmFja2JvbmVcIikpIDogdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoW1widW5kZXJzY29yZVwiLCBcImJhY2tib25lXCJdLCBmYWN0b3J5KSA6IGdsb2JhbC5CYWNrYm9uZS5SYWRpbyA9IGZhY3RvcnkoZ2xvYmFsLl8sIGdsb2JhbC5CYWNrYm9uZSk7XG59KSh0aGlzLCBmdW5jdGlvbiAoXywgQmFja2JvbmUpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIHByZXZpb3VzUmFkaW8gPSBCYWNrYm9uZS5SYWRpbztcblxuICB2YXIgUmFkaW8gPSBCYWNrYm9uZS5SYWRpbyA9IHt9O1xuXG4gIFJhZGlvLlZFUlNJT04gPSBcIjAuOS4xXCI7XG5cbiAgLy8gVGhpcyBhbGxvd3MgeW91IHRvIHJ1biBtdWx0aXBsZSBpbnN0YW5jZXMgb2YgUmFkaW8gb24gdGhlIHNhbWVcbiAgLy8gd2ViYXBwLiBBZnRlciBsb2FkaW5nIHRoZSBuZXcgdmVyc2lvbiwgY2FsbCBgbm9Db25mbGljdCgpYCB0b1xuICAvLyBnZXQgYSByZWZlcmVuY2UgdG8gaXQuIEF0IHRoZSBzYW1lIHRpbWUgdGhlIG9sZCB2ZXJzaW9uIHdpbGwgYmVcbiAgLy8gcmV0dXJuZWQgdG8gQmFja2JvbmUuUmFkaW8uXG4gIFJhZGlvLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgQmFja2JvbmUuUmFkaW8gPSBwcmV2aW91c1JhZGlvO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFdoZXRoZXIgb3Igbm90IHdlJ3JlIGluIERFQlVHIG1vZGUgb3Igbm90LiBERUJVRyBtb2RlIGhlbHBzIHlvdVxuICAvLyBnZXQgYXJvdW5kIHRoZSBpc3N1ZXMgb2YgbGFjayBvZiB3YXJuaW5ncyB3aGVuIGV2ZW50cyBhcmUgbWlzLXR5cGVkLlxuICBSYWRpby5ERUJVRyA9IGZhbHNlO1xuXG4gIC8vIEZvcm1hdCBkZWJ1ZyB0ZXh0LlxuICBSYWRpby5fZGVidWdUZXh0ID0gZnVuY3Rpb24gKHdhcm5pbmcsIGV2ZW50TmFtZSwgY2hhbm5lbE5hbWUpIHtcbiAgICByZXR1cm4gd2FybmluZyArIChjaGFubmVsTmFtZSA/IFwiIG9uIHRoZSBcIiArIGNoYW5uZWxOYW1lICsgXCIgY2hhbm5lbFwiIDogXCJcIikgKyBcIjogXFxcIlwiICsgZXZlbnROYW1lICsgXCJcXFwiXCI7XG4gIH07XG5cbiAgLy8gVGhpcyBpcyB0aGUgbWV0aG9kIHRoYXQncyBjYWxsZWQgd2hlbiBhbiB1bnJlZ2lzdGVyZWQgZXZlbnQgd2FzIGNhbGxlZC5cbiAgLy8gQnkgZGVmYXVsdCwgaXQgbG9ncyB3YXJuaW5nIHRvIHRoZSBjb25zb2xlLiBCeSBvdmVycmlkaW5nIHRoaXMgeW91IGNvdWxkXG4gIC8vIG1ha2UgaXQgdGhyb3cgYW4gRXJyb3IsIGZvciBpbnN0YW5jZS4gVGhpcyB3b3VsZCBtYWtlIGZpcmluZyBhIG5vbmV4aXN0ZW50IGV2ZW50XG4gIC8vIGhhdmUgdGhlIHNhbWUgY29uc2VxdWVuY2UgYXMgZmlyaW5nIGEgbm9uZXhpc3RlbnQgbWV0aG9kIG9uIGFuIE9iamVjdC5cbiAgUmFkaW8uZGVidWdMb2cgPSBmdW5jdGlvbiAod2FybmluZywgZXZlbnROYW1lLCBjaGFubmVsTmFtZSkge1xuICAgIGlmIChSYWRpby5ERUJVRyAmJiBjb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgY29uc29sZS53YXJuKFJhZGlvLl9kZWJ1Z1RleHQod2FybmluZywgZXZlbnROYW1lLCBjaGFubmVsTmFtZSkpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZXZlbnRTcGxpdHRlciA9IC9cXHMrLztcblxuICAvLyBBbiBpbnRlcm5hbCBtZXRob2QgdXNlZCB0byBoYW5kbGUgUmFkaW8ncyBtZXRob2Qgb3ZlcmxvYWRpbmcgZm9yIFJlcXVlc3RzIGFuZFxuICAvLyBDb21tYW5kcy4gSXQncyBib3Jyb3dlZCBmcm9tIEJhY2tib25lLkV2ZW50cy4gSXQgZGlmZmVycyBmcm9tIEJhY2tib25lJ3Mgb3ZlcmxvYWRcbiAgLy8gQVBJICh3aGljaCBpcyB1c2VkIGluIEJhY2tib25lLkV2ZW50cykgaW4gdGhhdCBpdCBkb2Vzbid0IHN1cHBvcnQgc3BhY2Utc2VwYXJhdGVkXG4gIC8vIGV2ZW50IG5hbWVzLlxuICBSYWRpby5fZXZlbnRzQXBpID0gZnVuY3Rpb24gKG9iaiwgYWN0aW9uLCBuYW1lLCByZXN0KSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdHMgPSB7fTtcblxuICAgIC8vIEhhbmRsZSBldmVudCBtYXBzLlxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgZm9yICh2YXIga2V5IGluIG5hbWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9ialthY3Rpb25dLmFwcGx5KG9iaiwgW2tleSwgbmFtZVtrZXldXS5jb25jYXQocmVzdCkpO1xuICAgICAgICBldmVudFNwbGl0dGVyLnRlc3Qoa2V5KSA/IF8uZXh0ZW5kKHJlc3VsdHMsIHJlc3VsdCkgOiByZXN1bHRzW2tleV0gPSByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgc3BhY2Ugc2VwYXJhdGVkIGV2ZW50IG5hbWVzLlxuICAgIGlmIChldmVudFNwbGl0dGVyLnRlc3QobmFtZSkpIHtcbiAgICAgIHZhciBuYW1lcyA9IG5hbWUuc3BsaXQoZXZlbnRTcGxpdHRlcik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICByZXN1bHRzW25hbWVzW2ldXSA9IG9ialthY3Rpb25dLmFwcGx5KG9iaiwgW25hbWVzW2ldXS5jb25jYXQocmVzdCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIEFuIG9wdGltaXplZCB3YXkgdG8gZXhlY3V0ZSBjYWxsYmFja3MuXG4gIFJhZGlvLl9jYWxsSGFuZGxlciA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCwgYXJncykge1xuICAgIHZhciBhMSA9IGFyZ3NbMF0sXG4gICAgICAgIGEyID0gYXJnc1sxXSxcbiAgICAgICAgYTMgPSBhcmdzWzJdO1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoY29udGV4dCk7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGExKTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgYTEsIGEyKTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgYTEsIGEyLCBhMyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEEgaGVscGVyIHVzZWQgYnkgYG9mZmAgbWV0aG9kcyB0byB0aGUgaGFuZGxlciBmcm9tIHRoZSBzdG9yZVxuICBmdW5jdGlvbiByZW1vdmVIYW5kbGVyKHN0b3JlLCBuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIHZhciBldmVudCA9IHN0b3JlW25hbWVdO1xuICAgIGlmICgoIWNhbGxiYWNrIHx8IChjYWxsYmFjayA9PT0gZXZlbnQuY2FsbGJhY2sgfHwgY2FsbGJhY2sgPT09IGV2ZW50LmNhbGxiYWNrLl9jYWxsYmFjaykpICYmICghY29udGV4dCB8fCBjb250ZXh0ID09PSBldmVudC5jb250ZXh0KSkge1xuICAgICAgZGVsZXRlIHN0b3JlW25hbWVdO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlSGFuZGxlcnMoc3RvcmUsIG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgc3RvcmUgfHwgKHN0b3JlID0ge30pO1xuICAgIHZhciBuYW1lcyA9IG5hbWUgPyBbbmFtZV0gOiBfLmtleXMoc3RvcmUpO1xuICAgIHZhciBtYXRjaGVkID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbmFtZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIG5hbWUgPSBuYW1lc1tpXTtcblxuICAgICAgLy8gSWYgdGhlcmUncyBubyBldmVudCBieSB0aGlzIG5hbWUsIGxvZyBpdCBhbmQgY29udGludWVcbiAgICAgIC8vIHdpdGggdGhlIGxvb3BcbiAgICAgIGlmICghc3RvcmVbbmFtZV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW1vdmVIYW5kbGVyKHN0b3JlLCBuYW1lLCBjYWxsYmFjaywgY29udGV4dCkpIHtcbiAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoZWQ7XG4gIH1cblxuICAvKlxuICAgKiB0dW5lLWluXG4gICAqIC0tLS0tLS1cbiAgICogR2V0IGNvbnNvbGUgbG9ncyBvZiBhIGNoYW5uZWwncyBhY3Rpdml0eVxuICAgKlxuICAgKi9cblxuICB2YXIgX2xvZ3MgPSB7fTtcblxuICAvLyBUaGlzIGlzIHRvIHByb2R1Y2UgYW4gaWRlbnRpY2FsIGZ1bmN0aW9uIGluIGJvdGggdHVuZUluIGFuZCB0dW5lT3V0LFxuICAvLyBzbyB0aGF0IEJhY2tib25lLkV2ZW50cyB1bnJlZ2lzdGVycyBpdC5cbiAgZnVuY3Rpb24gX3BhcnRpYWwoY2hhbm5lbE5hbWUpIHtcbiAgICByZXR1cm4gX2xvZ3NbY2hhbm5lbE5hbWVdIHx8IChfbG9nc1tjaGFubmVsTmFtZV0gPSBfLnBhcnRpYWwoUmFkaW8ubG9nLCBjaGFubmVsTmFtZSkpO1xuICB9XG5cbiAgXy5leHRlbmQoUmFkaW8sIHtcblxuICAgIC8vIExvZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2hhbm5lbCBhbmQgZXZlbnRcbiAgICBsb2c6IGZ1bmN0aW9uIGxvZyhjaGFubmVsTmFtZSwgZXZlbnROYW1lKSB7XG4gICAgICB2YXIgYXJncyA9IF8ucmVzdChhcmd1bWVudHMsIDIpO1xuICAgICAgY29uc29sZS5sb2coXCJbXCIgKyBjaGFubmVsTmFtZSArIFwiXSBcXFwiXCIgKyBldmVudE5hbWUgKyBcIlxcXCJcIiwgYXJncyk7XG4gICAgfSxcblxuICAgIC8vIExvZ3MgYWxsIGV2ZW50cyBvbiB0aGlzIGNoYW5uZWwgdG8gdGhlIGNvbnNvbGUuIEl0IHNldHMgYW5cbiAgICAvLyBpbnRlcm5hbCB2YWx1ZSBvbiB0aGUgY2hhbm5lbCB0ZWxsaW5nIGl0IHdlJ3JlIGxpc3RlbmluZyxcbiAgICAvLyB0aGVuIHNldHMgYSBsaXN0ZW5lciBvbiB0aGUgQmFja2JvbmUuRXZlbnRzXG4gICAgdHVuZUluOiBmdW5jdGlvbiB0dW5lSW4oY2hhbm5lbE5hbWUpIHtcbiAgICAgIHZhciBjaGFubmVsID0gUmFkaW8uY2hhbm5lbChjaGFubmVsTmFtZSk7XG4gICAgICBjaGFubmVsLl90dW5lZEluID0gdHJ1ZTtcbiAgICAgIGNoYW5uZWwub24oXCJhbGxcIiwgX3BhcnRpYWwoY2hhbm5lbE5hbWUpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBTdG9wIGxvZ2dpbmcgYWxsIG9mIHRoZSBhY3Rpdml0aWVzIG9uIHRoaXMgY2hhbm5lbCB0byB0aGUgY29uc29sZVxuICAgIHR1bmVPdXQ6IGZ1bmN0aW9uIHR1bmVPdXQoY2hhbm5lbE5hbWUpIHtcbiAgICAgIHZhciBjaGFubmVsID0gUmFkaW8uY2hhbm5lbChjaGFubmVsTmFtZSk7XG4gICAgICBjaGFubmVsLl90dW5lZEluID0gZmFsc2U7XG4gICAgICBjaGFubmVsLm9mZihcImFsbFwiLCBfcGFydGlhbChjaGFubmVsTmFtZSkpO1xuICAgICAgZGVsZXRlIF9sb2dzW2NoYW5uZWxOYW1lXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG5cbiAgLypcbiAgICogQmFja2JvbmUuUmFkaW8uQ29tbWFuZHNcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQSBtZXNzYWdpbmcgc3lzdGVtIGZvciBzZW5kaW5nIG9yZGVycy5cbiAgICpcbiAgICovXG5cbiAgUmFkaW8uQ29tbWFuZHMgPSB7XG5cbiAgICAvLyBJc3N1ZSBhIGNvbW1hbmRcbiAgICBjb21tYW5kOiBmdW5jdGlvbiBjb21tYW5kKG5hbWUpIHtcbiAgICAgIHZhciBhcmdzID0gXy5yZXN0KGFyZ3VtZW50cyk7XG4gICAgICBpZiAoUmFkaW8uX2V2ZW50c0FwaSh0aGlzLCBcImNvbW1hbmRcIiwgbmFtZSwgYXJncykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgY2hhbm5lbE5hbWUgPSB0aGlzLmNoYW5uZWxOYW1lO1xuICAgICAgdmFyIGNvbW1hbmRzID0gdGhpcy5fY29tbWFuZHM7XG5cbiAgICAgIC8vIENoZWNrIGlmIHdlIHNob3VsZCBsb2cgdGhlIGNvbW1hbmQsIGFuZCBpZiBzbywgZG8gaXRcbiAgICAgIGlmIChjaGFubmVsTmFtZSAmJiB0aGlzLl90dW5lZEluKSB7XG4gICAgICAgIFJhZGlvLmxvZy5hcHBseSh0aGlzLCBbY2hhbm5lbE5hbWUsIG5hbWVdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBjb21tYW5kIGlzbid0IGhhbmRsZWQsIGxvZyBpdCBpbiBERUJVRyBtb2RlIGFuZCBleGl0XG4gICAgICBpZiAoY29tbWFuZHMgJiYgKGNvbW1hbmRzW25hbWVdIHx8IGNvbW1hbmRzW1wiZGVmYXVsdFwiXSkpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBjb21tYW5kc1tuYW1lXSB8fCBjb21tYW5kc1tcImRlZmF1bHRcIl07XG4gICAgICAgIGFyZ3MgPSBjb21tYW5kc1tuYW1lXSA/IGFyZ3MgOiBhcmd1bWVudHM7XG4gICAgICAgIFJhZGlvLl9jYWxsSGFuZGxlcihoYW5kbGVyLmNhbGxiYWNrLCBoYW5kbGVyLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmFkaW8uZGVidWdMb2coXCJBbiB1bmhhbmRsZWQgY29tbWFuZCB3YXMgZmlyZWRcIiwgbmFtZSwgY2hhbm5lbE5hbWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmVnaXN0ZXIgYSBoYW5kbGVyIGZvciBhIGNvbW1hbmQuXG4gICAgY29tcGx5OiBmdW5jdGlvbiBjb21wbHkobmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIGlmIChSYWRpby5fZXZlbnRzQXBpKHRoaXMsIFwiY29tcGx5XCIsIG5hbWUsIFtjYWxsYmFjaywgY29udGV4dF0pKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29tbWFuZHMgfHwgKHRoaXMuX2NvbW1hbmRzID0ge30pO1xuXG4gICAgICBpZiAodGhpcy5fY29tbWFuZHNbbmFtZV0pIHtcbiAgICAgICAgUmFkaW8uZGVidWdMb2coXCJBIGNvbW1hbmQgd2FzIG92ZXJ3cml0dGVuXCIsIG5hbWUsIHRoaXMuY2hhbm5lbE5hbWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jb21tYW5kc1tuYW1lXSA9IHtcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0IHx8IHRoaXNcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBSZWdpc3RlciBhIGhhbmRsZXIgZm9yIGEgY29tbWFuZCB0aGF0IGhhcHBlbnMganVzdCBvbmNlLlxuICAgIGNvbXBseU9uY2U6IGZ1bmN0aW9uIGNvbXBseU9uY2UobmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIGlmIChSYWRpby5fZXZlbnRzQXBpKHRoaXMsIFwiY29tcGx5T25jZVwiLCBuYW1lLCBbY2FsbGJhY2ssIGNvbnRleHRdKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgdmFyIG9uY2UgPSBfLm9uY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnN0b3BDb21wbHlpbmcobmFtZSk7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBseShuYW1lLCBvbmNlLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGhhbmRsZXIocylcbiAgICBzdG9wQ29tcGx5aW5nOiBmdW5jdGlvbiBzdG9wQ29tcGx5aW5nKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICBpZiAoUmFkaW8uX2V2ZW50c0FwaSh0aGlzLCBcInN0b3BDb21wbHlpbmdcIiwgbmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBldmVyeXRoaW5nIGlmIHRoZXJlIGFyZSBubyBhcmd1bWVudHMgcGFzc2VkXG4gICAgICBpZiAoIW5hbWUgJiYgIWNhbGxiYWNrICYmICFjb250ZXh0KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9jb21tYW5kcztcbiAgICAgIH0gZWxzZSBpZiAoIXJlbW92ZUhhbmRsZXJzKHRoaXMuX2NvbW1hbmRzLCBuYW1lLCBjYWxsYmFjaywgY29udGV4dCkpIHtcbiAgICAgICAgUmFkaW8uZGVidWdMb2coXCJBdHRlbXB0ZWQgdG8gcmVtb3ZlIHRoZSB1bnJlZ2lzdGVyZWQgY29tbWFuZFwiLCBuYW1lLCB0aGlzLmNoYW5uZWxOYW1lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuXG4gIC8qXG4gICAqIEJhY2tib25lLlJhZGlvLlJlcXVlc3RzXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEEgbWVzc2FnaW5nIHN5c3RlbSBmb3IgcmVxdWVzdGluZyBkYXRhLlxuICAgKlxuICAgKi9cblxuICBmdW5jdGlvbiBtYWtlQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKGNhbGxiYWNrKSA/IGNhbGxiYWNrIDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgIH07XG4gIH1cblxuICBSYWRpby5SZXF1ZXN0cyA9IHtcblxuICAgIC8vIE1ha2UgYSByZXF1ZXN0XG4gICAgcmVxdWVzdDogZnVuY3Rpb24gcmVxdWVzdChuYW1lKSB7XG4gICAgICB2YXIgYXJncyA9IF8ucmVzdChhcmd1bWVudHMpO1xuICAgICAgdmFyIHJlc3VsdHMgPSBSYWRpby5fZXZlbnRzQXBpKHRoaXMsIFwicmVxdWVzdFwiLCBuYW1lLCBhcmdzKTtcbiAgICAgIGlmIChyZXN1bHRzKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfVxuICAgICAgdmFyIGNoYW5uZWxOYW1lID0gdGhpcy5jaGFubmVsTmFtZTtcbiAgICAgIHZhciByZXF1ZXN0cyA9IHRoaXMuX3JlcXVlc3RzO1xuXG4gICAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgbG9nIHRoZSByZXF1ZXN0LCBhbmQgaWYgc28sIGRvIGl0XG4gICAgICBpZiAoY2hhbm5lbE5hbWUgJiYgdGhpcy5fdHVuZWRJbikge1xuICAgICAgICBSYWRpby5sb2cuYXBwbHkodGhpcywgW2NoYW5uZWxOYW1lLCBuYW1lXS5jb25jYXQoYXJncykpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgcmVxdWVzdCBpc24ndCBoYW5kbGVkLCBsb2cgaXQgaW4gREVCVUcgbW9kZSBhbmQgZXhpdFxuICAgICAgaWYgKHJlcXVlc3RzICYmIChyZXF1ZXN0c1tuYW1lXSB8fCByZXF1ZXN0c1tcImRlZmF1bHRcIl0pKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gcmVxdWVzdHNbbmFtZV0gfHwgcmVxdWVzdHNbXCJkZWZhdWx0XCJdO1xuICAgICAgICBhcmdzID0gcmVxdWVzdHNbbmFtZV0gPyBhcmdzIDogYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gUmFkaW8uX2NhbGxIYW5kbGVyKGhhbmRsZXIuY2FsbGJhY2ssIGhhbmRsZXIuY29udGV4dCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSYWRpby5kZWJ1Z0xvZyhcIkFuIHVuaGFuZGxlZCByZXF1ZXN0IHdhcyBmaXJlZFwiLCBuYW1lLCBjaGFubmVsTmFtZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFNldCB1cCBhIGhhbmRsZXIgZm9yIGEgcmVxdWVzdFxuICAgIHJlcGx5OiBmdW5jdGlvbiByZXBseShuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgaWYgKFJhZGlvLl9ldmVudHNBcGkodGhpcywgXCJyZXBseVwiLCBuYW1lLCBbY2FsbGJhY2ssIGNvbnRleHRdKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVxdWVzdHMgfHwgKHRoaXMuX3JlcXVlc3RzID0ge30pO1xuXG4gICAgICBpZiAodGhpcy5fcmVxdWVzdHNbbmFtZV0pIHtcbiAgICAgICAgUmFkaW8uZGVidWdMb2coXCJBIHJlcXVlc3Qgd2FzIG92ZXJ3cml0dGVuXCIsIG5hbWUsIHRoaXMuY2hhbm5lbE5hbWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZXF1ZXN0c1tuYW1lXSA9IHtcbiAgICAgICAgY2FsbGJhY2s6IG1ha2VDYWxsYmFjayhjYWxsYmFjayksXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQgfHwgdGhpc1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFNldCB1cCBhIGhhbmRsZXIgdGhhdCBjYW4gb25seSBiZSByZXF1ZXN0ZWQgb25jZVxuICAgIHJlcGx5T25jZTogZnVuY3Rpb24gcmVwbHlPbmNlKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICBpZiAoUmFkaW8uX2V2ZW50c0FwaSh0aGlzLCBcInJlcGx5T25jZVwiLCBuYW1lLCBbY2FsbGJhY2ssIGNvbnRleHRdKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICB2YXIgb25jZSA9IF8ub25jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuc3RvcFJlcGx5aW5nKG5hbWUpO1xuICAgICAgICByZXR1cm4gbWFrZUNhbGxiYWNrKGNhbGxiYWNrKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzLnJlcGx5KG5hbWUsIG9uY2UsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgaGFuZGxlcihzKVxuICAgIHN0b3BSZXBseWluZzogZnVuY3Rpb24gc3RvcFJlcGx5aW5nKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICBpZiAoUmFkaW8uX2V2ZW50c0FwaSh0aGlzLCBcInN0b3BSZXBseWluZ1wiLCBuYW1lKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIGV2ZXJ5dGhpbmcgaWYgdGhlcmUgYXJlIG5vIGFyZ3VtZW50cyBwYXNzZWRcbiAgICAgIGlmICghbmFtZSAmJiAhY2FsbGJhY2sgJiYgIWNvbnRleHQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3JlcXVlc3RzO1xuICAgICAgfSBlbHNlIGlmICghcmVtb3ZlSGFuZGxlcnModGhpcy5fcmVxdWVzdHMsIG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSkge1xuICAgICAgICBSYWRpby5kZWJ1Z0xvZyhcIkF0dGVtcHRlZCB0byByZW1vdmUgdGhlIHVucmVnaXN0ZXJlZCByZXF1ZXN0XCIsIG5hbWUsIHRoaXMuY2hhbm5lbE5hbWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG5cbiAgLypcbiAgICogQmFja2JvbmUuUmFkaW8uY2hhbm5lbFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEdldCBhIHJlZmVyZW5jZSB0byBhIGNoYW5uZWwgYnkgbmFtZS5cbiAgICpcbiAgICovXG5cbiAgUmFkaW8uX2NoYW5uZWxzID0ge307XG5cbiAgUmFkaW8uY2hhbm5lbCA9IGZ1bmN0aW9uIChjaGFubmVsTmFtZSkge1xuICAgIGlmICghY2hhbm5lbE5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHByb3ZpZGUgYSBuYW1lIGZvciB0aGUgY2hhbm5lbC5cIik7XG4gICAgfVxuXG4gICAgaWYgKFJhZGlvLl9jaGFubmVsc1tjaGFubmVsTmFtZV0pIHtcbiAgICAgIHJldHVybiBSYWRpby5fY2hhbm5lbHNbY2hhbm5lbE5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUmFkaW8uX2NoYW5uZWxzW2NoYW5uZWxOYW1lXSA9IG5ldyBSYWRpby5DaGFubmVsKGNoYW5uZWxOYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgLypcbiAgICogQmFja2JvbmUuUmFkaW8uQ2hhbm5lbFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEEgQ2hhbm5lbCBpcyBhbiBvYmplY3QgdGhhdCBleHRlbmRzIGZyb20gQmFja2JvbmUuRXZlbnRzLFxuICAgKiBSYWRpby5Db21tYW5kcywgYW5kIFJhZGlvLlJlcXVlc3RzLlxuICAgKlxuICAgKi9cblxuICBSYWRpby5DaGFubmVsID0gZnVuY3Rpb24gKGNoYW5uZWxOYW1lKSB7XG4gICAgdGhpcy5jaGFubmVsTmFtZSA9IGNoYW5uZWxOYW1lO1xuICB9O1xuXG4gIF8uZXh0ZW5kKFJhZGlvLkNoYW5uZWwucHJvdG90eXBlLCBCYWNrYm9uZS5FdmVudHMsIFJhZGlvLkNvbW1hbmRzLCBSYWRpby5SZXF1ZXN0cywge1xuXG4gICAgLy8gUmVtb3ZlIGFsbCBoYW5kbGVycyBmcm9tIHRoZSBtZXNzYWdpbmcgc3lzdGVtcyBvZiB0aGlzIGNoYW5uZWxcbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLm9mZigpO1xuICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKCk7XG4gICAgICB0aGlzLnN0b3BDb21wbHlpbmcoKTtcbiAgICAgIHRoaXMuc3RvcFJlcGx5aW5nKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xuXG4gIC8qXG4gICAqIFRvcC1sZXZlbCBBUElcbiAgICogLS0tLS0tLS0tLS0tLVxuICAgKiBTdXBwbGllcyB0aGUgJ3RvcC1sZXZlbCBBUEknIGZvciB3b3JraW5nIHdpdGggQ2hhbm5lbHMgZGlyZWN0bHlcbiAgICogZnJvbSBCYWNrYm9uZS5SYWRpby5cbiAgICpcbiAgICovXG5cbiAgdmFyIGNoYW5uZWwsXG4gICAgICBhcmdzLFxuICAgICAgc3lzdGVtcyA9IFtCYWNrYm9uZS5FdmVudHMsIFJhZGlvLkNvbW1hbmRzLCBSYWRpby5SZXF1ZXN0c107XG5cbiAgXy5lYWNoKHN5c3RlbXMsIGZ1bmN0aW9uIChzeXN0ZW0pIHtcbiAgICBfLmVhY2goc3lzdGVtLCBmdW5jdGlvbiAobWV0aG9kLCBtZXRob2ROYW1lKSB7XG4gICAgICBSYWRpb1ttZXRob2ROYW1lXSA9IGZ1bmN0aW9uIChjaGFubmVsTmFtZSkge1xuICAgICAgICBhcmdzID0gXy5yZXN0KGFyZ3VtZW50cyk7XG4gICAgICAgIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWwoY2hhbm5lbE5hbWUpO1xuICAgICAgICByZXR1cm4gY2hhbm5lbFttZXRob2ROYW1lXS5hcHBseShjaGFubmVsLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH0pO1xuXG4gIFJhZGlvLnJlc2V0ID0gZnVuY3Rpb24gKGNoYW5uZWxOYW1lKSB7XG4gICAgdmFyIGNoYW5uZWxzID0gIWNoYW5uZWxOYW1lID8gdGhpcy5fY2hhbm5lbHMgOiBbdGhpcy5fY2hhbm5lbHNbY2hhbm5lbE5hbWVdXTtcbiAgICBfLmludm9rZShjaGFubmVscywgXCJyZXNldFwiKTtcbiAgfTtcblxuICB2YXIgYmFja2JvbmVfcmFkaW8gPSBSYWRpbztcblxuICByZXR1cm4gYmFja2JvbmVfcmFkaW87XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPS4vYmFja2JvbmUucmFkaW8uanMubWFwIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuLy8gICAgIEJhY2tib25lLmpzIDEuMi4xXG5cbi8vICAgICAoYykgMjAxMC0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgQmFja2JvbmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4vLyAgICAgRm9yIGFsbCBkZXRhaWxzIGFuZCBkb2N1bWVudGF0aW9uOlxuLy8gICAgIGh0dHA6Ly9iYWNrYm9uZWpzLm9yZ1xuXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xuXG4gIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIChgc2VsZmApIGluIHRoZSBicm93c2VyLCBvciBgZ2xvYmFsYCBvbiB0aGUgc2VydmVyLlxuICAvLyBXZSB1c2UgYHNlbGZgIGluc3RlYWQgb2YgYHdpbmRvd2AgZm9yIGBXZWJXb3JrZXJgIHN1cHBvcnQuXG4gIHZhciByb290ID0gKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PSBzZWxmICYmIHNlbGYpIHx8XG4gICAgICAgICAgICAodHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwuZ2xvYmFsID09IGdsb2JhbCAmJiBnbG9iYWwpO1xuXG4gIC8vIFNldCB1cCBCYWNrYm9uZSBhcHByb3ByaWF0ZWx5IGZvciB0aGUgZW52aXJvbm1lbnQuIFN0YXJ0IHdpdGggQU1ELlxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsndW5kZXJzY29yZScsICdqcXVlcnknLCAnZXhwb3J0cyddLCBmdW5jdGlvbihfLCAkLCBleHBvcnRzKSB7XG4gICAgICAvLyBFeHBvcnQgZ2xvYmFsIGV2ZW4gaW4gQU1EIGNhc2UgaW4gY2FzZSB0aGlzIHNjcmlwdCBpcyBsb2FkZWQgd2l0aFxuICAgICAgLy8gb3RoZXJzIHRoYXQgbWF5IHN0aWxsIGV4cGVjdCBhIGdsb2JhbCBCYWNrYm9uZS5cbiAgICAgIHJvb3QuQmFja2JvbmUgPSBmYWN0b3J5KHJvb3QsIGV4cG9ydHMsIF8sICQpO1xuICAgIH0pO1xuXG4gIC8vIE5leHQgZm9yIE5vZGUuanMgb3IgQ29tbW9uSlMuIGpRdWVyeSBtYXkgbm90IGJlIG5lZWRlZCBhcyBhIG1vZHVsZS5cbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKSwgJDtcbiAgICB0cnkgeyAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7IH0gY2F0Y2goZSkge31cbiAgICBmYWN0b3J5KHJvb3QsIGV4cG9ydHMsIF8sICQpO1xuXG4gIC8vIEZpbmFsbHksIGFzIGEgYnJvd3NlciBnbG9iYWwuXG4gIH0gZWxzZSB7XG4gICAgcm9vdC5CYWNrYm9uZSA9IGZhY3Rvcnkocm9vdCwge30sIHJvb3QuXywgKHJvb3QualF1ZXJ5IHx8IHJvb3QuWmVwdG8gfHwgcm9vdC5lbmRlciB8fCByb290LiQpKTtcbiAgfVxuXG59KGZ1bmN0aW9uKHJvb3QsIEJhY2tib25lLCBfLCAkKSB7XG5cbiAgLy8gSW5pdGlhbCBTZXR1cFxuICAvLyAtLS0tLS0tLS0tLS0tXG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBCYWNrYm9uZWAgdmFyaWFibGUsIHNvIHRoYXQgaXQgY2FuIGJlXG4gIC8vIHJlc3RvcmVkIGxhdGVyIG9uLCBpZiBgbm9Db25mbGljdGAgaXMgdXNlZC5cbiAgdmFyIHByZXZpb3VzQmFja2JvbmUgPSByb290LkJhY2tib25lO1xuXG4gIC8vIENyZWF0ZSBhIGxvY2FsIHJlZmVyZW5jZSB0byBhIGNvbW1vbiBhcnJheSBtZXRob2Qgd2UnbGwgd2FudCB0byB1c2UgbGF0ZXIuXG4gIHZhciBzbGljZSA9IFtdLnNsaWNlO1xuXG4gIC8vIEN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgbGlicmFyeS4gS2VlcCBpbiBzeW5jIHdpdGggYHBhY2thZ2UuanNvbmAuXG4gIEJhY2tib25lLlZFUlNJT04gPSAnMS4yLjEnO1xuXG4gIC8vIEZvciBCYWNrYm9uZSdzIHB1cnBvc2VzLCBqUXVlcnksIFplcHRvLCBFbmRlciwgb3IgTXkgTGlicmFyeSAoa2lkZGluZykgb3duc1xuICAvLyB0aGUgYCRgIHZhcmlhYmxlLlxuICBCYWNrYm9uZS4kID0gJDtcblxuICAvLyBSdW5zIEJhY2tib25lLmpzIGluICpub0NvbmZsaWN0KiBtb2RlLCByZXR1cm5pbmcgdGhlIGBCYWNrYm9uZWAgdmFyaWFibGVcbiAgLy8gdG8gaXRzIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoaXMgQmFja2JvbmUgb2JqZWN0LlxuICBCYWNrYm9uZS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5CYWNrYm9uZSA9IHByZXZpb3VzQmFja2JvbmU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gVHVybiBvbiBgZW11bGF0ZUhUVFBgIHRvIHN1cHBvcnQgbGVnYWN5IEhUVFAgc2VydmVycy4gU2V0dGluZyB0aGlzIG9wdGlvblxuICAvLyB3aWxsIGZha2UgYFwiUEFUQ0hcImAsIGBcIlBVVFwiYCBhbmQgYFwiREVMRVRFXCJgIHJlcXVlc3RzIHZpYSB0aGUgYF9tZXRob2RgIHBhcmFtZXRlciBhbmRcbiAgLy8gc2V0IGEgYFgtSHR0cC1NZXRob2QtT3ZlcnJpZGVgIGhlYWRlci5cbiAgQmFja2JvbmUuZW11bGF0ZUhUVFAgPSBmYWxzZTtcblxuICAvLyBUdXJuIG9uIGBlbXVsYXRlSlNPTmAgdG8gc3VwcG9ydCBsZWdhY3kgc2VydmVycyB0aGF0IGNhbid0IGRlYWwgd2l0aCBkaXJlY3RcbiAgLy8gYGFwcGxpY2F0aW9uL2pzb25gIHJlcXVlc3RzIC4uLiB0aGlzIHdpbGwgZW5jb2RlIHRoZSBib2R5IGFzXG4gIC8vIGBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRgIGluc3RlYWQgYW5kIHdpbGwgc2VuZCB0aGUgbW9kZWwgaW4gYVxuICAvLyBmb3JtIHBhcmFtIG5hbWVkIGBtb2RlbGAuXG4gIEJhY2tib25lLmVtdWxhdGVKU09OID0gZmFsc2U7XG5cbiAgLy8gUHJveHkgVW5kZXJzY29yZSBtZXRob2RzIHRvIGEgQmFja2JvbmUgY2xhc3MnIHByb3RvdHlwZSB1c2luZyBhXG4gIC8vIHBhcnRpY3VsYXIgYXR0cmlidXRlIGFzIHRoZSBkYXRhIGFyZ3VtZW50XG4gIHZhciBhZGRNZXRob2QgPSBmdW5jdGlvbihsZW5ndGgsIG1ldGhvZCwgYXR0cmlidXRlKSB7XG4gICAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX1ttZXRob2RdKHRoaXNbYXR0cmlidXRlXSk7XG4gICAgICB9O1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9bbWV0aG9kXSh0aGlzW2F0dHJpYnV0ZV0sIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gX1ttZXRob2RdKHRoaXNbYXR0cmlidXRlXSwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGl0ZXJhdGVlLCBkZWZhdWx0VmFsLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBfW21ldGhvZF0odGhpc1thdHRyaWJ1dGVdLCBpdGVyYXRlZSwgZGVmYXVsdFZhbCwgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgZGVmYXVsdDogcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgYXJncy51bnNoaWZ0KHRoaXNbYXR0cmlidXRlXSk7XG4gICAgICAgIHJldHVybiBfW21ldGhvZF0uYXBwbHkoXywgYXJncyk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgdmFyIGFkZFVuZGVyc2NvcmVNZXRob2RzID0gZnVuY3Rpb24oQ2xhc3MsIG1ldGhvZHMsIGF0dHJpYnV0ZSkge1xuICAgIF8uZWFjaChtZXRob2RzLCBmdW5jdGlvbihsZW5ndGgsIG1ldGhvZCkge1xuICAgICAgaWYgKF9bbWV0aG9kXSkgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBhZGRNZXRob2QobGVuZ3RoLCBtZXRob2QsIGF0dHJpYnV0ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQmFja2JvbmUuRXZlbnRzXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEEgbW9kdWxlIHRoYXQgY2FuIGJlIG1peGVkIGluIHRvICphbnkgb2JqZWN0KiBpbiBvcmRlciB0byBwcm92aWRlIGl0IHdpdGhcbiAgLy8gY3VzdG9tIGV2ZW50cy4gWW91IG1heSBiaW5kIHdpdGggYG9uYCBvciByZW1vdmUgd2l0aCBgb2ZmYCBjYWxsYmFja1xuICAvLyBmdW5jdGlvbnMgdG8gYW4gZXZlbnQ7IGB0cmlnZ2VyYC1pbmcgYW4gZXZlbnQgZmlyZXMgYWxsIGNhbGxiYWNrcyBpblxuICAvLyBzdWNjZXNzaW9uLlxuICAvL1xuICAvLyAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAvLyAgICAgXy5leHRlbmQob2JqZWN0LCBCYWNrYm9uZS5FdmVudHMpO1xuICAvLyAgICAgb2JqZWN0Lm9uKCdleHBhbmQnLCBmdW5jdGlvbigpeyBhbGVydCgnZXhwYW5kZWQnKTsgfSk7XG4gIC8vICAgICBvYmplY3QudHJpZ2dlcignZXhwYW5kJyk7XG4gIC8vXG4gIHZhciBFdmVudHMgPSBCYWNrYm9uZS5FdmVudHMgPSB7fTtcblxuICAvLyBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byBzcGxpdCBldmVudCBzdHJpbmdzLlxuICB2YXIgZXZlbnRTcGxpdHRlciA9IC9cXHMrLztcblxuICAvLyBJdGVyYXRlcyBvdmVyIHRoZSBzdGFuZGFyZCBgZXZlbnQsIGNhbGxiYWNrYCAoYXMgd2VsbCBhcyB0aGUgZmFuY3kgbXVsdGlwbGVcbiAgLy8gc3BhY2Utc2VwYXJhdGVkIGV2ZW50cyBgXCJjaGFuZ2UgYmx1clwiLCBjYWxsYmFja2AgYW5kIGpRdWVyeS1zdHlsZSBldmVudFxuICAvLyBtYXBzIGB7ZXZlbnQ6IGNhbGxiYWNrfWApLCByZWR1Y2luZyB0aGVtIGJ5IG1hbmlwdWxhdGluZyBgbWVtb2AuXG4gIC8vIFBhc3NlcyBhIG5vcm1hbGl6ZWQgc2luZ2xlIGV2ZW50IG5hbWUgYW5kIGNhbGxiYWNrLCBhcyB3ZWxsIGFzIGFueVxuICAvLyBvcHRpb25hbCBgb3B0c2AuXG4gIHZhciBldmVudHNBcGkgPSBmdW5jdGlvbihpdGVyYXRlZSwgbWVtbywgbmFtZSwgY2FsbGJhY2ssIG9wdHMpIHtcbiAgICB2YXIgaSA9IDAsIG5hbWVzO1xuICAgIGlmIChuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gSGFuZGxlIGV2ZW50IG1hcHMuXG4gICAgICBpZiAoY2FsbGJhY2sgIT09IHZvaWQgMCAmJiAnY29udGV4dCcgaW4gb3B0cyAmJiBvcHRzLmNvbnRleHQgPT09IHZvaWQgMCkgb3B0cy5jb250ZXh0ID0gY2FsbGJhY2s7XG4gICAgICBmb3IgKG5hbWVzID0gXy5rZXlzKG5hbWUpOyBpIDwgbmFtZXMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBuYW1lc1tpXSwgbmFtZVtuYW1lc1tpXV0sIG9wdHMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmFtZSAmJiBldmVudFNwbGl0dGVyLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIEhhbmRsZSBzcGFjZSBzZXBhcmF0ZWQgZXZlbnQgbmFtZXMuXG4gICAgICBmb3IgKG5hbWVzID0gbmFtZS5zcGxpdChldmVudFNwbGl0dGVyKTsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBuYW1lc1tpXSwgY2FsbGJhY2ssIG9wdHMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZW1vID0gaXRlcmF0ZWUobWVtbywgbmFtZSwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIH1cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcblxuICAvLyBCaW5kIGFuIGV2ZW50IHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi4gUGFzc2luZyBgXCJhbGxcImAgd2lsbCBiaW5kXG4gIC8vIHRoZSBjYWxsYmFjayB0byBhbGwgZXZlbnRzIGZpcmVkLlxuICBFdmVudHMub24gPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIHJldHVybiBpbnRlcm5hbE9uKHRoaXMsIG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCB1c2UgYG9uYCBmdW5jdGlvbiwgdXNlZCB0byBndWFyZCB0aGUgYGxpc3RlbmluZ2AgYXJndW1lbnQgZnJvbVxuICAvLyB0aGUgcHVibGljIEFQSS5cbiAgdmFyIGludGVybmFsT24gPSBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0LCBsaXN0ZW5pbmcpIHtcbiAgICBvYmouX2V2ZW50cyA9IGV2ZW50c0FwaShvbkFwaSwgb2JqLl9ldmVudHMgfHwge30sIG5hbWUsIGNhbGxiYWNrLCB7XG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIGN0eDogb2JqLFxuICAgICAgICBsaXN0ZW5pbmc6IGxpc3RlbmluZ1xuICAgIH0pO1xuXG4gICAgaWYgKGxpc3RlbmluZykge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IG9iai5fbGlzdGVuZXJzIHx8IChvYmouX2xpc3RlbmVycyA9IHt9KTtcbiAgICAgIGxpc3RlbmVyc1tsaXN0ZW5pbmcuaWRdID0gbGlzdGVuaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gSW52ZXJzaW9uLW9mLWNvbnRyb2wgdmVyc2lvbnMgb2YgYG9uYC4gVGVsbCAqdGhpcyogb2JqZWN0IHRvIGxpc3RlbiB0b1xuICAvLyBhbiBldmVudCBpbiBhbm90aGVyIG9iamVjdC4uLiBrZWVwaW5nIHRyYWNrIG9mIHdoYXQgaXQncyBsaXN0ZW5pbmcgdG8uXG4gIEV2ZW50cy5saXN0ZW5UbyA9ICBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiB0aGlzO1xuICAgIHZhciBpZCA9IG9iai5fbGlzdGVuSWQgfHwgKG9iai5fbGlzdGVuSWQgPSBfLnVuaXF1ZUlkKCdsJykpO1xuICAgIHZhciBsaXN0ZW5pbmdUbyA9IHRoaXMuX2xpc3RlbmluZ1RvIHx8ICh0aGlzLl9saXN0ZW5pbmdUbyA9IHt9KTtcbiAgICB2YXIgbGlzdGVuaW5nID0gbGlzdGVuaW5nVG9baWRdO1xuXG4gICAgLy8gVGhpcyBvYmplY3QgaXMgbm90IGxpc3RlbmluZyB0byBhbnkgb3RoZXIgZXZlbnRzIG9uIGBvYmpgIHlldC5cbiAgICAvLyBTZXR1cCB0aGUgbmVjZXNzYXJ5IHJlZmVyZW5jZXMgdG8gdHJhY2sgdGhlIGxpc3RlbmluZyBjYWxsYmFja3MuXG4gICAgaWYgKCFsaXN0ZW5pbmcpIHtcbiAgICAgIHZhciB0aGlzSWQgPSB0aGlzLl9saXN0ZW5JZCB8fCAodGhpcy5fbGlzdGVuSWQgPSBfLnVuaXF1ZUlkKCdsJykpO1xuICAgICAgbGlzdGVuaW5nID0gbGlzdGVuaW5nVG9baWRdID0ge29iajogb2JqLCBvYmpJZDogaWQsIGlkOiB0aGlzSWQsIGxpc3RlbmluZ1RvOiBsaXN0ZW5pbmdUbywgY291bnQ6IDB9O1xuICAgIH1cblxuICAgIC8vIEJpbmQgY2FsbGJhY2tzIG9uIG9iaiwgYW5kIGtlZXAgdHJhY2sgb2YgdGhlbSBvbiBsaXN0ZW5pbmcuXG4gICAgaW50ZXJuYWxPbihvYmosIG5hbWUsIGNhbGxiYWNrLCB0aGlzLCBsaXN0ZW5pbmcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFRoZSByZWR1Y2luZyBBUEkgdGhhdCBhZGRzIGEgY2FsbGJhY2sgdG8gdGhlIGBldmVudHNgIG9iamVjdC5cbiAgdmFyIG9uQXBpID0gZnVuY3Rpb24oZXZlbnRzLCBuYW1lLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdIHx8IChldmVudHNbbmFtZV0gPSBbXSk7XG4gICAgICB2YXIgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dCwgY3R4ID0gb3B0aW9ucy5jdHgsIGxpc3RlbmluZyA9IG9wdGlvbnMubGlzdGVuaW5nO1xuICAgICAgaWYgKGxpc3RlbmluZykgbGlzdGVuaW5nLmNvdW50Kys7XG5cbiAgICAgIGhhbmRsZXJzLnB1c2goeyBjYWxsYmFjazogY2FsbGJhY2ssIGNvbnRleHQ6IGNvbnRleHQsIGN0eDogY29udGV4dCB8fCBjdHgsIGxpc3RlbmluZzogbGlzdGVuaW5nIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9O1xuXG4gIC8vIFJlbW92ZSBvbmUgb3IgbWFueSBjYWxsYmFja3MuIElmIGBjb250ZXh0YCBpcyBudWxsLCByZW1vdmVzIGFsbFxuICAvLyBjYWxsYmFja3Mgd2l0aCB0aGF0IGZ1bmN0aW9uLiBJZiBgY2FsbGJhY2tgIGlzIG51bGwsIHJlbW92ZXMgYWxsXG4gIC8vIGNhbGxiYWNrcyBmb3IgdGhlIGV2ZW50LiBJZiBgbmFtZWAgaXMgbnVsbCwgcmVtb3ZlcyBhbGwgYm91bmRcbiAgLy8gY2FsbGJhY2tzIGZvciBhbGwgZXZlbnRzLlxuICBFdmVudHMub2ZmID0gIGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiB0aGlzO1xuICAgIHRoaXMuX2V2ZW50cyA9IGV2ZW50c0FwaShvZmZBcGksIHRoaXMuX2V2ZW50cywgbmFtZSwgY2FsbGJhY2ssIHtcbiAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgbGlzdGVuZXJzOiB0aGlzLl9saXN0ZW5lcnNcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBUZWxsIHRoaXMgb2JqZWN0IHRvIHN0b3AgbGlzdGVuaW5nIHRvIGVpdGhlciBzcGVjaWZpYyBldmVudHMgLi4uIG9yXG4gIC8vIHRvIGV2ZXJ5IG9iamVjdCBpdCdzIGN1cnJlbnRseSBsaXN0ZW5pbmcgdG8uXG4gIEV2ZW50cy5zdG9wTGlzdGVuaW5nID0gIGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgbGlzdGVuaW5nVG8gPSB0aGlzLl9saXN0ZW5pbmdUbztcbiAgICBpZiAoIWxpc3RlbmluZ1RvKSByZXR1cm4gdGhpcztcblxuICAgIHZhciBpZHMgPSBvYmogPyBbb2JqLl9saXN0ZW5JZF0gOiBfLmtleXMobGlzdGVuaW5nVG8pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaXN0ZW5pbmcgPSBsaXN0ZW5pbmdUb1tpZHNbaV1dO1xuXG4gICAgICAvLyBJZiBsaXN0ZW5pbmcgZG9lc24ndCBleGlzdCwgdGhpcyBvYmplY3QgaXMgbm90IGN1cnJlbnRseVxuICAgICAgLy8gbGlzdGVuaW5nIHRvIG9iai4gQnJlYWsgb3V0IGVhcmx5LlxuICAgICAgaWYgKCFsaXN0ZW5pbmcpIGJyZWFrO1xuXG4gICAgICBsaXN0ZW5pbmcub2JqLm9mZihuYW1lLCBjYWxsYmFjaywgdGhpcyk7XG4gICAgfVxuICAgIGlmIChfLmlzRW1wdHkobGlzdGVuaW5nVG8pKSB0aGlzLl9saXN0ZW5pbmdUbyA9IHZvaWQgMDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFRoZSByZWR1Y2luZyBBUEkgdGhhdCByZW1vdmVzIGEgY2FsbGJhY2sgZnJvbSB0aGUgYGV2ZW50c2Agb2JqZWN0LlxuICB2YXIgb2ZmQXBpID0gZnVuY3Rpb24oZXZlbnRzLCBuYW1lLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIC8vIE5vIGV2ZW50cyB0byBjb25zaWRlci5cbiAgICBpZiAoIWV2ZW50cykgcmV0dXJuO1xuXG4gICAgdmFyIGkgPSAwLCBsaXN0ZW5pbmc7XG4gICAgdmFyIGNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQsIGxpc3RlbmVycyA9IG9wdGlvbnMubGlzdGVuZXJzO1xuXG4gICAgLy8gRGVsZXRlIGFsbCBldmVudHMgbGlzdGVuZXJzIGFuZCBcImRyb3BcIiBldmVudHMuXG4gICAgaWYgKCFuYW1lICYmICFjYWxsYmFjayAmJiAhY29udGV4dCkge1xuICAgICAgdmFyIGlkcyA9IF8ua2V5cyhsaXN0ZW5lcnMpO1xuICAgICAgZm9yICg7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGlzdGVuaW5nID0gbGlzdGVuZXJzW2lkc1tpXV07XG4gICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbbGlzdGVuaW5nLmlkXTtcbiAgICAgICAgZGVsZXRlIGxpc3RlbmluZy5saXN0ZW5pbmdUb1tsaXN0ZW5pbmcub2JqSWRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuYW1lcyA9IG5hbWUgPyBbbmFtZV0gOiBfLmtleXMoZXZlbnRzKTtcbiAgICBmb3IgKDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG5cbiAgICAgIC8vIEJhaWwgb3V0IGlmIHRoZXJlIGFyZSBubyBldmVudHMgc3RvcmVkLlxuICAgICAgaWYgKCFoYW5kbGVycykgYnJlYWs7XG5cbiAgICAgIC8vIFJlcGxhY2UgZXZlbnRzIGlmIHRoZXJlIGFyZSBhbnkgcmVtYWluaW5nLiAgT3RoZXJ3aXNlLCBjbGVhbiB1cC5cbiAgICAgIHZhciByZW1haW5pbmcgPSBbXTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVyc1tqXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrICE9PSBoYW5kbGVyLmNhbGxiYWNrICYmXG4gICAgICAgICAgICBjYWxsYmFjayAhPT0gaGFuZGxlci5jYWxsYmFjay5fY2FsbGJhY2sgfHxcbiAgICAgICAgICAgICAgY29udGV4dCAmJiBjb250ZXh0ICE9PSBoYW5kbGVyLmNvbnRleHRcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmVtYWluaW5nLnB1c2goaGFuZGxlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGlzdGVuaW5nID0gaGFuZGxlci5saXN0ZW5pbmc7XG4gICAgICAgICAgaWYgKGxpc3RlbmluZyAmJiAtLWxpc3RlbmluZy5jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1tsaXN0ZW5pbmcuaWRdO1xuICAgICAgICAgICAgZGVsZXRlIGxpc3RlbmluZy5saXN0ZW5pbmdUb1tsaXN0ZW5pbmcub2JqSWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdGFpbCBldmVudCBpZiB0aGUgbGlzdCBoYXMgYW55IGV2ZW50cy4gIE90aGVyd2lzZSwgY2xlYW4gdXAuXG4gICAgICBpZiAocmVtYWluaW5nLmxlbmd0aCkge1xuICAgICAgICBldmVudHNbbmFtZV0gPSByZW1haW5pbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgZXZlbnRzW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoXy5zaXplKGV2ZW50cykpIHJldHVybiBldmVudHM7XG4gIH07XG5cbiAgLy8gQmluZCBhbiBldmVudCB0byBvbmx5IGJlIHRyaWdnZXJlZCBhIHNpbmdsZSB0aW1lLiBBZnRlciB0aGUgZmlyc3QgdGltZVxuICAvLyB0aGUgY2FsbGJhY2sgaXMgaW52b2tlZCwgaXQgd2lsbCBiZSByZW1vdmVkLiBXaGVuIG11bHRpcGxlIGV2ZW50cyBhcmVcbiAgLy8gcGFzc2VkIGluIHVzaW5nIHRoZSBzcGFjZS1zZXBhcmF0ZWQgc3ludGF4LCB0aGUgZXZlbnQgd2lsbCBmaXJlIG9uY2UgZm9yIGV2ZXJ5XG4gIC8vIGV2ZW50IHlvdSBwYXNzZWQgaW4sIG5vdCBvbmNlIGZvciBhIGNvbWJpbmF0aW9uIG9mIGFsbCBldmVudHNcbiAgRXZlbnRzLm9uY2UgPSAgZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAvLyBNYXAgdGhlIGV2ZW50IGludG8gYSBge2V2ZW50OiBvbmNlfWAgb2JqZWN0LlxuICAgIHZhciBldmVudHMgPSBldmVudHNBcGkob25jZU1hcCwge30sIG5hbWUsIGNhbGxiYWNrLCBfLmJpbmQodGhpcy5vZmYsIHRoaXMpKTtcbiAgICByZXR1cm4gdGhpcy5vbihldmVudHMsIHZvaWQgMCwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gSW52ZXJzaW9uLW9mLWNvbnRyb2wgdmVyc2lvbnMgb2YgYG9uY2VgLlxuICBFdmVudHMubGlzdGVuVG9PbmNlID0gIGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAvLyBNYXAgdGhlIGV2ZW50IGludG8gYSBge2V2ZW50OiBvbmNlfWAgb2JqZWN0LlxuICAgIHZhciBldmVudHMgPSBldmVudHNBcGkob25jZU1hcCwge30sIG5hbWUsIGNhbGxiYWNrLCBfLmJpbmQodGhpcy5zdG9wTGlzdGVuaW5nLCB0aGlzLCBvYmopKTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5UbyhvYmosIGV2ZW50cyk7XG4gIH07XG5cbiAgLy8gUmVkdWNlcyB0aGUgZXZlbnQgY2FsbGJhY2tzIGludG8gYSBtYXAgb2YgYHtldmVudDogb25jZVdyYXBwZXJ9YC5cbiAgLy8gYG9mZmVyYCB1bmJpbmRzIHRoZSBgb25jZVdyYXBwZXJgIGFmdGVyIGl0IGhhcyBiZWVuIGNhbGxlZC5cbiAgdmFyIG9uY2VNYXAgPSBmdW5jdGlvbihtYXAsIG5hbWUsIGNhbGxiYWNrLCBvZmZlcikge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdmFyIG9uY2UgPSBtYXBbbmFtZV0gPSBfLm9uY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgIG9mZmVyKG5hbWUsIG9uY2UpO1xuICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgICBvbmNlLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9O1xuXG4gIC8vIFRyaWdnZXIgb25lIG9yIG1hbnkgZXZlbnRzLCBmaXJpbmcgYWxsIGJvdW5kIGNhbGxiYWNrcy4gQ2FsbGJhY2tzIGFyZVxuICAvLyBwYXNzZWQgdGhlIHNhbWUgYXJndW1lbnRzIGFzIGB0cmlnZ2VyYCBpcywgYXBhcnQgZnJvbSB0aGUgZXZlbnQgbmFtZVxuICAvLyAodW5sZXNzIHlvdSdyZSBsaXN0ZW5pbmcgb24gYFwiYWxsXCJgLCB3aGljaCB3aWxsIGNhdXNlIHlvdXIgY2FsbGJhY2sgdG9cbiAgLy8gcmVjZWl2ZSB0aGUgdHJ1ZSBuYW1lIG9mIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgYXJndW1lbnQpLlxuICBFdmVudHMudHJpZ2dlciA9ICBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiB0aGlzO1xuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KDAsIGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG5cbiAgICBldmVudHNBcGkodHJpZ2dlckFwaSwgdGhpcy5fZXZlbnRzLCBuYW1lLCB2b2lkIDAsIGFyZ3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEhhbmRsZXMgdHJpZ2dlcmluZyB0aGUgYXBwcm9wcmlhdGUgZXZlbnQgY2FsbGJhY2tzLlxuICB2YXIgdHJpZ2dlckFwaSA9IGZ1bmN0aW9uKG9iakV2ZW50cywgbmFtZSwgY2IsIGFyZ3MpIHtcbiAgICBpZiAob2JqRXZlbnRzKSB7XG4gICAgICB2YXIgZXZlbnRzID0gb2JqRXZlbnRzW25hbWVdO1xuICAgICAgdmFyIGFsbEV2ZW50cyA9IG9iakV2ZW50cy5hbGw7XG4gICAgICBpZiAoZXZlbnRzICYmIGFsbEV2ZW50cykgYWxsRXZlbnRzID0gYWxsRXZlbnRzLnNsaWNlKCk7XG4gICAgICBpZiAoZXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGV2ZW50cywgYXJncyk7XG4gICAgICBpZiAoYWxsRXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGFsbEV2ZW50cywgW25hbWVdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmpFdmVudHM7XG4gIH07XG5cbiAgLy8gQSBkaWZmaWN1bHQtdG8tYmVsaWV2ZSwgYnV0IG9wdGltaXplZCBpbnRlcm5hbCBkaXNwYXRjaCBmdW5jdGlvbiBmb3JcbiAgLy8gdHJpZ2dlcmluZyBldmVudHMuIFRyaWVzIHRvIGtlZXAgdGhlIHVzdWFsIGNhc2VzIHNwZWVkeSAobW9zdCBpbnRlcm5hbFxuICAvLyBCYWNrYm9uZSBldmVudHMgaGF2ZSAzIGFyZ3VtZW50cykuXG4gIHZhciB0cmlnZ2VyRXZlbnRzID0gZnVuY3Rpb24oZXZlbnRzLCBhcmdzKSB7XG4gICAgdmFyIGV2LCBpID0gLTEsIGwgPSBldmVudHMubGVuZ3RoLCBhMSA9IGFyZ3NbMF0sIGEyID0gYXJnc1sxXSwgYTMgPSBhcmdzWzJdO1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgpOyByZXR1cm47XG4gICAgICBjYXNlIDE6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSk7IHJldHVybjtcbiAgICAgIGNhc2UgMjogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExLCBhMik7IHJldHVybjtcbiAgICAgIGNhc2UgMzogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExLCBhMiwgYTMpOyByZXR1cm47XG4gICAgICBkZWZhdWx0OiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5hcHBseShldi5jdHgsIGFyZ3MpOyByZXR1cm47XG4gICAgfVxuICB9O1xuXG4gIC8vIEFsaWFzZXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBFdmVudHMuYmluZCAgID0gRXZlbnRzLm9uO1xuICBFdmVudHMudW5iaW5kID0gRXZlbnRzLm9mZjtcblxuICAvLyBBbGxvdyB0aGUgYEJhY2tib25lYCBvYmplY3QgdG8gc2VydmUgYXMgYSBnbG9iYWwgZXZlbnQgYnVzLCBmb3IgZm9sa3Mgd2hvXG4gIC8vIHdhbnQgZ2xvYmFsIFwicHVic3ViXCIgaW4gYSBjb252ZW5pZW50IHBsYWNlLlxuICBfLmV4dGVuZChCYWNrYm9uZSwgRXZlbnRzKTtcblxuICAvLyBCYWNrYm9uZS5Nb2RlbFxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEJhY2tib25lICoqTW9kZWxzKiogYXJlIHRoZSBiYXNpYyBkYXRhIG9iamVjdCBpbiB0aGUgZnJhbWV3b3JrIC0tXG4gIC8vIGZyZXF1ZW50bHkgcmVwcmVzZW50aW5nIGEgcm93IGluIGEgdGFibGUgaW4gYSBkYXRhYmFzZSBvbiB5b3VyIHNlcnZlci5cbiAgLy8gQSBkaXNjcmV0ZSBjaHVuayBvZiBkYXRhIGFuZCBhIGJ1bmNoIG9mIHVzZWZ1bCwgcmVsYXRlZCBtZXRob2RzIGZvclxuICAvLyBwZXJmb3JtaW5nIGNvbXB1dGF0aW9ucyBhbmQgdHJhbnNmb3JtYXRpb25zIG9uIHRoYXQgZGF0YS5cblxuICAvLyBDcmVhdGUgYSBuZXcgbW9kZWwgd2l0aCB0aGUgc3BlY2lmaWVkIGF0dHJpYnV0ZXMuIEEgY2xpZW50IGlkIChgY2lkYClcbiAgLy8gaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYW5kIGFzc2lnbmVkIGZvciB5b3UuXG4gIHZhciBNb2RlbCA9IEJhY2tib25lLk1vZGVsID0gZnVuY3Rpb24oYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIHZhciBhdHRycyA9IGF0dHJpYnV0ZXMgfHwge307XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICB0aGlzLmNpZCA9IF8udW5pcXVlSWQodGhpcy5jaWRQcmVmaXgpO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIGlmIChvcHRpb25zLmNvbGxlY3Rpb24pIHRoaXMuY29sbGVjdGlvbiA9IG9wdGlvbnMuY29sbGVjdGlvbjtcbiAgICBpZiAob3B0aW9ucy5wYXJzZSkgYXR0cnMgPSB0aGlzLnBhcnNlKGF0dHJzLCBvcHRpb25zKSB8fCB7fTtcbiAgICBhdHRycyA9IF8uZGVmYXVsdHMoe30sIGF0dHJzLCBfLnJlc3VsdCh0aGlzLCAnZGVmYXVsdHMnKSk7XG4gICAgdGhpcy5zZXQoYXR0cnMsIG9wdGlvbnMpO1xuICAgIHRoaXMuY2hhbmdlZCA9IHt9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIEF0dGFjaCBhbGwgaW5oZXJpdGFibGUgbWV0aG9kcyB0byB0aGUgTW9kZWwgcHJvdG90eXBlLlxuICBfLmV4dGVuZChNb2RlbC5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgLy8gQSBoYXNoIG9mIGF0dHJpYnV0ZXMgd2hvc2UgY3VycmVudCBhbmQgcHJldmlvdXMgdmFsdWUgZGlmZmVyLlxuICAgIGNoYW5nZWQ6IG51bGwsXG5cbiAgICAvLyBUaGUgdmFsdWUgcmV0dXJuZWQgZHVyaW5nIHRoZSBsYXN0IGZhaWxlZCB2YWxpZGF0aW9uLlxuICAgIHZhbGlkYXRpb25FcnJvcjogbnVsbCxcblxuICAgIC8vIFRoZSBkZWZhdWx0IG5hbWUgZm9yIHRoZSBKU09OIGBpZGAgYXR0cmlidXRlIGlzIGBcImlkXCJgLiBNb25nb0RCIGFuZFxuICAgIC8vIENvdWNoREIgdXNlcnMgbWF5IHdhbnQgdG8gc2V0IHRoaXMgdG8gYFwiX2lkXCJgLlxuICAgIGlkQXR0cmlidXRlOiAnaWQnLFxuXG4gICAgLy8gVGhlIHByZWZpeCBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgY2xpZW50IGlkIHdoaWNoIGlzIHVzZWQgdG8gaWRlbnRpZnkgbW9kZWxzIGxvY2FsbHkuXG4gICAgLy8gWW91IG1heSB3YW50IHRvIG92ZXJyaWRlIHRoaXMgaWYgeW91J3JlIGV4cGVyaWVuY2luZyBuYW1lIGNsYXNoZXMgd2l0aCBtb2RlbCBpZHMuXG4gICAgY2lkUHJlZml4OiAnYycsXG5cbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXG5cbiAgICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBtb2RlbCdzIGBhdHRyaWJ1dGVzYCBvYmplY3QuXG4gICAgdG9KU09OOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gXy5jbG9uZSh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBQcm94eSBgQmFja2JvbmUuc3luY2AgYnkgZGVmYXVsdCAtLSBidXQgb3ZlcnJpZGUgdGhpcyBpZiB5b3UgbmVlZFxuICAgIC8vIGN1c3RvbSBzeW5jaW5nIHNlbWFudGljcyBmb3IgKnRoaXMqIHBhcnRpY3VsYXIgbW9kZWwuXG4gICAgc3luYzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQmFja2JvbmUuc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cbiAgICBnZXQ6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbYXR0cl07XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgSFRNTC1lc2NhcGVkIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cbiAgICBlc2NhcGU6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiBfLmVzY2FwZSh0aGlzLmdldChhdHRyKSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBhdHRyaWJ1dGUgY29udGFpbnMgYSB2YWx1ZSB0aGF0IGlzIG5vdCBudWxsXG4gICAgLy8gb3IgdW5kZWZpbmVkLlxuICAgIGhhczogZnVuY3Rpb24oYXR0cikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KGF0dHIpICE9IG51bGw7XG4gICAgfSxcblxuICAgIC8vIFNwZWNpYWwtY2FzZWQgcHJveHkgdG8gdW5kZXJzY29yZSdzIGBfLm1hdGNoZXNgIG1ldGhvZC5cbiAgICBtYXRjaGVzOiBmdW5jdGlvbihhdHRycykge1xuICAgICAgcmV0dXJuICEhXy5pdGVyYXRlZShhdHRycywgdGhpcykodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IGEgaGFzaCBvZiBtb2RlbCBhdHRyaWJ1dGVzIG9uIHRoZSBvYmplY3QsIGZpcmluZyBgXCJjaGFuZ2VcImAuIFRoaXMgaXNcbiAgICAvLyB0aGUgY29yZSBwcmltaXRpdmUgb3BlcmF0aW9uIG9mIGEgbW9kZWwsIHVwZGF0aW5nIHRoZSBkYXRhIGFuZCBub3RpZnlpbmdcbiAgICAvLyBhbnlvbmUgd2hvIG5lZWRzIHRvIGtub3cgYWJvdXQgdGhlIGNoYW5nZSBpbiBzdGF0ZS4gVGhlIGhlYXJ0IG9mIHRoZSBiZWFzdC5cbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsLCBvcHRpb25zKSB7XG4gICAgICBpZiAoa2V5ID09IG51bGwpIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBIYW5kbGUgYm90aCBgXCJrZXlcIiwgdmFsdWVgIGFuZCBge2tleTogdmFsdWV9YCAtc3R5bGUgYXJndW1lbnRzLlxuICAgICAgdmFyIGF0dHJzO1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGF0dHJzID0ga2V5O1xuICAgICAgICBvcHRpb25zID0gdmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKGF0dHJzID0ge30pW2tleV0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG5cbiAgICAgIC8vIFJ1biB2YWxpZGF0aW9uLlxuICAgICAgaWYgKCF0aGlzLl92YWxpZGF0ZShhdHRycywgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gRXh0cmFjdCBhdHRyaWJ1dGVzIGFuZCBvcHRpb25zLlxuICAgICAgdmFyIHVuc2V0ICAgICAgPSBvcHRpb25zLnVuc2V0O1xuICAgICAgdmFyIHNpbGVudCAgICAgPSBvcHRpb25zLnNpbGVudDtcbiAgICAgIHZhciBjaGFuZ2VzICAgID0gW107XG4gICAgICB2YXIgY2hhbmdpbmcgICA9IHRoaXMuX2NoYW5naW5nO1xuICAgICAgdGhpcy5fY2hhbmdpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIWNoYW5naW5nKSB7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcyA9IF8uY2xvbmUodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkID0ge307XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgdmFyIGNoYW5nZWQgPSB0aGlzLmNoYW5nZWQ7XG4gICAgICB2YXIgcHJldiAgICA9IHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcztcblxuICAgICAgLy8gQ2hlY2sgZm9yIGNoYW5nZXMgb2YgYGlkYC5cbiAgICAgIGlmICh0aGlzLmlkQXR0cmlidXRlIGluIGF0dHJzKSB0aGlzLmlkID0gYXR0cnNbdGhpcy5pZEF0dHJpYnV0ZV07XG5cbiAgICAgIC8vIEZvciBlYWNoIGBzZXRgIGF0dHJpYnV0ZSwgdXBkYXRlIG9yIGRlbGV0ZSB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgIGZvciAodmFyIGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgICAgdmFsID0gYXR0cnNbYXR0cl07XG4gICAgICAgIGlmICghXy5pc0VxdWFsKGN1cnJlbnRbYXR0cl0sIHZhbCkpIGNoYW5nZXMucHVzaChhdHRyKTtcbiAgICAgICAgaWYgKCFfLmlzRXF1YWwocHJldlthdHRyXSwgdmFsKSkge1xuICAgICAgICAgIGNoYW5nZWRbYXR0cl0gPSB2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGNoYW5nZWRbYXR0cl07XG4gICAgICAgIH1cbiAgICAgICAgdW5zZXQgPyBkZWxldGUgY3VycmVudFthdHRyXSA6IGN1cnJlbnRbYXR0cl0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIC8vIFRyaWdnZXIgYWxsIHJlbGV2YW50IGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMubGVuZ3RoKSB0aGlzLl9wZW5kaW5nID0gb3B0aW9ucztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2U6JyArIGNoYW5nZXNbaV0sIHRoaXMsIGN1cnJlbnRbY2hhbmdlc1tpXV0sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFlvdSBtaWdodCBiZSB3b25kZXJpbmcgd2h5IHRoZXJlJ3MgYSBgd2hpbGVgIGxvb3AgaGVyZS4gQ2hhbmdlcyBjYW5cbiAgICAgIC8vIGJlIHJlY3Vyc2l2ZWx5IG5lc3RlZCB3aXRoaW4gYFwiY2hhbmdlXCJgIGV2ZW50cy5cbiAgICAgIGlmIChjaGFuZ2luZykgcmV0dXJuIHRoaXM7XG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICB3aGlsZSAodGhpcy5fcGVuZGluZykge1xuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLl9wZW5kaW5nO1xuICAgICAgICAgIHRoaXMuX3BlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9wZW5kaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9jaGFuZ2luZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBhbiBhdHRyaWJ1dGUgZnJvbSB0aGUgbW9kZWwsIGZpcmluZyBgXCJjaGFuZ2VcImAuIGB1bnNldGAgaXMgYSBub29wXG4gICAgLy8gaWYgdGhlIGF0dHJpYnV0ZSBkb2Vzbid0IGV4aXN0LlxuICAgIHVuc2V0OiBmdW5jdGlvbihhdHRyLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoYXR0ciwgdm9pZCAwLCBfLmV4dGVuZCh7fSwgb3B0aW9ucywge3Vuc2V0OiB0cnVlfSkpO1xuICAgIH0sXG5cbiAgICAvLyBDbGVhciBhbGwgYXR0cmlidXRlcyBvbiB0aGUgbW9kZWwsIGZpcmluZyBgXCJjaGFuZ2VcImAuXG4gICAgY2xlYXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBhdHRycyA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuYXR0cmlidXRlcykgYXR0cnNba2V5XSA9IHZvaWQgMDtcbiAgICAgIHJldHVybiB0aGlzLnNldChhdHRycywgXy5leHRlbmQoe30sIG9wdGlvbnMsIHt1bnNldDogdHJ1ZX0pKTtcbiAgICB9LFxuXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBtb2RlbCBoYXMgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBgXCJjaGFuZ2VcImAgZXZlbnQuXG4gICAgLy8gSWYgeW91IHNwZWNpZnkgYW4gYXR0cmlidXRlIG5hbWUsIGRldGVybWluZSBpZiB0aGF0IGF0dHJpYnV0ZSBoYXMgY2hhbmdlZC5cbiAgICBoYXNDaGFuZ2VkOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICBpZiAoYXR0ciA9PSBudWxsKSByZXR1cm4gIV8uaXNFbXB0eSh0aGlzLmNoYW5nZWQpO1xuICAgICAgcmV0dXJuIF8uaGFzKHRoaXMuY2hhbmdlZCwgYXR0cik7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIGF0dHJpYnV0ZXMgdGhhdCBoYXZlIGNoYW5nZWQsIG9yXG4gICAgLy8gZmFsc2UgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZWQgYXR0cmlidXRlcy4gVXNlZnVsIGZvciBkZXRlcm1pbmluZyB3aGF0XG4gICAgLy8gcGFydHMgb2YgYSB2aWV3IG5lZWQgdG8gYmUgdXBkYXRlZCBhbmQvb3Igd2hhdCBhdHRyaWJ1dGVzIG5lZWQgdG8gYmVcbiAgICAvLyBwZXJzaXN0ZWQgdG8gdGhlIHNlcnZlci4gVW5zZXQgYXR0cmlidXRlcyB3aWxsIGJlIHNldCB0byB1bmRlZmluZWQuXG4gICAgLy8gWW91IGNhbiBhbHNvIHBhc3MgYW4gYXR0cmlidXRlcyBvYmplY3QgdG8gZGlmZiBhZ2FpbnN0IHRoZSBtb2RlbCxcbiAgICAvLyBkZXRlcm1pbmluZyBpZiB0aGVyZSAqd291bGQgYmUqIGEgY2hhbmdlLlxuICAgIGNoYW5nZWRBdHRyaWJ1dGVzOiBmdW5jdGlvbihkaWZmKSB7XG4gICAgICBpZiAoIWRpZmYpIHJldHVybiB0aGlzLmhhc0NoYW5nZWQoKSA/IF8uY2xvbmUodGhpcy5jaGFuZ2VkKSA6IGZhbHNlO1xuICAgICAgdmFyIG9sZCA9IHRoaXMuX2NoYW5naW5nID8gdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzIDogdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgdmFyIGNoYW5nZWQgPSB7fTtcbiAgICAgIGZvciAodmFyIGF0dHIgaW4gZGlmZikge1xuICAgICAgICB2YXIgdmFsID0gZGlmZlthdHRyXTtcbiAgICAgICAgaWYgKF8uaXNFcXVhbChvbGRbYXR0cl0sIHZhbCkpIGNvbnRpbnVlO1xuICAgICAgICBjaGFuZ2VkW2F0dHJdID0gdmFsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF8uc2l6ZShjaGFuZ2VkKSA/IGNoYW5nZWQgOiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBwcmV2aW91cyB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUsIHJlY29yZGVkIGF0IHRoZSB0aW1lIHRoZSBsYXN0XG4gICAgLy8gYFwiY2hhbmdlXCJgIGV2ZW50IHdhcyBmaXJlZC5cbiAgICBwcmV2aW91czogZnVuY3Rpb24oYXR0cikge1xuICAgICAgaWYgKGF0dHIgPT0gbnVsbCB8fCAhdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXNbYXR0cl07XG4gICAgfSxcblxuICAgIC8vIEdldCBhbGwgb2YgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIG1vZGVsIGF0IHRoZSB0aW1lIG9mIHRoZSBwcmV2aW91c1xuICAgIC8vIGBcImNoYW5nZVwiYCBldmVudC5cbiAgICBwcmV2aW91c0F0dHJpYnV0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF8uY2xvbmUodGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzKTtcbiAgICB9LFxuXG4gICAgLy8gRmV0Y2ggdGhlIG1vZGVsIGZyb20gdGhlIHNlcnZlciwgbWVyZ2luZyB0aGUgcmVzcG9uc2Ugd2l0aCB0aGUgbW9kZWwnc1xuICAgIC8vIGxvY2FsIGF0dHJpYnV0ZXMuIEFueSBjaGFuZ2VkIGF0dHJpYnV0ZXMgd2lsbCB0cmlnZ2VyIGEgXCJjaGFuZ2VcIiBldmVudC5cbiAgICBmZXRjaDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHtwYXJzZTogdHJ1ZX0sIG9wdGlvbnMpO1xuICAgICAgdmFyIG1vZGVsID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICB2YXIgc2VydmVyQXR0cnMgPSBvcHRpb25zLnBhcnNlID8gbW9kZWwucGFyc2UocmVzcCwgb3B0aW9ucykgOiByZXNwO1xuICAgICAgICBpZiAoIW1vZGVsLnNldChzZXJ2ZXJBdHRycywgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MuY2FsbChvcHRpb25zLmNvbnRleHQsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgbW9kZWwudHJpZ2dlcignc3luYycsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICAgIH07XG4gICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy5zeW5jKCdyZWFkJywgdGhpcywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8vIFNldCBhIGhhc2ggb2YgbW9kZWwgYXR0cmlidXRlcywgYW5kIHN5bmMgdGhlIG1vZGVsIHRvIHRoZSBzZXJ2ZXIuXG4gICAgLy8gSWYgdGhlIHNlcnZlciByZXR1cm5zIGFuIGF0dHJpYnV0ZXMgaGFzaCB0aGF0IGRpZmZlcnMsIHRoZSBtb2RlbCdzXG4gICAgLy8gc3RhdGUgd2lsbCBiZSBgc2V0YCBhZ2Fpbi5cbiAgICBzYXZlOiBmdW5jdGlvbihrZXksIHZhbCwgb3B0aW9ucykge1xuICAgICAgLy8gSGFuZGxlIGJvdGggYFwia2V5XCIsIHZhbHVlYCBhbmQgYHtrZXk6IHZhbHVlfWAgLXN0eWxlIGFyZ3VtZW50cy5cbiAgICAgIHZhciBhdHRycztcbiAgICAgIGlmIChrZXkgPT0gbnVsbCB8fCB0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhdHRycyA9IGtleTtcbiAgICAgICAgb3B0aW9ucyA9IHZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIChhdHRycyA9IHt9KVtrZXldID0gdmFsO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zID0gXy5leHRlbmQoe3ZhbGlkYXRlOiB0cnVlLCBwYXJzZTogdHJ1ZX0sIG9wdGlvbnMpO1xuICAgICAgdmFyIHdhaXQgPSBvcHRpb25zLndhaXQ7XG5cbiAgICAgIC8vIElmIHdlJ3JlIG5vdCB3YWl0aW5nIGFuZCBhdHRyaWJ1dGVzIGV4aXN0LCBzYXZlIGFjdHMgYXNcbiAgICAgIC8vIGBzZXQoYXR0cikuc2F2ZShudWxsLCBvcHRzKWAgd2l0aCB2YWxpZGF0aW9uLiBPdGhlcndpc2UsIGNoZWNrIGlmXG4gICAgICAvLyB0aGUgbW9kZWwgd2lsbCBiZSB2YWxpZCB3aGVuIHRoZSBhdHRyaWJ1dGVzLCBpZiBhbnksIGFyZSBzZXQuXG4gICAgICBpZiAoYXR0cnMgJiYgIXdhaXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNldChhdHRycywgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5fdmFsaWRhdGUoYXR0cnMsIG9wdGlvbnMpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIEFmdGVyIGEgc3VjY2Vzc2Z1bCBzZXJ2ZXItc2lkZSBzYXZlLCB0aGUgY2xpZW50IGlzIChvcHRpb25hbGx5KVxuICAgICAgLy8gdXBkYXRlZCB3aXRoIHRoZSBzZXJ2ZXItc2lkZSBzdGF0ZS5cbiAgICAgIHZhciBtb2RlbCA9IHRoaXM7XG4gICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICAvLyBFbnN1cmUgYXR0cmlidXRlcyBhcmUgcmVzdG9yZWQgZHVyaW5nIHN5bmNocm9ub3VzIHNhdmVzLlxuICAgICAgICBtb2RlbC5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgdmFyIHNlcnZlckF0dHJzID0gb3B0aW9ucy5wYXJzZSA/IG1vZGVsLnBhcnNlKHJlc3AsIG9wdGlvbnMpIDogcmVzcDtcbiAgICAgICAgaWYgKHdhaXQpIHNlcnZlckF0dHJzID0gXy5leHRlbmQoe30sIGF0dHJzLCBzZXJ2ZXJBdHRycyk7XG4gICAgICAgIGlmIChzZXJ2ZXJBdHRycyAmJiAhbW9kZWwuc2V0KHNlcnZlckF0dHJzLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcy5jYWxsKG9wdGlvbnMuY29udGV4dCwgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICBtb2RlbC50cmlnZ2VyKCdzeW5jJywgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICAgIHdyYXBFcnJvcih0aGlzLCBvcHRpb25zKTtcblxuICAgICAgLy8gU2V0IHRlbXBvcmFyeSBhdHRyaWJ1dGVzIGlmIGB7d2FpdDogdHJ1ZX1gIHRvIHByb3Blcmx5IGZpbmQgbmV3IGlkcy5cbiAgICAgIGlmIChhdHRycyAmJiB3YWl0KSB0aGlzLmF0dHJpYnV0ZXMgPSBfLmV4dGVuZCh7fSwgYXR0cmlidXRlcywgYXR0cnMpO1xuXG4gICAgICB2YXIgbWV0aG9kID0gdGhpcy5pc05ldygpID8gJ2NyZWF0ZScgOiAob3B0aW9ucy5wYXRjaCA/ICdwYXRjaCcgOiAndXBkYXRlJyk7XG4gICAgICBpZiAobWV0aG9kID09PSAncGF0Y2gnICYmICFvcHRpb25zLmF0dHJzKSBvcHRpb25zLmF0dHJzID0gYXR0cnM7XG4gICAgICB2YXIgeGhyID0gdGhpcy5zeW5jKG1ldGhvZCwgdGhpcywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIFJlc3RvcmUgYXR0cmlidXRlcy5cbiAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG5cbiAgICAgIHJldHVybiB4aHI7XG4gICAgfSxcblxuICAgIC8vIERlc3Ryb3kgdGhpcyBtb2RlbCBvbiB0aGUgc2VydmVyIGlmIGl0IHdhcyBhbHJlYWR5IHBlcnNpc3RlZC5cbiAgICAvLyBPcHRpbWlzdGljYWxseSByZW1vdmVzIHRoZSBtb2RlbCBmcm9tIGl0cyBjb2xsZWN0aW9uLCBpZiBpdCBoYXMgb25lLlxuICAgIC8vIElmIGB3YWl0OiB0cnVlYCBpcyBwYXNzZWQsIHdhaXRzIGZvciB0aGUgc2VydmVyIHRvIHJlc3BvbmQgYmVmb3JlIHJlbW92YWwuXG4gICAgZGVzdHJveTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICB2YXIgd2FpdCA9IG9wdGlvbnMud2FpdDtcblxuICAgICAgdmFyIGRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbW9kZWwuc3RvcExpc3RlbmluZygpO1xuICAgICAgICBtb2RlbC50cmlnZ2VyKCdkZXN0cm95JywgbW9kZWwsIG1vZGVsLmNvbGxlY3Rpb24sIG9wdGlvbnMpO1xuICAgICAgfTtcblxuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICBpZiAod2FpdCkgZGVzdHJveSgpO1xuICAgICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcy5jYWxsKG9wdGlvbnMuY29udGV4dCwgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIW1vZGVsLmlzTmV3KCkpIG1vZGVsLnRyaWdnZXIoJ3N5bmMnLCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgeGhyID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5pc05ldygpKSB7XG4gICAgICAgIF8uZGVmZXIob3B0aW9ucy5zdWNjZXNzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyYXBFcnJvcih0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgeGhyID0gdGhpcy5zeW5jKCdkZWxldGUnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICghd2FpdCkgZGVzdHJveSgpO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9LFxuXG4gICAgLy8gRGVmYXVsdCBVUkwgZm9yIHRoZSBtb2RlbCdzIHJlcHJlc2VudGF0aW9uIG9uIHRoZSBzZXJ2ZXIgLS0gaWYgeW91J3JlXG4gICAgLy8gdXNpbmcgQmFja2JvbmUncyByZXN0ZnVsIG1ldGhvZHMsIG92ZXJyaWRlIHRoaXMgdG8gY2hhbmdlIHRoZSBlbmRwb2ludFxuICAgIC8vIHRoYXQgd2lsbCBiZSBjYWxsZWQuXG4gICAgdXJsOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiYXNlID1cbiAgICAgICAgXy5yZXN1bHQodGhpcywgJ3VybFJvb3QnKSB8fFxuICAgICAgICBfLnJlc3VsdCh0aGlzLmNvbGxlY3Rpb24sICd1cmwnKSB8fFxuICAgICAgICB1cmxFcnJvcigpO1xuICAgICAgaWYgKHRoaXMuaXNOZXcoKSkgcmV0dXJuIGJhc2U7XG4gICAgICB2YXIgaWQgPSB0aGlzLmdldCh0aGlzLmlkQXR0cmlidXRlKTtcbiAgICAgIHJldHVybiBiYXNlLnJlcGxhY2UoL1teXFwvXSQvLCAnJCYvJykgKyBlbmNvZGVVUklDb21wb25lbnQoaWQpO1xuICAgIH0sXG5cbiAgICAvLyAqKnBhcnNlKiogY29udmVydHMgYSByZXNwb25zZSBpbnRvIHRoZSBoYXNoIG9mIGF0dHJpYnV0ZXMgdG8gYmUgYHNldGAgb25cbiAgICAvLyB0aGUgbW9kZWwuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGlzIGp1c3QgdG8gcGFzcyB0aGUgcmVzcG9uc2UgYWxvbmcuXG4gICAgcGFyc2U6IGZ1bmN0aW9uKHJlc3AsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiByZXNwO1xuICAgIH0sXG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgbW9kZWwgd2l0aCBpZGVudGljYWwgYXR0cmlidXRlcyB0byB0aGlzIG9uZS5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICB9LFxuXG4gICAgLy8gQSBtb2RlbCBpcyBuZXcgaWYgaXQgaGFzIG5ldmVyIGJlZW4gc2F2ZWQgdG8gdGhlIHNlcnZlciwgYW5kIGxhY2tzIGFuIGlkLlxuICAgIGlzTmV3OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhdGhpcy5oYXModGhpcy5pZEF0dHJpYnV0ZSk7XG4gICAgfSxcblxuICAgIC8vIENoZWNrIGlmIHRoZSBtb2RlbCBpcyBjdXJyZW50bHkgaW4gYSB2YWxpZCBzdGF0ZS5cbiAgICBpc1ZhbGlkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsaWRhdGUoe30sIF8uZGVmYXVsdHMoe3ZhbGlkYXRlOiB0cnVlfSwgb3B0aW9ucykpO1xuICAgIH0sXG5cbiAgICAvLyBSdW4gdmFsaWRhdGlvbiBhZ2FpbnN0IHRoZSBuZXh0IGNvbXBsZXRlIHNldCBvZiBtb2RlbCBhdHRyaWJ1dGVzLFxuICAgIC8vIHJldHVybmluZyBgdHJ1ZWAgaWYgYWxsIGlzIHdlbGwuIE90aGVyd2lzZSwgZmlyZSBhbiBgXCJpbnZhbGlkXCJgIGV2ZW50LlxuICAgIF92YWxpZGF0ZTogZnVuY3Rpb24oYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucy52YWxpZGF0ZSB8fCAhdGhpcy52YWxpZGF0ZSkgcmV0dXJuIHRydWU7XG4gICAgICBhdHRycyA9IF8uZXh0ZW5kKHt9LCB0aGlzLmF0dHJpYnV0ZXMsIGF0dHJzKTtcbiAgICAgIHZhciBlcnJvciA9IHRoaXMudmFsaWRhdGlvbkVycm9yID0gdGhpcy52YWxpZGF0ZShhdHRycywgb3B0aW9ucykgfHwgbnVsbDtcbiAgICAgIGlmICghZXJyb3IpIHJldHVybiB0cnVlO1xuICAgICAgdGhpcy50cmlnZ2VyKCdpbnZhbGlkJywgdGhpcywgZXJyb3IsIF8uZXh0ZW5kKG9wdGlvbnMsIHt2YWxpZGF0aW9uRXJyb3I6IGVycm9yfSkpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBVbmRlcnNjb3JlIG1ldGhvZHMgdGhhdCB3ZSB3YW50IHRvIGltcGxlbWVudCBvbiB0aGUgTW9kZWwuXG4gIHZhciBtb2RlbE1ldGhvZHMgPSB7IGtleXM6IDEsIHZhbHVlczogMSwgcGFpcnM6IDEsIGludmVydDogMSwgcGljazogMCxcbiAgICAgIG9taXQ6IDAsIGNoYWluOiAxLCBpc0VtcHR5OiAxIH07XG5cbiAgLy8gTWl4IGluIGVhY2ggVW5kZXJzY29yZSBtZXRob2QgYXMgYSBwcm94eSB0byBgTW9kZWwjYXR0cmlidXRlc2AuXG4gIGFkZFVuZGVyc2NvcmVNZXRob2RzKE1vZGVsLCBtb2RlbE1ldGhvZHMsICdhdHRyaWJ1dGVzJyk7XG5cbiAgLy8gQmFja2JvbmUuQ29sbGVjdGlvblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gSWYgbW9kZWxzIHRlbmQgdG8gcmVwcmVzZW50IGEgc2luZ2xlIHJvdyBvZiBkYXRhLCBhIEJhY2tib25lIENvbGxlY3Rpb24gaXNcbiAgLy8gbW9yZSBhbmFsb2dvdXMgdG8gYSB0YWJsZSBmdWxsIG9mIGRhdGEgLi4uIG9yIGEgc21hbGwgc2xpY2Ugb3IgcGFnZSBvZiB0aGF0XG4gIC8vIHRhYmxlLCBvciBhIGNvbGxlY3Rpb24gb2Ygcm93cyB0aGF0IGJlbG9uZyB0b2dldGhlciBmb3IgYSBwYXJ0aWN1bGFyIHJlYXNvblxuICAvLyAtLSBhbGwgb2YgdGhlIG1lc3NhZ2VzIGluIHRoaXMgcGFydGljdWxhciBmb2xkZXIsIGFsbCBvZiB0aGUgZG9jdW1lbnRzXG4gIC8vIGJlbG9uZ2luZyB0byB0aGlzIHBhcnRpY3VsYXIgYXV0aG9yLCBhbmQgc28gb24uIENvbGxlY3Rpb25zIG1haW50YWluXG4gIC8vIGluZGV4ZXMgb2YgdGhlaXIgbW9kZWxzLCBib3RoIGluIG9yZGVyLCBhbmQgZm9yIGxvb2t1cCBieSBgaWRgLlxuXG4gIC8vIENyZWF0ZSBhIG5ldyAqKkNvbGxlY3Rpb24qKiwgcGVyaGFwcyB0byBjb250YWluIGEgc3BlY2lmaWMgdHlwZSBvZiBgbW9kZWxgLlxuICAvLyBJZiBhIGBjb21wYXJhdG9yYCBpcyBzcGVjaWZpZWQsIHRoZSBDb2xsZWN0aW9uIHdpbGwgbWFpbnRhaW5cbiAgLy8gaXRzIG1vZGVscyBpbiBzb3J0IG9yZGVyLCBhcyB0aGV5J3JlIGFkZGVkIGFuZCByZW1vdmVkLlxuICB2YXIgQ29sbGVjdGlvbiA9IEJhY2tib25lLkNvbGxlY3Rpb24gPSBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIGlmIChvcHRpb25zLm1vZGVsKSB0aGlzLm1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICBpZiAob3B0aW9ucy5jb21wYXJhdG9yICE9PSB2b2lkIDApIHRoaXMuY29tcGFyYXRvciA9IG9wdGlvbnMuY29tcGFyYXRvcjtcbiAgICB0aGlzLl9yZXNldCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChtb2RlbHMpIHRoaXMucmVzZXQobW9kZWxzLCBfLmV4dGVuZCh7c2lsZW50OiB0cnVlfSwgb3B0aW9ucykpO1xuICB9O1xuXG4gIC8vIERlZmF1bHQgb3B0aW9ucyBmb3IgYENvbGxlY3Rpb24jc2V0YC5cbiAgdmFyIHNldE9wdGlvbnMgPSB7YWRkOiB0cnVlLCByZW1vdmU6IHRydWUsIG1lcmdlOiB0cnVlfTtcbiAgdmFyIGFkZE9wdGlvbnMgPSB7YWRkOiB0cnVlLCByZW1vdmU6IGZhbHNlfTtcblxuICAvLyBEZWZpbmUgdGhlIENvbGxlY3Rpb24ncyBpbmhlcml0YWJsZSBtZXRob2RzLlxuICBfLmV4dGVuZChDb2xsZWN0aW9uLnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBUaGUgZGVmYXVsdCBtb2RlbCBmb3IgYSBjb2xsZWN0aW9uIGlzIGp1c3QgYSAqKkJhY2tib25lLk1vZGVsKiouXG4gICAgLy8gVGhpcyBzaG91bGQgYmUgb3ZlcnJpZGRlbiBpbiBtb3N0IGNhc2VzLlxuICAgIG1vZGVsOiBNb2RlbCxcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vIFRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgQ29sbGVjdGlvbiBpcyBhbiBhcnJheSBvZiB0aGVcbiAgICAvLyBtb2RlbHMnIGF0dHJpYnV0ZXMuXG4gICAgdG9KU09OOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24obW9kZWwpIHsgcmV0dXJuIG1vZGVsLnRvSlNPTihvcHRpb25zKTsgfSk7XG4gICAgfSxcblxuICAgIC8vIFByb3h5IGBCYWNrYm9uZS5zeW5jYCBieSBkZWZhdWx0LlxuICAgIHN5bmM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEJhY2tib25lLnN5bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgbW9kZWwsIG9yIGxpc3Qgb2YgbW9kZWxzIHRvIHRoZSBzZXQuXG4gICAgYWRkOiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldChtb2RlbHMsIF8uZXh0ZW5kKHttZXJnZTogZmFsc2V9LCBvcHRpb25zLCBhZGRPcHRpb25zKSk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBhIG1vZGVsLCBvciBhIGxpc3Qgb2YgbW9kZWxzIGZyb20gdGhlIHNldC5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgICAgIHZhciBzaW5ndWxhciA9ICFfLmlzQXJyYXkobW9kZWxzKTtcbiAgICAgIG1vZGVscyA9IHNpbmd1bGFyID8gW21vZGVsc10gOiBfLmNsb25lKG1vZGVscyk7XG4gICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMuX3JlbW92ZU1vZGVscyhtb2RlbHMsIG9wdGlvbnMpO1xuICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCAmJiByZW1vdmVkKSB0aGlzLnRyaWdnZXIoJ3VwZGF0ZScsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHNpbmd1bGFyID8gcmVtb3ZlZFswXSA6IHJlbW92ZWQ7XG4gICAgfSxcblxuICAgIC8vIFVwZGF0ZSBhIGNvbGxlY3Rpb24gYnkgYHNldGAtaW5nIGEgbmV3IGxpc3Qgb2YgbW9kZWxzLCBhZGRpbmcgbmV3IG9uZXMsXG4gICAgLy8gcmVtb3ZpbmcgbW9kZWxzIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LCBhbmQgbWVyZ2luZyBtb2RlbHMgdGhhdFxuICAgIC8vIGFscmVhZHkgZXhpc3QgaW4gdGhlIGNvbGxlY3Rpb24sIGFzIG5lY2Vzc2FyeS4gU2ltaWxhciB0byAqKk1vZGVsI3NldCoqLFxuICAgIC8vIHRoZSBjb3JlIG9wZXJhdGlvbiBmb3IgdXBkYXRpbmcgdGhlIGRhdGEgY29udGFpbmVkIGJ5IHRoZSBjb2xsZWN0aW9uLlxuICAgIHNldDogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gXy5kZWZhdWx0cyh7fSwgb3B0aW9ucywgc2V0T3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5wYXJzZSAmJiAhdGhpcy5faXNNb2RlbChtb2RlbHMpKSBtb2RlbHMgPSB0aGlzLnBhcnNlKG1vZGVscywgb3B0aW9ucyk7XG4gICAgICB2YXIgc2luZ3VsYXIgPSAhXy5pc0FycmF5KG1vZGVscyk7XG4gICAgICBtb2RlbHMgPSBzaW5ndWxhciA/IChtb2RlbHMgPyBbbW9kZWxzXSA6IFtdKSA6IG1vZGVscy5zbGljZSgpO1xuICAgICAgdmFyIGlkLCBtb2RlbCwgYXR0cnMsIGV4aXN0aW5nLCBzb3J0O1xuICAgICAgdmFyIGF0ID0gb3B0aW9ucy5hdDtcbiAgICAgIGlmIChhdCAhPSBudWxsKSBhdCA9ICthdDtcbiAgICAgIGlmIChhdCA8IDApIGF0ICs9IHRoaXMubGVuZ3RoICsgMTtcbiAgICAgIHZhciBzb3J0YWJsZSA9IHRoaXMuY29tcGFyYXRvciAmJiAoYXQgPT0gbnVsbCkgJiYgb3B0aW9ucy5zb3J0ICE9PSBmYWxzZTtcbiAgICAgIHZhciBzb3J0QXR0ciA9IF8uaXNTdHJpbmcodGhpcy5jb21wYXJhdG9yKSA/IHRoaXMuY29tcGFyYXRvciA6IG51bGw7XG4gICAgICB2YXIgdG9BZGQgPSBbXSwgdG9SZW1vdmUgPSBbXSwgbW9kZWxNYXAgPSB7fTtcbiAgICAgIHZhciBhZGQgPSBvcHRpb25zLmFkZCwgbWVyZ2UgPSBvcHRpb25zLm1lcmdlLCByZW1vdmUgPSBvcHRpb25zLnJlbW92ZTtcbiAgICAgIHZhciBvcmRlciA9ICFzb3J0YWJsZSAmJiBhZGQgJiYgcmVtb3ZlID8gW10gOiBmYWxzZTtcbiAgICAgIHZhciBvcmRlckNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgLy8gVHVybiBiYXJlIG9iamVjdHMgaW50byBtb2RlbCByZWZlcmVuY2VzLCBhbmQgcHJldmVudCBpbnZhbGlkIG1vZGVsc1xuICAgICAgLy8gZnJvbSBiZWluZyBhZGRlZC5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW9kZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGF0dHJzID0gbW9kZWxzW2ldO1xuXG4gICAgICAgIC8vIElmIGEgZHVwbGljYXRlIGlzIGZvdW5kLCBwcmV2ZW50IGl0IGZyb20gYmVpbmcgYWRkZWQgYW5kXG4gICAgICAgIC8vIG9wdGlvbmFsbHkgbWVyZ2UgaXQgaW50byB0aGUgZXhpc3RpbmcgbW9kZWwuXG4gICAgICAgIGlmIChleGlzdGluZyA9IHRoaXMuZ2V0KGF0dHJzKSkge1xuICAgICAgICAgIGlmIChyZW1vdmUpIG1vZGVsTWFwW2V4aXN0aW5nLmNpZF0gPSB0cnVlO1xuICAgICAgICAgIGlmIChtZXJnZSAmJiBhdHRycyAhPT0gZXhpc3RpbmcpIHtcbiAgICAgICAgICAgIGF0dHJzID0gdGhpcy5faXNNb2RlbChhdHRycykgPyBhdHRycy5hdHRyaWJ1dGVzIDogYXR0cnM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYXJzZSkgYXR0cnMgPSBleGlzdGluZy5wYXJzZShhdHRycywgb3B0aW9ucyk7XG4gICAgICAgICAgICBleGlzdGluZy5zZXQoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHNvcnRhYmxlICYmICFzb3J0ICYmIGV4aXN0aW5nLmhhc0NoYW5nZWQoc29ydEF0dHIpKSBzb3J0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbW9kZWxzW2ldID0gZXhpc3Rpbmc7XG5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG5ldywgdmFsaWQgbW9kZWwsIHB1c2ggaXQgdG8gdGhlIGB0b0FkZGAgbGlzdC5cbiAgICAgICAgfSBlbHNlIGlmIChhZGQpIHtcbiAgICAgICAgICBtb2RlbCA9IG1vZGVsc1tpXSA9IHRoaXMuX3ByZXBhcmVNb2RlbChhdHRycywgb3B0aW9ucyk7XG4gICAgICAgICAgaWYgKCFtb2RlbCkgY29udGludWU7XG4gICAgICAgICAgdG9BZGQucHVzaChtb2RlbCk7XG4gICAgICAgICAgdGhpcy5fYWRkUmVmZXJlbmNlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvIG5vdCBhZGQgbXVsdGlwbGUgbW9kZWxzIHdpdGggdGhlIHNhbWUgYGlkYC5cbiAgICAgICAgbW9kZWwgPSBleGlzdGluZyB8fCBtb2RlbDtcbiAgICAgICAgaWYgKCFtb2RlbCkgY29udGludWU7XG4gICAgICAgIGlkID0gdGhpcy5tb2RlbElkKG1vZGVsLmF0dHJpYnV0ZXMpO1xuICAgICAgICBpZiAob3JkZXIgJiYgKG1vZGVsLmlzTmV3KCkgfHwgIW1vZGVsTWFwW2lkXSkpIHtcbiAgICAgICAgICBvcmRlci5wdXNoKG1vZGVsKTtcblxuICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGlzIGlzIGFjdHVhbGx5IGEgbmV3IG1vZGVsIGF0IHRoaXMgaW5kZXguXG4gICAgICAgICAgb3JkZXJDaGFuZ2VkID0gb3JkZXJDaGFuZ2VkIHx8ICF0aGlzLm1vZGVsc1tpXSB8fCBtb2RlbC5jaWQgIT09IHRoaXMubW9kZWxzW2ldLmNpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vZGVsTWFwW2lkXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBub25leGlzdGVudCBtb2RlbHMgaWYgYXBwcm9wcmlhdGUuXG4gICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICghbW9kZWxNYXBbKG1vZGVsID0gdGhpcy5tb2RlbHNbaV0pLmNpZF0pIHRvUmVtb3ZlLnB1c2gobW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b1JlbW92ZS5sZW5ndGgpIHRoaXMuX3JlbW92ZU1vZGVscyh0b1JlbW92ZSwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlZSBpZiBzb3J0aW5nIGlzIG5lZWRlZCwgdXBkYXRlIGBsZW5ndGhgIGFuZCBzcGxpY2UgaW4gbmV3IG1vZGVscy5cbiAgICAgIGlmICh0b0FkZC5sZW5ndGggfHwgb3JkZXJDaGFuZ2VkKSB7XG4gICAgICAgIGlmIChzb3J0YWJsZSkgc29ydCA9IHRydWU7XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IHRvQWRkLmxlbmd0aDtcbiAgICAgICAgaWYgKGF0ICE9IG51bGwpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvQWRkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVscy5zcGxpY2UoYXQgKyBpLCAwLCB0b0FkZFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChvcmRlcikgdGhpcy5tb2RlbHMubGVuZ3RoID0gMDtcbiAgICAgICAgICB2YXIgb3JkZXJlZE1vZGVscyA9IG9yZGVyIHx8IHRvQWRkO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXJlZE1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5tb2RlbHMucHVzaChvcmRlcmVkTW9kZWxzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU2lsZW50bHkgc29ydCB0aGUgY29sbGVjdGlvbiBpZiBhcHByb3ByaWF0ZS5cbiAgICAgIGlmIChzb3J0KSB0aGlzLnNvcnQoe3NpbGVudDogdHJ1ZX0pO1xuXG4gICAgICAvLyBVbmxlc3Mgc2lsZW5jZWQsIGl0J3MgdGltZSB0byBmaXJlIGFsbCBhcHByb3ByaWF0ZSBhZGQvc29ydCBldmVudHMuXG4gICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgIHZhciBhZGRPcHRzID0gYXQgIT0gbnVsbCA/IF8uY2xvbmUob3B0aW9ucykgOiBvcHRpb25zO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvQWRkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGF0ICE9IG51bGwpIGFkZE9wdHMuaW5kZXggPSBhdCArIGk7XG4gICAgICAgICAgKG1vZGVsID0gdG9BZGRbaV0pLnRyaWdnZXIoJ2FkZCcsIG1vZGVsLCB0aGlzLCBhZGRPcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc29ydCB8fCBvcmRlckNoYW5nZWQpIHRoaXMudHJpZ2dlcignc29ydCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAodG9BZGQubGVuZ3RoIHx8IHRvUmVtb3ZlLmxlbmd0aCkgdGhpcy50cmlnZ2VyKCd1cGRhdGUnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIHRoZSBhZGRlZCAob3IgbWVyZ2VkKSBtb2RlbCAob3IgbW9kZWxzKS5cbiAgICAgIHJldHVybiBzaW5ndWxhciA/IG1vZGVsc1swXSA6IG1vZGVscztcbiAgICB9LFxuXG4gICAgLy8gV2hlbiB5b3UgaGF2ZSBtb3JlIGl0ZW1zIHRoYW4geW91IHdhbnQgdG8gYWRkIG9yIHJlbW92ZSBpbmRpdmlkdWFsbHksXG4gICAgLy8geW91IGNhbiByZXNldCB0aGUgZW50aXJlIHNldCB3aXRoIGEgbmV3IGxpc3Qgb2YgbW9kZWxzLCB3aXRob3V0IGZpcmluZ1xuICAgIC8vIGFueSBncmFudWxhciBgYWRkYCBvciBgcmVtb3ZlYCBldmVudHMuIEZpcmVzIGByZXNldGAgd2hlbiBmaW5pc2hlZC5cbiAgICAvLyBVc2VmdWwgZm9yIGJ1bGsgb3BlcmF0aW9ucyBhbmQgb3B0aW1pemF0aW9ucy5cbiAgICByZXNldDogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tb2RlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlUmVmZXJlbmNlKHRoaXMubW9kZWxzW2ldLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMucHJldmlvdXNNb2RlbHMgPSB0aGlzLm1vZGVscztcbiAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICBtb2RlbHMgPSB0aGlzLmFkZChtb2RlbHMsIF8uZXh0ZW5kKHtzaWxlbnQ6IHRydWV9LCBvcHRpb25zKSk7XG4gICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB0aGlzLnRyaWdnZXIoJ3Jlc2V0JywgdGhpcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gbW9kZWxzO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBtb2RlbCB0byB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHB1c2g6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGQobW9kZWwsIF8uZXh0ZW5kKHthdDogdGhpcy5sZW5ndGh9LCBvcHRpb25zKSk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBhIG1vZGVsIGZyb20gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICBwb3A6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMuYXQodGhpcy5sZW5ndGggLSAxKTtcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIG1vZGVsIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgdW5zaGlmdDogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZChtb2RlbCwgXy5leHRlbmQoe2F0OiAwfSwgb3B0aW9ucykpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYSBtb2RlbCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgc2hpZnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMuYXQoMCk7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmUobW9kZWwsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyBTbGljZSBvdXQgYSBzdWItYXJyYXkgb2YgbW9kZWxzIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgc2xpY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNsaWNlLmFwcGx5KHRoaXMubW9kZWxzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYSBtb2RlbCBmcm9tIHRoZSBzZXQgYnkgaWQuXG4gICAgZ2V0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgIHZhciBpZCA9IHRoaXMubW9kZWxJZCh0aGlzLl9pc01vZGVsKG9iaikgPyBvYmouYXR0cmlidXRlcyA6IG9iaik7XG4gICAgICByZXR1cm4gdGhpcy5fYnlJZFtvYmpdIHx8IHRoaXMuX2J5SWRbaWRdIHx8IHRoaXMuX2J5SWRbb2JqLmNpZF07XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgbW9kZWwgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgIGF0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaWYgKGluZGV4IDwgMCkgaW5kZXggKz0gdGhpcy5sZW5ndGg7XG4gICAgICByZXR1cm4gdGhpcy5tb2RlbHNbaW5kZXhdO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gbW9kZWxzIHdpdGggbWF0Y2hpbmcgYXR0cmlidXRlcy4gVXNlZnVsIGZvciBzaW1wbGUgY2FzZXMgb2ZcbiAgICAvLyBgZmlsdGVyYC5cbiAgICB3aGVyZTogZnVuY3Rpb24oYXR0cnMsIGZpcnN0KSB7XG4gICAgICB2YXIgbWF0Y2hlcyA9IF8ubWF0Y2hlcyhhdHRycyk7XG4gICAgICByZXR1cm4gdGhpc1tmaXJzdCA/ICdmaW5kJyA6ICdmaWx0ZXInXShmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlcyhtb2RlbC5hdHRyaWJ1dGVzKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gdGhlIGZpcnN0IG1vZGVsIHdpdGggbWF0Y2hpbmcgYXR0cmlidXRlcy4gVXNlZnVsIGZvciBzaW1wbGUgY2FzZXNcbiAgICAvLyBvZiBgZmluZGAuXG4gICAgZmluZFdoZXJlOiBmdW5jdGlvbihhdHRycykge1xuICAgICAgcmV0dXJuIHRoaXMud2hlcmUoYXR0cnMsIHRydWUpO1xuICAgIH0sXG5cbiAgICAvLyBGb3JjZSB0aGUgY29sbGVjdGlvbiB0byByZS1zb3J0IGl0c2VsZi4gWW91IGRvbid0IG5lZWQgdG8gY2FsbCB0aGlzIHVuZGVyXG4gICAgLy8gbm9ybWFsIGNpcmN1bXN0YW5jZXMsIGFzIHRoZSBzZXQgd2lsbCBtYWludGFpbiBzb3J0IG9yZGVyIGFzIGVhY2ggaXRlbVxuICAgIC8vIGlzIGFkZGVkLlxuICAgIHNvcnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5jb21wYXJhdG9yKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzb3J0IGEgc2V0IHdpdGhvdXQgYSBjb21wYXJhdG9yJyk7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuXG4gICAgICAvLyBSdW4gc29ydCBiYXNlZCBvbiB0eXBlIG9mIGBjb21wYXJhdG9yYC5cbiAgICAgIGlmIChfLmlzU3RyaW5nKHRoaXMuY29tcGFyYXRvcikgfHwgdGhpcy5jb21wYXJhdG9yLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGlzLm1vZGVscyA9IHRoaXMuc29ydEJ5KHRoaXMuY29tcGFyYXRvciwgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1vZGVscy5zb3J0KF8uYmluZCh0aGlzLmNvbXBhcmF0b3IsIHRoaXMpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCkgdGhpcy50cmlnZ2VyKCdzb3J0JywgdGhpcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUGx1Y2sgYW4gYXR0cmlidXRlIGZyb20gZWFjaCBtb2RlbCBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICBwbHVjazogZnVuY3Rpb24oYXR0cikge1xuICAgICAgcmV0dXJuIF8uaW52b2tlKHRoaXMubW9kZWxzLCAnZ2V0JywgYXR0cik7XG4gICAgfSxcblxuICAgIC8vIEZldGNoIHRoZSBkZWZhdWx0IHNldCBvZiBtb2RlbHMgZm9yIHRoaXMgY29sbGVjdGlvbiwgcmVzZXR0aW5nIHRoZVxuICAgIC8vIGNvbGxlY3Rpb24gd2hlbiB0aGV5IGFycml2ZS4gSWYgYHJlc2V0OiB0cnVlYCBpcyBwYXNzZWQsIHRoZSByZXNwb25zZVxuICAgIC8vIGRhdGEgd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB0aGUgYHJlc2V0YCBtZXRob2QgaW5zdGVhZCBvZiBgc2V0YC5cbiAgICBmZXRjaDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHtwYXJzZTogdHJ1ZX0sIG9wdGlvbnMpO1xuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XG4gICAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvcHRpb25zLnJlc2V0ID8gJ3Jlc2V0JyA6ICdzZXQnO1xuICAgICAgICBjb2xsZWN0aW9uW21ldGhvZF0ocmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzLmNhbGwob3B0aW9ucy5jb250ZXh0LCBjb2xsZWN0aW9uLCByZXNwLCBvcHRpb25zKTtcbiAgICAgICAgY29sbGVjdGlvbi50cmlnZ2VyKCdzeW5jJywgY29sbGVjdGlvbiwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICB9O1xuICAgICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuc3luYygncmVhZCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgYSBtb2RlbCBpbiB0aGlzIGNvbGxlY3Rpb24uIEFkZCB0aGUgbW9kZWwgdG8gdGhlXG4gICAgLy8gY29sbGVjdGlvbiBpbW1lZGlhdGVseSwgdW5sZXNzIGB3YWl0OiB0cnVlYCBpcyBwYXNzZWQsIGluIHdoaWNoIGNhc2Ugd2VcbiAgICAvLyB3YWl0IGZvciB0aGUgc2VydmVyIHRvIGFncmVlLlxuICAgIGNyZWF0ZTogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgdmFyIHdhaXQgPSBvcHRpb25zLndhaXQ7XG4gICAgICBtb2RlbCA9IHRoaXMuX3ByZXBhcmVNb2RlbChtb2RlbCwgb3B0aW9ucyk7XG4gICAgICBpZiAoIW1vZGVsKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoIXdhaXQpIHRoaXMuYWRkKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcztcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24obW9kZWwsIHJlc3AsIGNhbGxiYWNrT3B0cykge1xuICAgICAgICBpZiAod2FpdCkgY29sbGVjdGlvbi5hZGQobW9kZWwsIGNhbGxiYWNrT3B0cyk7XG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzLmNhbGwoY2FsbGJhY2tPcHRzLmNvbnRleHQsIG1vZGVsLCByZXNwLCBjYWxsYmFja09wdHMpO1xuICAgICAgfTtcbiAgICAgIG1vZGVsLnNhdmUobnVsbCwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSxcblxuICAgIC8vICoqcGFyc2UqKiBjb252ZXJ0cyBhIHJlc3BvbnNlIGludG8gYSBsaXN0IG9mIG1vZGVscyB0byBiZSBhZGRlZCB0byB0aGVcbiAgICAvLyBjb2xsZWN0aW9uLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyBqdXN0IHRvIHBhc3MgaXQgdGhyb3VnaC5cbiAgICBwYXJzZTogZnVuY3Rpb24ocmVzcCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHJlc3A7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBjb2xsZWN0aW9uIHdpdGggYW4gaWRlbnRpY2FsIGxpc3Qgb2YgbW9kZWxzIGFzIHRoaXMgb25lLlxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLm1vZGVscywge1xuICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgY29tcGFyYXRvcjogdGhpcy5jb21wYXJhdG9yXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gRGVmaW5lIGhvdyB0byB1bmlxdWVseSBpZGVudGlmeSBtb2RlbHMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgbW9kZWxJZDogZnVuY3Rpb24gKGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnNbdGhpcy5tb2RlbC5wcm90b3R5cGUuaWRBdHRyaWJ1dGUgfHwgJ2lkJ107XG4gICAgfSxcblxuICAgIC8vIFByaXZhdGUgbWV0aG9kIHRvIHJlc2V0IGFsbCBpbnRlcm5hbCBzdGF0ZS4gQ2FsbGVkIHdoZW4gdGhlIGNvbGxlY3Rpb25cbiAgICAvLyBpcyBmaXJzdCBpbml0aWFsaXplZCBvciByZXNldC5cbiAgICBfcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5tb2RlbHMgPSBbXTtcbiAgICAgIHRoaXMuX2J5SWQgID0ge307XG4gICAgfSxcblxuICAgIC8vIFByZXBhcmUgYSBoYXNoIG9mIGF0dHJpYnV0ZXMgKG9yIG90aGVyIG1vZGVsKSB0byBiZSBhZGRlZCB0byB0aGlzXG4gICAgLy8gY29sbGVjdGlvbi5cbiAgICBfcHJlcGFyZU1vZGVsOiBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuX2lzTW9kZWwoYXR0cnMpKSB7XG4gICAgICAgIGlmICghYXR0cnMuY29sbGVjdGlvbikgYXR0cnMuY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBhdHRycztcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgb3B0aW9ucy5jb2xsZWN0aW9uID0gdGhpcztcbiAgICAgIHZhciBtb2RlbCA9IG5ldyB0aGlzLm1vZGVsKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgIGlmICghbW9kZWwudmFsaWRhdGlvbkVycm9yKSByZXR1cm4gbW9kZWw7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2ludmFsaWQnLCB0aGlzLCBtb2RlbC52YWxpZGF0aW9uRXJyb3IsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgY2FsbGVkIGJ5IGJvdGggcmVtb3ZlIGFuZCBzZXQuXG4gICAgLy8gUmV0dXJucyByZW1vdmVkIG1vZGVscywgb3IgZmFsc2UgaWYgbm90aGluZyBpcyByZW1vdmVkLlxuICAgIF9yZW1vdmVNb2RlbHM6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW9kZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMuZ2V0KG1vZGVsc1tpXSk7XG4gICAgICAgIGlmICghbW9kZWwpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXhPZihtb2RlbCk7XG4gICAgICAgIHRoaXMubW9kZWxzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHRoaXMubGVuZ3RoLS07XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgIG9wdGlvbnMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICBtb2RlbC50cmlnZ2VyKCdyZW1vdmUnLCBtb2RlbCwgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZW1vdmVkLnB1c2gobW9kZWwpO1xuICAgICAgICB0aGlzLl9yZW1vdmVSZWZlcmVuY2UobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlbW92ZWQubGVuZ3RoID8gcmVtb3ZlZCA6IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBNZXRob2QgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgbW9kZWwgZm9yXG4gICAgLy8gdGhlIHB1cnBvc2VzIG9mIGFkZGluZyB0byB0aGUgY29sbGVjdGlvbi5cbiAgICBfaXNNb2RlbDogZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICByZXR1cm4gbW9kZWwgaW5zdGFuY2VvZiBNb2RlbDtcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIGNyZWF0ZSBhIG1vZGVsJ3MgdGllcyB0byBhIGNvbGxlY3Rpb24uXG4gICAgX2FkZFJlZmVyZW5jZTogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2J5SWRbbW9kZWwuY2lkXSA9IG1vZGVsO1xuICAgICAgdmFyIGlkID0gdGhpcy5tb2RlbElkKG1vZGVsLmF0dHJpYnV0ZXMpO1xuICAgICAgaWYgKGlkICE9IG51bGwpIHRoaXMuX2J5SWRbaWRdID0gbW9kZWw7XG4gICAgICBtb2RlbC5vbignYWxsJywgdGhpcy5fb25Nb2RlbEV2ZW50LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIHRvIHNldmVyIGEgbW9kZWwncyB0aWVzIHRvIGEgY29sbGVjdGlvbi5cbiAgICBfcmVtb3ZlUmVmZXJlbmNlOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgZGVsZXRlIHRoaXMuX2J5SWRbbW9kZWwuY2lkXTtcbiAgICAgIHZhciBpZCA9IHRoaXMubW9kZWxJZChtb2RlbC5hdHRyaWJ1dGVzKTtcbiAgICAgIGlmIChpZCAhPSBudWxsKSBkZWxldGUgdGhpcy5fYnlJZFtpZF07XG4gICAgICBpZiAodGhpcyA9PT0gbW9kZWwuY29sbGVjdGlvbikgZGVsZXRlIG1vZGVsLmNvbGxlY3Rpb247XG4gICAgICBtb2RlbC5vZmYoJ2FsbCcsIHRoaXMuX29uTW9kZWxFdmVudCwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCBjYWxsZWQgZXZlcnkgdGltZSBhIG1vZGVsIGluIHRoZSBzZXQgZmlyZXMgYW4gZXZlbnQuXG4gICAgLy8gU2V0cyBuZWVkIHRvIHVwZGF0ZSB0aGVpciBpbmRleGVzIHdoZW4gbW9kZWxzIGNoYW5nZSBpZHMuIEFsbCBvdGhlclxuICAgIC8vIGV2ZW50cyBzaW1wbHkgcHJveHkgdGhyb3VnaC4gXCJhZGRcIiBhbmQgXCJyZW1vdmVcIiBldmVudHMgdGhhdCBvcmlnaW5hdGVcbiAgICAvLyBpbiBvdGhlciBjb2xsZWN0aW9ucyBhcmUgaWdub3JlZC5cbiAgICBfb25Nb2RlbEV2ZW50OiBmdW5jdGlvbihldmVudCwgbW9kZWwsIGNvbGxlY3Rpb24sIG9wdGlvbnMpIHtcbiAgICAgIGlmICgoZXZlbnQgPT09ICdhZGQnIHx8IGV2ZW50ID09PSAncmVtb3ZlJykgJiYgY29sbGVjdGlvbiAhPT0gdGhpcykgcmV0dXJuO1xuICAgICAgaWYgKGV2ZW50ID09PSAnZGVzdHJveScpIHRoaXMucmVtb3ZlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIGlmIChldmVudCA9PT0gJ2NoYW5nZScpIHtcbiAgICAgICAgdmFyIHByZXZJZCA9IHRoaXMubW9kZWxJZChtb2RlbC5wcmV2aW91c0F0dHJpYnV0ZXMoKSk7XG4gICAgICAgIHZhciBpZCA9IHRoaXMubW9kZWxJZChtb2RlbC5hdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKHByZXZJZCAhPT0gaWQpIHtcbiAgICAgICAgICBpZiAocHJldklkICE9IG51bGwpIGRlbGV0ZSB0aGlzLl9ieUlkW3ByZXZJZF07XG4gICAgICAgICAgaWYgKGlkICE9IG51bGwpIHRoaXMuX2J5SWRbaWRdID0gbW9kZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudHJpZ2dlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBVbmRlcnNjb3JlIG1ldGhvZHMgdGhhdCB3ZSB3YW50IHRvIGltcGxlbWVudCBvbiB0aGUgQ29sbGVjdGlvbi5cbiAgLy8gOTAlIG9mIHRoZSBjb3JlIHVzZWZ1bG5lc3Mgb2YgQmFja2JvbmUgQ29sbGVjdGlvbnMgaXMgYWN0dWFsbHkgaW1wbGVtZW50ZWRcbiAgLy8gcmlnaHQgaGVyZTpcbiAgdmFyIGNvbGxlY3Rpb25NZXRob2RzID0geyBmb3JFYWNoOiAzLCBlYWNoOiAzLCBtYXA6IDMsIGNvbGxlY3Q6IDMsIHJlZHVjZTogNCxcbiAgICAgIGZvbGRsOiA0LCBpbmplY3Q6IDQsIHJlZHVjZVJpZ2h0OiA0LCBmb2xkcjogNCwgZmluZDogMywgZGV0ZWN0OiAzLCBmaWx0ZXI6IDMsXG4gICAgICBzZWxlY3Q6IDMsIHJlamVjdDogMywgZXZlcnk6IDMsIGFsbDogMywgc29tZTogMywgYW55OiAzLCBpbmNsdWRlOiAyLFxuICAgICAgY29udGFpbnM6IDIsIGludm9rZTogMCwgbWF4OiAzLCBtaW46IDMsIHRvQXJyYXk6IDEsIHNpemU6IDEsIGZpcnN0OiAzLFxuICAgICAgaGVhZDogMywgdGFrZTogMywgaW5pdGlhbDogMywgcmVzdDogMywgdGFpbDogMywgZHJvcDogMywgbGFzdDogMyxcbiAgICAgIHdpdGhvdXQ6IDAsIGRpZmZlcmVuY2U6IDAsIGluZGV4T2Y6IDMsIHNodWZmbGU6IDEsIGxhc3RJbmRleE9mOiAzLFxuICAgICAgaXNFbXB0eTogMSwgY2hhaW46IDEsIHNhbXBsZTogMywgcGFydGl0aW9uOiAzIH07XG5cbiAgLy8gTWl4IGluIGVhY2ggVW5kZXJzY29yZSBtZXRob2QgYXMgYSBwcm94eSB0byBgQ29sbGVjdGlvbiNtb2RlbHNgLlxuICBhZGRVbmRlcnNjb3JlTWV0aG9kcyhDb2xsZWN0aW9uLCBjb2xsZWN0aW9uTWV0aG9kcywgJ21vZGVscycpO1xuXG4gIC8vIFVuZGVyc2NvcmUgbWV0aG9kcyB0aGF0IHRha2UgYSBwcm9wZXJ0eSBuYW1lIGFzIGFuIGFyZ3VtZW50LlxuICB2YXIgYXR0cmlidXRlTWV0aG9kcyA9IFsnZ3JvdXBCeScsICdjb3VudEJ5JywgJ3NvcnRCeScsICdpbmRleEJ5J107XG5cbiAgLy8gVXNlIGF0dHJpYnV0ZXMgaW5zdGVhZCBvZiBwcm9wZXJ0aWVzLlxuICBfLmVhY2goYXR0cmlidXRlTWV0aG9kcywgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgaWYgKCFfW21ldGhvZF0pIHJldHVybjtcbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZSA6IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgIHJldHVybiBtb2RlbC5nZXQodmFsdWUpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfW21ldGhvZF0odGhpcy5tb2RlbHMsIGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBCYWNrYm9uZS5WaWV3XG4gIC8vIC0tLS0tLS0tLS0tLS1cblxuICAvLyBCYWNrYm9uZSBWaWV3cyBhcmUgYWxtb3N0IG1vcmUgY29udmVudGlvbiB0aGFuIHRoZXkgYXJlIGFjdHVhbCBjb2RlLiBBIFZpZXdcbiAgLy8gaXMgc2ltcGx5IGEgSmF2YVNjcmlwdCBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgbG9naWNhbCBjaHVuayBvZiBVSSBpbiB0aGVcbiAgLy8gRE9NLiBUaGlzIG1pZ2h0IGJlIGEgc2luZ2xlIGl0ZW0sIGFuIGVudGlyZSBsaXN0LCBhIHNpZGViYXIgb3IgcGFuZWwsIG9yXG4gIC8vIGV2ZW4gdGhlIHN1cnJvdW5kaW5nIGZyYW1lIHdoaWNoIHdyYXBzIHlvdXIgd2hvbGUgYXBwLiBEZWZpbmluZyBhIGNodW5rIG9mXG4gIC8vIFVJIGFzIGEgKipWaWV3KiogYWxsb3dzIHlvdSB0byBkZWZpbmUgeW91ciBET00gZXZlbnRzIGRlY2xhcmF0aXZlbHksIHdpdGhvdXRcbiAgLy8gaGF2aW5nIHRvIHdvcnJ5IGFib3V0IHJlbmRlciBvcmRlciAuLi4gYW5kIG1ha2VzIGl0IGVhc3kgZm9yIHRoZSB2aWV3IHRvXG4gIC8vIHJlYWN0IHRvIHNwZWNpZmljIGNoYW5nZXMgaW4gdGhlIHN0YXRlIG9mIHlvdXIgbW9kZWxzLlxuXG4gIC8vIENyZWF0aW5nIGEgQmFja2JvbmUuVmlldyBjcmVhdGVzIGl0cyBpbml0aWFsIGVsZW1lbnQgb3V0c2lkZSBvZiB0aGUgRE9NLFxuICAvLyBpZiBhbiBleGlzdGluZyBlbGVtZW50IGlzIG5vdCBwcm92aWRlZC4uLlxuICB2YXIgVmlldyA9IEJhY2tib25lLlZpZXcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5jaWQgPSBfLnVuaXF1ZUlkKCd2aWV3Jyk7XG4gICAgXy5leHRlbmQodGhpcywgXy5waWNrKG9wdGlvbnMsIHZpZXdPcHRpb25zKSk7XG4gICAgdGhpcy5fZW5zdXJlRWxlbWVudCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIENhY2hlZCByZWdleCB0byBzcGxpdCBrZXlzIGZvciBgZGVsZWdhdGVgLlxuICB2YXIgZGVsZWdhdGVFdmVudFNwbGl0dGVyID0gL14oXFxTKylcXHMqKC4qKSQvO1xuXG4gIC8vIExpc3Qgb2YgdmlldyBvcHRpb25zIHRvIGJlIG1lcmdlZCBhcyBwcm9wZXJ0aWVzLlxuICB2YXIgdmlld09wdGlvbnMgPSBbJ21vZGVsJywgJ2NvbGxlY3Rpb24nLCAnZWwnLCAnaWQnLCAnYXR0cmlidXRlcycsICdjbGFzc05hbWUnLCAndGFnTmFtZScsICdldmVudHMnXTtcblxuICAvLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuVmlldyoqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKFZpZXcucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIFRoZSBkZWZhdWx0IGB0YWdOYW1lYCBvZiBhIFZpZXcncyBlbGVtZW50IGlzIGBcImRpdlwiYC5cbiAgICB0YWdOYW1lOiAnZGl2JyxcblxuICAgIC8vIGpRdWVyeSBkZWxlZ2F0ZSBmb3IgZWxlbWVudCBsb29rdXAsIHNjb3BlZCB0byBET00gZWxlbWVudHMgd2l0aGluIHRoZVxuICAgIC8vIGN1cnJlbnQgdmlldy4gVGhpcyBzaG91bGQgYmUgcHJlZmVycmVkIHRvIGdsb2JhbCBsb29rdXBzIHdoZXJlIHBvc3NpYmxlLlxuICAgICQ6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy4kZWwuZmluZChzZWxlY3Rvcik7XG4gICAgfSxcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vICoqcmVuZGVyKiogaXMgdGhlIGNvcmUgZnVuY3Rpb24gdGhhdCB5b3VyIHZpZXcgc2hvdWxkIG92ZXJyaWRlLCBpbiBvcmRlclxuICAgIC8vIHRvIHBvcHVsYXRlIGl0cyBlbGVtZW50IChgdGhpcy5lbGApLCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBIVE1MLiBUaGVcbiAgICAvLyBjb252ZW50aW9uIGlzIGZvciAqKnJlbmRlcioqIHRvIGFsd2F5cyByZXR1cm4gYHRoaXNgLlxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIHRoaXMgdmlldyBieSB0YWtpbmcgdGhlIGVsZW1lbnQgb3V0IG9mIHRoZSBET00sIGFuZCByZW1vdmluZyBhbnlcbiAgICAvLyBhcHBsaWNhYmxlIEJhY2tib25lLkV2ZW50cyBsaXN0ZW5lcnMuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUVsZW1lbnQoKTtcbiAgICAgIHRoaXMuc3RvcExpc3RlbmluZygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSB0aGlzIHZpZXcncyBlbGVtZW50IGZyb20gdGhlIGRvY3VtZW50IGFuZCBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgLy8gYXR0YWNoZWQgdG8gaXQuIEV4cG9zZWQgZm9yIHN1YmNsYXNzZXMgdXNpbmcgYW4gYWx0ZXJuYXRpdmUgRE9NXG4gICAgLy8gbWFuaXB1bGF0aW9uIEFQSS5cbiAgICBfcmVtb3ZlRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLiRlbC5yZW1vdmUoKTtcbiAgICB9LFxuXG4gICAgLy8gQ2hhbmdlIHRoZSB2aWV3J3MgZWxlbWVudCAoYHRoaXMuZWxgIHByb3BlcnR5KSBhbmQgcmUtZGVsZWdhdGUgdGhlXG4gICAgLy8gdmlldydzIGV2ZW50cyBvbiB0aGUgbmV3IGVsZW1lbnQuXG4gICAgc2V0RWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgdGhpcy51bmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICB0aGlzLl9zZXRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZXMgdGhlIGB0aGlzLmVsYCBhbmQgYHRoaXMuJGVsYCByZWZlcmVuY2VzIGZvciB0aGlzIHZpZXcgdXNpbmcgdGhlXG4gICAgLy8gZ2l2ZW4gYGVsYC4gYGVsYCBjYW4gYmUgYSBDU1Mgc2VsZWN0b3Igb3IgYW4gSFRNTCBzdHJpbmcsIGEgalF1ZXJ5XG4gICAgLy8gY29udGV4dCBvciBhbiBlbGVtZW50LiBTdWJjbGFzc2VzIGNhbiBvdmVycmlkZSB0aGlzIHRvIHV0aWxpemUgYW5cbiAgICAvLyBhbHRlcm5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIEFQSSBhbmQgYXJlIG9ubHkgcmVxdWlyZWQgdG8gc2V0IHRoZVxuICAgIC8vIGB0aGlzLmVsYCBwcm9wZXJ0eS5cbiAgICBfc2V0RWxlbWVudDogZnVuY3Rpb24oZWwpIHtcbiAgICAgIHRoaXMuJGVsID0gZWwgaW5zdGFuY2VvZiBCYWNrYm9uZS4kID8gZWwgOiBCYWNrYm9uZS4kKGVsKTtcbiAgICAgIHRoaXMuZWwgPSB0aGlzLiRlbFswXTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IGNhbGxiYWNrcywgd2hlcmUgYHRoaXMuZXZlbnRzYCBpcyBhIGhhc2ggb2ZcbiAgICAvL1xuICAgIC8vICp7XCJldmVudCBzZWxlY3RvclwiOiBcImNhbGxiYWNrXCJ9KlxuICAgIC8vXG4gICAgLy8gICAgIHtcbiAgICAvLyAgICAgICAnbW91c2Vkb3duIC50aXRsZSc6ICAnZWRpdCcsXG4gICAgLy8gICAgICAgJ2NsaWNrIC5idXR0b24nOiAgICAgJ3NhdmUnLFxuICAgIC8vICAgICAgICdjbGljayAub3Blbic6ICAgICAgIGZ1bmN0aW9uKGUpIHsgLi4uIH1cbiAgICAvLyAgICAgfVxuICAgIC8vXG4gICAgLy8gcGFpcnMuIENhbGxiYWNrcyB3aWxsIGJlIGJvdW5kIHRvIHRoZSB2aWV3LCB3aXRoIGB0aGlzYCBzZXQgcHJvcGVybHkuXG4gICAgLy8gVXNlcyBldmVudCBkZWxlZ2F0aW9uIGZvciBlZmZpY2llbmN5LlxuICAgIC8vIE9taXR0aW5nIHRoZSBzZWxlY3RvciBiaW5kcyB0aGUgZXZlbnQgdG8gYHRoaXMuZWxgLlxuICAgIGRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbihldmVudHMpIHtcbiAgICAgIGV2ZW50cyB8fCAoZXZlbnRzID0gXy5yZXN1bHQodGhpcywgJ2V2ZW50cycpKTtcbiAgICAgIGlmICghZXZlbnRzKSByZXR1cm4gdGhpcztcbiAgICAgIHRoaXMudW5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGV2ZW50cykge1xuICAgICAgICB2YXIgbWV0aG9kID0gZXZlbnRzW2tleV07XG4gICAgICAgIGlmICghXy5pc0Z1bmN0aW9uKG1ldGhvZCkpIG1ldGhvZCA9IHRoaXNbbWV0aG9kXTtcbiAgICAgICAgaWYgKCFtZXRob2QpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgbWF0Y2ggPSBrZXkubWF0Y2goZGVsZWdhdGVFdmVudFNwbGl0dGVyKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZShtYXRjaFsxXSwgbWF0Y2hbMl0sIF8uYmluZChtZXRob2QsIHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIHZpZXcncyBlbGVtZW50IChvciBhIGNoaWxkIGVsZW1lbnRcbiAgICAvLyB1c2luZyBgc2VsZWN0b3JgKS4gVGhpcyBvbmx5IHdvcmtzIGZvciBkZWxlZ2F0ZS1hYmxlIGV2ZW50czogbm90IGBmb2N1c2AsXG4gICAgLy8gYGJsdXJgLCBhbmQgbm90IGBjaGFuZ2VgLCBgc3VibWl0YCwgYW5kIGByZXNldGAgaW4gSW50ZXJuZXQgRXhwbG9yZXIuXG4gICAgZGVsZWdhdGU6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgc2VsZWN0b3IsIGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLiRlbC5vbihldmVudE5hbWUgKyAnLmRlbGVnYXRlRXZlbnRzJyArIHRoaXMuY2lkLCBzZWxlY3RvciwgbGlzdGVuZXIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENsZWFycyBhbGwgY2FsbGJhY2tzIHByZXZpb3VzbHkgYm91bmQgdG8gdGhlIHZpZXcgYnkgYGRlbGVnYXRlRXZlbnRzYC5cbiAgICAvLyBZb3UgdXN1YWxseSBkb24ndCBuZWVkIHRvIHVzZSB0aGlzLCBidXQgbWF5IHdpc2ggdG8gaWYgeW91IGhhdmUgbXVsdGlwbGVcbiAgICAvLyBCYWNrYm9uZSB2aWV3cyBhdHRhY2hlZCB0byB0aGUgc2FtZSBET00gZWxlbWVudC5cbiAgICB1bmRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLiRlbCkgdGhpcy4kZWwub2ZmKCcuZGVsZWdhdGVFdmVudHMnICsgdGhpcy5jaWQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEEgZmluZXItZ3JhaW5lZCBgdW5kZWxlZ2F0ZUV2ZW50c2AgZm9yIHJlbW92aW5nIGEgc2luZ2xlIGRlbGVnYXRlZCBldmVudC5cbiAgICAvLyBgc2VsZWN0b3JgIGFuZCBgbGlzdGVuZXJgIGFyZSBib3RoIG9wdGlvbmFsLlxuICAgIHVuZGVsZWdhdGU6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgc2VsZWN0b3IsIGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLiRlbC5vZmYoZXZlbnROYW1lICsgJy5kZWxlZ2F0ZUV2ZW50cycgKyB0aGlzLmNpZCwgc2VsZWN0b3IsIGxpc3RlbmVyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBQcm9kdWNlcyBhIERPTSBlbGVtZW50IHRvIGJlIGFzc2lnbmVkIHRvIHlvdXIgdmlldy4gRXhwb3NlZCBmb3JcbiAgICAvLyBzdWJjbGFzc2VzIHVzaW5nIGFuIGFsdGVybmF0aXZlIERPTSBtYW5pcHVsYXRpb24gQVBJLlxuICAgIF9jcmVhdGVFbGVtZW50OiBmdW5jdGlvbih0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICB9LFxuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIFZpZXcgaGFzIGEgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAgLy8gSWYgYHRoaXMuZWxgIGlzIGEgc3RyaW5nLCBwYXNzIGl0IHRocm91Z2ggYCQoKWAsIHRha2UgdGhlIGZpcnN0XG4gICAgLy8gbWF0Y2hpbmcgZWxlbWVudCwgYW5kIHJlLWFzc2lnbiBpdCB0byBgZWxgLiBPdGhlcndpc2UsIGNyZWF0ZVxuICAgIC8vIGFuIGVsZW1lbnQgZnJvbSB0aGUgYGlkYCwgYGNsYXNzTmFtZWAgYW5kIGB0YWdOYW1lYCBwcm9wZXJ0aWVzLlxuICAgIF9lbnN1cmVFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5lbCkge1xuICAgICAgICB2YXIgYXR0cnMgPSBfLmV4dGVuZCh7fSwgXy5yZXN1bHQodGhpcywgJ2F0dHJpYnV0ZXMnKSk7XG4gICAgICAgIGlmICh0aGlzLmlkKSBhdHRycy5pZCA9IF8ucmVzdWx0KHRoaXMsICdpZCcpO1xuICAgICAgICBpZiAodGhpcy5jbGFzc05hbWUpIGF0dHJzWydjbGFzcyddID0gXy5yZXN1bHQodGhpcywgJ2NsYXNzTmFtZScpO1xuICAgICAgICB0aGlzLnNldEVsZW1lbnQodGhpcy5fY3JlYXRlRWxlbWVudChfLnJlc3VsdCh0aGlzLCAndGFnTmFtZScpKSk7XG4gICAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZXMoYXR0cnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRFbGVtZW50KF8ucmVzdWx0KHRoaXMsICdlbCcpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gU2V0IGF0dHJpYnV0ZXMgZnJvbSBhIGhhc2ggb24gdGhpcyB2aWV3J3MgZWxlbWVudC4gIEV4cG9zZWQgZm9yXG4gICAgLy8gc3ViY2xhc3NlcyB1c2luZyBhbiBhbHRlcm5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIEFQSS5cbiAgICBfc2V0QXR0cmlidXRlczogZnVuY3Rpb24oYXR0cmlidXRlcykge1xuICAgICAgdGhpcy4kZWwuYXR0cihhdHRyaWJ1dGVzKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gQmFja2JvbmUuc3luY1xuICAvLyAtLS0tLS0tLS0tLS0tXG5cbiAgLy8gT3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBjaGFuZ2UgdGhlIG1hbm5lciBpbiB3aGljaCBCYWNrYm9uZSBwZXJzaXN0c1xuICAvLyBtb2RlbHMgdG8gdGhlIHNlcnZlci4gWW91IHdpbGwgYmUgcGFzc2VkIHRoZSB0eXBlIG9mIHJlcXVlc3QsIGFuZCB0aGVcbiAgLy8gbW9kZWwgaW4gcXVlc3Rpb24uIEJ5IGRlZmF1bHQsIG1ha2VzIGEgUkVTVGZ1bCBBamF4IHJlcXVlc3RcbiAgLy8gdG8gdGhlIG1vZGVsJ3MgYHVybCgpYC4gU29tZSBwb3NzaWJsZSBjdXN0b21pemF0aW9ucyBjb3VsZCBiZTpcbiAgLy9cbiAgLy8gKiBVc2UgYHNldFRpbWVvdXRgIHRvIGJhdGNoIHJhcGlkLWZpcmUgdXBkYXRlcyBpbnRvIGEgc2luZ2xlIHJlcXVlc3QuXG4gIC8vICogU2VuZCB1cCB0aGUgbW9kZWxzIGFzIFhNTCBpbnN0ZWFkIG9mIEpTT04uXG4gIC8vICogUGVyc2lzdCBtb2RlbHMgdmlhIFdlYlNvY2tldHMgaW5zdGVhZCBvZiBBamF4LlxuICAvL1xuICAvLyBUdXJuIG9uIGBCYWNrYm9uZS5lbXVsYXRlSFRUUGAgaW4gb3JkZXIgdG8gc2VuZCBgUFVUYCBhbmQgYERFTEVURWAgcmVxdWVzdHNcbiAgLy8gYXMgYFBPU1RgLCB3aXRoIGEgYF9tZXRob2RgIHBhcmFtZXRlciBjb250YWluaW5nIHRoZSB0cnVlIEhUVFAgbWV0aG9kLFxuICAvLyBhcyB3ZWxsIGFzIGFsbCByZXF1ZXN0cyB3aXRoIHRoZSBib2R5IGFzIGBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRgXG4gIC8vIGluc3RlYWQgb2YgYGFwcGxpY2F0aW9uL2pzb25gIHdpdGggdGhlIG1vZGVsIGluIGEgcGFyYW0gbmFtZWQgYG1vZGVsYC5cbiAgLy8gVXNlZnVsIHdoZW4gaW50ZXJmYWNpbmcgd2l0aCBzZXJ2ZXItc2lkZSBsYW5ndWFnZXMgbGlrZSAqKlBIUCoqIHRoYXQgbWFrZVxuICAvLyBpdCBkaWZmaWN1bHQgdG8gcmVhZCB0aGUgYm9keSBvZiBgUFVUYCByZXF1ZXN0cy5cbiAgQmFja2JvbmUuc3luYyA9IGZ1bmN0aW9uKG1ldGhvZCwgbW9kZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgdHlwZSA9IG1ldGhvZE1hcFttZXRob2RdO1xuXG4gICAgLy8gRGVmYXVsdCBvcHRpb25zLCB1bmxlc3Mgc3BlY2lmaWVkLlxuICAgIF8uZGVmYXVsdHMob3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KSwge1xuICAgICAgZW11bGF0ZUhUVFA6IEJhY2tib25lLmVtdWxhdGVIVFRQLFxuICAgICAgZW11bGF0ZUpTT046IEJhY2tib25lLmVtdWxhdGVKU09OXG4gICAgfSk7XG5cbiAgICAvLyBEZWZhdWx0IEpTT04tcmVxdWVzdCBvcHRpb25zLlxuICAgIHZhciBwYXJhbXMgPSB7dHlwZTogdHlwZSwgZGF0YVR5cGU6ICdqc29uJ307XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSBoYXZlIGEgVVJMLlxuICAgIGlmICghb3B0aW9ucy51cmwpIHtcbiAgICAgIHBhcmFtcy51cmwgPSBfLnJlc3VsdChtb2RlbCwgJ3VybCcpIHx8IHVybEVycm9yKCk7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgaGF2ZSB0aGUgYXBwcm9wcmlhdGUgcmVxdWVzdCBkYXRhLlxuICAgIGlmIChvcHRpb25zLmRhdGEgPT0gbnVsbCAmJiBtb2RlbCAmJiAobWV0aG9kID09PSAnY3JlYXRlJyB8fCBtZXRob2QgPT09ICd1cGRhdGUnIHx8IG1ldGhvZCA9PT0gJ3BhdGNoJykpIHtcbiAgICAgIHBhcmFtcy5jb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgIHBhcmFtcy5kYXRhID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5hdHRycyB8fCBtb2RlbC50b0pTT04ob3B0aW9ucykpO1xuICAgIH1cblxuICAgIC8vIEZvciBvbGRlciBzZXJ2ZXJzLCBlbXVsYXRlIEpTT04gYnkgZW5jb2RpbmcgdGhlIHJlcXVlc3QgaW50byBhbiBIVE1MLWZvcm0uXG4gICAgaWYgKG9wdGlvbnMuZW11bGF0ZUpTT04pIHtcbiAgICAgIHBhcmFtcy5jb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgcGFyYW1zLmRhdGEgPSBwYXJhbXMuZGF0YSA/IHttb2RlbDogcGFyYW1zLmRhdGF9IDoge307XG4gICAgfVxuXG4gICAgLy8gRm9yIG9sZGVyIHNlcnZlcnMsIGVtdWxhdGUgSFRUUCBieSBtaW1pY2tpbmcgdGhlIEhUVFAgbWV0aG9kIHdpdGggYF9tZXRob2RgXG4gICAgLy8gQW5kIGFuIGBYLUhUVFAtTWV0aG9kLU92ZXJyaWRlYCBoZWFkZXIuXG4gICAgaWYgKG9wdGlvbnMuZW11bGF0ZUhUVFAgJiYgKHR5cGUgPT09ICdQVVQnIHx8IHR5cGUgPT09ICdERUxFVEUnIHx8IHR5cGUgPT09ICdQQVRDSCcpKSB7XG4gICAgICBwYXJhbXMudHlwZSA9ICdQT1NUJztcbiAgICAgIGlmIChvcHRpb25zLmVtdWxhdGVKU09OKSBwYXJhbXMuZGF0YS5fbWV0aG9kID0gdHlwZTtcbiAgICAgIHZhciBiZWZvcmVTZW5kID0gb3B0aW9ucy5iZWZvcmVTZW5kO1xuICAgICAgb3B0aW9ucy5iZWZvcmVTZW5kID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdYLUhUVFAtTWV0aG9kLU92ZXJyaWRlJywgdHlwZSk7XG4gICAgICAgIGlmIChiZWZvcmVTZW5kKSByZXR1cm4gYmVmb3JlU2VuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBEb24ndCBwcm9jZXNzIGRhdGEgb24gYSBub24tR0VUIHJlcXVlc3QuXG4gICAgaWYgKHBhcmFtcy50eXBlICE9PSAnR0VUJyAmJiAhb3B0aW9ucy5lbXVsYXRlSlNPTikge1xuICAgICAgcGFyYW1zLnByb2Nlc3NEYXRhID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gUGFzcyBhbG9uZyBgdGV4dFN0YXR1c2AgYW5kIGBlcnJvclRocm93bmAgZnJvbSBqUXVlcnkuXG4gICAgdmFyIGVycm9yID0gb3B0aW9ucy5lcnJvcjtcbiAgICBvcHRpb25zLmVycm9yID0gZnVuY3Rpb24oeGhyLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgb3B0aW9ucy50ZXh0U3RhdHVzID0gdGV4dFN0YXR1cztcbiAgICAgIG9wdGlvbnMuZXJyb3JUaHJvd24gPSBlcnJvclRocm93bjtcbiAgICAgIGlmIChlcnJvcikgZXJyb3IuY2FsbChvcHRpb25zLmNvbnRleHQsIHhociwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pO1xuICAgIH07XG5cbiAgICAvLyBNYWtlIHRoZSByZXF1ZXN0LCBhbGxvd2luZyB0aGUgdXNlciB0byBvdmVycmlkZSBhbnkgQWpheCBvcHRpb25zLlxuICAgIHZhciB4aHIgPSBvcHRpb25zLnhociA9IEJhY2tib25lLmFqYXgoXy5leHRlbmQocGFyYW1zLCBvcHRpb25zKSk7XG4gICAgbW9kZWwudHJpZ2dlcigncmVxdWVzdCcsIG1vZGVsLCB4aHIsIG9wdGlvbnMpO1xuICAgIHJldHVybiB4aHI7XG4gIH07XG5cbiAgLy8gTWFwIGZyb20gQ1JVRCB0byBIVFRQIGZvciBvdXIgZGVmYXVsdCBgQmFja2JvbmUuc3luY2AgaW1wbGVtZW50YXRpb24uXG4gIHZhciBtZXRob2RNYXAgPSB7XG4gICAgJ2NyZWF0ZSc6ICdQT1NUJyxcbiAgICAndXBkYXRlJzogJ1BVVCcsXG4gICAgJ3BhdGNoJzogICdQQVRDSCcsXG4gICAgJ2RlbGV0ZSc6ICdERUxFVEUnLFxuICAgICdyZWFkJzogICAnR0VUJ1xuICB9O1xuXG4gIC8vIFNldCB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgQmFja2JvbmUuYWpheGAgdG8gcHJveHkgdGhyb3VnaCB0byBgJGAuXG4gIC8vIE92ZXJyaWRlIHRoaXMgaWYgeW91J2QgbGlrZSB0byB1c2UgYSBkaWZmZXJlbnQgbGlicmFyeS5cbiAgQmFja2JvbmUuYWpheCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBCYWNrYm9uZS4kLmFqYXguYXBwbHkoQmFja2JvbmUuJCwgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBCYWNrYm9uZS5Sb3V0ZXJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUm91dGVycyBtYXAgZmF1eC1VUkxzIHRvIGFjdGlvbnMsIGFuZCBmaXJlIGV2ZW50cyB3aGVuIHJvdXRlcyBhcmVcbiAgLy8gbWF0Y2hlZC4gQ3JlYXRpbmcgYSBuZXcgb25lIHNldHMgaXRzIGByb3V0ZXNgIGhhc2gsIGlmIG5vdCBzZXQgc3RhdGljYWxseS5cbiAgdmFyIFJvdXRlciA9IEJhY2tib25lLlJvdXRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIGlmIChvcHRpb25zLnJvdXRlcykgdGhpcy5yb3V0ZXMgPSBvcHRpb25zLnJvdXRlcztcbiAgICB0aGlzLl9iaW5kUm91dGVzKCk7XG4gICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMgZm9yIG1hdGNoaW5nIG5hbWVkIHBhcmFtIHBhcnRzIGFuZCBzcGxhdHRlZFxuICAvLyBwYXJ0cyBvZiByb3V0ZSBzdHJpbmdzLlxuICB2YXIgb3B0aW9uYWxQYXJhbSA9IC9cXCgoLio/KVxcKS9nO1xuICB2YXIgbmFtZWRQYXJhbSAgICA9IC8oXFwoXFw/KT86XFx3Ky9nO1xuICB2YXIgc3BsYXRQYXJhbSAgICA9IC9cXCpcXHcrL2c7XG4gIHZhciBlc2NhcGVSZWdFeHAgID0gL1tcXC17fVxcW1xcXSs/LixcXFxcXFxeJHwjXFxzXS9nO1xuXG4gIC8vIFNldCB1cCBhbGwgaW5oZXJpdGFibGUgKipCYWNrYm9uZS5Sb3V0ZXIqKiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxuICBfLmV4dGVuZChSb3V0ZXIucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8vIE1hbnVhbGx5IGJpbmQgYSBzaW5nbGUgbmFtZWQgcm91dGUgdG8gYSBjYWxsYmFjay4gRm9yIGV4YW1wbGU6XG4gICAgLy9cbiAgICAvLyAgICAgdGhpcy5yb3V0ZSgnc2VhcmNoLzpxdWVyeS9wOm51bScsICdzZWFyY2gnLCBmdW5jdGlvbihxdWVyeSwgbnVtKSB7XG4gICAgLy8gICAgICAgLi4uXG4gICAgLy8gICAgIH0pO1xuICAgIC8vXG4gICAgcm91dGU6IGZ1bmN0aW9uKHJvdXRlLCBuYW1lLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCFfLmlzUmVnRXhwKHJvdXRlKSkgcm91dGUgPSB0aGlzLl9yb3V0ZVRvUmVnRXhwKHJvdXRlKTtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24obmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuYW1lO1xuICAgICAgICBuYW1lID0gJyc7XG4gICAgICB9XG4gICAgICBpZiAoIWNhbGxiYWNrKSBjYWxsYmFjayA9IHRoaXNbbmFtZV07XG4gICAgICB2YXIgcm91dGVyID0gdGhpcztcbiAgICAgIEJhY2tib25lLmhpc3Rvcnkucm91dGUocm91dGUsIGZ1bmN0aW9uKGZyYWdtZW50KSB7XG4gICAgICAgIHZhciBhcmdzID0gcm91dGVyLl9leHRyYWN0UGFyYW1ldGVycyhyb3V0ZSwgZnJhZ21lbnQpO1xuICAgICAgICBpZiAocm91dGVyLmV4ZWN1dGUoY2FsbGJhY2ssIGFyZ3MsIG5hbWUpICE9PSBmYWxzZSkge1xuICAgICAgICAgIHJvdXRlci50cmlnZ2VyLmFwcGx5KHJvdXRlciwgWydyb3V0ZTonICsgbmFtZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICByb3V0ZXIudHJpZ2dlcigncm91dGUnLCBuYW1lLCBhcmdzKTtcbiAgICAgICAgICBCYWNrYm9uZS5oaXN0b3J5LnRyaWdnZXIoJ3JvdXRlJywgcm91dGVyLCBuYW1lLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gRXhlY3V0ZSBhIHJvdXRlIGhhbmRsZXIgd2l0aCB0aGUgcHJvdmlkZWQgcGFyYW1ldGVycy4gIFRoaXMgaXMgYW5cbiAgICAvLyBleGNlbGxlbnQgcGxhY2UgdG8gZG8gcHJlLXJvdXRlIHNldHVwIG9yIHBvc3Qtcm91dGUgY2xlYW51cC5cbiAgICBleGVjdXRlOiBmdW5jdGlvbihjYWxsYmFjaywgYXJncywgbmFtZSkge1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9LFxuXG4gICAgLy8gU2ltcGxlIHByb3h5IHRvIGBCYWNrYm9uZS5oaXN0b3J5YCB0byBzYXZlIGEgZnJhZ21lbnQgaW50byB0aGUgaGlzdG9yeS5cbiAgICBuYXZpZ2F0ZTogZnVuY3Rpb24oZnJhZ21lbnQsIG9wdGlvbnMpIHtcbiAgICAgIEJhY2tib25lLmhpc3RvcnkubmF2aWdhdGUoZnJhZ21lbnQsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEJpbmQgYWxsIGRlZmluZWQgcm91dGVzIHRvIGBCYWNrYm9uZS5oaXN0b3J5YC4gV2UgaGF2ZSB0byByZXZlcnNlIHRoZVxuICAgIC8vIG9yZGVyIG9mIHRoZSByb3V0ZXMgaGVyZSB0byBzdXBwb3J0IGJlaGF2aW9yIHdoZXJlIHRoZSBtb3N0IGdlbmVyYWxcbiAgICAvLyByb3V0ZXMgY2FuIGJlIGRlZmluZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgcm91dGUgbWFwLlxuICAgIF9iaW5kUm91dGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5yb3V0ZXMpIHJldHVybjtcbiAgICAgIHRoaXMucm91dGVzID0gXy5yZXN1bHQodGhpcywgJ3JvdXRlcycpO1xuICAgICAgdmFyIHJvdXRlLCByb3V0ZXMgPSBfLmtleXModGhpcy5yb3V0ZXMpO1xuICAgICAgd2hpbGUgKChyb3V0ZSA9IHJvdXRlcy5wb3AoKSkgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJvdXRlKHJvdXRlLCB0aGlzLnJvdXRlc1tyb3V0ZV0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgcm91dGUgc3RyaW5nIGludG8gYSByZWd1bGFyIGV4cHJlc3Npb24sIHN1aXRhYmxlIGZvciBtYXRjaGluZ1xuICAgIC8vIGFnYWluc3QgdGhlIGN1cnJlbnQgbG9jYXRpb24gaGFzaC5cbiAgICBfcm91dGVUb1JlZ0V4cDogZnVuY3Rpb24ocm91dGUpIHtcbiAgICAgIHJvdXRlID0gcm91dGUucmVwbGFjZShlc2NhcGVSZWdFeHAsICdcXFxcJCYnKVxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKG9wdGlvbmFsUGFyYW0sICcoPzokMSk/JylcbiAgICAgICAgICAgICAgICAgICAucmVwbGFjZShuYW1lZFBhcmFtLCBmdW5jdGlvbihtYXRjaCwgb3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25hbCA/IG1hdGNoIDogJyhbXi8/XSspJztcbiAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHNwbGF0UGFyYW0sICcoW14/XSo/KScpO1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcm91dGUgKyAnKD86XFxcXD8oW1xcXFxzXFxcXFNdKikpPyQnKTtcbiAgICB9LFxuXG4gICAgLy8gR2l2ZW4gYSByb3V0ZSwgYW5kIGEgVVJMIGZyYWdtZW50IHRoYXQgaXQgbWF0Y2hlcywgcmV0dXJuIHRoZSBhcnJheSBvZlxuICAgIC8vIGV4dHJhY3RlZCBkZWNvZGVkIHBhcmFtZXRlcnMuIEVtcHR5IG9yIHVubWF0Y2hlZCBwYXJhbWV0ZXJzIHdpbGwgYmVcbiAgICAvLyB0cmVhdGVkIGFzIGBudWxsYCB0byBub3JtYWxpemUgY3Jvc3MtYnJvd3NlciBiZWhhdmlvci5cbiAgICBfZXh0cmFjdFBhcmFtZXRlcnM6IGZ1bmN0aW9uKHJvdXRlLCBmcmFnbWVudCkge1xuICAgICAgdmFyIHBhcmFtcyA9IHJvdXRlLmV4ZWMoZnJhZ21lbnQpLnNsaWNlKDEpO1xuICAgICAgcmV0dXJuIF8ubWFwKHBhcmFtcywgZnVuY3Rpb24ocGFyYW0sIGkpIHtcbiAgICAgICAgLy8gRG9uJ3QgZGVjb2RlIHRoZSBzZWFyY2ggcGFyYW1zLlxuICAgICAgICBpZiAoaSA9PT0gcGFyYW1zLmxlbmd0aCAtIDEpIHJldHVybiBwYXJhbSB8fCBudWxsO1xuICAgICAgICByZXR1cm4gcGFyYW0gPyBkZWNvZGVVUklDb21wb25lbnQocGFyYW0pIDogbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBCYWNrYm9uZS5IaXN0b3J5XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBIYW5kbGVzIGNyb3NzLWJyb3dzZXIgaGlzdG9yeSBtYW5hZ2VtZW50LCBiYXNlZCBvbiBlaXRoZXJcbiAgLy8gW3B1c2hTdGF0ZV0oaHR0cDovL2RpdmVpbnRvaHRtbDUuaW5mby9oaXN0b3J5Lmh0bWwpIGFuZCByZWFsIFVSTHMsIG9yXG4gIC8vIFtvbmhhc2hjaGFuZ2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL3dpbmRvdy5vbmhhc2hjaGFuZ2UpXG4gIC8vIGFuZCBVUkwgZnJhZ21lbnRzLiBJZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBuZWl0aGVyIChvbGQgSUUsIG5hdGNoKSxcbiAgLy8gZmFsbHMgYmFjayB0byBwb2xsaW5nLlxuICB2YXIgSGlzdG9yeSA9IEJhY2tib25lLkhpc3RvcnkgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgXy5iaW5kQWxsKHRoaXMsICdjaGVja1VybCcpO1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgYEhpc3RvcnlgIGNhbiBiZSB1c2VkIG91dHNpZGUgb2YgdGhlIGJyb3dzZXIuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuICAgICAgdGhpcy5oaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gICAgfVxuICB9O1xuXG4gIC8vIENhY2hlZCByZWdleCBmb3Igc3RyaXBwaW5nIGEgbGVhZGluZyBoYXNoL3NsYXNoIGFuZCB0cmFpbGluZyBzcGFjZS5cbiAgdmFyIHJvdXRlU3RyaXBwZXIgPSAvXlsjXFwvXXxcXHMrJC9nO1xuXG4gIC8vIENhY2hlZCByZWdleCBmb3Igc3RyaXBwaW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMuXG4gIHZhciByb290U3RyaXBwZXIgPSAvXlxcLyt8XFwvKyQvZztcblxuICAvLyBDYWNoZWQgcmVnZXggZm9yIHN0cmlwcGluZyB1cmxzIG9mIGhhc2guXG4gIHZhciBwYXRoU3RyaXBwZXIgPSAvIy4qJC87XG5cbiAgLy8gSGFzIHRoZSBoaXN0b3J5IGhhbmRsaW5nIGFscmVhZHkgYmVlbiBzdGFydGVkP1xuICBIaXN0b3J5LnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAvLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuSGlzdG9yeSoqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKEhpc3RvcnkucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIFRoZSBkZWZhdWx0IGludGVydmFsIHRvIHBvbGwgZm9yIGhhc2ggY2hhbmdlcywgaWYgbmVjZXNzYXJ5LCBpc1xuICAgIC8vIHR3ZW50eSB0aW1lcyBhIHNlY29uZC5cbiAgICBpbnRlcnZhbDogNTAsXG5cbiAgICAvLyBBcmUgd2UgYXQgdGhlIGFwcCByb290P1xuICAgIGF0Um9vdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMubG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvW15cXC9dJC8sICckJi8nKTtcbiAgICAgIHJldHVybiBwYXRoID09PSB0aGlzLnJvb3QgJiYgIXRoaXMuZ2V0U2VhcmNoKCk7XG4gICAgfSxcblxuICAgIC8vIERvZXMgdGhlIHBhdGhuYW1lIG1hdGNoIHRoZSByb290P1xuICAgIG1hdGNoUm9vdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMuZGVjb2RlRnJhZ21lbnQodGhpcy5sb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgICB2YXIgcm9vdCA9IHBhdGguc2xpY2UoMCwgdGhpcy5yb290Lmxlbmd0aCAtIDEpICsgJy8nO1xuICAgICAgcmV0dXJuIHJvb3QgPT09IHRoaXMucm9vdDtcbiAgICB9LFxuXG4gICAgLy8gVW5pY29kZSBjaGFyYWN0ZXJzIGluIGBsb2NhdGlvbi5wYXRobmFtZWAgYXJlIHBlcmNlbnQgZW5jb2RlZCBzbyB0aGV5J3JlXG4gICAgLy8gZGVjb2RlZCBmb3IgY29tcGFyaXNvbi4gYCUyNWAgc2hvdWxkIG5vdCBiZSBkZWNvZGVkIHNpbmNlIGl0IG1heSBiZSBwYXJ0XG4gICAgLy8gb2YgYW4gZW5jb2RlZCBwYXJhbWV0ZXIuXG4gICAgZGVjb2RlRnJhZ21lbnQ6IGZ1bmN0aW9uKGZyYWdtZW50KSB7XG4gICAgICByZXR1cm4gZGVjb2RlVVJJKGZyYWdtZW50LnJlcGxhY2UoLyUyNS9nLCAnJTI1MjUnKSk7XG4gICAgfSxcblxuICAgIC8vIEluIElFNiwgdGhlIGhhc2ggZnJhZ21lbnQgYW5kIHNlYXJjaCBwYXJhbXMgYXJlIGluY29ycmVjdCBpZiB0aGVcbiAgICAvLyBmcmFnbWVudCBjb250YWlucyBgP2AuXG4gICAgZ2V0U2VhcmNoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXRjaCA9IHRoaXMubG9jYXRpb24uaHJlZi5yZXBsYWNlKC8jLiovLCAnJykubWF0Y2goL1xcPy4rLyk7XG4gICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFswXSA6ICcnO1xuICAgIH0sXG5cbiAgICAvLyBHZXRzIHRoZSB0cnVlIGhhc2ggdmFsdWUuIENhbm5vdCB1c2UgbG9jYXRpb24uaGFzaCBkaXJlY3RseSBkdWUgdG8gYnVnXG4gICAgLy8gaW4gRmlyZWZveCB3aGVyZSBsb2NhdGlvbi5oYXNoIHdpbGwgYWx3YXlzIGJlIGRlY29kZWQuXG4gICAgZ2V0SGFzaDogZnVuY3Rpb24od2luZG93KSB7XG4gICAgICB2YXIgbWF0Y2ggPSAod2luZG93IHx8IHRoaXMpLmxvY2F0aW9uLmhyZWYubWF0Y2goLyMoLiopJC8pO1xuICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJztcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBwYXRobmFtZSBhbmQgc2VhcmNoIHBhcmFtcywgd2l0aG91dCB0aGUgcm9vdC5cbiAgICBnZXRQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5kZWNvZGVGcmFnbWVudChcbiAgICAgICAgdGhpcy5sb2NhdGlvbi5wYXRobmFtZSArIHRoaXMuZ2V0U2VhcmNoKClcbiAgICAgICkuc2xpY2UodGhpcy5yb290Lmxlbmd0aCAtIDEpO1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoLnNsaWNlKDEpIDogcGF0aDtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBjcm9zcy1icm93c2VyIG5vcm1hbGl6ZWQgVVJMIGZyYWdtZW50IGZyb20gdGhlIHBhdGggb3IgaGFzaC5cbiAgICBnZXRGcmFnbWVudDogZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgICAgIGlmIChmcmFnbWVudCA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLl91c2VQdXNoU3RhdGUgfHwgIXRoaXMuX3dhbnRzSGFzaENoYW5nZSkge1xuICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZXRQYXRoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEhhc2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2Uocm91dGVTdHJpcHBlciwgJycpO1xuICAgIH0sXG5cbiAgICAvLyBTdGFydCB0aGUgaGFzaCBjaGFuZ2UgaGFuZGxpbmcsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlIGN1cnJlbnQgVVJMIG1hdGNoZXNcbiAgICAvLyBhbiBleGlzdGluZyByb3V0ZSwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgIHN0YXJ0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoSGlzdG9yeS5zdGFydGVkKSB0aHJvdyBuZXcgRXJyb3IoJ0JhY2tib25lLmhpc3RvcnkgaGFzIGFscmVhZHkgYmVlbiBzdGFydGVkJyk7XG4gICAgICBIaXN0b3J5LnN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgICAvLyBGaWd1cmUgb3V0IHRoZSBpbml0aWFsIGNvbmZpZ3VyYXRpb24uIERvIHdlIG5lZWQgYW4gaWZyYW1lP1xuICAgICAgLy8gSXMgcHVzaFN0YXRlIGRlc2lyZWQgLi4uIGlzIGl0IGF2YWlsYWJsZT9cbiAgICAgIHRoaXMub3B0aW9ucyAgICAgICAgICA9IF8uZXh0ZW5kKHtyb290OiAnLyd9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5yb290ICAgICAgICAgICAgID0gdGhpcy5vcHRpb25zLnJvb3Q7XG4gICAgICB0aGlzLl93YW50c0hhc2hDaGFuZ2UgPSB0aGlzLm9wdGlvbnMuaGFzaENoYW5nZSAhPT0gZmFsc2U7XG4gICAgICB0aGlzLl9oYXNIYXNoQ2hhbmdlICAgPSAnb25oYXNoY2hhbmdlJyBpbiB3aW5kb3c7XG4gICAgICB0aGlzLl91c2VIYXNoQ2hhbmdlICAgPSB0aGlzLl93YW50c0hhc2hDaGFuZ2UgJiYgdGhpcy5faGFzSGFzaENoYW5nZTtcbiAgICAgIHRoaXMuX3dhbnRzUHVzaFN0YXRlICA9ICEhdGhpcy5vcHRpb25zLnB1c2hTdGF0ZTtcbiAgICAgIHRoaXMuX2hhc1B1c2hTdGF0ZSAgICA9ICEhKHRoaXMuaGlzdG9yeSAmJiB0aGlzLmhpc3RvcnkucHVzaFN0YXRlKTtcbiAgICAgIHRoaXMuX3VzZVB1c2hTdGF0ZSAgICA9IHRoaXMuX3dhbnRzUHVzaFN0YXRlICYmIHRoaXMuX2hhc1B1c2hTdGF0ZTtcbiAgICAgIHRoaXMuZnJhZ21lbnQgICAgICAgICA9IHRoaXMuZ2V0RnJhZ21lbnQoKTtcblxuICAgICAgLy8gTm9ybWFsaXplIHJvb3QgdG8gYWx3YXlzIGluY2x1ZGUgYSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaC5cbiAgICAgIHRoaXMucm9vdCA9ICgnLycgKyB0aGlzLnJvb3QgKyAnLycpLnJlcGxhY2Uocm9vdFN0cmlwcGVyLCAnLycpO1xuXG4gICAgICAvLyBUcmFuc2l0aW9uIGZyb20gaGFzaENoYW5nZSB0byBwdXNoU3RhdGUgb3IgdmljZSB2ZXJzYSBpZiBib3RoIGFyZVxuICAgICAgLy8gcmVxdWVzdGVkLlxuICAgICAgaWYgKHRoaXMuX3dhbnRzSGFzaENoYW5nZSAmJiB0aGlzLl93YW50c1B1c2hTdGF0ZSkge1xuXG4gICAgICAgIC8vIElmIHdlJ3ZlIHN0YXJ0ZWQgb2ZmIHdpdGggYSByb3V0ZSBmcm9tIGEgYHB1c2hTdGF0ZWAtZW5hYmxlZFxuICAgICAgICAvLyBicm93c2VyLCBidXQgd2UncmUgY3VycmVudGx5IGluIGEgYnJvd3NlciB0aGF0IGRvZXNuJ3Qgc3VwcG9ydCBpdC4uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc1B1c2hTdGF0ZSAmJiAhdGhpcy5hdFJvb3QoKSkge1xuICAgICAgICAgIHZhciByb290ID0gdGhpcy5yb290LnNsaWNlKDAsIC0xKSB8fCAnLyc7XG4gICAgICAgICAgdGhpcy5sb2NhdGlvbi5yZXBsYWNlKHJvb3QgKyAnIycgKyB0aGlzLmdldFBhdGgoKSk7XG4gICAgICAgICAgLy8gUmV0dXJuIGltbWVkaWF0ZWx5IGFzIGJyb3dzZXIgd2lsbCBkbyByZWRpcmVjdCB0byBuZXcgdXJsXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgLy8gT3IgaWYgd2UndmUgc3RhcnRlZCBvdXQgd2l0aCBhIGhhc2gtYmFzZWQgcm91dGUsIGJ1dCB3ZSdyZSBjdXJyZW50bHlcbiAgICAgICAgLy8gaW4gYSBicm93c2VyIHdoZXJlIGl0IGNvdWxkIGJlIGBwdXNoU3RhdGVgLWJhc2VkIGluc3RlYWQuLi5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9oYXNQdXNoU3RhdGUgJiYgdGhpcy5hdFJvb3QoKSkge1xuICAgICAgICAgIHRoaXMubmF2aWdhdGUodGhpcy5nZXRIYXNoKCksIHtyZXBsYWNlOiB0cnVlfSk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICAvLyBQcm94eSBhbiBpZnJhbWUgdG8gaGFuZGxlIGxvY2F0aW9uIGV2ZW50cyBpZiB0aGUgYnJvd3NlciBkb2Vzbid0XG4gICAgICAvLyBzdXBwb3J0IHRoZSBgaGFzaGNoYW5nZWAgZXZlbnQsIEhUTUw1IGhpc3RvcnksIG9yIHRoZSB1c2VyIHdhbnRzXG4gICAgICAvLyBgaGFzaENoYW5nZWAgYnV0IG5vdCBgcHVzaFN0YXRlYC5cbiAgICAgIGlmICghdGhpcy5faGFzSGFzaENoYW5nZSAmJiB0aGlzLl93YW50c0hhc2hDaGFuZ2UgJiYgIXRoaXMuX3VzZVB1c2hTdGF0ZSkge1xuICAgICAgICB0aGlzLmlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICB0aGlzLmlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDowJztcbiAgICAgICAgdGhpcy5pZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5pZnJhbWUudGFiSW5kZXggPSAtMTtcbiAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICAvLyBVc2luZyBgYXBwZW5kQ2hpbGRgIHdpbGwgdGhyb3cgb24gSUUgPCA5IGlmIHRoZSBkb2N1bWVudCBpcyBub3QgcmVhZHkuXG4gICAgICAgIHZhciBpV2luZG93ID0gYm9keS5pbnNlcnRCZWZvcmUodGhpcy5pZnJhbWUsIGJvZHkuZmlyc3RDaGlsZCkuY29udGVudFdpbmRvdztcbiAgICAgICAgaVdpbmRvdy5kb2N1bWVudC5vcGVuKCk7XG4gICAgICAgIGlXaW5kb3cuZG9jdW1lbnQuY2xvc2UoKTtcbiAgICAgICAgaVdpbmRvdy5sb2NhdGlvbi5oYXNoID0gJyMnICsgdGhpcy5mcmFnbWVudDtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGEgY3Jvc3MtcGxhdGZvcm0gYGFkZEV2ZW50TGlzdGVuZXJgIHNoaW0gZm9yIG9sZGVyIGJyb3dzZXJzLlxuICAgICAgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgfTtcblxuICAgICAgLy8gRGVwZW5kaW5nIG9uIHdoZXRoZXIgd2UncmUgdXNpbmcgcHVzaFN0YXRlIG9yIGhhc2hlcywgYW5kIHdoZXRoZXJcbiAgICAgIC8vICdvbmhhc2hjaGFuZ2UnIGlzIHN1cHBvcnRlZCwgZGV0ZXJtaW5lIGhvdyB3ZSBjaGVjayB0aGUgVVJMIHN0YXRlLlxuICAgICAgaWYgKHRoaXMuX3VzZVB1c2hTdGF0ZSkge1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMuY2hlY2tVcmwsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fdXNlSGFzaENoYW5nZSAmJiAhdGhpcy5pZnJhbWUpIHtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIHRoaXMuY2hlY2tVcmwsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrVXJsSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLmNoZWNrVXJsLCB0aGlzLmludGVydmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2lsZW50KSByZXR1cm4gdGhpcy5sb2FkVXJsKCk7XG4gICAgfSxcblxuICAgIC8vIERpc2FibGUgQmFja2JvbmUuaGlzdG9yeSwgcGVyaGFwcyB0ZW1wb3JhcmlseS4gTm90IHVzZWZ1bCBpbiBhIHJlYWwgYXBwLFxuICAgIC8vIGJ1dCBwb3NzaWJseSB1c2VmdWwgZm9yIHVuaXQgdGVzdGluZyBSb3V0ZXJzLlxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gQWRkIGEgY3Jvc3MtcGxhdGZvcm0gYHJlbW92ZUV2ZW50TGlzdGVuZXJgIHNoaW0gZm9yIG9sZGVyIGJyb3dzZXJzLlxuICAgICAgdmFyIHJlbW92ZUV2ZW50TGlzdGVuZXIgPSB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciB8fCBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgfTtcblxuICAgICAgLy8gUmVtb3ZlIHdpbmRvdyBsaXN0ZW5lcnMuXG4gICAgICBpZiAodGhpcy5fdXNlUHVzaFN0YXRlKSB7XG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5jaGVja1VybCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl91c2VIYXNoQ2hhbmdlICYmICF0aGlzLmlmcmFtZSkge1xuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgdGhpcy5jaGVja1VybCwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhbiB1cCB0aGUgaWZyYW1lIGlmIG5lY2Vzc2FyeS5cbiAgICAgIGlmICh0aGlzLmlmcmFtZSkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMuaWZyYW1lKTtcbiAgICAgICAgdGhpcy5pZnJhbWUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBTb21lIGVudmlyb25tZW50cyB3aWxsIHRocm93IHdoZW4gY2xlYXJpbmcgYW4gdW5kZWZpbmVkIGludGVydmFsLlxuICAgICAgaWYgKHRoaXMuX2NoZWNrVXJsSW50ZXJ2YWwpIGNsZWFySW50ZXJ2YWwodGhpcy5fY2hlY2tVcmxJbnRlcnZhbCk7XG4gICAgICBIaXN0b3J5LnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgcm91dGUgdG8gYmUgdGVzdGVkIHdoZW4gdGhlIGZyYWdtZW50IGNoYW5nZXMuIFJvdXRlcyBhZGRlZCBsYXRlclxuICAgIC8vIG1heSBvdmVycmlkZSBwcmV2aW91cyByb3V0ZXMuXG4gICAgcm91dGU6IGZ1bmN0aW9uKHJvdXRlLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy5oYW5kbGVycy51bnNoaWZ0KHtyb3V0ZTogcm91dGUsIGNhbGxiYWNrOiBjYWxsYmFja30pO1xuICAgIH0sXG5cbiAgICAvLyBDaGVja3MgdGhlIGN1cnJlbnQgVVJMIHRvIHNlZSBpZiBpdCBoYXMgY2hhbmdlZCwgYW5kIGlmIGl0IGhhcyxcbiAgICAvLyBjYWxscyBgbG9hZFVybGAsIG5vcm1hbGl6aW5nIGFjcm9zcyB0aGUgaGlkZGVuIGlmcmFtZS5cbiAgICBjaGVja1VybDogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldEZyYWdtZW50KCk7XG5cbiAgICAgIC8vIElmIHRoZSB1c2VyIHByZXNzZWQgdGhlIGJhY2sgYnV0dG9uLCB0aGUgaWZyYW1lJ3MgaGFzaCB3aWxsIGhhdmVcbiAgICAgIC8vIGNoYW5nZWQgYW5kIHdlIHNob3VsZCB1c2UgdGhhdCBmb3IgY29tcGFyaXNvbi5cbiAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmZyYWdtZW50ICYmIHRoaXMuaWZyYW1lKSB7XG4gICAgICAgIGN1cnJlbnQgPSB0aGlzLmdldEhhc2godGhpcy5pZnJhbWUuY29udGVudFdpbmRvdyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmZyYWdtZW50KSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAodGhpcy5pZnJhbWUpIHRoaXMubmF2aWdhdGUoY3VycmVudCk7XG4gICAgICB0aGlzLmxvYWRVcmwoKTtcbiAgICB9LFxuXG4gICAgLy8gQXR0ZW1wdCB0byBsb2FkIHRoZSBjdXJyZW50IFVSTCBmcmFnbWVudC4gSWYgYSByb3V0ZSBzdWNjZWVkcyB3aXRoIGFcbiAgICAvLyBtYXRjaCwgcmV0dXJucyBgdHJ1ZWAuIElmIG5vIGRlZmluZWQgcm91dGVzIG1hdGNoZXMgdGhlIGZyYWdtZW50LFxuICAgIC8vIHJldHVybnMgYGZhbHNlYC5cbiAgICBsb2FkVXJsOiBmdW5jdGlvbihmcmFnbWVudCkge1xuICAgICAgLy8gSWYgdGhlIHJvb3QgZG9lc24ndCBtYXRjaCwgbm8gcm91dGVzIGNhbiBtYXRjaCBlaXRoZXIuXG4gICAgICBpZiAoIXRoaXMubWF0Y2hSb290KCkpIHJldHVybiBmYWxzZTtcbiAgICAgIGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudCA9IHRoaXMuZ2V0RnJhZ21lbnQoZnJhZ21lbnQpO1xuICAgICAgcmV0dXJuIF8uYW55KHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGhhbmRsZXIucm91dGUudGVzdChmcmFnbWVudCkpIHtcbiAgICAgICAgICBoYW5kbGVyLmNhbGxiYWNrKGZyYWdtZW50KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIFNhdmUgYSBmcmFnbWVudCBpbnRvIHRoZSBoYXNoIGhpc3RvcnksIG9yIHJlcGxhY2UgdGhlIFVSTCBzdGF0ZSBpZiB0aGVcbiAgICAvLyAncmVwbGFjZScgb3B0aW9uIGlzIHBhc3NlZC4gWW91IGFyZSByZXNwb25zaWJsZSBmb3IgcHJvcGVybHkgVVJMLWVuY29kaW5nXG4gICAgLy8gdGhlIGZyYWdtZW50IGluIGFkdmFuY2UuXG4gICAgLy9cbiAgICAvLyBUaGUgb3B0aW9ucyBvYmplY3QgY2FuIGNvbnRhaW4gYHRyaWdnZXI6IHRydWVgIGlmIHlvdSB3aXNoIHRvIGhhdmUgdGhlXG4gICAgLy8gcm91dGUgY2FsbGJhY2sgYmUgZmlyZWQgKG5vdCB1c3VhbGx5IGRlc2lyYWJsZSksIG9yIGByZXBsYWNlOiB0cnVlYCwgaWZcbiAgICAvLyB5b3Ugd2lzaCB0byBtb2RpZnkgdGhlIGN1cnJlbnQgVVJMIHdpdGhvdXQgYWRkaW5nIGFuIGVudHJ5IHRvIHRoZSBoaXN0b3J5LlxuICAgIG5hdmlnYXRlOiBmdW5jdGlvbihmcmFnbWVudCwgb3B0aW9ucykge1xuICAgICAgaWYgKCFIaXN0b3J5LnN0YXJ0ZWQpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zID09PSB0cnVlKSBvcHRpb25zID0ge3RyaWdnZXI6ICEhb3B0aW9uc307XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgZnJhZ21lbnQuXG4gICAgICBmcmFnbWVudCA9IHRoaXMuZ2V0RnJhZ21lbnQoZnJhZ21lbnQgfHwgJycpO1xuXG4gICAgICAvLyBEb24ndCBpbmNsdWRlIGEgdHJhaWxpbmcgc2xhc2ggb24gdGhlIHJvb3QuXG4gICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcbiAgICAgIGlmIChmcmFnbWVudCA9PT0gJycgfHwgZnJhZ21lbnQuY2hhckF0KDApID09PSAnPycpIHtcbiAgICAgICAgcm9vdCA9IHJvb3Quc2xpY2UoMCwgLTEpIHx8ICcvJztcbiAgICAgIH1cbiAgICAgIHZhciB1cmwgPSByb290ICsgZnJhZ21lbnQ7XG5cbiAgICAgIC8vIFN0cmlwIHRoZSBoYXNoIGFuZCBkZWNvZGUgZm9yIG1hdGNoaW5nLlxuICAgICAgZnJhZ21lbnQgPSB0aGlzLmRlY29kZUZyYWdtZW50KGZyYWdtZW50LnJlcGxhY2UocGF0aFN0cmlwcGVyLCAnJykpO1xuXG4gICAgICBpZiAodGhpcy5mcmFnbWVudCA9PT0gZnJhZ21lbnQpIHJldHVybjtcbiAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudDtcblxuICAgICAgLy8gSWYgcHVzaFN0YXRlIGlzIGF2YWlsYWJsZSwgd2UgdXNlIGl0IHRvIHNldCB0aGUgZnJhZ21lbnQgYXMgYSByZWFsIFVSTC5cbiAgICAgIGlmICh0aGlzLl91c2VQdXNoU3RhdGUpIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5W29wdGlvbnMucmVwbGFjZSA/ICdyZXBsYWNlU3RhdGUnIDogJ3B1c2hTdGF0ZSddKHt9LCBkb2N1bWVudC50aXRsZSwgdXJsKTtcblxuICAgICAgLy8gSWYgaGFzaCBjaGFuZ2VzIGhhdmVuJ3QgYmVlbiBleHBsaWNpdGx5IGRpc2FibGVkLCB1cGRhdGUgdGhlIGhhc2hcbiAgICAgIC8vIGZyYWdtZW50IHRvIHN0b3JlIGhpc3RvcnkuXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3dhbnRzSGFzaENoYW5nZSkge1xuICAgICAgICB0aGlzLl91cGRhdGVIYXNoKHRoaXMubG9jYXRpb24sIGZyYWdtZW50LCBvcHRpb25zLnJlcGxhY2UpO1xuICAgICAgICBpZiAodGhpcy5pZnJhbWUgJiYgKGZyYWdtZW50ICE9PSB0aGlzLmdldEhhc2godGhpcy5pZnJhbWUuY29udGVudFdpbmRvdykpKSB7XG4gICAgICAgICAgdmFyIGlXaW5kb3cgPSB0aGlzLmlmcmFtZS5jb250ZW50V2luZG93O1xuXG4gICAgICAgICAgLy8gT3BlbmluZyBhbmQgY2xvc2luZyB0aGUgaWZyYW1lIHRyaWNrcyBJRTcgYW5kIGVhcmxpZXIgdG8gcHVzaCBhXG4gICAgICAgICAgLy8gaGlzdG9yeSBlbnRyeSBvbiBoYXNoLXRhZyBjaGFuZ2UuICBXaGVuIHJlcGxhY2UgaXMgdHJ1ZSwgd2UgZG9uJ3RcbiAgICAgICAgICAvLyB3YW50IHRoaXMuXG4gICAgICAgICAgaWYgKCFvcHRpb25zLnJlcGxhY2UpIHtcbiAgICAgICAgICAgIGlXaW5kb3cuZG9jdW1lbnQub3BlbigpO1xuICAgICAgICAgICAgaVdpbmRvdy5kb2N1bWVudC5jbG9zZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3VwZGF0ZUhhc2goaVdpbmRvdy5sb2NhdGlvbiwgZnJhZ21lbnQsIG9wdGlvbnMucmVwbGFjZSk7XG4gICAgICAgIH1cblxuICAgICAgLy8gSWYgeW91J3ZlIHRvbGQgdXMgdGhhdCB5b3UgZXhwbGljaXRseSBkb24ndCB3YW50IGZhbGxiYWNrIGhhc2hjaGFuZ2UtXG4gICAgICAvLyBiYXNlZCBoaXN0b3J5LCB0aGVuIGBuYXZpZ2F0ZWAgYmVjb21lcyBhIHBhZ2UgcmVmcmVzaC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudHJpZ2dlcikgcmV0dXJuIHRoaXMubG9hZFVybChmcmFnbWVudCk7XG4gICAgfSxcblxuICAgIC8vIFVwZGF0ZSB0aGUgaGFzaCBsb2NhdGlvbiwgZWl0aGVyIHJlcGxhY2luZyB0aGUgY3VycmVudCBlbnRyeSwgb3IgYWRkaW5nXG4gICAgLy8gYSBuZXcgb25lIHRvIHRoZSBicm93c2VyIGhpc3RvcnkuXG4gICAgX3VwZGF0ZUhhc2g6IGZ1bmN0aW9uKGxvY2F0aW9uLCBmcmFnbWVudCwgcmVwbGFjZSkge1xuICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgdmFyIGhyZWYgPSBsb2NhdGlvbi5ocmVmLnJlcGxhY2UoLyhqYXZhc2NyaXB0OnwjKS4qJC8sICcnKTtcbiAgICAgICAgbG9jYXRpb24ucmVwbGFjZShocmVmICsgJyMnICsgZnJhZ21lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU29tZSBicm93c2VycyByZXF1aXJlIHRoYXQgYGhhc2hgIGNvbnRhaW5zIGEgbGVhZGluZyAjLlxuICAgICAgICBsb2NhdGlvbi5oYXNoID0gJyMnICsgZnJhZ21lbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIENyZWF0ZSB0aGUgZGVmYXVsdCBCYWNrYm9uZS5oaXN0b3J5LlxuICBCYWNrYm9uZS5oaXN0b3J5ID0gbmV3IEhpc3Rvcnk7XG5cbiAgLy8gSGVscGVyc1xuICAvLyAtLS0tLS0tXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvcnJlY3RseSBzZXQgdXAgdGhlIHByb3RvdHlwZSBjaGFpbiBmb3Igc3ViY2xhc3Nlcy5cbiAgLy8gU2ltaWxhciB0byBgZ29vZy5pbmhlcml0c2AsIGJ1dCB1c2VzIGEgaGFzaCBvZiBwcm90b3R5cGUgcHJvcGVydGllcyBhbmRcbiAgLy8gY2xhc3MgcHJvcGVydGllcyB0byBiZSBleHRlbmRlZC5cbiAgdmFyIGV4dGVuZCA9IGZ1bmN0aW9uKHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgdmFyIGNoaWxkO1xuXG4gICAgLy8gVGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgbmV3IHN1YmNsYXNzIGlzIGVpdGhlciBkZWZpbmVkIGJ5IHlvdVxuICAgIC8vICh0aGUgXCJjb25zdHJ1Y3RvclwiIHByb3BlcnR5IGluIHlvdXIgYGV4dGVuZGAgZGVmaW5pdGlvbiksIG9yIGRlZmF1bHRlZFxuICAgIC8vIGJ5IHVzIHRvIHNpbXBseSBjYWxsIHRoZSBwYXJlbnQgY29uc3RydWN0b3IuXG4gICAgaWYgKHByb3RvUHJvcHMgJiYgXy5oYXMocHJvdG9Qcm9wcywgJ2NvbnN0cnVjdG9yJykpIHtcbiAgICAgIGNoaWxkID0gcHJvdG9Qcm9wcy5jb25zdHJ1Y3RvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGQgPSBmdW5jdGlvbigpeyByZXR1cm4gcGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgfVxuXG4gICAgLy8gQWRkIHN0YXRpYyBwcm9wZXJ0aWVzIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgaWYgc3VwcGxpZWQuXG4gICAgXy5leHRlbmQoY2hpbGQsIHBhcmVudCwgc3RhdGljUHJvcHMpO1xuXG4gICAgLy8gU2V0IHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gaW5oZXJpdCBmcm9tIGBwYXJlbnRgLCB3aXRob3V0IGNhbGxpbmdcbiAgICAvLyBgcGFyZW50YCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICB2YXIgU3Vycm9nYXRlID0gZnVuY3Rpb24oKXsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9O1xuICAgIFN1cnJvZ2F0ZS5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBTdXJyb2dhdGU7XG5cbiAgICAvLyBBZGQgcHJvdG90eXBlIHByb3BlcnRpZXMgKGluc3RhbmNlIHByb3BlcnRpZXMpIHRvIHRoZSBzdWJjbGFzcyxcbiAgICAvLyBpZiBzdXBwbGllZC5cbiAgICBpZiAocHJvdG9Qcm9wcykgXy5leHRlbmQoY2hpbGQucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcblxuICAgIC8vIFNldCBhIGNvbnZlbmllbmNlIHByb3BlcnR5IGluIGNhc2UgdGhlIHBhcmVudCdzIHByb3RvdHlwZSBpcyBuZWVkZWRcbiAgICAvLyBsYXRlci5cbiAgICBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlO1xuXG4gICAgcmV0dXJuIGNoaWxkO1xuICB9O1xuXG4gIC8vIFNldCB1cCBpbmhlcml0YW5jZSBmb3IgdGhlIG1vZGVsLCBjb2xsZWN0aW9uLCByb3V0ZXIsIHZpZXcgYW5kIGhpc3RvcnkuXG4gIE1vZGVsLmV4dGVuZCA9IENvbGxlY3Rpb24uZXh0ZW5kID0gUm91dGVyLmV4dGVuZCA9IFZpZXcuZXh0ZW5kID0gSGlzdG9yeS5leHRlbmQgPSBleHRlbmQ7XG5cbiAgLy8gVGhyb3cgYW4gZXJyb3Igd2hlbiBhIFVSTCBpcyBuZWVkZWQsIGFuZCBub25lIGlzIHN1cHBsaWVkLlxuICB2YXIgdXJsRXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgXCJ1cmxcIiBwcm9wZXJ0eSBvciBmdW5jdGlvbiBtdXN0IGJlIHNwZWNpZmllZCcpO1xuICB9O1xuXG4gIC8vIFdyYXAgYW4gb3B0aW9uYWwgZXJyb3IgY2FsbGJhY2sgd2l0aCBhIGZhbGxiYWNrIGVycm9yIGV2ZW50LlxuICB2YXIgd3JhcEVycm9yID0gZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgZXJyb3IgPSBvcHRpb25zLmVycm9yO1xuICAgIG9wdGlvbnMuZXJyb3IgPSBmdW5jdGlvbihyZXNwKSB7XG4gICAgICBpZiAoZXJyb3IpIGVycm9yLmNhbGwob3B0aW9ucy5jb250ZXh0LCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICBtb2RlbC50cmlnZ2VyKCdlcnJvcicsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBCYWNrYm9uZTtcblxufSkpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltNXZaR1ZmYlc5a2RXeGxjeTlpWVdOclltOXVaUzlpWVdOclltOXVaUzVxY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBGQlFVRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVNJc0ltWnBiR1VpT2lKblpXNWxjbUYwWldRdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lMeThnSUNBZ0lFSmhZMnRpYjI1bExtcHpJREV1TWk0eFhHNWNiaTh2SUNBZ0lDQW9ZeWtnTWpBeE1DMHlNREUxSUVwbGNtVnRlU0JCYzJoclpXNWhjeXdnUkc5amRXMWxiblJEYkc5MVpDQmhibVFnU1c1MlpYTjBhV2RoZEdsMlpTQlNaWEJ2Y25SbGNuTWdKaUJGWkdsMGIzSnpYRzR2THlBZ0lDQWdRbUZqYTJKdmJtVWdiV0Y1SUdKbElHWnlaV1ZzZVNCa2FYTjBjbWxpZFhSbFpDQjFibVJsY2lCMGFHVWdUVWxVSUd4cFkyVnVjMlV1WEc0dkx5QWdJQ0FnUm05eUlHRnNiQ0JrWlhSaGFXeHpJR0Z1WkNCa2IyTjFiV1Z1ZEdGMGFXOXVPbHh1THk4Z0lDQWdJR2gwZEhBNkx5OWlZV05yWW05dVpXcHpMbTl5WjF4dVhHNG9ablZ1WTNScGIyNG9abUZqZEc5eWVTa2dlMXh1WEc0Z0lDOHZJRVZ6ZEdGaWJHbHphQ0IwYUdVZ2NtOXZkQ0J2WW1wbFkzUXNJR0IzYVc1a2IzZGdJQ2hnYzJWc1ptQXBJR2x1SUhSb1pTQmljbTkzYzJWeUxDQnZjaUJnWjJ4dlltRnNZQ0J2YmlCMGFHVWdjMlZ5ZG1WeUxseHVJQ0F2THlCWFpTQjFjMlVnWUhObGJHWmdJR2x1YzNSbFlXUWdiMllnWUhkcGJtUnZkMkFnWm05eUlHQlhaV0pYYjNKclpYSmdJSE4xY0hCdmNuUXVYRzRnSUhaaGNpQnliMjkwSUQwZ0tIUjVjR1Z2WmlCelpXeG1JRDA5SUNkdlltcGxZM1FuSUNZbUlITmxiR1l1YzJWc1ppQTlQU0J6Wld4bUlDWW1JSE5sYkdZcElIeDhYRzRnSUNBZ0lDQWdJQ0FnSUNBb2RIbHdaVzltSUdkc2IySmhiQ0E5UFNBbmIySnFaV04wSnlBbUppQm5iRzlpWVd3dVoyeHZZbUZzSUQwOUlHZHNiMkpoYkNBbUppQm5iRzlpWVd3cE8xeHVYRzRnSUM4dklGTmxkQ0IxY0NCQ1lXTnJZbTl1WlNCaGNIQnliM0J5YVdGMFpXeDVJR1p2Y2lCMGFHVWdaVzUyYVhKdmJtMWxiblF1SUZOMFlYSjBJSGRwZEdnZ1FVMUVMbHh1SUNCcFppQW9kSGx3Wlc5bUlHUmxabWx1WlNBOVBUMGdKMloxYm1OMGFXOXVKeUFtSmlCa1pXWnBibVV1WVcxa0tTQjdYRzRnSUNBZ1pHVm1hVzVsS0ZzbmRXNWtaWEp6WTI5eVpTY3NJQ2RxY1hWbGNua25MQ0FuWlhod2IzSjBjeWRkTENCbWRXNWpkR2x2YmloZkxDQWtMQ0JsZUhCdmNuUnpLU0I3WEc0Z0lDQWdJQ0F2THlCRmVIQnZjblFnWjJ4dlltRnNJR1YyWlc0Z2FXNGdRVTFFSUdOaGMyVWdhVzRnWTJGelpTQjBhR2x6SUhOamNtbHdkQ0JwY3lCc2IyRmtaV1FnZDJsMGFGeHVJQ0FnSUNBZ0x5OGdiM1JvWlhKeklIUm9ZWFFnYldGNUlITjBhV3hzSUdWNGNHVmpkQ0JoSUdkc2IySmhiQ0JDWVdOclltOXVaUzVjYmlBZ0lDQWdJSEp2YjNRdVFtRmphMkp2Ym1VZ1BTQm1ZV04wYjNKNUtISnZiM1FzSUdWNGNHOXlkSE1zSUY4c0lDUXBPMXh1SUNBZ0lIMHBPMXh1WEc0Z0lDOHZJRTVsZUhRZ1ptOXlJRTV2WkdVdWFuTWdiM0lnUTI5dGJXOXVTbE11SUdwUmRXVnllU0J0WVhrZ2JtOTBJR0psSUc1bFpXUmxaQ0JoY3lCaElHMXZaSFZzWlM1Y2JpQWdmU0JsYkhObElHbG1JQ2gwZVhCbGIyWWdaWGh3YjNKMGN5QWhQVDBnSjNWdVpHVm1hVzVsWkNjcElIdGNiaUFnSUNCMllYSWdYeUE5SUhKbGNYVnBjbVVvSjNWdVpHVnljMk52Y21VbktTd2dKRHRjYmlBZ0lDQjBjbmtnZXlBa0lEMGdjbVZ4ZFdseVpTZ25hbkYxWlhKNUp5azdJSDBnWTJGMFkyZ29aU2tnZTMxY2JpQWdJQ0JtWVdOMGIzSjVLSEp2YjNRc0lHVjRjRzl5ZEhNc0lGOHNJQ1FwTzF4dVhHNGdJQzh2SUVacGJtRnNiSGtzSUdGeklHRWdZbkp2ZDNObGNpQm5iRzlpWVd3dVhHNGdJSDBnWld4elpTQjdYRzRnSUNBZ2NtOXZkQzVDWVdOclltOXVaU0E5SUdaaFkzUnZjbmtvY205dmRDd2dlMzBzSUhKdmIzUXVYeXdnS0hKdmIzUXVhbEYxWlhKNUlIeDhJSEp2YjNRdVdtVndkRzhnZkh3Z2NtOXZkQzVsYm1SbGNpQjhmQ0J5YjI5MExpUXBLVHRjYmlBZ2ZWeHVYRzU5S0daMWJtTjBhVzl1S0hKdmIzUXNJRUpoWTJ0aWIyNWxMQ0JmTENBa0tTQjdYRzVjYmlBZ0x5OGdTVzVwZEdsaGJDQlRaWFIxY0Z4dUlDQXZMeUF0TFMwdExTMHRMUzB0TFMwdFhHNWNiaUFnTHk4Z1UyRjJaU0IwYUdVZ2NISmxkbWx2ZFhNZ2RtRnNkV1VnYjJZZ2RHaGxJR0JDWVdOclltOXVaV0FnZG1GeWFXRmliR1VzSUhOdklIUm9ZWFFnYVhRZ1kyRnVJR0psWEc0Z0lDOHZJSEpsYzNSdmNtVmtJR3hoZEdWeUlHOXVMQ0JwWmlCZ2JtOURiMjVtYkdsamRHQWdhWE1nZFhObFpDNWNiaUFnZG1GeUlIQnlaWFpwYjNWelFtRmphMkp2Ym1VZ1BTQnliMjkwTGtKaFkydGliMjVsTzF4dVhHNGdJQzh2SUVOeVpXRjBaU0JoSUd4dlkyRnNJSEpsWm1WeVpXNWpaU0IwYnlCaElHTnZiVzF2YmlCaGNuSmhlU0J0WlhSb2IyUWdkMlVuYkd3Z2QyRnVkQ0IwYnlCMWMyVWdiR0YwWlhJdVhHNGdJSFpoY2lCemJHbGpaU0E5SUZ0ZExuTnNhV05sTzF4dVhHNGdJQzh2SUVOMWNuSmxiblFnZG1WeWMybHZiaUJ2WmlCMGFHVWdiR2xpY21GeWVTNGdTMlZsY0NCcGJpQnplVzVqSUhkcGRHZ2dZSEJoWTJ0aFoyVXVhbk52Ym1BdVhHNGdJRUpoWTJ0aWIyNWxMbFpGVWxOSlQwNGdQU0FuTVM0eUxqRW5PMXh1WEc0Z0lDOHZJRVp2Y2lCQ1lXTnJZbTl1WlNkeklIQjFjbkJ2YzJWekxDQnFVWFZsY25rc0lGcGxjSFJ2TENCRmJtUmxjaXdnYjNJZ1RYa2dUR2xpY21GeWVTQW9hMmxrWkdsdVp5a2diM2R1YzF4dUlDQXZMeUIwYUdVZ1lDUmdJSFpoY21saFlteGxMbHh1SUNCQ1lXTnJZbTl1WlM0a0lEMGdKRHRjYmx4dUlDQXZMeUJTZFc1eklFSmhZMnRpYjI1bExtcHpJR2x1SUNwdWIwTnZibVpzYVdOMEtpQnRiMlJsTENCeVpYUjFjbTVwYm1jZ2RHaGxJR0JDWVdOclltOXVaV0FnZG1GeWFXRmliR1ZjYmlBZ0x5OGdkRzhnYVhSeklIQnlaWFpwYjNWeklHOTNibVZ5TGlCU1pYUjFjbTV6SUdFZ2NtVm1aWEpsYm1ObElIUnZJSFJvYVhNZ1FtRmphMkp2Ym1VZ2IySnFaV04wTGx4dUlDQkNZV05yWW05dVpTNXViME52Ym1ac2FXTjBJRDBnWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnY205dmRDNUNZV05yWW05dVpTQTlJSEJ5WlhacGIzVnpRbUZqYTJKdmJtVTdYRzRnSUNBZ2NtVjBkWEp1SUhSb2FYTTdYRzRnSUgwN1hHNWNiaUFnTHk4Z1ZIVnliaUJ2YmlCZ1pXMTFiR0YwWlVoVVZGQmdJSFJ2SUhOMWNIQnZjblFnYkdWbllXTjVJRWhVVkZBZ2MyVnlkbVZ5Y3k0Z1UyVjBkR2x1WnlCMGFHbHpJRzl3ZEdsdmJseHVJQ0F2THlCM2FXeHNJR1poYTJVZ1lGd2lVRUZVUTBoY0ltQXNJR0JjSWxCVlZGd2lZQ0JoYm1RZ1lGd2lSRVZNUlZSRlhDSmdJSEpsY1hWbGMzUnpJSFpwWVNCMGFHVWdZRjl0WlhSb2IyUmdJSEJoY21GdFpYUmxjaUJoYm1SY2JpQWdMeThnYzJWMElHRWdZRmd0U0hSMGNDMU5aWFJvYjJRdFQzWmxjbkpwWkdWZ0lHaGxZV1JsY2k1Y2JpQWdRbUZqYTJKdmJtVXVaVzExYkdGMFpVaFVWRkFnUFNCbVlXeHpaVHRjYmx4dUlDQXZMeUJVZFhKdUlHOXVJR0JsYlhWc1lYUmxTbE5QVG1BZ2RHOGdjM1Z3Y0c5eWRDQnNaV2RoWTNrZ2MyVnlkbVZ5Y3lCMGFHRjBJR05oYmlkMElHUmxZV3dnZDJsMGFDQmthWEpsWTNSY2JpQWdMeThnWUdGd2NHeHBZMkYwYVc5dUwycHpiMjVnSUhKbGNYVmxjM1J6SUM0dUxpQjBhR2x6SUhkcGJHd2daVzVqYjJSbElIUm9aU0JpYjJSNUlHRnpYRzRnSUM4dklHQmhjSEJzYVdOaGRHbHZiaTk0TFhkM2R5MW1iM0p0TFhWeWJHVnVZMjlrWldSZ0lHbHVjM1JsWVdRZ1lXNWtJSGRwYkd3Z2MyVnVaQ0IwYUdVZ2JXOWtaV3dnYVc0Z1lWeHVJQ0F2THlCbWIzSnRJSEJoY21GdElHNWhiV1ZrSUdCdGIyUmxiR0F1WEc0Z0lFSmhZMnRpYjI1bExtVnRkV3hoZEdWS1UwOU9JRDBnWm1Gc2MyVTdYRzVjYmlBZ0x5OGdVSEp2ZUhrZ1ZXNWtaWEp6WTI5eVpTQnRaWFJvYjJSeklIUnZJR0VnUW1GamEySnZibVVnWTJ4aGMzTW5JSEJ5YjNSdmRIbHdaU0IxYzJsdVp5QmhYRzRnSUM4dklIQmhjblJwWTNWc1lYSWdZWFIwY21saWRYUmxJR0Z6SUhSb1pTQmtZWFJoSUdGeVozVnRaVzUwWEc0Z0lIWmhjaUJoWkdSTlpYUm9iMlFnUFNCbWRXNWpkR2x2Ymloc1pXNW5kR2dzSUcxbGRHaHZaQ3dnWVhSMGNtbGlkWFJsS1NCN1hHNGdJQ0FnYzNkcGRHTm9JQ2hzWlc1bmRHZ3BJSHRjYmlBZ0lDQWdJR05oYzJVZ01Ub2djbVYwZFhKdUlHWjFibU4wYVc5dUtDa2dlMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdYMXR0WlhSb2IyUmRLSFJvYVhOYllYUjBjbWxpZFhSbFhTazdYRzRnSUNBZ0lDQjlPMXh1SUNBZ0lDQWdZMkZ6WlNBeU9pQnlaWFIxY200Z1puVnVZM1JwYjI0b2RtRnNkV1VwSUh0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1SUY5YmJXVjBhRzlrWFNoMGFHbHpXMkYwZEhKcFluVjBaVjBzSUhaaGJIVmxLVHRjYmlBZ0lDQWdJSDA3WEc0Z0lDQWdJQ0JqWVhObElETTZJSEpsZEhWeWJpQm1kVzVqZEdsdmJpaHBkR1Z5WVhSbFpTd2dZMjl1ZEdWNGRDa2dlMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdYMXR0WlhSb2IyUmRLSFJvYVhOYllYUjBjbWxpZFhSbFhTd2dhWFJsY21GMFpXVXNJR052Ym5SbGVIUXBPMXh1SUNBZ0lDQWdmVHRjYmlBZ0lDQWdJR05oYzJVZ05Eb2djbVYwZFhKdUlHWjFibU4wYVc5dUtHbDBaWEpoZEdWbExDQmtaV1poZFd4MFZtRnNMQ0JqYjI1MFpYaDBLU0I3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUJmVzIxbGRHaHZaRjBvZEdocGMxdGhkSFJ5YVdKMWRHVmRMQ0JwZEdWeVlYUmxaU3dnWkdWbVlYVnNkRlpoYkN3Z1kyOXVkR1Y0ZENrN1hHNGdJQ0FnSUNCOU8xeHVJQ0FnSUNBZ1pHVm1ZWFZzZERvZ2NtVjBkWEp1SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0FnSUNBZ0lDQjJZWElnWVhKbmN5QTlJSE5zYVdObExtTmhiR3dvWVhKbmRXMWxiblJ6S1R0Y2JpQWdJQ0FnSUNBZ1lYSm5jeTUxYm5Ob2FXWjBLSFJvYVhOYllYUjBjbWxpZFhSbFhTazdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQmZXMjFsZEdodlpGMHVZWEJ3Ykhrb1h5d2dZWEpuY3lrN1hHNGdJQ0FnSUNCOU8xeHVJQ0FnSUgxY2JpQWdmVHRjYmlBZ2RtRnlJR0ZrWkZWdVpHVnljMk52Y21WTlpYUm9iMlJ6SUQwZ1puVnVZM1JwYjI0b1EyeGhjM01zSUcxbGRHaHZaSE1zSUdGMGRISnBZblYwWlNrZ2UxeHVJQ0FnSUY4dVpXRmphQ2h0WlhSb2IyUnpMQ0JtZFc1amRHbHZiaWhzWlc1bmRHZ3NJRzFsZEdodlpDa2dlMXh1SUNBZ0lDQWdhV1lnS0Y5YmJXVjBhRzlrWFNrZ1EyeGhjM011Y0hKdmRHOTBlWEJsVzIxbGRHaHZaRjBnUFNCaFpHUk5aWFJvYjJRb2JHVnVaM1JvTENCdFpYUm9iMlFzSUdGMGRISnBZblYwWlNrN1hHNGdJQ0FnZlNrN1hHNGdJSDA3WEc1Y2JpQWdMeThnUW1GamEySnZibVV1UlhabGJuUnpYRzRnSUM4dklDMHRMUzB0TFMwdExTMHRMUzB0TFZ4dVhHNGdJQzh2SUVFZ2JXOWtkV3hsSUhSb1lYUWdZMkZ1SUdKbElHMXBlR1ZrSUdsdUlIUnZJQ3BoYm5rZ2IySnFaV04wS2lCcGJpQnZjbVJsY2lCMGJ5QndjbTkyYVdSbElHbDBJSGRwZEdoY2JpQWdMeThnWTNWemRHOXRJR1YyWlc1MGN5NGdXVzkxSUcxaGVTQmlhVzVrSUhkcGRHZ2dZRzl1WUNCdmNpQnlaVzF2ZG1VZ2QybDBhQ0JnYjJabVlDQmpZV3hzWW1GamExeHVJQ0F2THlCbWRXNWpkR2x2Ym5NZ2RHOGdZVzRnWlhabGJuUTdJR0IwY21sbloyVnlZQzFwYm1jZ1lXNGdaWFpsYm5RZ1ptbHlaWE1nWVd4c0lHTmhiR3hpWVdOcmN5QnBibHh1SUNBdkx5QnpkV05qWlhOemFXOXVMbHh1SUNBdkwxeHVJQ0F2THlBZ0lDQWdkbUZ5SUc5aWFtVmpkQ0E5SUh0OU8xeHVJQ0F2THlBZ0lDQWdYeTVsZUhSbGJtUW9iMkpxWldOMExDQkNZV05yWW05dVpTNUZkbVZ1ZEhNcE8xeHVJQ0F2THlBZ0lDQWdiMkpxWldOMExtOXVLQ2RsZUhCaGJtUW5MQ0JtZFc1amRHbHZiaWdwZXlCaGJHVnlkQ2duWlhod1lXNWtaV1FuS1RzZ2ZTazdYRzRnSUM4dklDQWdJQ0J2WW1wbFkzUXVkSEpwWjJkbGNpZ25aWGh3WVc1a0p5azdYRzRnSUM4dlhHNGdJSFpoY2lCRmRtVnVkSE1nUFNCQ1lXTnJZbTl1WlM1RmRtVnVkSE1nUFNCN2ZUdGNibHh1SUNBdkx5QlNaV2QxYkdGeUlHVjRjSEpsYzNOcGIyNGdkWE5sWkNCMGJ5QnpjR3hwZENCbGRtVnVkQ0J6ZEhKcGJtZHpMbHh1SUNCMllYSWdaWFpsYm5SVGNHeHBkSFJsY2lBOUlDOWNYSE1yTHp0Y2JseHVJQ0F2THlCSmRHVnlZWFJsY3lCdmRtVnlJSFJvWlNCemRHRnVaR0Z5WkNCZ1pYWmxiblFzSUdOaGJHeGlZV05yWUNBb1lYTWdkMlZzYkNCaGN5QjBhR1VnWm1GdVkza2diWFZzZEdsd2JHVmNiaUFnTHk4Z2MzQmhZMlV0YzJWd1lYSmhkR1ZrSUdWMlpXNTBjeUJnWENKamFHRnVaMlVnWW14MWNsd2lMQ0JqWVd4c1ltRmphMkFnWVc1a0lHcFJkV1Z5ZVMxemRIbHNaU0JsZG1WdWRGeHVJQ0F2THlCdFlYQnpJR0I3WlhabGJuUTZJR05oYkd4aVlXTnJmV0FwTENCeVpXUjFZMmx1WnlCMGFHVnRJR0o1SUcxaGJtbHdkV3hoZEdsdVp5QmdiV1Z0YjJBdVhHNGdJQzh2SUZCaGMzTmxjeUJoSUc1dmNtMWhiR2w2WldRZ2MybHVaMnhsSUdWMlpXNTBJRzVoYldVZ1lXNWtJR05oYkd4aVlXTnJMQ0JoY3lCM1pXeHNJR0Z6SUdGdWVWeHVJQ0F2THlCdmNIUnBiMjVoYkNCZ2IzQjBjMkF1WEc0Z0lIWmhjaUJsZG1WdWRITkJjR2tnUFNCbWRXNWpkR2x2YmlocGRHVnlZWFJsWlN3Z2JXVnRieXdnYm1GdFpTd2dZMkZzYkdKaFkyc3NJRzl3ZEhNcElIdGNiaUFnSUNCMllYSWdhU0E5SURBc0lHNWhiV1Z6TzF4dUlDQWdJR2xtSUNodVlXMWxJQ1ltSUhSNWNHVnZaaUJ1WVcxbElEMDlQU0FuYjJKcVpXTjBKeWtnZTF4dUlDQWdJQ0FnTHk4Z1NHRnVaR3hsSUdWMlpXNTBJRzFoY0hNdVhHNGdJQ0FnSUNCcFppQW9ZMkZzYkdKaFkyc2dJVDA5SUhadmFXUWdNQ0FtSmlBblkyOXVkR1Y0ZENjZ2FXNGdiM0IwY3lBbUppQnZjSFJ6TG1OdmJuUmxlSFFnUFQwOUlIWnZhV1FnTUNrZ2IzQjBjeTVqYjI1MFpYaDBJRDBnWTJGc2JHSmhZMnM3WEc0Z0lDQWdJQ0JtYjNJZ0tHNWhiV1Z6SUQwZ1h5NXJaWGx6S0c1aGJXVXBPeUJwSUR3Z2JtRnRaWE11YkdWdVozUm9JRHNnYVNzcktTQjdYRzRnSUNBZ0lDQWdJRzFsYlc4Z1BTQnBkR1Z5WVhSbFpTaHRaVzF2TENCdVlXMWxjMXRwWFN3Z2JtRnRaVnR1WVcxbGMxdHBYVjBzSUc5d2RITXBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMGdaV3h6WlNCcFppQW9ibUZ0WlNBbUppQmxkbVZ1ZEZOd2JHbDBkR1Z5TG5SbGMzUW9ibUZ0WlNrcElIdGNiaUFnSUNBZ0lDOHZJRWhoYm1Sc1pTQnpjR0ZqWlNCelpYQmhjbUYwWldRZ1pYWmxiblFnYm1GdFpYTXVYRzRnSUNBZ0lDQm1iM0lnS0c1aGJXVnpJRDBnYm1GdFpTNXpjR3hwZENobGRtVnVkRk53YkdsMGRHVnlLVHNnYVNBOElHNWhiV1Z6TG14bGJtZDBhRHNnYVNzcktTQjdYRzRnSUNBZ0lDQWdJRzFsYlc4Z1BTQnBkR1Z5WVhSbFpTaHRaVzF2TENCdVlXMWxjMXRwWFN3Z1kyRnNiR0poWTJzc0lHOXdkSE1wTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJSDBnWld4elpTQjdYRzRnSUNBZ0lDQnRaVzF2SUQwZ2FYUmxjbUYwWldVb2JXVnRieXdnYm1GdFpTd2dZMkZzYkdKaFkyc3NJRzl3ZEhNcE8xeHVJQ0FnSUgxY2JpQWdJQ0J5WlhSMWNtNGdiV1Z0Ynp0Y2JpQWdmVHRjYmx4dUlDQXZMeUJDYVc1a0lHRnVJR1YyWlc1MElIUnZJR0VnWUdOaGJHeGlZV05yWUNCbWRXNWpkR2x2Ymk0Z1VHRnpjMmx1WnlCZ1hDSmhiR3hjSW1BZ2QybHNiQ0JpYVc1a1hHNGdJQzh2SUhSb1pTQmpZV3hzWW1GamF5QjBieUJoYkd3Z1pYWmxiblJ6SUdacGNtVmtMbHh1SUNCRmRtVnVkSE11YjI0Z1BTQm1kVzVqZEdsdmJpaHVZVzFsTENCallXeHNZbUZqYXl3Z1kyOXVkR1Y0ZENrZ2UxeHVJQ0FnSUhKbGRIVnliaUJwYm5SbGNtNWhiRTl1S0hSb2FYTXNJRzVoYldVc0lHTmhiR3hpWVdOckxDQmpiMjUwWlhoMEtUdGNiaUFnZlR0Y2JseHVJQ0F2THlCQmJpQnBiblJsY201aGJDQjFjMlVnWUc5dVlDQm1kVzVqZEdsdmJpd2dkWE5sWkNCMGJ5Qm5kV0Z5WkNCMGFHVWdZR3hwYzNSbGJtbHVaMkFnWVhKbmRXMWxiblFnWm5KdmJWeHVJQ0F2THlCMGFHVWdjSFZpYkdsaklFRlFTUzVjYmlBZ2RtRnlJR2x1ZEdWeWJtRnNUMjRnUFNCbWRXNWpkR2x2Ymlodlltb3NJRzVoYldVc0lHTmhiR3hpWVdOckxDQmpiMjUwWlhoMExDQnNhWE4wWlc1cGJtY3BJSHRjYmlBZ0lDQnZZbW91WDJWMlpXNTBjeUE5SUdWMlpXNTBjMEZ3YVNodmJrRndhU3dnYjJKcUxsOWxkbVZ1ZEhNZ2ZId2dlMzBzSUc1aGJXVXNJR05oYkd4aVlXTnJMQ0I3WEc0Z0lDQWdJQ0FnSUdOdmJuUmxlSFE2SUdOdmJuUmxlSFFzWEc0Z0lDQWdJQ0FnSUdOMGVEb2diMkpxTEZ4dUlDQWdJQ0FnSUNCc2FYTjBaVzVwYm1jNklHeHBjM1JsYm1sdVoxeHVJQ0FnSUgwcE8xeHVYRzRnSUNBZ2FXWWdLR3hwYzNSbGJtbHVaeWtnZTF4dUlDQWdJQ0FnZG1GeUlHeHBjM1JsYm1WeWN5QTlJRzlpYWk1ZmJHbHpkR1Z1WlhKeklIeDhJQ2h2WW1vdVgyeHBjM1JsYm1WeWN5QTlJSHQ5S1R0Y2JpQWdJQ0FnSUd4cGMzUmxibVZ5YzF0c2FYTjBaVzVwYm1jdWFXUmRJRDBnYkdsemRHVnVhVzVuTzF4dUlDQWdJSDFjYmx4dUlDQWdJSEpsZEhWeWJpQnZZbW83WEc0Z0lIMDdYRzVjYmlBZ0x5OGdTVzUyWlhKemFXOXVMVzltTFdOdmJuUnliMndnZG1WeWMybHZibk1nYjJZZ1lHOXVZQzRnVkdWc2JDQXFkR2hwY3lvZ2IySnFaV04wSUhSdklHeHBjM1JsYmlCMGIxeHVJQ0F2THlCaGJpQmxkbVZ1ZENCcGJpQmhibTkwYUdWeUlHOWlhbVZqZEM0dUxpQnJaV1Z3YVc1bklIUnlZV05ySUc5bUlIZG9ZWFFnYVhRbmN5QnNhWE4wWlc1cGJtY2dkRzh1WEc0Z0lFVjJaVzUwY3k1c2FYTjBaVzVVYnlBOUlDQm1kVzVqZEdsdmJpaHZZbW9zSUc1aGJXVXNJR05oYkd4aVlXTnJLU0I3WEc0Z0lDQWdhV1lnS0NGdlltb3BJSEpsZEhWeWJpQjBhR2x6TzF4dUlDQWdJSFpoY2lCcFpDQTlJRzlpYWk1ZmJHbHpkR1Z1U1dRZ2ZId2dLRzlpYWk1ZmJHbHpkR1Z1U1dRZ1BTQmZMblZ1YVhGMVpVbGtLQ2RzSnlrcE8xeHVJQ0FnSUhaaGNpQnNhWE4wWlc1cGJtZFVieUE5SUhSb2FYTXVYMnhwYzNSbGJtbHVaMVJ2SUh4OElDaDBhR2x6TGw5c2FYTjBaVzVwYm1kVWJ5QTlJSHQ5S1R0Y2JpQWdJQ0IyWVhJZ2JHbHpkR1Z1YVc1bklEMGdiR2x6ZEdWdWFXNW5WRzliYVdSZE8xeHVYRzRnSUNBZ0x5OGdWR2hwY3lCdlltcGxZM1FnYVhNZ2JtOTBJR3hwYzNSbGJtbHVaeUIwYnlCaGJua2diM1JvWlhJZ1pYWmxiblJ6SUc5dUlHQnZZbXBnSUhsbGRDNWNiaUFnSUNBdkx5QlRaWFIxY0NCMGFHVWdibVZqWlhOellYSjVJSEpsWm1WeVpXNWpaWE1nZEc4Z2RISmhZMnNnZEdobElHeHBjM1JsYm1sdVp5QmpZV3hzWW1GamEzTXVYRzRnSUNBZ2FXWWdLQ0ZzYVhOMFpXNXBibWNwSUh0Y2JpQWdJQ0FnSUhaaGNpQjBhR2x6U1dRZ1BTQjBhR2x6TGw5c2FYTjBaVzVKWkNCOGZDQW9kR2hwY3k1ZmJHbHpkR1Z1U1dRZ1BTQmZMblZ1YVhGMVpVbGtLQ2RzSnlrcE8xeHVJQ0FnSUNBZ2JHbHpkR1Z1YVc1bklEMGdiR2x6ZEdWdWFXNW5WRzliYVdSZElEMGdlMjlpYWpvZ2IySnFMQ0J2WW1wSlpEb2dhV1FzSUdsa09pQjBhR2x6U1dRc0lHeHBjM1JsYm1sdVoxUnZPaUJzYVhOMFpXNXBibWRVYnl3Z1kyOTFiblE2SURCOU8xeHVJQ0FnSUgxY2JseHVJQ0FnSUM4dklFSnBibVFnWTJGc2JHSmhZMnR6SUc5dUlHOWlhaXdnWVc1a0lHdGxaWEFnZEhKaFkyc2diMllnZEdobGJTQnZiaUJzYVhOMFpXNXBibWN1WEc0Z0lDQWdhVzUwWlhKdVlXeFBiaWh2WW1vc0lHNWhiV1VzSUdOaGJHeGlZV05yTENCMGFHbHpMQ0JzYVhOMFpXNXBibWNwTzF4dUlDQWdJSEpsZEhWeWJpQjBhR2x6TzF4dUlDQjlPMXh1WEc0Z0lDOHZJRlJvWlNCeVpXUjFZMmx1WnlCQlVFa2dkR2hoZENCaFpHUnpJR0VnWTJGc2JHSmhZMnNnZEc4Z2RHaGxJR0JsZG1WdWRITmdJRzlpYW1WamRDNWNiaUFnZG1GeUlHOXVRWEJwSUQwZ1puVnVZM1JwYjI0b1pYWmxiblJ6TENCdVlXMWxMQ0JqWVd4c1ltRmpheXdnYjNCMGFXOXVjeWtnZTF4dUlDQWdJR2xtSUNoallXeHNZbUZqYXlrZ2UxeHVJQ0FnSUNBZ2RtRnlJR2hoYm1Sc1pYSnpJRDBnWlhabGJuUnpXMjVoYldWZElIeDhJQ2hsZG1WdWRITmJibUZ0WlYwZ1BTQmJYU2s3WEc0Z0lDQWdJQ0IyWVhJZ1kyOXVkR1Y0ZENBOUlHOXdkR2x2Ym5NdVkyOXVkR1Y0ZEN3Z1kzUjRJRDBnYjNCMGFXOXVjeTVqZEhnc0lHeHBjM1JsYm1sdVp5QTlJRzl3ZEdsdmJuTXViR2x6ZEdWdWFXNW5PMXh1SUNBZ0lDQWdhV1lnS0d4cGMzUmxibWx1WnlrZ2JHbHpkR1Z1YVc1bkxtTnZkVzUwS3lzN1hHNWNiaUFnSUNBZ0lHaGhibVJzWlhKekxuQjFjMmdvZXlCallXeHNZbUZqYXpvZ1kyRnNiR0poWTJzc0lHTnZiblJsZUhRNklHTnZiblJsZUhRc0lHTjBlRG9nWTI5dWRHVjRkQ0I4ZkNCamRIZ3NJR3hwYzNSbGJtbHVaem9nYkdsemRHVnVhVzVuSUgwcE8xeHVJQ0FnSUgxY2JpQWdJQ0J5WlhSMWNtNGdaWFpsYm5Sek8xeHVJQ0I5TzF4dVhHNGdJQzh2SUZKbGJXOTJaU0J2Ym1VZ2IzSWdiV0Z1ZVNCallXeHNZbUZqYTNNdUlFbG1JR0JqYjI1MFpYaDBZQ0JwY3lCdWRXeHNMQ0J5WlcxdmRtVnpJR0ZzYkZ4dUlDQXZMeUJqWVd4c1ltRmphM01nZDJsMGFDQjBhR0YwSUdaMWJtTjBhVzl1TGlCSlppQmdZMkZzYkdKaFkydGdJR2x6SUc1MWJHd3NJSEpsYlc5MlpYTWdZV3hzWEc0Z0lDOHZJR05oYkd4aVlXTnJjeUJtYjNJZ2RHaGxJR1YyWlc1MExpQkpaaUJnYm1GdFpXQWdhWE1nYm5Wc2JDd2djbVZ0YjNabGN5QmhiR3dnWW05MWJtUmNiaUFnTHk4Z1kyRnNiR0poWTJ0eklHWnZjaUJoYkd3Z1pYWmxiblJ6TGx4dUlDQkZkbVZ1ZEhNdWIyWm1JRDBnSUdaMWJtTjBhVzl1S0c1aGJXVXNJR05oYkd4aVlXTnJMQ0JqYjI1MFpYaDBLU0I3WEc0Z0lDQWdhV1lnS0NGMGFHbHpMbDlsZG1WdWRITXBJSEpsZEhWeWJpQjBhR2x6TzF4dUlDQWdJSFJvYVhNdVgyVjJaVzUwY3lBOUlHVjJaVzUwYzBGd2FTaHZabVpCY0drc0lIUm9hWE11WDJWMlpXNTBjeXdnYm1GdFpTd2dZMkZzYkdKaFkyc3NJSHRjYmlBZ0lDQWdJQ0FnWTI5dWRHVjRkRG9nWTI5dWRHVjRkQ3hjYmlBZ0lDQWdJQ0FnYkdsemRHVnVaWEp6T2lCMGFHbHpMbDlzYVhOMFpXNWxjbk5jYmlBZ0lDQjlLVHRjYmlBZ0lDQnlaWFIxY200Z2RHaHBjenRjYmlBZ2ZUdGNibHh1SUNBdkx5QlVaV3hzSUhSb2FYTWdiMkpxWldOMElIUnZJSE4wYjNBZ2JHbHpkR1Z1YVc1bklIUnZJR1ZwZEdobGNpQnpjR1ZqYVdacFl5QmxkbVZ1ZEhNZ0xpNHVJRzl5WEc0Z0lDOHZJSFJ2SUdWMlpYSjVJRzlpYW1WamRDQnBkQ2R6SUdOMWNuSmxiblJzZVNCc2FYTjBaVzVwYm1jZ2RHOHVYRzRnSUVWMlpXNTBjeTV6ZEc5d1RHbHpkR1Z1YVc1bklEMGdJR1oxYm1OMGFXOXVLRzlpYWl3Z2JtRnRaU3dnWTJGc2JHSmhZMnNwSUh0Y2JpQWdJQ0IyWVhJZ2JHbHpkR1Z1YVc1blZHOGdQU0IwYUdsekxsOXNhWE4wWlc1cGJtZFVienRjYmlBZ0lDQnBaaUFvSVd4cGMzUmxibWx1WjFSdktTQnlaWFIxY200Z2RHaHBjenRjYmx4dUlDQWdJSFpoY2lCcFpITWdQU0J2WW1vZ1B5QmJiMkpxTGw5c2FYTjBaVzVKWkYwZ09pQmZMbXRsZVhNb2JHbHpkR1Z1YVc1blZHOHBPMXh1WEc0Z0lDQWdabTl5SUNoMllYSWdhU0E5SURBN0lHa2dQQ0JwWkhNdWJHVnVaM1JvT3lCcEt5c3BJSHRjYmlBZ0lDQWdJSFpoY2lCc2FYTjBaVzVwYm1jZ1BTQnNhWE4wWlc1cGJtZFViMXRwWkhOYmFWMWRPMXh1WEc0Z0lDQWdJQ0F2THlCSlppQnNhWE4wWlc1cGJtY2daRzlsYzI0bmRDQmxlR2x6ZEN3Z2RHaHBjeUJ2WW1wbFkzUWdhWE1nYm05MElHTjFjbkpsYm5Sc2VWeHVJQ0FnSUNBZ0x5OGdiR2x6ZEdWdWFXNW5JSFJ2SUc5aWFpNGdRbkpsWVdzZ2IzVjBJR1ZoY214NUxseHVJQ0FnSUNBZ2FXWWdLQ0ZzYVhOMFpXNXBibWNwSUdKeVpXRnJPMXh1WEc0Z0lDQWdJQ0JzYVhOMFpXNXBibWN1YjJKcUxtOW1aaWh1WVcxbExDQmpZV3hzWW1GamF5d2dkR2hwY3lrN1hHNGdJQ0FnZlZ4dUlDQWdJR2xtSUNoZkxtbHpSVzF3ZEhrb2JHbHpkR1Z1YVc1blZHOHBLU0IwYUdsekxsOXNhWE4wWlc1cGJtZFVieUE5SUhadmFXUWdNRHRjYmx4dUlDQWdJSEpsZEhWeWJpQjBhR2x6TzF4dUlDQjlPMXh1WEc0Z0lDOHZJRlJvWlNCeVpXUjFZMmx1WnlCQlVFa2dkR2hoZENCeVpXMXZkbVZ6SUdFZ1kyRnNiR0poWTJzZ1puSnZiU0IwYUdVZ1lHVjJaVzUwYzJBZ2IySnFaV04wTGx4dUlDQjJZWElnYjJabVFYQnBJRDBnWm5WdVkzUnBiMjRvWlhabGJuUnpMQ0J1WVcxbExDQmpZV3hzWW1GamF5d2diM0IwYVc5dWN5a2dlMXh1SUNBZ0lDOHZJRTV2SUdWMlpXNTBjeUIwYnlCamIyNXphV1JsY2k1Y2JpQWdJQ0JwWmlBb0lXVjJaVzUwY3lrZ2NtVjBkWEp1TzF4dVhHNGdJQ0FnZG1GeUlHa2dQU0F3TENCc2FYTjBaVzVwYm1jN1hHNGdJQ0FnZG1GeUlHTnZiblJsZUhRZ1BTQnZjSFJwYjI1ekxtTnZiblJsZUhRc0lHeHBjM1JsYm1WeWN5QTlJRzl3ZEdsdmJuTXViR2x6ZEdWdVpYSnpPMXh1WEc0Z0lDQWdMeThnUkdWc1pYUmxJR0ZzYkNCbGRtVnVkSE1nYkdsemRHVnVaWEp6SUdGdVpDQmNJbVJ5YjNCY0lpQmxkbVZ1ZEhNdVhHNGdJQ0FnYVdZZ0tDRnVZVzFsSUNZbUlDRmpZV3hzWW1GamF5QW1KaUFoWTI5dWRHVjRkQ2tnZTF4dUlDQWdJQ0FnZG1GeUlHbGtjeUE5SUY4dWEyVjVjeWhzYVhOMFpXNWxjbk1wTzF4dUlDQWdJQ0FnWm05eUlDZzdJR2tnUENCcFpITXViR1Z1WjNSb095QnBLeXNwSUh0Y2JpQWdJQ0FnSUNBZ2JHbHpkR1Z1YVc1bklEMGdiR2x6ZEdWdVpYSnpXMmxrYzF0cFhWMDdYRzRnSUNBZ0lDQWdJR1JsYkdWMFpTQnNhWE4wWlc1bGNuTmJiR2x6ZEdWdWFXNW5MbWxrWFR0Y2JpQWdJQ0FnSUNBZ1pHVnNaWFJsSUd4cGMzUmxibWx1Wnk1c2FYTjBaVzVwYm1kVWIxdHNhWE4wWlc1cGJtY3ViMkpxU1dSZE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2NtVjBkWEp1TzF4dUlDQWdJSDFjYmx4dUlDQWdJSFpoY2lCdVlXMWxjeUE5SUc1aGJXVWdQeUJiYm1GdFpWMGdPaUJmTG10bGVYTW9aWFpsYm5SektUdGNiaUFnSUNCbWIzSWdLRHNnYVNBOElHNWhiV1Z6TG14bGJtZDBhRHNnYVNzcktTQjdYRzRnSUNBZ0lDQnVZVzFsSUQwZ2JtRnRaWE5iYVYwN1hHNGdJQ0FnSUNCMllYSWdhR0Z1Wkd4bGNuTWdQU0JsZG1WdWRITmJibUZ0WlYwN1hHNWNiaUFnSUNBZ0lDOHZJRUpoYVd3Z2IzVjBJR2xtSUhSb1pYSmxJR0Z5WlNCdWJ5QmxkbVZ1ZEhNZ2MzUnZjbVZrTGx4dUlDQWdJQ0FnYVdZZ0tDRm9ZVzVrYkdWeWN5a2dZbkpsWVdzN1hHNWNiaUFnSUNBZ0lDOHZJRkpsY0d4aFkyVWdaWFpsYm5SeklHbG1JSFJvWlhKbElHRnlaU0JoYm5rZ2NtVnRZV2x1YVc1bkxpQWdUM1JvWlhKM2FYTmxMQ0JqYkdWaGJpQjFjQzVjYmlBZ0lDQWdJSFpoY2lCeVpXMWhhVzVwYm1jZ1BTQmJYVHRjYmlBZ0lDQWdJR1p2Y2lBb2RtRnlJR29nUFNBd095QnFJRHdnYUdGdVpHeGxjbk11YkdWdVozUm9PeUJxS3lzcElIdGNiaUFnSUNBZ0lDQWdkbUZ5SUdoaGJtUnNaWElnUFNCb1lXNWtiR1Z5YzF0cVhUdGNiaUFnSUNBZ0lDQWdhV1lnS0Z4dUlDQWdJQ0FnSUNBZ0lHTmhiR3hpWVdOcklDWW1JR05oYkd4aVlXTnJJQ0U5UFNCb1lXNWtiR1Z5TG1OaGJHeGlZV05ySUNZbVhHNGdJQ0FnSUNBZ0lDQWdJQ0JqWVd4c1ltRmpheUFoUFQwZ2FHRnVaR3hsY2k1allXeHNZbUZqYXk1ZlkyRnNiR0poWTJzZ2ZIeGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ1kyOXVkR1Y0ZENBbUppQmpiMjUwWlhoMElDRTlQU0JvWVc1a2JHVnlMbU52Ym5SbGVIUmNiaUFnSUNBZ0lDQWdLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2NtVnRZV2x1YVc1bkxuQjFjMmdvYUdGdVpHeGxjaWs3WEc0Z0lDQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUNBZ2JHbHpkR1Z1YVc1bklEMGdhR0Z1Wkd4bGNpNXNhWE4wWlc1cGJtYzdYRzRnSUNBZ0lDQWdJQ0FnYVdZZ0tHeHBjM1JsYm1sdVp5QW1KaUF0TFd4cGMzUmxibWx1Wnk1amIzVnVkQ0E5UFQwZ01Da2dlMXh1SUNBZ0lDQWdJQ0FnSUNBZ1pHVnNaWFJsSUd4cGMzUmxibVZ5YzF0c2FYTjBaVzVwYm1jdWFXUmRPMXh1SUNBZ0lDQWdJQ0FnSUNBZ1pHVnNaWFJsSUd4cGMzUmxibWx1Wnk1c2FYTjBaVzVwYm1kVWIxdHNhWE4wWlc1cGJtY3ViMkpxU1dSZE8xeHVJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNBdkx5QlZjR1JoZEdVZ2RHRnBiQ0JsZG1WdWRDQnBaaUIwYUdVZ2JHbHpkQ0JvWVhNZ1lXNTVJR1YyWlc1MGN5NGdJRTkwYUdWeWQybHpaU3dnWTJ4bFlXNGdkWEF1WEc0Z0lDQWdJQ0JwWmlBb2NtVnRZV2x1YVc1bkxteGxibWQwYUNrZ2UxeHVJQ0FnSUNBZ0lDQmxkbVZ1ZEhOYmJtRnRaVjBnUFNCeVpXMWhhVzVwYm1jN1hHNGdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNCa1pXeGxkR1VnWlhabGJuUnpXMjVoYldWZE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUgxY2JpQWdJQ0JwWmlBb1h5NXphWHBsS0dWMlpXNTBjeWtwSUhKbGRIVnliaUJsZG1WdWRITTdYRzRnSUgwN1hHNWNiaUFnTHk4Z1FtbHVaQ0JoYmlCbGRtVnVkQ0IwYnlCdmJteDVJR0psSUhSeWFXZG5aWEpsWkNCaElITnBibWRzWlNCMGFXMWxMaUJCWm5SbGNpQjBhR1VnWm1seWMzUWdkR2x0WlZ4dUlDQXZMeUIwYUdVZ1kyRnNiR0poWTJzZ2FYTWdhVzUyYjJ0bFpDd2dhWFFnZDJsc2JDQmlaU0J5WlcxdmRtVmtMaUJYYUdWdUlHMTFiSFJwY0d4bElHVjJaVzUwY3lCaGNtVmNiaUFnTHk4Z2NHRnpjMlZrSUdsdUlIVnphVzVuSUhSb1pTQnpjR0ZqWlMxelpYQmhjbUYwWldRZ2MzbHVkR0Y0TENCMGFHVWdaWFpsYm5RZ2QybHNiQ0JtYVhKbElHOXVZMlVnWm05eUlHVjJaWEo1WEc0Z0lDOHZJR1YyWlc1MElIbHZkU0J3WVhOelpXUWdhVzRzSUc1dmRDQnZibU5sSUdadmNpQmhJR052YldKcGJtRjBhVzl1SUc5bUlHRnNiQ0JsZG1WdWRITmNiaUFnUlhabGJuUnpMbTl1WTJVZ1BTQWdablZ1WTNScGIyNG9ibUZ0WlN3Z1kyRnNiR0poWTJzc0lHTnZiblJsZUhRcElIdGNiaUFnSUNBdkx5Qk5ZWEFnZEdobElHVjJaVzUwSUdsdWRHOGdZU0JnZTJWMlpXNTBPaUJ2Ym1ObGZXQWdiMkpxWldOMExseHVJQ0FnSUhaaGNpQmxkbVZ1ZEhNZ1BTQmxkbVZ1ZEhOQmNHa29iMjVqWlUxaGNDd2dlMzBzSUc1aGJXVXNJR05oYkd4aVlXTnJMQ0JmTG1KcGJtUW9kR2hwY3k1dlptWXNJSFJvYVhNcEtUdGNiaUFnSUNCeVpYUjFjbTRnZEdocGN5NXZiaWhsZG1WdWRITXNJSFp2YVdRZ01Dd2dZMjl1ZEdWNGRDazdYRzRnSUgwN1hHNWNiaUFnTHk4Z1NXNTJaWEp6YVc5dUxXOW1MV052Ym5SeWIyd2dkbVZ5YzJsdmJuTWdiMllnWUc5dVkyVmdMbHh1SUNCRmRtVnVkSE11YkdsemRHVnVWRzlQYm1ObElEMGdJR1oxYm1OMGFXOXVLRzlpYWl3Z2JtRnRaU3dnWTJGc2JHSmhZMnNwSUh0Y2JpQWdJQ0F2THlCTllYQWdkR2hsSUdWMlpXNTBJR2x1ZEc4Z1lTQmdlMlYyWlc1ME9pQnZibU5sZldBZ2IySnFaV04wTGx4dUlDQWdJSFpoY2lCbGRtVnVkSE1nUFNCbGRtVnVkSE5CY0drb2IyNWpaVTFoY0N3Z2UzMHNJRzVoYldVc0lHTmhiR3hpWVdOckxDQmZMbUpwYm1Rb2RHaHBjeTV6ZEc5d1RHbHpkR1Z1YVc1bkxDQjBhR2x6TENCdlltb3BLVHRjYmlBZ0lDQnlaWFIxY200Z2RHaHBjeTVzYVhOMFpXNVVieWh2WW1vc0lHVjJaVzUwY3lrN1hHNGdJSDA3WEc1Y2JpQWdMeThnVW1Wa2RXTmxjeUIwYUdVZ1pYWmxiblFnWTJGc2JHSmhZMnR6SUdsdWRHOGdZU0J0WVhBZ2IyWWdZSHRsZG1WdWREb2diMjVqWlZkeVlYQndaWEo5WUM1Y2JpQWdMeThnWUc5bVptVnlZQ0IxYm1KcGJtUnpJSFJvWlNCZ2IyNWpaVmR5WVhCd1pYSmdJR0ZtZEdWeUlHbDBJR2hoY3lCaVpXVnVJR05oYkd4bFpDNWNiaUFnZG1GeUlHOXVZMlZOWVhBZ1BTQm1kVzVqZEdsdmJpaHRZWEFzSUc1aGJXVXNJR05oYkd4aVlXTnJMQ0J2Wm1abGNpa2dlMXh1SUNBZ0lHbG1JQ2hqWVd4c1ltRmpheWtnZTF4dUlDQWdJQ0FnZG1GeUlHOXVZMlVnUFNCdFlYQmJibUZ0WlYwZ1BTQmZMbTl1WTJVb1puVnVZM1JwYjI0b0tTQjdYRzRnSUNBZ0lDQWdJRzltWm1WeUtHNWhiV1VzSUc5dVkyVXBPMXh1SUNBZ0lDQWdJQ0JqWVd4c1ltRmpheTVoY0hCc2VTaDBhR2x6TENCaGNtZDFiV1Z1ZEhNcE8xeHVJQ0FnSUNBZ2ZTazdYRzRnSUNBZ0lDQnZibU5sTGw5allXeHNZbUZqYXlBOUlHTmhiR3hpWVdOck8xeHVJQ0FnSUgxY2JpQWdJQ0J5WlhSMWNtNGdiV0Z3TzF4dUlDQjlPMXh1WEc0Z0lDOHZJRlJ5YVdkblpYSWdiMjVsSUc5eUlHMWhibmtnWlhabGJuUnpMQ0JtYVhKcGJtY2dZV3hzSUdKdmRXNWtJR05oYkd4aVlXTnJjeTRnUTJGc2JHSmhZMnR6SUdGeVpWeHVJQ0F2THlCd1lYTnpaV1FnZEdobElITmhiV1VnWVhKbmRXMWxiblJ6SUdGeklHQjBjbWxuWjJWeVlDQnBjeXdnWVhCaGNuUWdabkp2YlNCMGFHVWdaWFpsYm5RZ2JtRnRaVnh1SUNBdkx5QW9kVzVzWlhOeklIbHZkU2R5WlNCc2FYTjBaVzVwYm1jZ2IyNGdZRndpWVd4c1hDSmdMQ0IzYUdsamFDQjNhV3hzSUdOaGRYTmxJSGx2ZFhJZ1kyRnNiR0poWTJzZ2RHOWNiaUFnTHk4Z2NtVmpaV2wyWlNCMGFHVWdkSEoxWlNCdVlXMWxJRzltSUhSb1pTQmxkbVZ1ZENCaGN5QjBhR1VnWm1seWMzUWdZWEpuZFcxbGJuUXBMbHh1SUNCRmRtVnVkSE11ZEhKcFoyZGxjaUE5SUNCbWRXNWpkR2x2YmlodVlXMWxLU0I3WEc0Z0lDQWdhV1lnS0NGMGFHbHpMbDlsZG1WdWRITXBJSEpsZEhWeWJpQjBhR2x6TzF4dVhHNGdJQ0FnZG1GeUlHeGxibWQwYUNBOUlFMWhkR2d1YldGNEtEQXNJR0Z5WjNWdFpXNTBjeTVzWlc1bmRHZ2dMU0F4S1R0Y2JpQWdJQ0IyWVhJZ1lYSm5jeUE5SUVGeWNtRjVLR3hsYm1kMGFDazdYRzRnSUNBZ1ptOXlJQ2gyWVhJZ2FTQTlJREE3SUdrZ1BDQnNaVzVuZEdnN0lHa3JLeWtnWVhKbmMxdHBYU0E5SUdGeVozVnRaVzUwYzF0cElDc2dNVjA3WEc1Y2JpQWdJQ0JsZG1WdWRITkJjR2tvZEhKcFoyZGxja0Z3YVN3Z2RHaHBjeTVmWlhabGJuUnpMQ0J1WVcxbExDQjJiMmxrSURBc0lHRnlaM01wTzF4dUlDQWdJSEpsZEhWeWJpQjBhR2x6TzF4dUlDQjlPMXh1WEc0Z0lDOHZJRWhoYm1Sc1pYTWdkSEpwWjJkbGNtbHVaeUIwYUdVZ1lYQndjbTl3Y21saGRHVWdaWFpsYm5RZ1kyRnNiR0poWTJ0ekxseHVJQ0IyWVhJZ2RISnBaMmRsY2tGd2FTQTlJR1oxYm1OMGFXOXVLRzlpYWtWMlpXNTBjeXdnYm1GdFpTd2dZMklzSUdGeVozTXBJSHRjYmlBZ0lDQnBaaUFvYjJKcVJYWmxiblJ6S1NCN1hHNGdJQ0FnSUNCMllYSWdaWFpsYm5SeklEMGdiMkpxUlhabGJuUnpXMjVoYldWZE8xeHVJQ0FnSUNBZ2RtRnlJR0ZzYkVWMlpXNTBjeUE5SUc5aWFrVjJaVzUwY3k1aGJHdzdYRzRnSUNBZ0lDQnBaaUFvWlhabGJuUnpJQ1ltSUdGc2JFVjJaVzUwY3lrZ1lXeHNSWFpsYm5SeklEMGdZV3hzUlhabGJuUnpMbk5zYVdObEtDazdYRzRnSUNBZ0lDQnBaaUFvWlhabGJuUnpLU0IwY21sbloyVnlSWFpsYm5SektHVjJaVzUwY3l3Z1lYSm5jeWs3WEc0Z0lDQWdJQ0JwWmlBb1lXeHNSWFpsYm5SektTQjBjbWxuWjJWeVJYWmxiblJ6S0dGc2JFVjJaVzUwY3l3Z1cyNWhiV1ZkTG1OdmJtTmhkQ2hoY21kektTazdYRzRnSUNBZ2ZWeHVJQ0FnSUhKbGRIVnliaUJ2WW1wRmRtVnVkSE03WEc0Z0lIMDdYRzVjYmlBZ0x5OGdRU0JrYVdabWFXTjFiSFF0ZEc4dFltVnNhV1YyWlN3Z1luVjBJRzl3ZEdsdGFYcGxaQ0JwYm5SbGNtNWhiQ0JrYVhOd1lYUmphQ0JtZFc1amRHbHZiaUJtYjNKY2JpQWdMeThnZEhKcFoyZGxjbWx1WnlCbGRtVnVkSE11SUZSeWFXVnpJSFJ2SUd0bFpYQWdkR2hsSUhWemRXRnNJR05oYzJWeklITndaV1ZrZVNBb2JXOXpkQ0JwYm5SbGNtNWhiRnh1SUNBdkx5QkNZV05yWW05dVpTQmxkbVZ1ZEhNZ2FHRjJaU0F6SUdGeVozVnRaVzUwY3lrdVhHNGdJSFpoY2lCMGNtbG5aMlZ5UlhabGJuUnpJRDBnWm5WdVkzUnBiMjRvWlhabGJuUnpMQ0JoY21kektTQjdYRzRnSUNBZ2RtRnlJR1YyTENCcElEMGdMVEVzSUd3Z1BTQmxkbVZ1ZEhNdWJHVnVaM1JvTENCaE1TQTlJR0Z5WjNOYk1GMHNJR0V5SUQwZ1lYSm5jMXN4WFN3Z1lUTWdQU0JoY21keld6SmRPMXh1SUNBZ0lITjNhWFJqYUNBb1lYSm5jeTVzWlc1bmRHZ3BJSHRjYmlBZ0lDQWdJR05oYzJVZ01Eb2dkMmhwYkdVZ0tDc3JhU0E4SUd3cElDaGxkaUE5SUdWMlpXNTBjMXRwWFNrdVkyRnNiR0poWTJzdVkyRnNiQ2hsZGk1amRIZ3BPeUJ5WlhSMWNtNDdYRzRnSUNBZ0lDQmpZWE5sSURFNklIZG9hV3hsSUNncksya2dQQ0JzS1NBb1pYWWdQU0JsZG1WdWRITmJhVjBwTG1OaGJHeGlZV05yTG1OaGJHd29aWFl1WTNSNExDQmhNU2s3SUhKbGRIVnlianRjYmlBZ0lDQWdJR05oYzJVZ01qb2dkMmhwYkdVZ0tDc3JhU0E4SUd3cElDaGxkaUE5SUdWMlpXNTBjMXRwWFNrdVkyRnNiR0poWTJzdVkyRnNiQ2hsZGk1amRIZ3NJR0V4TENCaE1pazdJSEpsZEhWeWJqdGNiaUFnSUNBZ0lHTmhjMlVnTXpvZ2QyaHBiR1VnS0NzcmFTQThJR3dwSUNobGRpQTlJR1YyWlc1MGMxdHBYU2t1WTJGc2JHSmhZMnN1WTJGc2JDaGxkaTVqZEhnc0lHRXhMQ0JoTWl3Z1lUTXBPeUJ5WlhSMWNtNDdYRzRnSUNBZ0lDQmtaV1poZFd4ME9pQjNhR2xzWlNBb0t5dHBJRHdnYkNrZ0tHVjJJRDBnWlhabGJuUnpXMmxkS1M1allXeHNZbUZqYXk1aGNIQnNlU2hsZGk1amRIZ3NJR0Z5WjNNcE95QnlaWFIxY200N1hHNGdJQ0FnZlZ4dUlDQjlPMXh1WEc0Z0lDOHZJRUZzYVdGelpYTWdabTl5SUdKaFkydDNZWEprY3lCamIyMXdZWFJwWW1sc2FYUjVMbHh1SUNCRmRtVnVkSE11WW1sdVpDQWdJRDBnUlhabGJuUnpMbTl1TzF4dUlDQkZkbVZ1ZEhNdWRXNWlhVzVrSUQwZ1JYWmxiblJ6TG05bVpqdGNibHh1SUNBdkx5QkJiR3h2ZHlCMGFHVWdZRUpoWTJ0aWIyNWxZQ0J2WW1wbFkzUWdkRzhnYzJWeWRtVWdZWE1nWVNCbmJHOWlZV3dnWlhabGJuUWdZblZ6TENCbWIzSWdabTlzYTNNZ2QyaHZYRzRnSUM4dklIZGhiblFnWjJ4dlltRnNJRndpY0hWaWMzVmlYQ0lnYVc0Z1lTQmpiMjUyWlc1cFpXNTBJSEJzWVdObExseHVJQ0JmTG1WNGRHVnVaQ2hDWVdOclltOXVaU3dnUlhabGJuUnpLVHRjYmx4dUlDQXZMeUJDWVdOclltOXVaUzVOYjJSbGJGeHVJQ0F2THlBdExTMHRMUzB0TFMwdExTMHRMVnh1WEc0Z0lDOHZJRUpoWTJ0aWIyNWxJQ29xVFc5a1pXeHpLaW9nWVhKbElIUm9aU0JpWVhOcFl5QmtZWFJoSUc5aWFtVmpkQ0JwYmlCMGFHVWdabkpoYldWM2IzSnJJQzB0WEc0Z0lDOHZJR1p5WlhGMVpXNTBiSGtnY21Wd2NtVnpaVzUwYVc1bklHRWdjbTkzSUdsdUlHRWdkR0ZpYkdVZ2FXNGdZU0JrWVhSaFltRnpaU0J2YmlCNWIzVnlJSE5sY25abGNpNWNiaUFnTHk4Z1FTQmthWE5qY21WMFpTQmphSFZ1YXlCdlppQmtZWFJoSUdGdVpDQmhJR0oxYm1Ob0lHOW1JSFZ6WldaMWJDd2djbVZzWVhSbFpDQnRaWFJvYjJSeklHWnZjbHh1SUNBdkx5QndaWEptYjNKdGFXNW5JR052YlhCMWRHRjBhVzl1Y3lCaGJtUWdkSEpoYm5ObWIzSnRZWFJwYjI1eklHOXVJSFJvWVhRZ1pHRjBZUzVjYmx4dUlDQXZMeUJEY21WaGRHVWdZU0J1WlhjZ2JXOWtaV3dnZDJsMGFDQjBhR1VnYzNCbFkybG1hV1ZrSUdGMGRISnBZblYwWlhNdUlFRWdZMnhwWlc1MElHbGtJQ2hnWTJsa1lDbGNiaUFnTHk4Z2FYTWdZWFYwYjIxaGRHbGpZV3hzZVNCblpXNWxjbUYwWldRZ1lXNWtJR0Z6YzJsbmJtVmtJR1p2Y2lCNWIzVXVYRzRnSUhaaGNpQk5iMlJsYkNBOUlFSmhZMnRpYjI1bExrMXZaR1ZzSUQwZ1puVnVZM1JwYjI0b1lYUjBjbWxpZFhSbGN5d2diM0IwYVc5dWN5a2dlMXh1SUNBZ0lIWmhjaUJoZEhSeWN5QTlJR0YwZEhKcFluVjBaWE1nZkh3Z2UzMDdYRzRnSUNBZ2IzQjBhVzl1Y3lCOGZDQW9iM0IwYVc5dWN5QTlJSHQ5S1R0Y2JpQWdJQ0IwYUdsekxtTnBaQ0E5SUY4dWRXNXBjWFZsU1dRb2RHaHBjeTVqYVdSUWNtVm1hWGdwTzF4dUlDQWdJSFJvYVhNdVlYUjBjbWxpZFhSbGN5QTlJSHQ5TzF4dUlDQWdJR2xtSUNodmNIUnBiMjV6TG1OdmJHeGxZM1JwYjI0cElIUm9hWE11WTI5c2JHVmpkR2x2YmlBOUlHOXdkR2x2Ym5NdVkyOXNiR1ZqZEdsdmJqdGNiaUFnSUNCcFppQW9iM0IwYVc5dWN5NXdZWEp6WlNrZ1lYUjBjbk1nUFNCMGFHbHpMbkJoY25ObEtHRjBkSEp6TENCdmNIUnBiMjV6S1NCOGZDQjdmVHRjYmlBZ0lDQmhkSFJ5Y3lBOUlGOHVaR1ZtWVhWc2RITW9lMzBzSUdGMGRISnpMQ0JmTG5KbGMzVnNkQ2gwYUdsekxDQW5aR1ZtWVhWc2RITW5LU2s3WEc0Z0lDQWdkR2hwY3k1elpYUW9ZWFIwY25Nc0lHOXdkR2x2Ym5NcE8xeHVJQ0FnSUhSb2FYTXVZMmhoYm1kbFpDQTlJSHQ5TzF4dUlDQWdJSFJvYVhNdWFXNXBkR2xoYkdsNlpTNWhjSEJzZVNoMGFHbHpMQ0JoY21kMWJXVnVkSE1wTzF4dUlDQjlPMXh1WEc0Z0lDOHZJRUYwZEdGamFDQmhiR3dnYVc1b1pYSnBkR0ZpYkdVZ2JXVjBhRzlrY3lCMGJ5QjBhR1VnVFc5a1pXd2djSEp2ZEc5MGVYQmxMbHh1SUNCZkxtVjRkR1Z1WkNoTmIyUmxiQzV3Y205MGIzUjVjR1VzSUVWMlpXNTBjeXdnZTF4dVhHNGdJQ0FnTHk4Z1FTQm9ZWE5vSUc5bUlHRjBkSEpwWW5WMFpYTWdkMmh2YzJVZ1kzVnljbVZ1ZENCaGJtUWdjSEpsZG1sdmRYTWdkbUZzZFdVZ1pHbG1abVZ5TGx4dUlDQWdJR05vWVc1blpXUTZJRzUxYkd3c1hHNWNiaUFnSUNBdkx5QlVhR1VnZG1Gc2RXVWdjbVYwZFhKdVpXUWdaSFZ5YVc1bklIUm9aU0JzWVhOMElHWmhhV3hsWkNCMllXeHBaR0YwYVc5dUxseHVJQ0FnSUhaaGJHbGtZWFJwYjI1RmNuSnZjam9nYm5Wc2JDeGNibHh1SUNBZ0lDOHZJRlJvWlNCa1pXWmhkV3gwSUc1aGJXVWdabTl5SUhSb1pTQktVMDlPSUdCcFpHQWdZWFIwY21saWRYUmxJR2x6SUdCY0ltbGtYQ0pnTGlCTmIyNW5iMFJDSUdGdVpGeHVJQ0FnSUM4dklFTnZkV05vUkVJZ2RYTmxjbk1nYldGNUlIZGhiblFnZEc4Z2MyVjBJSFJvYVhNZ2RHOGdZRndpWDJsa1hDSmdMbHh1SUNBZ0lHbGtRWFIwY21saWRYUmxPaUFuYVdRbkxGeHVYRzRnSUNBZ0x5OGdWR2hsSUhCeVpXWnBlQ0JwY3lCMWMyVmtJSFJ2SUdOeVpXRjBaU0IwYUdVZ1kyeHBaVzUwSUdsa0lIZG9hV05vSUdseklIVnpaV1FnZEc4Z2FXUmxiblJwWm5rZ2JXOWtaV3h6SUd4dlkyRnNiSGt1WEc0Z0lDQWdMeThnV1c5MUlHMWhlU0IzWVc1MElIUnZJRzkyWlhKeWFXUmxJSFJvYVhNZ2FXWWdlVzkxSjNKbElHVjRjR1Z5YVdWdVkybHVaeUJ1WVcxbElHTnNZWE5vWlhNZ2QybDBhQ0J0YjJSbGJDQnBaSE11WEc0Z0lDQWdZMmxrVUhKbFptbDRPaUFuWXljc1hHNWNiaUFnSUNBdkx5QkpibWwwYVdGc2FYcGxJR2x6SUdGdUlHVnRjSFI1SUdaMWJtTjBhVzl1SUdKNUlHUmxabUYxYkhRdUlFOTJaWEp5YVdSbElHbDBJSGRwZEdnZ2VXOTFjaUJ2ZDI1Y2JpQWdJQ0F2THlCcGJtbDBhV0ZzYVhwaGRHbHZiaUJzYjJkcFl5NWNiaUFnSUNCcGJtbDBhV0ZzYVhwbE9pQm1kVzVqZEdsdmJpZ3BlMzBzWEc1Y2JpQWdJQ0F2THlCU1pYUjFjbTRnWVNCamIzQjVJRzltSUhSb1pTQnRiMlJsYkNkeklHQmhkSFJ5YVdKMWRHVnpZQ0J2WW1wbFkzUXVYRzRnSUNBZ2RHOUtVMDlPT2lCbWRXNWpkR2x2YmlodmNIUnBiMjV6S1NCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnWHk1amJHOXVaU2gwYUdsekxtRjBkSEpwWW5WMFpYTXBPMXh1SUNBZ0lIMHNYRzVjYmlBZ0lDQXZMeUJRY205NGVTQmdRbUZqYTJKdmJtVXVjM2x1WTJBZ1lua2daR1ZtWVhWc2RDQXRMU0JpZFhRZ2IzWmxjbkpwWkdVZ2RHaHBjeUJwWmlCNWIzVWdibVZsWkZ4dUlDQWdJQzh2SUdOMWMzUnZiU0J6ZVc1amFXNW5JSE5sYldGdWRHbGpjeUJtYjNJZ0tuUm9hWE1xSUhCaGNuUnBZM1ZzWVhJZ2JXOWtaV3d1WEc0Z0lDQWdjM2x1WXpvZ1puVnVZM1JwYjI0b0tTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z1FtRmphMkp2Ym1VdWMzbHVZeTVoY0hCc2VTaDBhR2x6TENCaGNtZDFiV1Z1ZEhNcE8xeHVJQ0FnSUgwc1hHNWNiaUFnSUNBdkx5QkhaWFFnZEdobElIWmhiSFZsSUc5bUlHRnVJR0YwZEhKcFluVjBaUzVjYmlBZ0lDQm5aWFE2SUdaMWJtTjBhVzl1S0dGMGRISXBJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQjBhR2x6TG1GMGRISnBZblYwWlhOYllYUjBjbDA3WEc0Z0lDQWdmU3hjYmx4dUlDQWdJQzh2SUVkbGRDQjBhR1VnU0ZSTlRDMWxjMk5oY0dWa0lIWmhiSFZsSUc5bUlHRnVJR0YwZEhKcFluVjBaUzVjYmlBZ0lDQmxjMk5oY0dVNklHWjFibU4wYVc5dUtHRjBkSElwSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUJmTG1WelkyRndaU2gwYUdsekxtZGxkQ2hoZEhSeUtTazdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lDOHZJRkpsZEhWeWJuTWdZSFJ5ZFdWZ0lHbG1JSFJvWlNCaGRIUnlhV0oxZEdVZ1kyOXVkR0ZwYm5NZ1lTQjJZV3gxWlNCMGFHRjBJR2x6SUc1dmRDQnVkV3hzWEc0Z0lDQWdMeThnYjNJZ2RXNWtaV1pwYm1Wa0xseHVJQ0FnSUdoaGN6b2dablZ1WTNScGIyNG9ZWFIwY2lrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTXVaMlYwS0dGMGRISXBJQ0U5SUc1MWJHdzdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lDOHZJRk53WldOcFlXd3RZMkZ6WldRZ2NISnZlSGtnZEc4Z2RXNWtaWEp6WTI5eVpTZHpJR0JmTG0xaGRHTm9aWE5nSUcxbGRHaHZaQzVjYmlBZ0lDQnRZWFJqYUdWek9pQm1kVzVqZEdsdmJpaGhkSFJ5Y3lrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUNFaFh5NXBkR1Z5WVhSbFpTaGhkSFJ5Y3l3Z2RHaHBjeWtvZEdocGN5NWhkSFJ5YVdKMWRHVnpLVHRjYmlBZ0lDQjlMRnh1WEc0Z0lDQWdMeThnVTJWMElHRWdhR0Z6YUNCdlppQnRiMlJsYkNCaGRIUnlhV0oxZEdWeklHOXVJSFJvWlNCdlltcGxZM1FzSUdacGNtbHVaeUJnWENKamFHRnVaMlZjSW1BdUlGUm9hWE1nYVhOY2JpQWdJQ0F2THlCMGFHVWdZMjl5WlNCd2NtbHRhWFJwZG1VZ2IzQmxjbUYwYVc5dUlHOW1JR0VnYlc5a1pXd3NJSFZ3WkdGMGFXNW5JSFJvWlNCa1lYUmhJR0Z1WkNCdWIzUnBabmxwYm1kY2JpQWdJQ0F2THlCaGJubHZibVVnZDJodklHNWxaV1J6SUhSdklHdHViM2NnWVdKdmRYUWdkR2hsSUdOb1lXNW5aU0JwYmlCemRHRjBaUzRnVkdobElHaGxZWEowSUc5bUlIUm9aU0JpWldGemRDNWNiaUFnSUNCelpYUTZJR1oxYm1OMGFXOXVLR3RsZVN3Z2RtRnNMQ0J2Y0hScGIyNXpLU0I3WEc0Z0lDQWdJQ0JwWmlBb2EyVjVJRDA5SUc1MWJHd3BJSEpsZEhWeWJpQjBhR2x6TzF4dVhHNGdJQ0FnSUNBdkx5QklZVzVrYkdVZ1ltOTBhQ0JnWENKclpYbGNJaXdnZG1Gc2RXVmdJR0Z1WkNCZ2UydGxlVG9nZG1Gc2RXVjlZQ0F0YzNSNWJHVWdZWEpuZFcxbGJuUnpMbHh1SUNBZ0lDQWdkbUZ5SUdGMGRISnpPMXh1SUNBZ0lDQWdhV1lnS0hSNWNHVnZaaUJyWlhrZ1BUMDlJQ2R2WW1wbFkzUW5LU0I3WEc0Z0lDQWdJQ0FnSUdGMGRISnpJRDBnYTJWNU8xeHVJQ0FnSUNBZ0lDQnZjSFJwYjI1eklEMGdkbUZzTzF4dUlDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnS0dGMGRISnpJRDBnZTMwcFcydGxlVjBnUFNCMllXdzdYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJRzl3ZEdsdmJuTWdmSHdnS0c5d2RHbHZibk1nUFNCN2ZTazdYRzVjYmlBZ0lDQWdJQzh2SUZKMWJpQjJZV3hwWkdGMGFXOXVMbHh1SUNBZ0lDQWdhV1lnS0NGMGFHbHpMbDkyWVd4cFpHRjBaU2hoZEhSeWN5d2diM0IwYVc5dWN5a3BJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JseHVJQ0FnSUNBZ0x5OGdSWGgwY21GamRDQmhkSFJ5YVdKMWRHVnpJR0Z1WkNCdmNIUnBiMjV6TGx4dUlDQWdJQ0FnZG1GeUlIVnVjMlYwSUNBZ0lDQWdQU0J2Y0hScGIyNXpMblZ1YzJWME8xeHVJQ0FnSUNBZ2RtRnlJSE5wYkdWdWRDQWdJQ0FnUFNCdmNIUnBiMjV6TG5OcGJHVnVkRHRjYmlBZ0lDQWdJSFpoY2lCamFHRnVaMlZ6SUNBZ0lEMGdXMTA3WEc0Z0lDQWdJQ0IyWVhJZ1kyaGhibWRwYm1jZ0lDQTlJSFJvYVhNdVgyTm9ZVzVuYVc1bk8xeHVJQ0FnSUNBZ2RHaHBjeTVmWTJoaGJtZHBibWNnUFNCMGNuVmxPMXh1WEc0Z0lDQWdJQ0JwWmlBb0lXTm9ZVzVuYVc1bktTQjdYRzRnSUNBZ0lDQWdJSFJvYVhNdVgzQnlaWFpwYjNWelFYUjBjbWxpZFhSbGN5QTlJRjh1WTJ4dmJtVW9kR2hwY3k1aGRIUnlhV0oxZEdWektUdGNiaUFnSUNBZ0lDQWdkR2hwY3k1amFHRnVaMlZrSUQwZ2UzMDdYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJSFpoY2lCamRYSnlaVzUwSUQwZ2RHaHBjeTVoZEhSeWFXSjFkR1Z6TzF4dUlDQWdJQ0FnZG1GeUlHTm9ZVzVuWldRZ1BTQjBhR2x6TG1Ob1lXNW5aV1E3WEc0Z0lDQWdJQ0IyWVhJZ2NISmxkaUFnSUNBOUlIUm9hWE11WDNCeVpYWnBiM1Z6UVhSMGNtbGlkWFJsY3p0Y2JseHVJQ0FnSUNBZ0x5OGdRMmhsWTJzZ1ptOXlJR05vWVc1blpYTWdiMllnWUdsa1lDNWNiaUFnSUNBZ0lHbG1JQ2gwYUdsekxtbGtRWFIwY21saWRYUmxJR2x1SUdGMGRISnpLU0IwYUdsekxtbGtJRDBnWVhSMGNuTmJkR2hwY3k1cFpFRjBkSEpwWW5WMFpWMDdYRzVjYmlBZ0lDQWdJQzh2SUVadmNpQmxZV05vSUdCelpYUmdJR0YwZEhKcFluVjBaU3dnZFhCa1lYUmxJRzl5SUdSbGJHVjBaU0IwYUdVZ1kzVnljbVZ1ZENCMllXeDFaUzVjYmlBZ0lDQWdJR1p2Y2lBb2RtRnlJR0YwZEhJZ2FXNGdZWFIwY25NcElIdGNiaUFnSUNBZ0lDQWdkbUZzSUQwZ1lYUjBjbk5iWVhSMGNsMDdYRzRnSUNBZ0lDQWdJR2xtSUNnaFh5NXBjMFZ4ZFdGc0tHTjFjbkpsYm5SYllYUjBjbDBzSUhaaGJDa3BJR05vWVc1blpYTXVjSFZ6YUNoaGRIUnlLVHRjYmlBZ0lDQWdJQ0FnYVdZZ0tDRmZMbWx6UlhGMVlXd29jSEpsZGx0aGRIUnlYU3dnZG1Gc0tTa2dlMXh1SUNBZ0lDQWdJQ0FnSUdOb1lXNW5aV1JiWVhSMGNsMGdQU0IyWVd3N1hHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDQWdaR1ZzWlhSbElHTm9ZVzVuWldSYllYUjBjbDA3WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUNBZ2RXNXpaWFFnUHlCa1pXeGxkR1VnWTNWeWNtVnVkRnRoZEhSeVhTQTZJR04xY25KbGJuUmJZWFIwY2wwZ1BTQjJZV3c3WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUM4dklGUnlhV2RuWlhJZ1lXeHNJSEpsYkdWMllXNTBJR0YwZEhKcFluVjBaU0JqYUdGdVoyVnpMbHh1SUNBZ0lDQWdhV1lnS0NGemFXeGxiblFwSUh0Y2JpQWdJQ0FnSUNBZ2FXWWdLR05vWVc1blpYTXViR1Z1WjNSb0tTQjBhR2x6TGw5d1pXNWthVzVuSUQwZ2IzQjBhVzl1Y3p0Y2JpQWdJQ0FnSUNBZ1ptOXlJQ2gyWVhJZ2FTQTlJREE3SUdrZ1BDQmphR0Z1WjJWekxteGxibWQwYURzZ2FTc3JLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2RHaHBjeTUwY21sbloyVnlLQ2RqYUdGdVoyVTZKeUFySUdOb1lXNW5aWE5iYVYwc0lIUm9hWE1zSUdOMWNuSmxiblJiWTJoaGJtZGxjMXRwWFYwc0lHOXdkR2x2Ym5NcE8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJQzh2SUZsdmRTQnRhV2RvZENCaVpTQjNiMjVrWlhKcGJtY2dkMmg1SUhSb1pYSmxKM01nWVNCZ2QyaHBiR1ZnSUd4dmIzQWdhR1Z5WlM0Z1EyaGhibWRsY3lCallXNWNiaUFnSUNBZ0lDOHZJR0psSUhKbFkzVnljMmwyWld4NUlHNWxjM1JsWkNCM2FYUm9hVzRnWUZ3aVkyaGhibWRsWENKZ0lHVjJaVzUwY3k1Y2JpQWdJQ0FnSUdsbUlDaGphR0Z1WjJsdVp5a2djbVYwZFhKdUlIUm9hWE03WEc0Z0lDQWdJQ0JwWmlBb0lYTnBiR1Z1ZENrZ2UxeHVJQ0FnSUNBZ0lDQjNhR2xzWlNBb2RHaHBjeTVmY0dWdVpHbHVaeWtnZTF4dUlDQWdJQ0FnSUNBZ0lHOXdkR2x2Ym5NZ1BTQjBhR2x6TGw5d1pXNWthVzVuTzF4dUlDQWdJQ0FnSUNBZ0lIUm9hWE11WDNCbGJtUnBibWNnUFNCbVlXeHpaVHRjYmlBZ0lDQWdJQ0FnSUNCMGFHbHpMblJ5YVdkblpYSW9KMk5vWVc1blpTY3NJSFJvYVhNc0lHOXdkR2x2Ym5NcE8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQjBhR2x6TGw5d1pXNWthVzVuSUQwZ1ptRnNjMlU3WEc0Z0lDQWdJQ0IwYUdsekxsOWphR0Z1WjJsdVp5QTlJR1poYkhObE8xeHVJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTTdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lDOHZJRkpsYlc5MlpTQmhiaUJoZEhSeWFXSjFkR1VnWm5KdmJTQjBhR1VnYlc5a1pXd3NJR1pwY21sdVp5QmdYQ0pqYUdGdVoyVmNJbUF1SUdCMWJuTmxkR0FnYVhNZ1lTQnViMjl3WEc0Z0lDQWdMeThnYVdZZ2RHaGxJR0YwZEhKcFluVjBaU0JrYjJWemJpZDBJR1Y0YVhOMExseHVJQ0FnSUhWdWMyVjBPaUJtZFc1amRHbHZiaWhoZEhSeUxDQnZjSFJwYjI1ektTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z2RHaHBjeTV6WlhRb1lYUjBjaXdnZG05cFpDQXdMQ0JmTG1WNGRHVnVaQ2g3ZlN3Z2IzQjBhVzl1Y3l3Z2UzVnVjMlYwT2lCMGNuVmxmU2twTzF4dUlDQWdJSDBzWEc1Y2JpQWdJQ0F2THlCRGJHVmhjaUJoYkd3Z1lYUjBjbWxpZFhSbGN5QnZiaUIwYUdVZ2JXOWtaV3dzSUdacGNtbHVaeUJnWENKamFHRnVaMlZjSW1BdVhHNGdJQ0FnWTJ4bFlYSTZJR1oxYm1OMGFXOXVLRzl3ZEdsdmJuTXBJSHRjYmlBZ0lDQWdJSFpoY2lCaGRIUnljeUE5SUh0OU8xeHVJQ0FnSUNBZ1ptOXlJQ2gyWVhJZ2EyVjVJR2x1SUhSb2FYTXVZWFIwY21saWRYUmxjeWtnWVhSMGNuTmJhMlY1WFNBOUlIWnZhV1FnTUR0Y2JpQWdJQ0FnSUhKbGRIVnliaUIwYUdsekxuTmxkQ2hoZEhSeWN5d2dYeTVsZUhSbGJtUW9lMzBzSUc5d2RHbHZibk1zSUh0MWJuTmxkRG9nZEhKMVpYMHBLVHRjYmlBZ0lDQjlMRnh1WEc0Z0lDQWdMeThnUkdWMFpYSnRhVzVsSUdsbUlIUm9aU0J0YjJSbGJDQm9ZWE1nWTJoaGJtZGxaQ0J6YVc1alpTQjBhR1VnYkdGemRDQmdYQ0pqYUdGdVoyVmNJbUFnWlhabGJuUXVYRzRnSUNBZ0x5OGdTV1lnZVc5MUlITndaV05wWm5rZ1lXNGdZWFIwY21saWRYUmxJRzVoYldVc0lHUmxkR1Z5YldsdVpTQnBaaUIwYUdGMElHRjBkSEpwWW5WMFpTQm9ZWE1nWTJoaGJtZGxaQzVjYmlBZ0lDQm9ZWE5EYUdGdVoyVmtPaUJtZFc1amRHbHZiaWhoZEhSeUtTQjdYRzRnSUNBZ0lDQnBaaUFvWVhSMGNpQTlQU0J1ZFd4c0tTQnlaWFIxY200Z0lWOHVhWE5GYlhCMGVTaDBhR2x6TG1Ob1lXNW5aV1FwTzF4dUlDQWdJQ0FnY21WMGRYSnVJRjh1YUdGektIUm9hWE11WTJoaGJtZGxaQ3dnWVhSMGNpazdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lDOHZJRkpsZEhWeWJpQmhiaUJ2WW1wbFkzUWdZMjl1ZEdGcGJtbHVaeUJoYkd3Z2RHaGxJR0YwZEhKcFluVjBaWE1nZEdoaGRDQm9ZWFpsSUdOb1lXNW5aV1FzSUc5eVhHNGdJQ0FnTHk4Z1ptRnNjMlVnYVdZZ2RHaGxjbVVnWVhKbElHNXZJR05vWVc1blpXUWdZWFIwY21saWRYUmxjeTRnVlhObFpuVnNJR1p2Y2lCa1pYUmxjbTFwYm1sdVp5QjNhR0YwWEc0Z0lDQWdMeThnY0dGeWRITWdiMllnWVNCMmFXVjNJRzVsWldRZ2RHOGdZbVVnZFhCa1lYUmxaQ0JoYm1RdmIzSWdkMmhoZENCaGRIUnlhV0oxZEdWeklHNWxaV1FnZEc4Z1ltVmNiaUFnSUNBdkx5QndaWEp6YVhOMFpXUWdkRzhnZEdobElITmxjblpsY2k0Z1ZXNXpaWFFnWVhSMGNtbGlkWFJsY3lCM2FXeHNJR0psSUhObGRDQjBieUIxYm1SbFptbHVaV1F1WEc0Z0lDQWdMeThnV1c5MUlHTmhiaUJoYkhOdklIQmhjM01nWVc0Z1lYUjBjbWxpZFhSbGN5QnZZbXBsWTNRZ2RHOGdaR2xtWmlCaFoyRnBibk4wSUhSb1pTQnRiMlJsYkN4Y2JpQWdJQ0F2THlCa1pYUmxjbTFwYm1sdVp5QnBaaUIwYUdWeVpTQXFkMjkxYkdRZ1ltVXFJR0VnWTJoaGJtZGxMbHh1SUNBZ0lHTm9ZVzVuWldSQmRIUnlhV0oxZEdWek9pQm1kVzVqZEdsdmJpaGthV1ptS1NCN1hHNGdJQ0FnSUNCcFppQW9JV1JwWm1ZcElISmxkSFZ5YmlCMGFHbHpMbWhoYzBOb1lXNW5aV1FvS1NBL0lGOHVZMnh2Ym1Vb2RHaHBjeTVqYUdGdVoyVmtLU0E2SUdaaGJITmxPMXh1SUNBZ0lDQWdkbUZ5SUc5c1pDQTlJSFJvYVhNdVgyTm9ZVzVuYVc1bklEOGdkR2hwY3k1ZmNISmxkbWx2ZFhOQmRIUnlhV0oxZEdWeklEb2dkR2hwY3k1aGRIUnlhV0oxZEdWek8xeHVJQ0FnSUNBZ2RtRnlJR05vWVc1blpXUWdQU0I3ZlR0Y2JpQWdJQ0FnSUdadmNpQW9kbUZ5SUdGMGRISWdhVzRnWkdsbVppa2dlMXh1SUNBZ0lDQWdJQ0IyWVhJZ2RtRnNJRDBnWkdsbVpsdGhkSFJ5WFR0Y2JpQWdJQ0FnSUNBZ2FXWWdLRjh1YVhORmNYVmhiQ2h2YkdSYllYUjBjbDBzSUhaaGJDa3BJR052Ym5ScGJuVmxPMXh1SUNBZ0lDQWdJQ0JqYUdGdVoyVmtXMkYwZEhKZElEMGdkbUZzTzF4dUlDQWdJQ0FnZlZ4dUlDQWdJQ0FnY21WMGRYSnVJRjh1YzJsNlpTaGphR0Z1WjJWa0tTQS9JR05vWVc1blpXUWdPaUJtWVd4elpUdGNiaUFnSUNCOUxGeHVYRzRnSUNBZ0x5OGdSMlYwSUhSb1pTQndjbVYyYVc5MWN5QjJZV3gxWlNCdlppQmhiaUJoZEhSeWFXSjFkR1VzSUhKbFkyOXlaR1ZrSUdGMElIUm9aU0IwYVcxbElIUm9aU0JzWVhOMFhHNGdJQ0FnTHk4Z1lGd2lZMmhoYm1kbFhDSmdJR1YyWlc1MElIZGhjeUJtYVhKbFpDNWNiaUFnSUNCd2NtVjJhVzkxY3pvZ1puVnVZM1JwYjI0b1lYUjBjaWtnZTF4dUlDQWdJQ0FnYVdZZ0tHRjBkSElnUFQwZ2JuVnNiQ0I4ZkNBaGRHaHBjeTVmY0hKbGRtbHZkWE5CZEhSeWFXSjFkR1Z6S1NCeVpYUjFjbTRnYm5Wc2JEdGNiaUFnSUNBZ0lISmxkSFZ5YmlCMGFHbHpMbDl3Y21WMmFXOTFjMEYwZEhKcFluVjBaWE5iWVhSMGNsMDdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lDOHZJRWRsZENCaGJHd2diMllnZEdobElHRjBkSEpwWW5WMFpYTWdiMllnZEdobElHMXZaR1ZzSUdGMElIUm9aU0IwYVcxbElHOW1JSFJvWlNCd2NtVjJhVzkxYzF4dUlDQWdJQzh2SUdCY0ltTm9ZVzVuWlZ3aVlDQmxkbVZ1ZEM1Y2JpQWdJQ0J3Y21WMmFXOTFjMEYwZEhKcFluVjBaWE02SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUY4dVkyeHZibVVvZEdocGN5NWZjSEpsZG1sdmRYTkJkSFJ5YVdKMWRHVnpLVHRjYmlBZ0lDQjlMRnh1WEc0Z0lDQWdMeThnUm1WMFkyZ2dkR2hsSUcxdlpHVnNJR1p5YjIwZ2RHaGxJSE5sY25abGNpd2diV1Z5WjJsdVp5QjBhR1VnY21WemNHOXVjMlVnZDJsMGFDQjBhR1VnYlc5a1pXd25jMXh1SUNBZ0lDOHZJR3h2WTJGc0lHRjBkSEpwWW5WMFpYTXVJRUZ1ZVNCamFHRnVaMlZrSUdGMGRISnBZblYwWlhNZ2QybHNiQ0IwY21sbloyVnlJR0VnWENKamFHRnVaMlZjSWlCbGRtVnVkQzVjYmlBZ0lDQm1aWFJqYURvZ1puVnVZM1JwYjI0b2IzQjBhVzl1Y3lrZ2UxeHVJQ0FnSUNBZ2IzQjBhVzl1Y3lBOUlGOHVaWGgwWlc1a0tIdHdZWEp6WlRvZ2RISjFaWDBzSUc5d2RHbHZibk1wTzF4dUlDQWdJQ0FnZG1GeUlHMXZaR1ZzSUQwZ2RHaHBjenRjYmlBZ0lDQWdJSFpoY2lCemRXTmpaWE56SUQwZ2IzQjBhVzl1Y3k1emRXTmpaWE56TzF4dUlDQWdJQ0FnYjNCMGFXOXVjeTV6ZFdOalpYTnpJRDBnWm5WdVkzUnBiMjRvY21WemNDa2dlMXh1SUNBZ0lDQWdJQ0IyWVhJZ2MyVnlkbVZ5UVhSMGNuTWdQU0J2Y0hScGIyNXpMbkJoY25ObElEOGdiVzlrWld3dWNHRnljMlVvY21WemNDd2diM0IwYVc5dWN5a2dPaUJ5WlhOd08xeHVJQ0FnSUNBZ0lDQnBaaUFvSVcxdlpHVnNMbk5sZENoelpYSjJaWEpCZEhSeWN5d2diM0IwYVc5dWN5a3BJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdJQ0FnSUNBZ2FXWWdLSE4xWTJObGMzTXBJSE4xWTJObGMzTXVZMkZzYkNodmNIUnBiMjV6TG1OdmJuUmxlSFFzSUcxdlpHVnNMQ0J5WlhOd0xDQnZjSFJwYjI1ektUdGNiaUFnSUNBZ0lDQWdiVzlrWld3dWRISnBaMmRsY2lnbmMzbHVZeWNzSUcxdlpHVnNMQ0J5WlhOd0xDQnZjSFJwYjI1ektUdGNiaUFnSUNBZ0lIMDdYRzRnSUNBZ0lDQjNjbUZ3UlhKeWIzSW9kR2hwY3l3Z2IzQjBhVzl1Y3lrN1hHNGdJQ0FnSUNCeVpYUjFjbTRnZEdocGN5NXplVzVqS0NkeVpXRmtKeXdnZEdocGN5d2diM0IwYVc5dWN5azdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lDOHZJRk5sZENCaElHaGhjMmdnYjJZZ2JXOWtaV3dnWVhSMGNtbGlkWFJsY3l3Z1lXNWtJSE41Ym1NZ2RHaGxJRzF2WkdWc0lIUnZJSFJvWlNCelpYSjJaWEl1WEc0Z0lDQWdMeThnU1dZZ2RHaGxJSE5sY25abGNpQnlaWFIxY201eklHRnVJR0YwZEhKcFluVjBaWE1nYUdGemFDQjBhR0YwSUdScFptWmxjbk1zSUhSb1pTQnRiMlJsYkNkelhHNGdJQ0FnTHk4Z2MzUmhkR1VnZDJsc2JDQmlaU0JnYzJWMFlDQmhaMkZwYmk1Y2JpQWdJQ0J6WVhabE9pQm1kVzVqZEdsdmJpaHJaWGtzSUhaaGJDd2diM0IwYVc5dWN5a2dlMXh1SUNBZ0lDQWdMeThnU0dGdVpHeGxJR0p2ZEdnZ1lGd2lhMlY1WENJc0lIWmhiSFZsWUNCaGJtUWdZSHRyWlhrNklIWmhiSFZsZldBZ0xYTjBlV3hsSUdGeVozVnRaVzUwY3k1Y2JpQWdJQ0FnSUhaaGNpQmhkSFJ5Y3p0Y2JpQWdJQ0FnSUdsbUlDaHJaWGtnUFQwZ2JuVnNiQ0I4ZkNCMGVYQmxiMllnYTJWNUlEMDlQU0FuYjJKcVpXTjBKeWtnZTF4dUlDQWdJQ0FnSUNCaGRIUnljeUE5SUd0bGVUdGNiaUFnSUNBZ0lDQWdiM0IwYVc5dWN5QTlJSFpoYkR0Y2JpQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUNoaGRIUnljeUE5SUh0OUtWdHJaWGxkSUQwZ2RtRnNPMXh1SUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0J2Y0hScGIyNXpJRDBnWHk1bGVIUmxibVFvZTNaaGJHbGtZWFJsT2lCMGNuVmxMQ0J3WVhKelpUb2dkSEoxWlgwc0lHOXdkR2x2Ym5NcE8xeHVJQ0FnSUNBZ2RtRnlJSGRoYVhRZ1BTQnZjSFJwYjI1ekxuZGhhWFE3WEc1Y2JpQWdJQ0FnSUM4dklFbG1JSGRsSjNKbElHNXZkQ0IzWVdsMGFXNW5JR0Z1WkNCaGRIUnlhV0oxZEdWeklHVjRhWE4wTENCellYWmxJR0ZqZEhNZ1lYTmNiaUFnSUNBZ0lDOHZJR0J6WlhRb1lYUjBjaWt1YzJGMlpTaHVkV3hzTENCdmNIUnpLV0FnZDJsMGFDQjJZV3hwWkdGMGFXOXVMaUJQZEdobGNuZHBjMlVzSUdOb1pXTnJJR2xtWEc0Z0lDQWdJQ0F2THlCMGFHVWdiVzlrWld3Z2QybHNiQ0JpWlNCMllXeHBaQ0IzYUdWdUlIUm9aU0JoZEhSeWFXSjFkR1Z6TENCcFppQmhibmtzSUdGeVpTQnpaWFF1WEc0Z0lDQWdJQ0JwWmlBb1lYUjBjbk1nSmlZZ0lYZGhhWFFwSUh0Y2JpQWdJQ0FnSUNBZ2FXWWdLQ0YwYUdsekxuTmxkQ2hoZEhSeWN5d2diM0IwYVc5dWN5a3BJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUdsbUlDZ2hkR2hwY3k1ZmRtRnNhV1JoZEdVb1lYUjBjbk1zSUc5d2RHbHZibk1wS1NCeVpYUjFjbTRnWm1Gc2MyVTdYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJQzh2SUVGbWRHVnlJR0VnYzNWalkyVnpjMloxYkNCelpYSjJaWEl0YzJsa1pTQnpZWFpsTENCMGFHVWdZMnhwWlc1MElHbHpJQ2h2Y0hScGIyNWhiR3g1S1Z4dUlDQWdJQ0FnTHk4Z2RYQmtZWFJsWkNCM2FYUm9JSFJvWlNCelpYSjJaWEl0YzJsa1pTQnpkR0YwWlM1Y2JpQWdJQ0FnSUhaaGNpQnRiMlJsYkNBOUlIUm9hWE03WEc0Z0lDQWdJQ0IyWVhJZ2MzVmpZMlZ6Y3lBOUlHOXdkR2x2Ym5NdWMzVmpZMlZ6Y3p0Y2JpQWdJQ0FnSUhaaGNpQmhkSFJ5YVdKMWRHVnpJRDBnZEdocGN5NWhkSFJ5YVdKMWRHVnpPMXh1SUNBZ0lDQWdiM0IwYVc5dWN5NXpkV05qWlhOeklEMGdablZ1WTNScGIyNG9jbVZ6Y0NrZ2UxeHVJQ0FnSUNBZ0lDQXZMeUJGYm5OMWNtVWdZWFIwY21saWRYUmxjeUJoY21VZ2NtVnpkRzl5WldRZ1pIVnlhVzVuSUhONWJtTm9jbTl1YjNWeklITmhkbVZ6TGx4dUlDQWdJQ0FnSUNCdGIyUmxiQzVoZEhSeWFXSjFkR1Z6SUQwZ1lYUjBjbWxpZFhSbGN6dGNiaUFnSUNBZ0lDQWdkbUZ5SUhObGNuWmxja0YwZEhKeklEMGdiM0IwYVc5dWN5NXdZWEp6WlNBL0lHMXZaR1ZzTG5CaGNuTmxLSEpsYzNBc0lHOXdkR2x2Ym5NcElEb2djbVZ6Y0R0Y2JpQWdJQ0FnSUNBZ2FXWWdLSGRoYVhRcElITmxjblpsY2tGMGRISnpJRDBnWHk1bGVIUmxibVFvZTMwc0lHRjBkSEp6TENCelpYSjJaWEpCZEhSeWN5azdYRzRnSUNBZ0lDQWdJR2xtSUNoelpYSjJaWEpCZEhSeWN5QW1KaUFoYlc5a1pXd3VjMlYwS0hObGNuWmxja0YwZEhKekxDQnZjSFJwYjI1ektTa2djbVYwZFhKdUlHWmhiSE5sTzF4dUlDQWdJQ0FnSUNCcFppQW9jM1ZqWTJWemN5a2djM1ZqWTJWemN5NWpZV3hzS0c5d2RHbHZibk11WTI5dWRHVjRkQ3dnYlc5a1pXd3NJSEpsYzNBc0lHOXdkR2x2Ym5NcE8xeHVJQ0FnSUNBZ0lDQnRiMlJsYkM1MGNtbG5aMlZ5S0NkemVXNWpKeXdnYlc5a1pXd3NJSEpsYzNBc0lHOXdkR2x2Ym5NcE8xeHVJQ0FnSUNBZ2ZUdGNiaUFnSUNBZ0lIZHlZWEJGY25KdmNpaDBhR2x6TENCdmNIUnBiMjV6S1R0Y2JseHVJQ0FnSUNBZ0x5OGdVMlYwSUhSbGJYQnZjbUZ5ZVNCaGRIUnlhV0oxZEdWeklHbG1JR0I3ZDJGcGREb2dkSEoxWlgxZ0lIUnZJSEJ5YjNCbGNteDVJR1pwYm1RZ2JtVjNJR2xrY3k1Y2JpQWdJQ0FnSUdsbUlDaGhkSFJ5Y3lBbUppQjNZV2wwS1NCMGFHbHpMbUYwZEhKcFluVjBaWE1nUFNCZkxtVjRkR1Z1WkNoN2ZTd2dZWFIwY21saWRYUmxjeXdnWVhSMGNuTXBPMXh1WEc0Z0lDQWdJQ0IyWVhJZ2JXVjBhRzlrSUQwZ2RHaHBjeTVwYzA1bGR5Z3BJRDhnSjJOeVpXRjBaU2NnT2lBb2IzQjBhVzl1Y3k1d1lYUmphQ0EvSUNkd1lYUmphQ2NnT2lBbmRYQmtZWFJsSnlrN1hHNGdJQ0FnSUNCcFppQW9iV1YwYUc5a0lEMDlQU0FuY0dGMFkyZ25JQ1ltSUNGdmNIUnBiMjV6TG1GMGRISnpLU0J2Y0hScGIyNXpMbUYwZEhKeklEMGdZWFIwY25NN1hHNGdJQ0FnSUNCMllYSWdlR2h5SUQwZ2RHaHBjeTV6ZVc1aktHMWxkR2h2WkN3Z2RHaHBjeXdnYjNCMGFXOXVjeWs3WEc1Y2JpQWdJQ0FnSUM4dklGSmxjM1J2Y21VZ1lYUjBjbWxpZFhSbGN5NWNiaUFnSUNBZ0lIUm9hWE11WVhSMGNtbGlkWFJsY3lBOUlHRjBkSEpwWW5WMFpYTTdYRzVjYmlBZ0lDQWdJSEpsZEhWeWJpQjRhSEk3WEc0Z0lDQWdmU3hjYmx4dUlDQWdJQzh2SUVSbGMzUnliM2tnZEdocGN5QnRiMlJsYkNCdmJpQjBhR1VnYzJWeWRtVnlJR2xtSUdsMElIZGhjeUJoYkhKbFlXUjVJSEJsY25OcGMzUmxaQzVjYmlBZ0lDQXZMeUJQY0hScGJXbHpkR2xqWVd4c2VTQnlaVzF2ZG1WeklIUm9aU0J0YjJSbGJDQm1jbTl0SUdsMGN5QmpiMnhzWldOMGFXOXVMQ0JwWmlCcGRDQm9ZWE1nYjI1bExseHVJQ0FnSUM4dklFbG1JR0IzWVdsME9pQjBjblZsWUNCcGN5QndZWE56WldRc0lIZGhhWFJ6SUdadmNpQjBhR1VnYzJWeWRtVnlJSFJ2SUhKbGMzQnZibVFnWW1WbWIzSmxJSEpsYlc5MllXd3VYRzRnSUNBZ1pHVnpkSEp2ZVRvZ1puVnVZM1JwYjI0b2IzQjBhVzl1Y3lrZ2UxeHVJQ0FnSUNBZ2IzQjBhVzl1Y3lBOUlHOXdkR2x2Ym5NZ1B5QmZMbU5zYjI1bEtHOXdkR2x2Ym5NcElEb2dlMzA3WEc0Z0lDQWdJQ0IyWVhJZ2JXOWtaV3dnUFNCMGFHbHpPMXh1SUNBZ0lDQWdkbUZ5SUhOMVkyTmxjM01nUFNCdmNIUnBiMjV6TG5OMVkyTmxjM003WEc0Z0lDQWdJQ0IyWVhJZ2QyRnBkQ0E5SUc5d2RHbHZibk11ZDJGcGREdGNibHh1SUNBZ0lDQWdkbUZ5SUdSbGMzUnliM2tnUFNCbWRXNWpkR2x2YmlncElIdGNiaUFnSUNBZ0lDQWdiVzlrWld3dWMzUnZjRXhwYzNSbGJtbHVaeWdwTzF4dUlDQWdJQ0FnSUNCdGIyUmxiQzUwY21sbloyVnlLQ2RrWlhOMGNtOTVKeXdnYlc5a1pXd3NJRzF2WkdWc0xtTnZiR3hsWTNScGIyNHNJRzl3ZEdsdmJuTXBPMXh1SUNBZ0lDQWdmVHRjYmx4dUlDQWdJQ0FnYjNCMGFXOXVjeTV6ZFdOalpYTnpJRDBnWm5WdVkzUnBiMjRvY21WemNDa2dlMXh1SUNBZ0lDQWdJQ0JwWmlBb2QyRnBkQ2tnWkdWemRISnZlU2dwTzF4dUlDQWdJQ0FnSUNCcFppQW9jM1ZqWTJWemN5a2djM1ZqWTJWemN5NWpZV3hzS0c5d2RHbHZibk11WTI5dWRHVjRkQ3dnYlc5a1pXd3NJSEpsYzNBc0lHOXdkR2x2Ym5NcE8xeHVJQ0FnSUNBZ0lDQnBaaUFvSVcxdlpHVnNMbWx6VG1WM0tDa3BJRzF2WkdWc0xuUnlhV2RuWlhJb0ozTjVibU1uTENCdGIyUmxiQ3dnY21WemNDd2diM0IwYVc5dWN5azdYRzRnSUNBZ0lDQjlPMXh1WEc0Z0lDQWdJQ0IyWVhJZ2VHaHlJRDBnWm1Gc2MyVTdYRzRnSUNBZ0lDQnBaaUFvZEdocGN5NXBjMDVsZHlncEtTQjdYRzRnSUNBZ0lDQWdJRjh1WkdWbVpYSW9iM0IwYVc5dWN5NXpkV05qWlhOektUdGNiaUFnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lIZHlZWEJGY25KdmNpaDBhR2x6TENCdmNIUnBiMjV6S1R0Y2JpQWdJQ0FnSUNBZ2VHaHlJRDBnZEdocGN5NXplVzVqS0Nka1pXeGxkR1VuTENCMGFHbHpMQ0J2Y0hScGIyNXpLVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQWdJR2xtSUNnaGQyRnBkQ2tnWkdWemRISnZlU2dwTzF4dUlDQWdJQ0FnY21WMGRYSnVJSGhvY2p0Y2JpQWdJQ0I5TEZ4dVhHNGdJQ0FnTHk4Z1JHVm1ZWFZzZENCVlVrd2dabTl5SUhSb1pTQnRiMlJsYkNkeklISmxjSEpsYzJWdWRHRjBhVzl1SUc5dUlIUm9aU0J6WlhKMlpYSWdMUzBnYVdZZ2VXOTFKM0psWEc0Z0lDQWdMeThnZFhOcGJtY2dRbUZqYTJKdmJtVW5jeUJ5WlhOMFpuVnNJRzFsZEdodlpITXNJRzkyWlhKeWFXUmxJSFJvYVhNZ2RHOGdZMmhoYm1kbElIUm9aU0JsYm1Sd2IybHVkRnh1SUNBZ0lDOHZJSFJvWVhRZ2QybHNiQ0JpWlNCallXeHNaV1F1WEc0Z0lDQWdkWEpzT2lCbWRXNWpkR2x2YmlncElIdGNiaUFnSUNBZ0lIWmhjaUJpWVhObElEMWNiaUFnSUNBZ0lDQWdYeTV5WlhOMWJIUW9kR2hwY3l3Z0ozVnliRkp2YjNRbktTQjhmRnh1SUNBZ0lDQWdJQ0JmTG5KbGMzVnNkQ2gwYUdsekxtTnZiR3hsWTNScGIyNHNJQ2QxY213bktTQjhmRnh1SUNBZ0lDQWdJQ0IxY214RmNuSnZjaWdwTzF4dUlDQWdJQ0FnYVdZZ0tIUm9hWE11YVhOT1pYY29LU2tnY21WMGRYSnVJR0poYzJVN1hHNGdJQ0FnSUNCMllYSWdhV1FnUFNCMGFHbHpMbWRsZENoMGFHbHpMbWxrUVhSMGNtbGlkWFJsS1R0Y2JpQWdJQ0FnSUhKbGRIVnliaUJpWVhObExuSmxjR3hoWTJVb0wxdGVYRnd2WFNRdkxDQW5KQ1l2SnlrZ0t5QmxibU52WkdWVlVrbERiMjF3YjI1bGJuUW9hV1FwTzF4dUlDQWdJSDBzWEc1Y2JpQWdJQ0F2THlBcUtuQmhjbk5sS2lvZ1kyOXVkbVZ5ZEhNZ1lTQnlaWE53YjI1elpTQnBiblJ2SUhSb1pTQm9ZWE5vSUc5bUlHRjBkSEpwWW5WMFpYTWdkRzhnWW1VZ1lITmxkR0FnYjI1Y2JpQWdJQ0F2THlCMGFHVWdiVzlrWld3dUlGUm9aU0JrWldaaGRXeDBJR2x0Y0d4bGJXVnVkR0YwYVc5dUlHbHpJR3AxYzNRZ2RHOGdjR0Z6Y3lCMGFHVWdjbVZ6Y0c5dWMyVWdZV3h2Ym1jdVhHNGdJQ0FnY0dGeWMyVTZJR1oxYm1OMGFXOXVLSEpsYzNBc0lHOXdkR2x2Ym5NcElIdGNiaUFnSUNBZ0lISmxkSFZ5YmlCeVpYTndPMXh1SUNBZ0lIMHNYRzVjYmlBZ0lDQXZMeUJEY21WaGRHVWdZU0J1WlhjZ2JXOWtaV3dnZDJsMGFDQnBaR1Z1ZEdsallXd2dZWFIwY21saWRYUmxjeUIwYnlCMGFHbHpJRzl1WlM1Y2JpQWdJQ0JqYkc5dVpUb2dablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdibVYzSUhSb2FYTXVZMjl1YzNSeWRXTjBiM0lvZEdocGN5NWhkSFJ5YVdKMWRHVnpLVHRjYmlBZ0lDQjlMRnh1WEc0Z0lDQWdMeThnUVNCdGIyUmxiQ0JwY3lCdVpYY2dhV1lnYVhRZ2FHRnpJRzVsZG1WeUlHSmxaVzRnYzJGMlpXUWdkRzhnZEdobElITmxjblpsY2l3Z1lXNWtJR3hoWTJ0eklHRnVJR2xrTGx4dUlDQWdJR2x6VG1WM09pQm1kVzVqZEdsdmJpZ3BJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQWhkR2hwY3k1b1lYTW9kR2hwY3k1cFpFRjBkSEpwWW5WMFpTazdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lDOHZJRU5vWldOcklHbG1JSFJvWlNCdGIyUmxiQ0JwY3lCamRYSnlaVzUwYkhrZ2FXNGdZU0IyWVd4cFpDQnpkR0YwWlM1Y2JpQWdJQ0JwYzFaaGJHbGtPaUJtZFc1amRHbHZiaWh2Y0hScGIyNXpLU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdkR2hwY3k1ZmRtRnNhV1JoZEdVb2UzMHNJRjh1WkdWbVlYVnNkSE1vZTNaaGJHbGtZWFJsT2lCMGNuVmxmU3dnYjNCMGFXOXVjeWtwTzF4dUlDQWdJSDBzWEc1Y2JpQWdJQ0F2THlCU2RXNGdkbUZzYVdSaGRHbHZiaUJoWjJGcGJuTjBJSFJvWlNCdVpYaDBJR052YlhCc1pYUmxJSE5sZENCdlppQnRiMlJsYkNCaGRIUnlhV0oxZEdWekxGeHVJQ0FnSUM4dklISmxkSFZ5Ym1sdVp5QmdkSEoxWldBZ2FXWWdZV3hzSUdseklIZGxiR3d1SUU5MGFHVnlkMmx6WlN3Z1ptbHlaU0JoYmlCZ1hDSnBiblpoYkdsa1hDSmdJR1YyWlc1MExseHVJQ0FnSUY5MllXeHBaR0YwWlRvZ1puVnVZM1JwYjI0b1lYUjBjbk1zSUc5d2RHbHZibk1wSUh0Y2JpQWdJQ0FnSUdsbUlDZ2hiM0IwYVc5dWN5NTJZV3hwWkdGMFpTQjhmQ0FoZEdocGN5NTJZV3hwWkdGMFpTa2djbVYwZFhKdUlIUnlkV1U3WEc0Z0lDQWdJQ0JoZEhSeWN5QTlJRjh1WlhoMFpXNWtLSHQ5TENCMGFHbHpMbUYwZEhKcFluVjBaWE1zSUdGMGRISnpLVHRjYmlBZ0lDQWdJSFpoY2lCbGNuSnZjaUE5SUhSb2FYTXVkbUZzYVdSaGRHbHZia1Z5Y205eUlEMGdkR2hwY3k1MllXeHBaR0YwWlNoaGRIUnljeXdnYjNCMGFXOXVjeWtnZkh3Z2JuVnNiRHRjYmlBZ0lDQWdJR2xtSUNnaFpYSnliM0lwSUhKbGRIVnliaUIwY25WbE8xeHVJQ0FnSUNBZ2RHaHBjeTUwY21sbloyVnlLQ2RwYm5aaGJHbGtKeXdnZEdocGN5d2daWEp5YjNJc0lGOHVaWGgwWlc1a0tHOXdkR2x2Ym5Nc0lIdDJZV3hwWkdGMGFXOXVSWEp5YjNJNklHVnljbTl5ZlNrcE8xeHVJQ0FnSUNBZ2NtVjBkWEp1SUdaaGJITmxPMXh1SUNBZ0lIMWNibHh1SUNCOUtUdGNibHh1SUNBdkx5QlZibVJsY25OamIzSmxJRzFsZEdodlpITWdkR2hoZENCM1pTQjNZVzUwSUhSdklHbHRjR3hsYldWdWRDQnZiaUIwYUdVZ1RXOWtaV3d1WEc0Z0lIWmhjaUJ0YjJSbGJFMWxkR2h2WkhNZ1BTQjdJR3RsZVhNNklERXNJSFpoYkhWbGN6b2dNU3dnY0dGcGNuTTZJREVzSUdsdWRtVnlkRG9nTVN3Z2NHbGphem9nTUN4Y2JpQWdJQ0FnSUc5dGFYUTZJREFzSUdOb1lXbHVPaUF4TENCcGMwVnRjSFI1T2lBeElIMDdYRzVjYmlBZ0x5OGdUV2w0SUdsdUlHVmhZMmdnVlc1a1pYSnpZMjl5WlNCdFpYUm9iMlFnWVhNZ1lTQndjbTk0ZVNCMGJ5QmdUVzlrWld3allYUjBjbWxpZFhSbGMyQXVYRzRnSUdGa1pGVnVaR1Z5YzJOdmNtVk5aWFJvYjJSektFMXZaR1ZzTENCdGIyUmxiRTFsZEdodlpITXNJQ2RoZEhSeWFXSjFkR1Z6SnlrN1hHNWNiaUFnTHk4Z1FtRmphMkp2Ym1VdVEyOXNiR1ZqZEdsdmJseHVJQ0F2THlBdExTMHRMUzB0TFMwdExTMHRMUzB0TFMwdFhHNWNiaUFnTHk4Z1NXWWdiVzlrWld4eklIUmxibVFnZEc4Z2NtVndjbVZ6Wlc1MElHRWdjMmx1WjJ4bElISnZkeUJ2WmlCa1lYUmhMQ0JoSUVKaFkydGliMjVsSUVOdmJHeGxZM1JwYjI0Z2FYTmNiaUFnTHk4Z2JXOXlaU0JoYm1Gc2IyZHZkWE1nZEc4Z1lTQjBZV0pzWlNCbWRXeHNJRzltSUdSaGRHRWdMaTR1SUc5eUlHRWdjMjFoYkd3Z2MyeHBZMlVnYjNJZ2NHRm5aU0J2WmlCMGFHRjBYRzRnSUM4dklIUmhZbXhsTENCdmNpQmhJR052Ykd4bFkzUnBiMjRnYjJZZ2NtOTNjeUIwYUdGMElHSmxiRzl1WnlCMGIyZGxkR2hsY2lCbWIzSWdZU0J3WVhKMGFXTjFiR0Z5SUhKbFlYTnZibHh1SUNBdkx5QXRMU0JoYkd3Z2IyWWdkR2hsSUcxbGMzTmhaMlZ6SUdsdUlIUm9hWE1nY0dGeWRHbGpkV3hoY2lCbWIyeGtaWElzSUdGc2JDQnZaaUIwYUdVZ1pHOWpkVzFsYm5SelhHNGdJQzh2SUdKbGJHOXVaMmx1WnlCMGJ5QjBhR2x6SUhCaGNuUnBZM1ZzWVhJZ1lYVjBhRzl5TENCaGJtUWdjMjhnYjI0dUlFTnZiR3hsWTNScGIyNXpJRzFoYVc1MFlXbHVYRzRnSUM4dklHbHVaR1Y0WlhNZ2IyWWdkR2hsYVhJZ2JXOWtaV3h6TENCaWIzUm9JR2x1SUc5eVpHVnlMQ0JoYm1RZ1ptOXlJR3h2YjJ0MWNDQmllU0JnYVdSZ0xseHVYRzRnSUM4dklFTnlaV0YwWlNCaElHNWxkeUFxS2tOdmJHeGxZM1JwYjI0cUtpd2djR1Z5YUdGd2N5QjBieUJqYjI1MFlXbHVJR0VnYzNCbFkybG1hV01nZEhsd1pTQnZaaUJnYlc5a1pXeGdMbHh1SUNBdkx5QkpaaUJoSUdCamIyMXdZWEpoZEc5eVlDQnBjeUJ6Y0dWamFXWnBaV1FzSUhSb1pTQkRiMnhzWldOMGFXOXVJSGRwYkd3Z2JXRnBiblJoYVc1Y2JpQWdMeThnYVhSeklHMXZaR1ZzY3lCcGJpQnpiM0owSUc5eVpHVnlMQ0JoY3lCMGFHVjVKM0psSUdGa1pHVmtJR0Z1WkNCeVpXMXZkbVZrTGx4dUlDQjJZWElnUTI5c2JHVmpkR2x2YmlBOUlFSmhZMnRpYjI1bExrTnZiR3hsWTNScGIyNGdQU0JtZFc1amRHbHZiaWh0YjJSbGJITXNJRzl3ZEdsdmJuTXBJSHRjYmlBZ0lDQnZjSFJwYjI1eklIeDhJQ2h2Y0hScGIyNXpJRDBnZTMwcE8xeHVJQ0FnSUdsbUlDaHZjSFJwYjI1ekxtMXZaR1ZzS1NCMGFHbHpMbTF2WkdWc0lEMGdiM0IwYVc5dWN5NXRiMlJsYkR0Y2JpQWdJQ0JwWmlBb2IzQjBhVzl1Y3k1amIyMXdZWEpoZEc5eUlDRTlQU0IyYjJsa0lEQXBJSFJvYVhNdVkyOXRjR0Z5WVhSdmNpQTlJRzl3ZEdsdmJuTXVZMjl0Y0dGeVlYUnZjanRjYmlBZ0lDQjBhR2x6TGw5eVpYTmxkQ2dwTzF4dUlDQWdJSFJvYVhNdWFXNXBkR2xoYkdsNlpTNWhjSEJzZVNoMGFHbHpMQ0JoY21kMWJXVnVkSE1wTzF4dUlDQWdJR2xtSUNodGIyUmxiSE1wSUhSb2FYTXVjbVZ6WlhRb2JXOWtaV3h6TENCZkxtVjRkR1Z1WkNoN2MybHNaVzUwT2lCMGNuVmxmU3dnYjNCMGFXOXVjeWtwTzF4dUlDQjlPMXh1WEc0Z0lDOHZJRVJsWm1GMWJIUWdiM0IwYVc5dWN5Qm1iM0lnWUVOdmJHeGxZM1JwYjI0amMyVjBZQzVjYmlBZ2RtRnlJSE5sZEU5d2RHbHZibk1nUFNCN1lXUmtPaUIwY25WbExDQnlaVzF2ZG1VNklIUnlkV1VzSUcxbGNtZGxPaUIwY25WbGZUdGNiaUFnZG1GeUlHRmtaRTl3ZEdsdmJuTWdQU0I3WVdSa09pQjBjblZsTENCeVpXMXZkbVU2SUdaaGJITmxmVHRjYmx4dUlDQXZMeUJFWldacGJtVWdkR2hsSUVOdmJHeGxZM1JwYjI0bmN5QnBibWhsY21sMFlXSnNaU0J0WlhSb2IyUnpMbHh1SUNCZkxtVjRkR1Z1WkNoRGIyeHNaV04wYVc5dUxuQnliM1J2ZEhsd1pTd2dSWFpsYm5SekxDQjdYRzVjYmlBZ0lDQXZMeUJVYUdVZ1pHVm1ZWFZzZENCdGIyUmxiQ0JtYjNJZ1lTQmpiMnhzWldOMGFXOXVJR2x6SUdwMWMzUWdZU0FxS2tKaFkydGliMjVsTGsxdlpHVnNLaW91WEc0Z0lDQWdMeThnVkdocGN5QnphRzkxYkdRZ1ltVWdiM1psY25KcFpHUmxiaUJwYmlCdGIzTjBJR05oYzJWekxseHVJQ0FnSUcxdlpHVnNPaUJOYjJSbGJDeGNibHh1SUNBZ0lDOHZJRWx1YVhScFlXeHBlbVVnYVhNZ1lXNGdaVzF3ZEhrZ1puVnVZM1JwYjI0Z1lua2daR1ZtWVhWc2RDNGdUM1psY25KcFpHVWdhWFFnZDJsMGFDQjViM1Z5SUc5M2JseHVJQ0FnSUM4dklHbHVhWFJwWVd4cGVtRjBhVzl1SUd4dloybGpMbHh1SUNBZ0lHbHVhWFJwWVd4cGVtVTZJR1oxYm1OMGFXOXVLQ2w3ZlN4Y2JseHVJQ0FnSUM4dklGUm9aU0JLVTA5T0lISmxjSEpsYzJWdWRHRjBhVzl1SUc5bUlHRWdRMjlzYkdWamRHbHZiaUJwY3lCaGJpQmhjbkpoZVNCdlppQjBhR1ZjYmlBZ0lDQXZMeUJ0YjJSbGJITW5JR0YwZEhKcFluVjBaWE11WEc0Z0lDQWdkRzlLVTA5T09pQm1kVzVqZEdsdmJpaHZjSFJwYjI1ektTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z2RHaHBjeTV0WVhBb1puVnVZM1JwYjI0b2JXOWtaV3dwSUhzZ2NtVjBkWEp1SUcxdlpHVnNMblJ2U2xOUFRpaHZjSFJwYjI1ektUc2dmU2s3WEc0Z0lDQWdmU3hjYmx4dUlDQWdJQzh2SUZCeWIzaDVJR0JDWVdOclltOXVaUzV6ZVc1allDQmllU0JrWldaaGRXeDBMbHh1SUNBZ0lITjVibU02SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0FnSUNBZ2NtVjBkWEp1SUVKaFkydGliMjVsTG5ONWJtTXVZWEJ3Ykhrb2RHaHBjeXdnWVhKbmRXMWxiblJ6S1R0Y2JpQWdJQ0I5TEZ4dVhHNGdJQ0FnTHk4Z1FXUmtJR0VnYlc5a1pXd3NJRzl5SUd4cGMzUWdiMllnYlc5a1pXeHpJSFJ2SUhSb1pTQnpaWFF1WEc0Z0lDQWdZV1JrT2lCbWRXNWpkR2x2YmlodGIyUmxiSE1zSUc5d2RHbHZibk1wSUh0Y2JpQWdJQ0FnSUhKbGRIVnliaUIwYUdsekxuTmxkQ2h0YjJSbGJITXNJRjh1WlhoMFpXNWtLSHR0WlhKblpUb2dabUZzYzJWOUxDQnZjSFJwYjI1ekxDQmhaR1JQY0hScGIyNXpLU2s3WEc0Z0lDQWdmU3hjYmx4dUlDQWdJQzh2SUZKbGJXOTJaU0JoSUcxdlpHVnNMQ0J2Y2lCaElHeHBjM1FnYjJZZ2JXOWtaV3h6SUdaeWIyMGdkR2hsSUhObGRDNWNiaUFnSUNCeVpXMXZkbVU2SUdaMWJtTjBhVzl1S0cxdlpHVnNjeXdnYjNCMGFXOXVjeWtnZTF4dUlDQWdJQ0FnYjNCMGFXOXVjeUE5SUY4dVpYaDBaVzVrS0h0OUxDQnZjSFJwYjI1ektUdGNiaUFnSUNBZ0lIWmhjaUJ6YVc1bmRXeGhjaUE5SUNGZkxtbHpRWEp5WVhrb2JXOWtaV3h6S1R0Y2JpQWdJQ0FnSUcxdlpHVnNjeUE5SUhOcGJtZDFiR0Z5SUQ4Z1cyMXZaR1ZzYzEwZ09pQmZMbU5zYjI1bEtHMXZaR1ZzY3lrN1hHNGdJQ0FnSUNCMllYSWdjbVZ0YjNabFpDQTlJSFJvYVhNdVgzSmxiVzkyWlUxdlpHVnNjeWh0YjJSbGJITXNJRzl3ZEdsdmJuTXBPMXh1SUNBZ0lDQWdhV1lnS0NGdmNIUnBiMjV6TG5OcGJHVnVkQ0FtSmlCeVpXMXZkbVZrS1NCMGFHbHpMblJ5YVdkblpYSW9KM1Z3WkdGMFpTY3NJSFJvYVhNc0lHOXdkR2x2Ym5NcE8xeHVJQ0FnSUNBZ2NtVjBkWEp1SUhOcGJtZDFiR0Z5SUQ4Z2NtVnRiM1psWkZzd1hTQTZJSEpsYlc5MlpXUTdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lDOHZJRlZ3WkdGMFpTQmhJR052Ykd4bFkzUnBiMjRnWW5rZ1lITmxkR0F0YVc1bklHRWdibVYzSUd4cGMzUWdiMllnYlc5a1pXeHpMQ0JoWkdScGJtY2dibVYzSUc5dVpYTXNYRzRnSUNBZ0x5OGdjbVZ0YjNacGJtY2diVzlrWld4eklIUm9ZWFFnWVhKbElHNXZJR3h2Ym1kbGNpQndjbVZ6Wlc1MExDQmhibVFnYldWeVoybHVaeUJ0YjJSbGJITWdkR2hoZEZ4dUlDQWdJQzh2SUdGc2NtVmhaSGtnWlhocGMzUWdhVzRnZEdobElHTnZiR3hsWTNScGIyNHNJR0Z6SUc1bFkyVnpjMkZ5ZVM0Z1UybHRhV3hoY2lCMGJ5QXFLazF2WkdWc0kzTmxkQ29xTEZ4dUlDQWdJQzh2SUhSb1pTQmpiM0psSUc5d1pYSmhkR2x2YmlCbWIzSWdkWEJrWVhScGJtY2dkR2hsSUdSaGRHRWdZMjl1ZEdGcGJtVmtJR0o1SUhSb1pTQmpiMnhzWldOMGFXOXVMbHh1SUNBZ0lITmxkRG9nWm5WdVkzUnBiMjRvYlc5a1pXeHpMQ0J2Y0hScGIyNXpLU0I3WEc0Z0lDQWdJQ0J2Y0hScGIyNXpJRDBnWHk1a1pXWmhkV3gwY3loN2ZTd2diM0IwYVc5dWN5d2djMlYwVDNCMGFXOXVjeWs3WEc0Z0lDQWdJQ0JwWmlBb2IzQjBhVzl1Y3k1d1lYSnpaU0FtSmlBaGRHaHBjeTVmYVhOTmIyUmxiQ2h0YjJSbGJITXBLU0J0YjJSbGJITWdQU0IwYUdsekxuQmhjbk5sS0cxdlpHVnNjeXdnYjNCMGFXOXVjeWs3WEc0Z0lDQWdJQ0IyWVhJZ2MybHVaM1ZzWVhJZ1BTQWhYeTVwYzBGeWNtRjVLRzF2WkdWc2N5azdYRzRnSUNBZ0lDQnRiMlJsYkhNZ1BTQnphVzVuZFd4aGNpQS9JQ2h0YjJSbGJITWdQeUJiYlc5a1pXeHpYU0E2SUZ0ZEtTQTZJRzF2WkdWc2N5NXpiR2xqWlNncE8xeHVJQ0FnSUNBZ2RtRnlJR2xrTENCdGIyUmxiQ3dnWVhSMGNuTXNJR1Y0YVhOMGFXNW5MQ0J6YjNKME8xeHVJQ0FnSUNBZ2RtRnlJR0YwSUQwZ2IzQjBhVzl1Y3k1aGREdGNiaUFnSUNBZ0lHbG1JQ2hoZENBaFBTQnVkV3hzS1NCaGRDQTlJQ3RoZER0Y2JpQWdJQ0FnSUdsbUlDaGhkQ0E4SURBcElHRjBJQ3M5SUhSb2FYTXViR1Z1WjNSb0lDc2dNVHRjYmlBZ0lDQWdJSFpoY2lCemIzSjBZV0pzWlNBOUlIUm9hWE11WTI5dGNHRnlZWFJ2Y2lBbUppQW9ZWFFnUFQwZ2JuVnNiQ2tnSmlZZ2IzQjBhVzl1Y3k1emIzSjBJQ0U5UFNCbVlXeHpaVHRjYmlBZ0lDQWdJSFpoY2lCemIzSjBRWFIwY2lBOUlGOHVhWE5UZEhKcGJtY29kR2hwY3k1amIyMXdZWEpoZEc5eUtTQS9JSFJvYVhNdVkyOXRjR0Z5WVhSdmNpQTZJRzUxYkd3N1hHNGdJQ0FnSUNCMllYSWdkRzlCWkdRZ1BTQmJYU3dnZEc5U1pXMXZkbVVnUFNCYlhTd2diVzlrWld4TllYQWdQU0I3ZlR0Y2JpQWdJQ0FnSUhaaGNpQmhaR1FnUFNCdmNIUnBiMjV6TG1Ga1pDd2diV1Z5WjJVZ1BTQnZjSFJwYjI1ekxtMWxjbWRsTENCeVpXMXZkbVVnUFNCdmNIUnBiMjV6TG5KbGJXOTJaVHRjYmlBZ0lDQWdJSFpoY2lCdmNtUmxjaUE5SUNGemIzSjBZV0pzWlNBbUppQmhaR1FnSmlZZ2NtVnRiM1psSUQ4Z1cxMGdPaUJtWVd4elpUdGNiaUFnSUNBZ0lIWmhjaUJ2Y21SbGNrTm9ZVzVuWldRZ1BTQm1ZV3h6WlR0Y2JseHVJQ0FnSUNBZ0x5OGdWSFZ5YmlCaVlYSmxJRzlpYW1WamRITWdhVzUwYnlCdGIyUmxiQ0J5WldabGNtVnVZMlZ6TENCaGJtUWdjSEpsZG1WdWRDQnBiblpoYkdsa0lHMXZaR1ZzYzF4dUlDQWdJQ0FnTHk4Z1puSnZiU0JpWldsdVp5QmhaR1JsWkM1Y2JpQWdJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z2JXOWtaV3h6TG14bGJtZDBhRHNnYVNzcktTQjdYRzRnSUNBZ0lDQWdJR0YwZEhKeklEMGdiVzlrWld4elcybGRPMXh1WEc0Z0lDQWdJQ0FnSUM4dklFbG1JR0VnWkhWd2JHbGpZWFJsSUdseklHWnZkVzVrTENCd2NtVjJaVzUwSUdsMElHWnliMjBnWW1WcGJtY2dZV1JrWldRZ1lXNWtYRzRnSUNBZ0lDQWdJQzh2SUc5d2RHbHZibUZzYkhrZ2JXVnlaMlVnYVhRZ2FXNTBieUIwYUdVZ1pYaHBjM1JwYm1jZ2JXOWtaV3d1WEc0Z0lDQWdJQ0FnSUdsbUlDaGxlR2x6ZEdsdVp5QTlJSFJvYVhNdVoyVjBLR0YwZEhKektTa2dlMXh1SUNBZ0lDQWdJQ0FnSUdsbUlDaHlaVzF2ZG1VcElHMXZaR1ZzVFdGd1cyVjRhWE4wYVc1bkxtTnBaRjBnUFNCMGNuVmxPMXh1SUNBZ0lDQWdJQ0FnSUdsbUlDaHRaWEpuWlNBbUppQmhkSFJ5Y3lBaFBUMGdaWGhwYzNScGJtY3BJSHRjYmlBZ0lDQWdJQ0FnSUNBZ0lHRjBkSEp6SUQwZ2RHaHBjeTVmYVhOTmIyUmxiQ2hoZEhSeWN5a2dQeUJoZEhSeWN5NWhkSFJ5YVdKMWRHVnpJRG9nWVhSMGNuTTdYRzRnSUNBZ0lDQWdJQ0FnSUNCcFppQW9iM0IwYVc5dWN5NXdZWEp6WlNrZ1lYUjBjbk1nUFNCbGVHbHpkR2x1Wnk1d1lYSnpaU2hoZEhSeWN5d2diM0IwYVc5dWN5azdYRzRnSUNBZ0lDQWdJQ0FnSUNCbGVHbHpkR2x1Wnk1elpYUW9ZWFIwY25Nc0lHOXdkR2x2Ym5NcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnYVdZZ0tITnZjblJoWW14bElDWW1JQ0Z6YjNKMElDWW1JR1Y0YVhOMGFXNW5MbWhoYzBOb1lXNW5aV1FvYzI5eWRFRjBkSElwS1NCemIzSjBJRDBnZEhKMVpUdGNiaUFnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUNBZ2JXOWtaV3h6VzJsZElEMGdaWGhwYzNScGJtYzdYRzVjYmlBZ0lDQWdJQ0FnTHk4Z1NXWWdkR2hwY3lCcGN5QmhJRzVsZHl3Z2RtRnNhV1FnYlc5a1pXd3NJSEIxYzJnZ2FYUWdkRzhnZEdobElHQjBiMEZrWkdBZ2JHbHpkQzVjYmlBZ0lDQWdJQ0FnZlNCbGJITmxJR2xtSUNoaFpHUXBJSHRjYmlBZ0lDQWdJQ0FnSUNCdGIyUmxiQ0E5SUcxdlpHVnNjMXRwWFNBOUlIUm9hWE11WDNCeVpYQmhjbVZOYjJSbGJDaGhkSFJ5Y3l3Z2IzQjBhVzl1Y3lrN1hHNGdJQ0FnSUNBZ0lDQWdhV1lnS0NGdGIyUmxiQ2tnWTI5dWRHbHVkV1U3WEc0Z0lDQWdJQ0FnSUNBZ2RHOUJaR1F1Y0hWemFDaHRiMlJsYkNrN1hHNGdJQ0FnSUNBZ0lDQWdkR2hwY3k1ZllXUmtVbVZtWlhKbGJtTmxLRzF2WkdWc0xDQnZjSFJwYjI1ektUdGNiaUFnSUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0FnSUM4dklFUnZJRzV2ZENCaFpHUWdiWFZzZEdsd2JHVWdiVzlrWld4eklIZHBkR2dnZEdobElITmhiV1VnWUdsa1lDNWNiaUFnSUNBZ0lDQWdiVzlrWld3Z1BTQmxlR2x6ZEdsdVp5QjhmQ0J0YjJSbGJEdGNiaUFnSUNBZ0lDQWdhV1lnS0NGdGIyUmxiQ2tnWTI5dWRHbHVkV1U3WEc0Z0lDQWdJQ0FnSUdsa0lEMGdkR2hwY3k1dGIyUmxiRWxrS0cxdlpHVnNMbUYwZEhKcFluVjBaWE1wTzF4dUlDQWdJQ0FnSUNCcFppQW9iM0prWlhJZ0ppWWdLRzF2WkdWc0xtbHpUbVYzS0NrZ2ZId2dJVzF2WkdWc1RXRndXMmxrWFNrcElIdGNiaUFnSUNBZ0lDQWdJQ0J2Y21SbGNpNXdkWE5vS0cxdlpHVnNLVHRjYmx4dUlDQWdJQ0FnSUNBZ0lDOHZJRU5vWldOcklIUnZJSE5sWlNCcFppQjBhR2x6SUdseklHRmpkSFZoYkd4NUlHRWdibVYzSUcxdlpHVnNJR0YwSUhSb2FYTWdhVzVrWlhndVhHNGdJQ0FnSUNBZ0lDQWdiM0prWlhKRGFHRnVaMlZrSUQwZ2IzSmtaWEpEYUdGdVoyVmtJSHg4SUNGMGFHbHpMbTF2WkdWc2MxdHBYU0I4ZkNCdGIyUmxiQzVqYVdRZ0lUMDlJSFJvYVhNdWJXOWtaV3h6VzJsZExtTnBaRHRjYmlBZ0lDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNBZ0lHMXZaR1ZzVFdGd1cybGtYU0E5SUhSeWRXVTdYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJQzh2SUZKbGJXOTJaU0J1YjI1bGVHbHpkR1Z1ZENCdGIyUmxiSE1nYVdZZ1lYQndjbTl3Y21saGRHVXVYRzRnSUNBZ0lDQnBaaUFvY21WdGIzWmxLU0I3WEc0Z0lDQWdJQ0FnSUdadmNpQW9kbUZ5SUdrZ1BTQXdPeUJwSUR3Z2RHaHBjeTVzWlc1bmRHZzdJR2tyS3lrZ2UxeHVJQ0FnSUNBZ0lDQWdJR2xtSUNnaGJXOWtaV3hOWVhCYktHMXZaR1ZzSUQwZ2RHaHBjeTV0YjJSbGJITmJhVjBwTG1OcFpGMHBJSFJ2VW1WdGIzWmxMbkIxYzJnb2JXOWtaV3dwTzF4dUlDQWdJQ0FnSUNCOVhHNGdJQ0FnSUNBZ0lHbG1JQ2gwYjFKbGJXOTJaUzVzWlc1bmRHZ3BJSFJvYVhNdVgzSmxiVzkyWlUxdlpHVnNjeWgwYjFKbGJXOTJaU3dnYjNCMGFXOXVjeWs3WEc0Z0lDQWdJQ0I5WEc1Y2JpQWdJQ0FnSUM4dklGTmxaU0JwWmlCemIzSjBhVzVuSUdseklHNWxaV1JsWkN3Z2RYQmtZWFJsSUdCc1pXNW5kR2hnSUdGdVpDQnpjR3hwWTJVZ2FXNGdibVYzSUcxdlpHVnNjeTVjYmlBZ0lDQWdJR2xtSUNoMGIwRmtaQzVzWlc1bmRHZ2dmSHdnYjNKa1pYSkRhR0Z1WjJWa0tTQjdYRzRnSUNBZ0lDQWdJR2xtSUNoemIzSjBZV0pzWlNrZ2MyOXlkQ0E5SUhSeWRXVTdYRzRnSUNBZ0lDQWdJSFJvYVhNdWJHVnVaM1JvSUNzOUlIUnZRV1JrTG14bGJtZDBhRHRjYmlBZ0lDQWdJQ0FnYVdZZ0tHRjBJQ0U5SUc1MWJHd3BJSHRjYmlBZ0lDQWdJQ0FnSUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElIUnZRV1JrTG14bGJtZDBhRHNnYVNzcktTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCMGFHbHpMbTF2WkdWc2N5NXpjR3hwWTJVb1lYUWdLeUJwTENBd0xDQjBiMEZrWkZ0cFhTazdYRzRnSUNBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnSUNCOUlHVnNjMlVnZTF4dUlDQWdJQ0FnSUNBZ0lHbG1JQ2h2Y21SbGNpa2dkR2hwY3k1dGIyUmxiSE11YkdWdVozUm9JRDBnTUR0Y2JpQWdJQ0FnSUNBZ0lDQjJZWElnYjNKa1pYSmxaRTF2WkdWc2N5QTlJRzl5WkdWeUlIeDhJSFJ2UVdSa08xeHVJQ0FnSUNBZ0lDQWdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnYjNKa1pYSmxaRTF2WkdWc2N5NXNaVzVuZEdnN0lHa3JLeWtnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdkR2hwY3k1dGIyUmxiSE11Y0hWemFDaHZjbVJsY21Wa1RXOWtaV3h6VzJsZEtUdGNiaUFnSUNBZ0lDQWdJQ0I5WEc0Z0lDQWdJQ0FnSUgxY2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ0x5OGdVMmxzWlc1MGJIa2djMjl5ZENCMGFHVWdZMjlzYkdWamRHbHZiaUJwWmlCaGNIQnliM0J5YVdGMFpTNWNiaUFnSUNBZ0lHbG1JQ2h6YjNKMEtTQjBhR2x6TG5OdmNuUW9lM05wYkdWdWREb2dkSEoxWlgwcE8xeHVYRzRnSUNBZ0lDQXZMeUJWYm14bGMzTWdjMmxzWlc1alpXUXNJR2wwSjNNZ2RHbHRaU0IwYnlCbWFYSmxJR0ZzYkNCaGNIQnliM0J5YVdGMFpTQmhaR1F2YzI5eWRDQmxkbVZ1ZEhNdVhHNGdJQ0FnSUNCcFppQW9JVzl3ZEdsdmJuTXVjMmxzWlc1MEtTQjdYRzRnSUNBZ0lDQWdJSFpoY2lCaFpHUlBjSFJ6SUQwZ1lYUWdJVDBnYm5Wc2JDQS9JRjh1WTJ4dmJtVW9iM0IwYVc5dWN5a2dPaUJ2Y0hScGIyNXpPMXh1SUNBZ0lDQWdJQ0JtYjNJZ0tIWmhjaUJwSUQwZ01Ec2dhU0E4SUhSdlFXUmtMbXhsYm1kMGFEc2dhU3NyS1NCN1hHNGdJQ0FnSUNBZ0lDQWdhV1lnS0dGMElDRTlJRzUxYkd3cElHRmtaRTl3ZEhNdWFXNWtaWGdnUFNCaGRDQXJJR2s3WEc0Z0lDQWdJQ0FnSUNBZ0tHMXZaR1ZzSUQwZ2RHOUJaR1JiYVYwcExuUnlhV2RuWlhJb0oyRmtaQ2NzSUcxdlpHVnNMQ0IwYUdsekxDQmhaR1JQY0hSektUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdJQ0JwWmlBb2MyOXlkQ0I4ZkNCdmNtUmxja05vWVc1blpXUXBJSFJvYVhNdWRISnBaMmRsY2lnbmMyOXlkQ2NzSUhSb2FYTXNJRzl3ZEdsdmJuTXBPMXh1SUNBZ0lDQWdJQ0JwWmlBb2RHOUJaR1F1YkdWdVozUm9JSHg4SUhSdlVtVnRiM1psTG14bGJtZDBhQ2tnZEdocGN5NTBjbWxuWjJWeUtDZDFjR1JoZEdVbkxDQjBhR2x6TENCdmNIUnBiMjV6S1R0Y2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ0x5OGdVbVYwZFhKdUlIUm9aU0JoWkdSbFpDQW9iM0lnYldWeVoyVmtLU0J0YjJSbGJDQW9iM0lnYlc5a1pXeHpLUzVjYmlBZ0lDQWdJSEpsZEhWeWJpQnphVzVuZFd4aGNpQS9JRzF2WkdWc2Mxc3dYU0E2SUcxdlpHVnNjenRjYmlBZ0lDQjlMRnh1WEc0Z0lDQWdMeThnVjJobGJpQjViM1VnYUdGMlpTQnRiM0psSUdsMFpXMXpJSFJvWVc0Z2VXOTFJSGRoYm5RZ2RHOGdZV1JrSUc5eUlISmxiVzkyWlNCcGJtUnBkbWxrZFdGc2JIa3NYRzRnSUNBZ0x5OGdlVzkxSUdOaGJpQnlaWE5sZENCMGFHVWdaVzUwYVhKbElITmxkQ0IzYVhSb0lHRWdibVYzSUd4cGMzUWdiMllnYlc5a1pXeHpMQ0IzYVhSb2IzVjBJR1pwY21sdVoxeHVJQ0FnSUM4dklHRnVlU0JuY21GdWRXeGhjaUJnWVdSa1lDQnZjaUJnY21WdGIzWmxZQ0JsZG1WdWRITXVJRVpwY21WeklHQnlaWE5sZEdBZ2QyaGxiaUJtYVc1cGMyaGxaQzVjYmlBZ0lDQXZMeUJWYzJWbWRXd2dabTl5SUdKMWJHc2diM0JsY21GMGFXOXVjeUJoYm1RZ2IzQjBhVzFwZW1GMGFXOXVjeTVjYmlBZ0lDQnlaWE5sZERvZ1puVnVZM1JwYjI0b2JXOWtaV3h6TENCdmNIUnBiMjV6S1NCN1hHNGdJQ0FnSUNCdmNIUnBiMjV6SUQwZ2IzQjBhVzl1Y3lBL0lGOHVZMnh2Ym1Vb2IzQjBhVzl1Y3lrZ09pQjdmVHRjYmlBZ0lDQWdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnZEdocGN5NXRiMlJsYkhNdWJHVnVaM1JvT3lCcEt5c3BJSHRjYmlBZ0lDQWdJQ0FnZEdocGN5NWZjbVZ0YjNabFVtVm1aWEpsYm1ObEtIUm9hWE11Ylc5a1pXeHpXMmxkTENCdmNIUnBiMjV6S1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0FnSUc5d2RHbHZibk11Y0hKbGRtbHZkWE5OYjJSbGJITWdQU0IwYUdsekxtMXZaR1ZzY3p0Y2JpQWdJQ0FnSUhSb2FYTXVYM0psYzJWMEtDazdYRzRnSUNBZ0lDQnRiMlJsYkhNZ1BTQjBhR2x6TG1Ga1pDaHRiMlJsYkhNc0lGOHVaWGgwWlc1a0tIdHphV3hsYm5RNklIUnlkV1Y5TENCdmNIUnBiMjV6S1NrN1hHNGdJQ0FnSUNCcFppQW9JVzl3ZEdsdmJuTXVjMmxzWlc1MEtTQjBhR2x6TG5SeWFXZG5aWElvSjNKbGMyVjBKeXdnZEdocGN5d2diM0IwYVc5dWN5azdYRzRnSUNBZ0lDQnlaWFIxY200Z2JXOWtaV3h6TzF4dUlDQWdJSDBzWEc1Y2JpQWdJQ0F2THlCQlpHUWdZU0J0YjJSbGJDQjBieUIwYUdVZ1pXNWtJRzltSUhSb1pTQmpiMnhzWldOMGFXOXVMbHh1SUNBZ0lIQjFjMmc2SUdaMWJtTjBhVzl1S0cxdlpHVnNMQ0J2Y0hScGIyNXpLU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdkR2hwY3k1aFpHUW9iVzlrWld3c0lGOHVaWGgwWlc1a0tIdGhkRG9nZEdocGN5NXNaVzVuZEdoOUxDQnZjSFJwYjI1ektTazdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lDOHZJRkpsYlc5MlpTQmhJRzF2WkdWc0lHWnliMjBnZEdobElHVnVaQ0J2WmlCMGFHVWdZMjlzYkdWamRHbHZiaTVjYmlBZ0lDQndiM0E2SUdaMWJtTjBhVzl1S0c5d2RHbHZibk1wSUh0Y2JpQWdJQ0FnSUhaaGNpQnRiMlJsYkNBOUlIUm9hWE11WVhRb2RHaHBjeTVzWlc1bmRHZ2dMU0F4S1R0Y2JpQWdJQ0FnSUhKbGRIVnliaUIwYUdsekxuSmxiVzkyWlNodGIyUmxiQ3dnYjNCMGFXOXVjeWs3WEc0Z0lDQWdmU3hjYmx4dUlDQWdJQzh2SUVGa1pDQmhJRzF2WkdWc0lIUnZJSFJvWlNCaVpXZHBibTVwYm1jZ2IyWWdkR2hsSUdOdmJHeGxZM1JwYjI0dVhHNGdJQ0FnZFc1emFHbG1kRG9nWm5WdVkzUnBiMjRvYlc5a1pXd3NJRzl3ZEdsdmJuTXBJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQjBhR2x6TG1Ga1pDaHRiMlJsYkN3Z1h5NWxlSFJsYm1Rb2UyRjBPaUF3ZlN3Z2IzQjBhVzl1Y3lrcE8xeHVJQ0FnSUgwc1hHNWNiaUFnSUNBdkx5QlNaVzF2ZG1VZ1lTQnRiMlJsYkNCbWNtOXRJSFJvWlNCaVpXZHBibTVwYm1jZ2IyWWdkR2hsSUdOdmJHeGxZM1JwYjI0dVhHNGdJQ0FnYzJocFpuUTZJR1oxYm1OMGFXOXVLRzl3ZEdsdmJuTXBJSHRjYmlBZ0lDQWdJSFpoY2lCdGIyUmxiQ0E5SUhSb2FYTXVZWFFvTUNrN1hHNGdJQ0FnSUNCeVpYUjFjbTRnZEdocGN5NXlaVzF2ZG1Vb2JXOWtaV3dzSUc5d2RHbHZibk1wTzF4dUlDQWdJSDBzWEc1Y2JpQWdJQ0F2THlCVGJHbGpaU0J2ZFhRZ1lTQnpkV0l0WVhKeVlYa2diMllnYlc5a1pXeHpJR1p5YjIwZ2RHaGxJR052Ykd4bFkzUnBiMjR1WEc0Z0lDQWdjMnhwWTJVNklHWjFibU4wYVc5dUtDa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlITnNhV05sTG1Gd2NHeDVLSFJvYVhNdWJXOWtaV3h6TENCaGNtZDFiV1Z1ZEhNcE8xeHVJQ0FnSUgwc1hHNWNiaUFnSUNBdkx5QkhaWFFnWVNCdGIyUmxiQ0JtY205dElIUm9aU0J6WlhRZ1lua2dhV1F1WEc0Z0lDQWdaMlYwT2lCbWRXNWpkR2x2Ymlodlltb3BJSHRjYmlBZ0lDQWdJR2xtSUNodlltb2dQVDBnYm5Wc2JDa2djbVYwZFhKdUlIWnZhV1FnTUR0Y2JpQWdJQ0FnSUhaaGNpQnBaQ0E5SUhSb2FYTXViVzlrWld4SlpDaDBhR2x6TGw5cGMwMXZaR1ZzS0c5aWFpa2dQeUJ2WW1vdVlYUjBjbWxpZFhSbGN5QTZJRzlpYWlrN1hHNGdJQ0FnSUNCeVpYUjFjbTRnZEdocGN5NWZZbmxKWkZ0dlltcGRJSHg4SUhSb2FYTXVYMko1U1dSYmFXUmRJSHg4SUhSb2FYTXVYMko1U1dSYmIySnFMbU5wWkYwN1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUM4dklFZGxkQ0IwYUdVZ2JXOWtaV3dnWVhRZ2RHaGxJR2RwZG1WdUlHbHVaR1Y0TGx4dUlDQWdJR0YwT2lCbWRXNWpkR2x2YmlocGJtUmxlQ2tnZTF4dUlDQWdJQ0FnYVdZZ0tHbHVaR1Y0SUR3Z01Da2dhVzVrWlhnZ0t6MGdkR2hwY3k1c1pXNW5kR2c3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdkR2hwY3k1dGIyUmxiSE5iYVc1a1pYaGRPMXh1SUNBZ0lIMHNYRzVjYmlBZ0lDQXZMeUJTWlhSMWNtNGdiVzlrWld4eklIZHBkR2dnYldGMFkyaHBibWNnWVhSMGNtbGlkWFJsY3k0Z1ZYTmxablZzSUdadmNpQnphVzF3YkdVZ1kyRnpaWE1nYjJaY2JpQWdJQ0F2THlCZ1ptbHNkR1Z5WUM1Y2JpQWdJQ0IzYUdWeVpUb2dablZ1WTNScGIyNG9ZWFIwY25Nc0lHWnBjbk4wS1NCN1hHNGdJQ0FnSUNCMllYSWdiV0YwWTJobGN5QTlJRjh1YldGMFkyaGxjeWhoZEhSeWN5azdYRzRnSUNBZ0lDQnlaWFIxY200Z2RHaHBjMXRtYVhKemRDQS9JQ2RtYVc1a0p5QTZJQ2RtYVd4MFpYSW5YU2htZFc1amRHbHZiaWh0YjJSbGJDa2dlMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdiV0YwWTJobGN5aHRiMlJsYkM1aGRIUnlhV0oxZEdWektUdGNiaUFnSUNBZ0lIMHBPMXh1SUNBZ0lIMHNYRzVjYmlBZ0lDQXZMeUJTWlhSMWNtNGdkR2hsSUdacGNuTjBJRzF2WkdWc0lIZHBkR2dnYldGMFkyaHBibWNnWVhSMGNtbGlkWFJsY3k0Z1ZYTmxablZzSUdadmNpQnphVzF3YkdVZ1kyRnpaWE5jYmlBZ0lDQXZMeUJ2WmlCZ1ptbHVaR0F1WEc0Z0lDQWdabWx1WkZkb1pYSmxPaUJtZFc1amRHbHZiaWhoZEhSeWN5a2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlIUm9hWE11ZDJobGNtVW9ZWFIwY25Nc0lIUnlkV1VwTzF4dUlDQWdJSDBzWEc1Y2JpQWdJQ0F2THlCR2IzSmpaU0IwYUdVZ1kyOXNiR1ZqZEdsdmJpQjBieUJ5WlMxemIzSjBJR2wwYzJWc1ppNGdXVzkxSUdSdmJpZDBJRzVsWldRZ2RHOGdZMkZzYkNCMGFHbHpJSFZ1WkdWeVhHNGdJQ0FnTHk4Z2JtOXliV0ZzSUdOcGNtTjFiWE4wWVc1alpYTXNJR0Z6SUhSb1pTQnpaWFFnZDJsc2JDQnRZV2x1ZEdGcGJpQnpiM0owSUc5eVpHVnlJR0Z6SUdWaFkyZ2dhWFJsYlZ4dUlDQWdJQzh2SUdseklHRmtaR1ZrTGx4dUlDQWdJSE52Y25RNklHWjFibU4wYVc5dUtHOXdkR2x2Ym5NcElIdGNiaUFnSUNBZ0lHbG1JQ2doZEdocGN5NWpiMjF3WVhKaGRHOXlLU0IwYUhKdmR5QnVaWGNnUlhKeWIzSW9KME5oYm01dmRDQnpiM0owSUdFZ2MyVjBJSGRwZEdodmRYUWdZU0JqYjIxd1lYSmhkRzl5SnlrN1hHNGdJQ0FnSUNCdmNIUnBiMjV6SUh4OElDaHZjSFJwYjI1eklEMGdlMzBwTzF4dVhHNGdJQ0FnSUNBdkx5QlNkVzRnYzI5eWRDQmlZWE5sWkNCdmJpQjBlWEJsSUc5bUlHQmpiMjF3WVhKaGRHOXlZQzVjYmlBZ0lDQWdJR2xtSUNoZkxtbHpVM1J5YVc1bktIUm9hWE11WTI5dGNHRnlZWFJ2Y2lrZ2ZId2dkR2hwY3k1amIyMXdZWEpoZEc5eUxteGxibWQwYUNBOVBUMGdNU2tnZTF4dUlDQWdJQ0FnSUNCMGFHbHpMbTF2WkdWc2N5QTlJSFJvYVhNdWMyOXlkRUo1S0hSb2FYTXVZMjl0Y0dGeVlYUnZjaXdnZEdocGN5azdYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ0lDQjBhR2x6TG0xdlpHVnNjeTV6YjNKMEtGOHVZbWx1WkNoMGFHbHpMbU52YlhCaGNtRjBiM0lzSUhSb2FYTXBLVHRjYmlBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnYVdZZ0tDRnZjSFJwYjI1ekxuTnBiR1Z1ZENrZ2RHaHBjeTUwY21sbloyVnlLQ2R6YjNKMEp5d2dkR2hwY3l3Z2IzQjBhVzl1Y3lrN1hHNGdJQ0FnSUNCeVpYUjFjbTRnZEdocGN6dGNiaUFnSUNCOUxGeHVYRzRnSUNBZ0x5OGdVR3gxWTJzZ1lXNGdZWFIwY21saWRYUmxJR1p5YjIwZ1pXRmphQ0J0YjJSbGJDQnBiaUIwYUdVZ1kyOXNiR1ZqZEdsdmJpNWNiaUFnSUNCd2JIVmphem9nWm5WdVkzUnBiMjRvWVhSMGNpa2dlMXh1SUNBZ0lDQWdjbVYwZFhKdUlGOHVhVzUyYjJ0bEtIUm9hWE11Ylc5a1pXeHpMQ0FuWjJWMEp5d2dZWFIwY2lrN1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUM4dklFWmxkR05vSUhSb1pTQmtaV1poZFd4MElITmxkQ0J2WmlCdGIyUmxiSE1nWm05eUlIUm9hWE1nWTI5c2JHVmpkR2x2Yml3Z2NtVnpaWFIwYVc1bklIUm9aVnh1SUNBZ0lDOHZJR052Ykd4bFkzUnBiMjRnZDJobGJpQjBhR1Y1SUdGeWNtbDJaUzRnU1dZZ1lISmxjMlYwT2lCMGNuVmxZQ0JwY3lCd1lYTnpaV1FzSUhSb1pTQnlaWE53YjI1elpWeHVJQ0FnSUM4dklHUmhkR0VnZDJsc2JDQmlaU0J3WVhOelpXUWdkR2h5YjNWbmFDQjBhR1VnWUhKbGMyVjBZQ0J0WlhSb2IyUWdhVzV6ZEdWaFpDQnZaaUJnYzJWMFlDNWNiaUFnSUNCbVpYUmphRG9nWm5WdVkzUnBiMjRvYjNCMGFXOXVjeWtnZTF4dUlDQWdJQ0FnYjNCMGFXOXVjeUE5SUY4dVpYaDBaVzVrS0h0d1lYSnpaVG9nZEhKMVpYMHNJRzl3ZEdsdmJuTXBPMXh1SUNBZ0lDQWdkbUZ5SUhOMVkyTmxjM01nUFNCdmNIUnBiMjV6TG5OMVkyTmxjM003WEc0Z0lDQWdJQ0IyWVhJZ1kyOXNiR1ZqZEdsdmJpQTlJSFJvYVhNN1hHNGdJQ0FnSUNCdmNIUnBiMjV6TG5OMVkyTmxjM01nUFNCbWRXNWpkR2x2YmloeVpYTndLU0I3WEc0Z0lDQWdJQ0FnSUhaaGNpQnRaWFJvYjJRZ1BTQnZjSFJwYjI1ekxuSmxjMlYwSUQ4Z0ozSmxjMlYwSnlBNklDZHpaWFFuTzF4dUlDQWdJQ0FnSUNCamIyeHNaV04wYVc5dVcyMWxkR2h2WkYwb2NtVnpjQ3dnYjNCMGFXOXVjeWs3WEc0Z0lDQWdJQ0FnSUdsbUlDaHpkV05qWlhOektTQnpkV05qWlhOekxtTmhiR3dvYjNCMGFXOXVjeTVqYjI1MFpYaDBMQ0JqYjJ4c1pXTjBhVzl1TENCeVpYTndMQ0J2Y0hScGIyNXpLVHRjYmlBZ0lDQWdJQ0FnWTI5c2JHVmpkR2x2Ymk1MGNtbG5aMlZ5S0NkemVXNWpKeXdnWTI5c2JHVmpkR2x2Yml3Z2NtVnpjQ3dnYjNCMGFXOXVjeWs3WEc0Z0lDQWdJQ0I5TzF4dUlDQWdJQ0FnZDNKaGNFVnljbTl5S0hSb2FYTXNJRzl3ZEdsdmJuTXBPMXh1SUNBZ0lDQWdjbVYwZFhKdUlIUm9hWE11YzNsdVl5Z25jbVZoWkNjc0lIUm9hWE1zSUc5d2RHbHZibk1wTzF4dUlDQWdJSDBzWEc1Y2JpQWdJQ0F2THlCRGNtVmhkR1VnWVNCdVpYY2dhVzV6ZEdGdVkyVWdiMllnWVNCdGIyUmxiQ0JwYmlCMGFHbHpJR052Ykd4bFkzUnBiMjR1SUVGa1pDQjBhR1VnYlc5a1pXd2dkRzhnZEdobFhHNGdJQ0FnTHk4Z1kyOXNiR1ZqZEdsdmJpQnBiVzFsWkdsaGRHVnNlU3dnZFc1c1pYTnpJR0IzWVdsME9pQjBjblZsWUNCcGN5QndZWE56WldRc0lHbHVJSGRvYVdOb0lHTmhjMlVnZDJWY2JpQWdJQ0F2THlCM1lXbDBJR1p2Y2lCMGFHVWdjMlZ5ZG1WeUlIUnZJR0ZuY21WbExseHVJQ0FnSUdOeVpXRjBaVG9nWm5WdVkzUnBiMjRvYlc5a1pXd3NJRzl3ZEdsdmJuTXBJSHRjYmlBZ0lDQWdJRzl3ZEdsdmJuTWdQU0J2Y0hScGIyNXpJRDhnWHk1amJHOXVaU2h2Y0hScGIyNXpLU0E2SUh0OU8xeHVJQ0FnSUNBZ2RtRnlJSGRoYVhRZ1BTQnZjSFJwYjI1ekxuZGhhWFE3WEc0Z0lDQWdJQ0J0YjJSbGJDQTlJSFJvYVhNdVgzQnlaWEJoY21WTmIyUmxiQ2h0YjJSbGJDd2diM0IwYVc5dWN5azdYRzRnSUNBZ0lDQnBaaUFvSVcxdlpHVnNLU0J5WlhSMWNtNGdabUZzYzJVN1hHNGdJQ0FnSUNCcFppQW9JWGRoYVhRcElIUm9hWE11WVdSa0tHMXZaR1ZzTENCdmNIUnBiMjV6S1R0Y2JpQWdJQ0FnSUhaaGNpQmpiMnhzWldOMGFXOXVJRDBnZEdocGN6dGNiaUFnSUNBZ0lIWmhjaUJ6ZFdOalpYTnpJRDBnYjNCMGFXOXVjeTV6ZFdOalpYTnpPMXh1SUNBZ0lDQWdiM0IwYVc5dWN5NXpkV05qWlhOeklEMGdablZ1WTNScGIyNG9iVzlrWld3c0lISmxjM0FzSUdOaGJHeGlZV05yVDNCMGN5a2dlMXh1SUNBZ0lDQWdJQ0JwWmlBb2QyRnBkQ2tnWTI5c2JHVmpkR2x2Ymk1aFpHUW9iVzlrWld3c0lHTmhiR3hpWVdOclQzQjBjeWs3WEc0Z0lDQWdJQ0FnSUdsbUlDaHpkV05qWlhOektTQnpkV05qWlhOekxtTmhiR3dvWTJGc2JHSmhZMnRQY0hSekxtTnZiblJsZUhRc0lHMXZaR1ZzTENCeVpYTndMQ0JqWVd4c1ltRmphMDl3ZEhNcE8xeHVJQ0FnSUNBZ2ZUdGNiaUFnSUNBZ0lHMXZaR1ZzTG5OaGRtVW9iblZzYkN3Z2IzQjBhVzl1Y3lrN1hHNGdJQ0FnSUNCeVpYUjFjbTRnYlc5a1pXdzdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lDOHZJQ29xY0dGeWMyVXFLaUJqYjI1MlpYSjBjeUJoSUhKbGMzQnZibk5sSUdsdWRHOGdZU0JzYVhOMElHOW1JRzF2WkdWc2N5QjBieUJpWlNCaFpHUmxaQ0IwYnlCMGFHVmNiaUFnSUNBdkx5QmpiMnhzWldOMGFXOXVMaUJVYUdVZ1pHVm1ZWFZzZENCcGJYQnNaVzFsYm5SaGRHbHZiaUJwY3lCcWRYTjBJSFJ2SUhCaGMzTWdhWFFnZEdoeWIzVm5hQzVjYmlBZ0lDQndZWEp6WlRvZ1puVnVZM1JwYjI0b2NtVnpjQ3dnYjNCMGFXOXVjeWtnZTF4dUlDQWdJQ0FnY21WMGRYSnVJSEpsYzNBN1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUM4dklFTnlaV0YwWlNCaElHNWxkeUJqYjJ4c1pXTjBhVzl1SUhkcGRHZ2dZVzRnYVdSbGJuUnBZMkZzSUd4cGMzUWdiMllnYlc5a1pXeHpJR0Z6SUhSb2FYTWdiMjVsTGx4dUlDQWdJR05zYjI1bE9pQm1kVzVqZEdsdmJpZ3BJSHRjYmlBZ0lDQWdJSEpsZEhWeWJpQnVaWGNnZEdocGN5NWpiMjV6ZEhKMVkzUnZjaWgwYUdsekxtMXZaR1ZzY3l3Z2UxeHVJQ0FnSUNBZ0lDQnRiMlJsYkRvZ2RHaHBjeTV0YjJSbGJDeGNiaUFnSUNBZ0lDQWdZMjl0Y0dGeVlYUnZjam9nZEdocGN5NWpiMjF3WVhKaGRHOXlYRzRnSUNBZ0lDQjlLVHRjYmlBZ0lDQjlMRnh1WEc0Z0lDQWdMeThnUkdWbWFXNWxJR2h2ZHlCMGJ5QjFibWx4ZFdWc2VTQnBaR1Z1ZEdsbWVTQnRiMlJsYkhNZ2FXNGdkR2hsSUdOdmJHeGxZM1JwYjI0dVhHNGdJQ0FnYlc5a1pXeEpaRG9nWm5WdVkzUnBiMjRnS0dGMGRISnpLU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdZWFIwY25OYmRHaHBjeTV0YjJSbGJDNXdjbTkwYjNSNWNHVXVhV1JCZEhSeWFXSjFkR1VnZkh3Z0oybGtKMTA3WEc0Z0lDQWdmU3hjYmx4dUlDQWdJQzh2SUZCeWFYWmhkR1VnYldWMGFHOWtJSFJ2SUhKbGMyVjBJR0ZzYkNCcGJuUmxjbTVoYkNCemRHRjBaUzRnUTJGc2JHVmtJSGRvWlc0Z2RHaGxJR052Ykd4bFkzUnBiMjVjYmlBZ0lDQXZMeUJwY3lCbWFYSnpkQ0JwYm1sMGFXRnNhWHBsWkNCdmNpQnlaWE5sZEM1Y2JpQWdJQ0JmY21WelpYUTZJR1oxYm1OMGFXOXVLQ2tnZTF4dUlDQWdJQ0FnZEdocGN5NXNaVzVuZEdnZ1BTQXdPMXh1SUNBZ0lDQWdkR2hwY3k1dGIyUmxiSE1nUFNCYlhUdGNiaUFnSUNBZ0lIUm9hWE11WDJKNVNXUWdJRDBnZTMwN1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUM4dklGQnlaWEJoY21VZ1lTQm9ZWE5vSUc5bUlHRjBkSEpwWW5WMFpYTWdLRzl5SUc5MGFHVnlJRzF2WkdWc0tTQjBieUJpWlNCaFpHUmxaQ0IwYnlCMGFHbHpYRzRnSUNBZ0x5OGdZMjlzYkdWamRHbHZiaTVjYmlBZ0lDQmZjSEpsY0dGeVpVMXZaR1ZzT2lCbWRXNWpkR2x2YmloaGRIUnljeXdnYjNCMGFXOXVjeWtnZTF4dUlDQWdJQ0FnYVdZZ0tIUm9hWE11WDJselRXOWtaV3dvWVhSMGNuTXBLU0I3WEc0Z0lDQWdJQ0FnSUdsbUlDZ2hZWFIwY25NdVkyOXNiR1ZqZEdsdmJpa2dZWFIwY25NdVkyOXNiR1ZqZEdsdmJpQTlJSFJvYVhNN1hHNGdJQ0FnSUNBZ0lISmxkSFZ5YmlCaGRIUnljenRjYmlBZ0lDQWdJSDFjYmlBZ0lDQWdJRzl3ZEdsdmJuTWdQU0J2Y0hScGIyNXpJRDhnWHk1amJHOXVaU2h2Y0hScGIyNXpLU0E2SUh0OU8xeHVJQ0FnSUNBZ2IzQjBhVzl1Y3k1amIyeHNaV04wYVc5dUlEMGdkR2hwY3p0Y2JpQWdJQ0FnSUhaaGNpQnRiMlJsYkNBOUlHNWxkeUIwYUdsekxtMXZaR1ZzS0dGMGRISnpMQ0J2Y0hScGIyNXpLVHRjYmlBZ0lDQWdJR2xtSUNnaGJXOWtaV3d1ZG1Gc2FXUmhkR2x2YmtWeWNtOXlLU0J5WlhSMWNtNGdiVzlrWld3N1hHNGdJQ0FnSUNCMGFHbHpMblJ5YVdkblpYSW9KMmx1ZG1Gc2FXUW5MQ0IwYUdsekxDQnRiMlJsYkM1MllXeHBaR0YwYVc5dVJYSnliM0lzSUc5d2RHbHZibk1wTzF4dUlDQWdJQ0FnY21WMGRYSnVJR1poYkhObE8xeHVJQ0FnSUgwc1hHNWNiaUFnSUNBdkx5QkpiblJsY201aGJDQnRaWFJvYjJRZ1kyRnNiR1ZrSUdKNUlHSnZkR2dnY21WdGIzWmxJR0Z1WkNCelpYUXVYRzRnSUNBZ0x5OGdVbVYwZFhKdWN5QnlaVzF2ZG1Wa0lHMXZaR1ZzY3l3Z2IzSWdabUZzYzJVZ2FXWWdibTkwYUdsdVp5QnBjeUJ5WlcxdmRtVmtMbHh1SUNBZ0lGOXlaVzF2ZG1WTmIyUmxiSE02SUdaMWJtTjBhVzl1S0cxdlpHVnNjeXdnYjNCMGFXOXVjeWtnZTF4dUlDQWdJQ0FnZG1GeUlISmxiVzkyWldRZ1BTQmJYVHRjYmlBZ0lDQWdJR1p2Y2lBb2RtRnlJR2tnUFNBd095QnBJRHdnYlc5a1pXeHpMbXhsYm1kMGFEc2dhU3NyS1NCN1hHNGdJQ0FnSUNBZ0lIWmhjaUJ0YjJSbGJDQTlJSFJvYVhNdVoyVjBLRzF2WkdWc2MxdHBYU2s3WEc0Z0lDQWdJQ0FnSUdsbUlDZ2hiVzlrWld3cElHTnZiblJwYm5WbE8xeHVYRzRnSUNBZ0lDQWdJSFpoY2lCcGJtUmxlQ0E5SUhSb2FYTXVhVzVrWlhoUFppaHRiMlJsYkNrN1hHNGdJQ0FnSUNBZ0lIUm9hWE11Ylc5a1pXeHpMbk53YkdsalpTaHBibVJsZUN3Z01TazdYRzRnSUNBZ0lDQWdJSFJvYVhNdWJHVnVaM1JvTFMwN1hHNWNiaUFnSUNBZ0lDQWdhV1lnS0NGdmNIUnBiMjV6TG5OcGJHVnVkQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lHOXdkR2x2Ym5NdWFXNWtaWGdnUFNCcGJtUmxlRHRjYmlBZ0lDQWdJQ0FnSUNCdGIyUmxiQzUwY21sbloyVnlLQ2R5WlcxdmRtVW5MQ0J0YjJSbGJDd2dkR2hwY3l3Z2IzQjBhVzl1Y3lrN1hHNGdJQ0FnSUNBZ0lIMWNibHh1SUNBZ0lDQWdJQ0J5WlcxdmRtVmtMbkIxYzJnb2JXOWtaV3dwTzF4dUlDQWdJQ0FnSUNCMGFHbHpMbDl5WlcxdmRtVlNaV1psY21WdVkyVW9iVzlrWld3c0lHOXdkR2x2Ym5NcE8xeHVJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2NtVjBkWEp1SUhKbGJXOTJaV1F1YkdWdVozUm9JRDhnY21WdGIzWmxaQ0E2SUdaaGJITmxPMXh1SUNBZ0lIMHNYRzVjYmlBZ0lDQXZMeUJOWlhSb2IyUWdabTl5SUdOb1pXTnJhVzVuSUhkb1pYUm9aWElnWVc0Z2IySnFaV04wSUhOb2IzVnNaQ0JpWlNCamIyNXphV1JsY21Wa0lHRWdiVzlrWld3Z1ptOXlYRzRnSUNBZ0x5OGdkR2hsSUhCMWNuQnZjMlZ6SUc5bUlHRmtaR2x1WnlCMGJ5QjBhR1VnWTI5c2JHVmpkR2x2Ymk1Y2JpQWdJQ0JmYVhOTmIyUmxiRG9nWm5WdVkzUnBiMjRnS0cxdlpHVnNLU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdiVzlrWld3Z2FXNXpkR0Z1WTJWdlppQk5iMlJsYkR0Y2JpQWdJQ0I5TEZ4dVhHNGdJQ0FnTHk4Z1NXNTBaWEp1WVd3Z2JXVjBhRzlrSUhSdklHTnlaV0YwWlNCaElHMXZaR1ZzSjNNZ2RHbGxjeUIwYnlCaElHTnZiR3hsWTNScGIyNHVYRzRnSUNBZ1gyRmtaRkpsWm1WeVpXNWpaVG9nWm5WdVkzUnBiMjRvYlc5a1pXd3NJRzl3ZEdsdmJuTXBJSHRjYmlBZ0lDQWdJSFJvYVhNdVgySjVTV1JiYlc5a1pXd3VZMmxrWFNBOUlHMXZaR1ZzTzF4dUlDQWdJQ0FnZG1GeUlHbGtJRDBnZEdocGN5NXRiMlJsYkVsa0tHMXZaR1ZzTG1GMGRISnBZblYwWlhNcE8xeHVJQ0FnSUNBZ2FXWWdLR2xrSUNFOUlHNTFiR3dwSUhSb2FYTXVYMko1U1dSYmFXUmRJRDBnYlc5a1pXdzdYRzRnSUNBZ0lDQnRiMlJsYkM1dmJpZ25ZV3hzSnl3Z2RHaHBjeTVmYjI1TmIyUmxiRVYyWlc1MExDQjBhR2x6S1R0Y2JpQWdJQ0I5TEZ4dVhHNGdJQ0FnTHk4Z1NXNTBaWEp1WVd3Z2JXVjBhRzlrSUhSdklITmxkbVZ5SUdFZ2JXOWtaV3duY3lCMGFXVnpJSFJ2SUdFZ1kyOXNiR1ZqZEdsdmJpNWNiaUFnSUNCZmNtVnRiM1psVW1WbVpYSmxibU5sT2lCbWRXNWpkR2x2YmlodGIyUmxiQ3dnYjNCMGFXOXVjeWtnZTF4dUlDQWdJQ0FnWkdWc1pYUmxJSFJvYVhNdVgySjVTV1JiYlc5a1pXd3VZMmxrWFR0Y2JpQWdJQ0FnSUhaaGNpQnBaQ0E5SUhSb2FYTXViVzlrWld4SlpDaHRiMlJsYkM1aGRIUnlhV0oxZEdWektUdGNiaUFnSUNBZ0lHbG1JQ2hwWkNBaFBTQnVkV3hzS1NCa1pXeGxkR1VnZEdocGN5NWZZbmxKWkZ0cFpGMDdYRzRnSUNBZ0lDQnBaaUFvZEdocGN5QTlQVDBnYlc5a1pXd3VZMjlzYkdWamRHbHZiaWtnWkdWc1pYUmxJRzF2WkdWc0xtTnZiR3hsWTNScGIyNDdYRzRnSUNBZ0lDQnRiMlJsYkM1dlptWW9KMkZzYkNjc0lIUm9hWE11WDI5dVRXOWtaV3hGZG1WdWRDd2dkR2hwY3lrN1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUM4dklFbHVkR1Z5Ym1Gc0lHMWxkR2h2WkNCallXeHNaV1FnWlhabGNua2dkR2x0WlNCaElHMXZaR1ZzSUdsdUlIUm9aU0J6WlhRZ1ptbHlaWE1nWVc0Z1pYWmxiblF1WEc0Z0lDQWdMeThnVTJWMGN5QnVaV1ZrSUhSdklIVndaR0YwWlNCMGFHVnBjaUJwYm1SbGVHVnpJSGRvWlc0Z2JXOWtaV3h6SUdOb1lXNW5aU0JwWkhNdUlFRnNiQ0J2ZEdobGNseHVJQ0FnSUM4dklHVjJaVzUwY3lCemFXMXdiSGtnY0hKdmVIa2dkR2h5YjNWbmFDNGdYQ0poWkdSY0lpQmhibVFnWENKeVpXMXZkbVZjSWlCbGRtVnVkSE1nZEdoaGRDQnZjbWxuYVc1aGRHVmNiaUFnSUNBdkx5QnBiaUJ2ZEdobGNpQmpiMnhzWldOMGFXOXVjeUJoY21VZ2FXZHViM0psWkM1Y2JpQWdJQ0JmYjI1TmIyUmxiRVYyWlc1ME9pQm1kVzVqZEdsdmJpaGxkbVZ1ZEN3Z2JXOWtaV3dzSUdOdmJHeGxZM1JwYjI0c0lHOXdkR2x2Ym5NcElIdGNiaUFnSUNBZ0lHbG1JQ2dvWlhabGJuUWdQVDA5SUNkaFpHUW5JSHg4SUdWMlpXNTBJRDA5UFNBbmNtVnRiM1psSnlrZ0ppWWdZMjlzYkdWamRHbHZiaUFoUFQwZ2RHaHBjeWtnY21WMGRYSnVPMXh1SUNBZ0lDQWdhV1lnS0dWMlpXNTBJRDA5UFNBblpHVnpkSEp2ZVNjcElIUm9hWE11Y21WdGIzWmxLRzF2WkdWc0xDQnZjSFJwYjI1ektUdGNiaUFnSUNBZ0lHbG1JQ2hsZG1WdWRDQTlQVDBnSjJOb1lXNW5aU2NwSUh0Y2JpQWdJQ0FnSUNBZ2RtRnlJSEJ5WlhaSlpDQTlJSFJvYVhNdWJXOWtaV3hKWkNodGIyUmxiQzV3Y21WMmFXOTFjMEYwZEhKcFluVjBaWE1vS1NrN1hHNGdJQ0FnSUNBZ0lIWmhjaUJwWkNBOUlIUm9hWE11Ylc5a1pXeEpaQ2h0YjJSbGJDNWhkSFJ5YVdKMWRHVnpLVHRjYmlBZ0lDQWdJQ0FnYVdZZ0tIQnlaWFpKWkNBaFBUMGdhV1FwSUh0Y2JpQWdJQ0FnSUNBZ0lDQnBaaUFvY0hKbGRrbGtJQ0U5SUc1MWJHd3BJR1JsYkdWMFpTQjBhR2x6TGw5aWVVbGtXM0J5WlhaSlpGMDdYRzRnSUNBZ0lDQWdJQ0FnYVdZZ0tHbGtJQ0U5SUc1MWJHd3BJSFJvYVhNdVgySjVTV1JiYVdSZElEMGdiVzlrWld3N1hHNGdJQ0FnSUNBZ0lIMWNiaUFnSUNBZ0lIMWNiaUFnSUNBZ0lIUm9hWE11ZEhKcFoyZGxjaTVoY0hCc2VTaDBhR2x6TENCaGNtZDFiV1Z1ZEhNcE8xeHVJQ0FnSUgxY2JseHVJQ0I5S1R0Y2JseHVJQ0F2THlCVmJtUmxjbk5qYjNKbElHMWxkR2h2WkhNZ2RHaGhkQ0IzWlNCM1lXNTBJSFJ2SUdsdGNHeGxiV1Z1ZENCdmJpQjBhR1VnUTI5c2JHVmpkR2x2Ymk1Y2JpQWdMeThnT1RBbElHOW1JSFJvWlNCamIzSmxJSFZ6WldaMWJHNWxjM01nYjJZZ1FtRmphMkp2Ym1VZ1EyOXNiR1ZqZEdsdmJuTWdhWE1nWVdOMGRXRnNiSGtnYVcxd2JHVnRaVzUwWldSY2JpQWdMeThnY21sbmFIUWdhR1Z5WlRwY2JpQWdkbUZ5SUdOdmJHeGxZM1JwYjI1TlpYUm9iMlJ6SUQwZ2V5Qm1iM0pGWVdOb09pQXpMQ0JsWVdOb09pQXpMQ0J0WVhBNklETXNJR052Ykd4bFkzUTZJRE1zSUhKbFpIVmpaVG9nTkN4Y2JpQWdJQ0FnSUdadmJHUnNPaUEwTENCcGJtcGxZM1E2SURRc0lISmxaSFZqWlZKcFoyaDBPaUEwTENCbWIyeGtjam9nTkN3Z1ptbHVaRG9nTXl3Z1pHVjBaV04wT2lBekxDQm1hV3gwWlhJNklETXNYRzRnSUNBZ0lDQnpaV3hsWTNRNklETXNJSEpsYW1WamREb2dNeXdnWlhabGNuazZJRE1zSUdGc2JEb2dNeXdnYzI5dFpUb2dNeXdnWVc1NU9pQXpMQ0JwYm1Oc2RXUmxPaUF5TEZ4dUlDQWdJQ0FnWTI5dWRHRnBibk02SURJc0lHbHVkbTlyWlRvZ01Dd2diV0Y0T2lBekxDQnRhVzQ2SURNc0lIUnZRWEp5WVhrNklERXNJSE5wZW1VNklERXNJR1pwY25OME9pQXpMRnh1SUNBZ0lDQWdhR1ZoWkRvZ015d2dkR0ZyWlRvZ015d2dhVzVwZEdsaGJEb2dNeXdnY21WemREb2dNeXdnZEdGcGJEb2dNeXdnWkhKdmNEb2dNeXdnYkdGemREb2dNeXhjYmlBZ0lDQWdJSGRwZEdodmRYUTZJREFzSUdScFptWmxjbVZ1WTJVNklEQXNJR2x1WkdWNFQyWTZJRE1zSUhOb2RXWm1iR1U2SURFc0lHeGhjM1JKYm1SbGVFOW1PaUF6TEZ4dUlDQWdJQ0FnYVhORmJYQjBlVG9nTVN3Z1kyaGhhVzQ2SURFc0lITmhiWEJzWlRvZ015d2djR0Z5ZEdsMGFXOXVPaUF6SUgwN1hHNWNiaUFnTHk4Z1RXbDRJR2x1SUdWaFkyZ2dWVzVrWlhKelkyOXlaU0J0WlhSb2IyUWdZWE1nWVNCd2NtOTRlU0IwYnlCZ1EyOXNiR1ZqZEdsdmJpTnRiMlJsYkhOZ0xseHVJQ0JoWkdSVmJtUmxjbk5qYjNKbFRXVjBhRzlrY3loRGIyeHNaV04wYVc5dUxDQmpiMnhzWldOMGFXOXVUV1YwYUc5a2N5d2dKMjF2WkdWc2N5Y3BPMXh1WEc0Z0lDOHZJRlZ1WkdWeWMyTnZjbVVnYldWMGFHOWtjeUIwYUdGMElIUmhhMlVnWVNCd2NtOXdaWEowZVNCdVlXMWxJR0Z6SUdGdUlHRnlaM1Z0Wlc1MExseHVJQ0IyWVhJZ1lYUjBjbWxpZFhSbFRXVjBhRzlrY3lBOUlGc25aM0p2ZFhCQ2VTY3NJQ2RqYjNWdWRFSjVKeXdnSjNOdmNuUkNlU2NzSUNkcGJtUmxlRUo1SjEwN1hHNWNiaUFnTHk4Z1ZYTmxJR0YwZEhKcFluVjBaWE1nYVc1emRHVmhaQ0J2WmlCd2NtOXdaWEowYVdWekxseHVJQ0JmTG1WaFkyZ29ZWFIwY21saWRYUmxUV1YwYUc5a2N5d2dablZ1WTNScGIyNG9iV1YwYUc5a0tTQjdYRzRnSUNBZ2FXWWdLQ0ZmVzIxbGRHaHZaRjBwSUhKbGRIVnlianRjYmlBZ0lDQkRiMnhzWldOMGFXOXVMbkJ5YjNSdmRIbHdaVnR0WlhSb2IyUmRJRDBnWm5WdVkzUnBiMjRvZG1Gc2RXVXNJR052Ym5SbGVIUXBJSHRjYmlBZ0lDQWdJSFpoY2lCcGRHVnlZWFJ2Y2lBOUlGOHVhWE5HZFc1amRHbHZiaWgyWVd4MVpTa2dQeUIyWVd4MVpTQTZJR1oxYm1OMGFXOXVLRzF2WkdWc0tTQjdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJpQnRiMlJsYkM1blpYUW9kbUZzZFdVcE8xeHVJQ0FnSUNBZ2ZUdGNiaUFnSUNBZ0lISmxkSFZ5YmlCZlcyMWxkR2h2WkYwb2RHaHBjeTV0YjJSbGJITXNJR2wwWlhKaGRHOXlMQ0JqYjI1MFpYaDBLVHRjYmlBZ0lDQjlPMXh1SUNCOUtUdGNibHh1SUNBdkx5QkNZV05yWW05dVpTNVdhV1YzWEc0Z0lDOHZJQzB0TFMwdExTMHRMUzB0TFMxY2JseHVJQ0F2THlCQ1lXTnJZbTl1WlNCV2FXVjNjeUJoY21VZ1lXeHRiM04wSUcxdmNtVWdZMjl1ZG1WdWRHbHZiaUIwYUdGdUlIUm9aWGtnWVhKbElHRmpkSFZoYkNCamIyUmxMaUJCSUZacFpYZGNiaUFnTHk4Z2FYTWdjMmx0Y0d4NUlHRWdTbUYyWVZOamNtbHdkQ0J2WW1wbFkzUWdkR2hoZENCeVpYQnlaWE5sYm5SeklHRWdiRzluYVdOaGJDQmphSFZ1YXlCdlppQlZTU0JwYmlCMGFHVmNiaUFnTHk4Z1JFOU5MaUJVYUdseklHMXBaMmgwSUdKbElHRWdjMmx1WjJ4bElHbDBaVzBzSUdGdUlHVnVkR2x5WlNCc2FYTjBMQ0JoSUhOcFpHVmlZWElnYjNJZ2NHRnVaV3dzSUc5eVhHNGdJQzh2SUdWMlpXNGdkR2hsSUhOMWNuSnZkVzVrYVc1bklHWnlZVzFsSUhkb2FXTm9JSGR5WVhCeklIbHZkWElnZDJodmJHVWdZWEJ3TGlCRVpXWnBibWx1WnlCaElHTm9kVzVySUc5bVhHNGdJQzh2SUZWSklHRnpJR0VnS2lwV2FXVjNLaW9nWVd4c2IzZHpJSGx2ZFNCMGJ5QmtaV1pwYm1VZ2VXOTFjaUJFVDAwZ1pYWmxiblJ6SUdSbFkyeGhjbUYwYVhabGJIa3NJSGRwZEdodmRYUmNiaUFnTHk4Z2FHRjJhVzVuSUhSdklIZHZjbko1SUdGaWIzVjBJSEpsYm1SbGNpQnZjbVJsY2lBdUxpNGdZVzVrSUcxaGEyVnpJR2wwSUdWaGMza2dabTl5SUhSb1pTQjJhV1YzSUhSdlhHNGdJQzh2SUhKbFlXTjBJSFJ2SUhOd1pXTnBabWxqSUdOb1lXNW5aWE1nYVc0Z2RHaGxJSE4wWVhSbElHOW1JSGx2ZFhJZ2JXOWtaV3h6TGx4dVhHNGdJQzh2SUVOeVpXRjBhVzVuSUdFZ1FtRmphMkp2Ym1VdVZtbGxkeUJqY21WaGRHVnpJR2wwY3lCcGJtbDBhV0ZzSUdWc1pXMWxiblFnYjNWMGMybGtaU0J2WmlCMGFHVWdSRTlOTEZ4dUlDQXZMeUJwWmlCaGJpQmxlR2x6ZEdsdVp5QmxiR1Z0Wlc1MElHbHpJRzV2ZENCd2NtOTJhV1JsWkM0dUxseHVJQ0IyWVhJZ1ZtbGxkeUE5SUVKaFkydGliMjVsTGxacFpYY2dQU0JtZFc1amRHbHZiaWh2Y0hScGIyNXpLU0I3WEc0Z0lDQWdkR2hwY3k1amFXUWdQU0JmTG5WdWFYRjFaVWxrS0NkMmFXVjNKeWs3WEc0Z0lDQWdYeTVsZUhSbGJtUW9kR2hwY3l3Z1h5NXdhV05yS0c5d2RHbHZibk1zSUhacFpYZFBjSFJwYjI1ektTazdYRzRnSUNBZ2RHaHBjeTVmWlc1emRYSmxSV3hsYldWdWRDZ3BPMXh1SUNBZ0lIUm9hWE11YVc1cGRHbGhiR2w2WlM1aGNIQnNlU2gwYUdsekxDQmhjbWQxYldWdWRITXBPMXh1SUNCOU8xeHVYRzRnSUM4dklFTmhZMmhsWkNCeVpXZGxlQ0IwYnlCemNHeHBkQ0JyWlhseklHWnZjaUJnWkdWc1pXZGhkR1ZnTGx4dUlDQjJZWElnWkdWc1pXZGhkR1ZGZG1WdWRGTndiR2wwZEdWeUlEMGdMMTRvWEZ4VEt5bGNYSE1xS0M0cUtTUXZPMXh1WEc0Z0lDOHZJRXhwYzNRZ2IyWWdkbWxsZHlCdmNIUnBiMjV6SUhSdklHSmxJRzFsY21kbFpDQmhjeUJ3Y205d1pYSjBhV1Z6TGx4dUlDQjJZWElnZG1sbGQwOXdkR2x2Ym5NZ1BTQmJKMjF2WkdWc0p5d2dKMk52Ykd4bFkzUnBiMjRuTENBblpXd25MQ0FuYVdRbkxDQW5ZWFIwY21saWRYUmxjeWNzSUNkamJHRnpjMDVoYldVbkxDQW5kR0ZuVG1GdFpTY3NJQ2RsZG1WdWRITW5YVHRjYmx4dUlDQXZMeUJUWlhRZ2RYQWdZV3hzSUdsdWFHVnlhWFJoWW14bElDb3FRbUZqYTJKdmJtVXVWbWxsZHlvcUlIQnliM0JsY25ScFpYTWdZVzVrSUcxbGRHaHZaSE11WEc0Z0lGOHVaWGgwWlc1a0tGWnBaWGN1Y0hKdmRHOTBlWEJsTENCRmRtVnVkSE1zSUh0Y2JseHVJQ0FnSUM4dklGUm9aU0JrWldaaGRXeDBJR0IwWVdkT1lXMWxZQ0J2WmlCaElGWnBaWGNuY3lCbGJHVnRaVzUwSUdseklHQmNJbVJwZGx3aVlDNWNiaUFnSUNCMFlXZE9ZVzFsT2lBblpHbDJKeXhjYmx4dUlDQWdJQzh2SUdwUmRXVnllU0JrWld4bFoyRjBaU0JtYjNJZ1pXeGxiV1Z1ZENCc2IyOXJkWEFzSUhOamIzQmxaQ0IwYnlCRVQwMGdaV3hsYldWdWRITWdkMmwwYUdsdUlIUm9aVnh1SUNBZ0lDOHZJR04xY25KbGJuUWdkbWxsZHk0Z1ZHaHBjeUJ6YUc5MWJHUWdZbVVnY0hKbFptVnljbVZrSUhSdklHZHNiMkpoYkNCc2IyOXJkWEJ6SUhkb1pYSmxJSEJ2YzNOcFlteGxMbHh1SUNBZ0lDUTZJR1oxYm1OMGFXOXVLSE5sYkdWamRHOXlLU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdkR2hwY3k0a1pXd3VabWx1WkNoelpXeGxZM1J2Y2lrN1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUM4dklFbHVhWFJwWVd4cGVtVWdhWE1nWVc0Z1pXMXdkSGtnWm5WdVkzUnBiMjRnWW5rZ1pHVm1ZWFZzZEM0Z1QzWmxjbkpwWkdVZ2FYUWdkMmwwYUNCNWIzVnlJRzkzYmx4dUlDQWdJQzh2SUdsdWFYUnBZV3hwZW1GMGFXOXVJR3h2WjJsakxseHVJQ0FnSUdsdWFYUnBZV3hwZW1VNklHWjFibU4wYVc5dUtDbDdmU3hjYmx4dUlDQWdJQzh2SUNvcWNtVnVaR1Z5S2lvZ2FYTWdkR2hsSUdOdmNtVWdablZ1WTNScGIyNGdkR2hoZENCNWIzVnlJSFpwWlhjZ2MyaHZkV3hrSUc5MlpYSnlhV1JsTENCcGJpQnZjbVJsY2x4dUlDQWdJQzh2SUhSdklIQnZjSFZzWVhSbElHbDBjeUJsYkdWdFpXNTBJQ2hnZEdocGN5NWxiR0FwTENCM2FYUm9JSFJvWlNCaGNIQnliM0J5YVdGMFpTQklWRTFNTGlCVWFHVmNiaUFnSUNBdkx5QmpiMjUyWlc1MGFXOXVJR2x6SUdadmNpQXFLbkpsYm1SbGNpb3FJSFJ2SUdGc2QyRjVjeUJ5WlhSMWNtNGdZSFJvYVhOZ0xseHVJQ0FnSUhKbGJtUmxjam9nWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNCeVpYUjFjbTRnZEdocGN6dGNiaUFnSUNCOUxGeHVYRzRnSUNBZ0x5OGdVbVZ0YjNabElIUm9hWE1nZG1sbGR5QmllU0IwWVd0cGJtY2dkR2hsSUdWc1pXMWxiblFnYjNWMElHOW1JSFJvWlNCRVQwMHNJR0Z1WkNCeVpXMXZkbWx1WnlCaGJubGNiaUFnSUNBdkx5QmhjSEJzYVdOaFlteGxJRUpoWTJ0aWIyNWxMa1YyWlc1MGN5QnNhWE4wWlc1bGNuTXVYRzRnSUNBZ2NtVnRiM1psT2lCbWRXNWpkR2x2YmlncElIdGNiaUFnSUNBZ0lIUm9hWE11WDNKbGJXOTJaVVZzWlcxbGJuUW9LVHRjYmlBZ0lDQWdJSFJvYVhNdWMzUnZjRXhwYzNSbGJtbHVaeWdwTzF4dUlDQWdJQ0FnY21WMGRYSnVJSFJvYVhNN1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUM4dklGSmxiVzkyWlNCMGFHbHpJSFpwWlhjbmN5QmxiR1Z0Wlc1MElHWnliMjBnZEdobElHUnZZM1Z0Wlc1MElHRnVaQ0JoYkd3Z1pYWmxiblFnYkdsemRHVnVaWEp6WEc0Z0lDQWdMeThnWVhSMFlXTm9aV1FnZEc4Z2FYUXVJRVY0Y0c5elpXUWdabTl5SUhOMVltTnNZWE56WlhNZ2RYTnBibWNnWVc0Z1lXeDBaWEp1WVhScGRtVWdSRTlOWEc0Z0lDQWdMeThnYldGdWFYQjFiR0YwYVc5dUlFRlFTUzVjYmlBZ0lDQmZjbVZ0YjNabFJXeGxiV1Z1ZERvZ1puVnVZM1JwYjI0b0tTQjdYRzRnSUNBZ0lDQjBhR2x6TGlSbGJDNXlaVzF2ZG1Vb0tUdGNiaUFnSUNCOUxGeHVYRzRnSUNBZ0x5OGdRMmhoYm1kbElIUm9aU0IyYVdWM0ozTWdaV3hsYldWdWRDQW9ZSFJvYVhNdVpXeGdJSEJ5YjNCbGNuUjVLU0JoYm1RZ2NtVXRaR1ZzWldkaGRHVWdkR2hsWEc0Z0lDQWdMeThnZG1sbGR5ZHpJR1YyWlc1MGN5QnZiaUIwYUdVZ2JtVjNJR1ZzWlcxbGJuUXVYRzRnSUNBZ2MyVjBSV3hsYldWdWREb2dablZ1WTNScGIyNG9aV3hsYldWdWRDa2dlMXh1SUNBZ0lDQWdkR2hwY3k1MWJtUmxiR1ZuWVhSbFJYWmxiblJ6S0NrN1hHNGdJQ0FnSUNCMGFHbHpMbDl6WlhSRmJHVnRaVzUwS0dWc1pXMWxiblFwTzF4dUlDQWdJQ0FnZEdocGN5NWtaV3hsWjJGMFpVVjJaVzUwY3lncE8xeHVJQ0FnSUNBZ2NtVjBkWEp1SUhSb2FYTTdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lDOHZJRU55WldGMFpYTWdkR2hsSUdCMGFHbHpMbVZzWUNCaGJtUWdZSFJvYVhNdUpHVnNZQ0J5WldabGNtVnVZMlZ6SUdadmNpQjBhR2x6SUhacFpYY2dkWE5wYm1jZ2RHaGxYRzRnSUNBZ0x5OGdaMmwyWlc0Z1lHVnNZQzRnWUdWc1lDQmpZVzRnWW1VZ1lTQkRVMU1nYzJWc1pXTjBiM0lnYjNJZ1lXNGdTRlJOVENCemRISnBibWNzSUdFZ2FsRjFaWEo1WEc0Z0lDQWdMeThnWTI5dWRHVjRkQ0J2Y2lCaGJpQmxiR1Z0Wlc1MExpQlRkV0pqYkdGemMyVnpJR05oYmlCdmRtVnljbWxrWlNCMGFHbHpJSFJ2SUhWMGFXeHBlbVVnWVc1Y2JpQWdJQ0F2THlCaGJIUmxjbTVoZEdsMlpTQkVUMDBnYldGdWFYQjFiR0YwYVc5dUlFRlFTU0JoYm1RZ1lYSmxJRzl1YkhrZ2NtVnhkV2x5WldRZ2RHOGdjMlYwSUhSb1pWeHVJQ0FnSUM4dklHQjBhR2x6TG1Wc1lDQndjbTl3WlhKMGVTNWNiaUFnSUNCZmMyVjBSV3hsYldWdWREb2dablZ1WTNScGIyNG9aV3dwSUh0Y2JpQWdJQ0FnSUhSb2FYTXVKR1ZzSUQwZ1pXd2dhVzV6ZEdGdVkyVnZaaUJDWVdOclltOXVaUzRrSUQ4Z1pXd2dPaUJDWVdOclltOXVaUzRrS0dWc0tUdGNiaUFnSUNBZ0lIUm9hWE11Wld3Z1BTQjBhR2x6TGlSbGJGc3dYVHRjYmlBZ0lDQjlMRnh1WEc0Z0lDQWdMeThnVTJWMElHTmhiR3hpWVdOcmN5d2dkMmhsY21VZ1lIUm9hWE11WlhabGJuUnpZQ0JwY3lCaElHaGhjMmdnYjJaY2JpQWdJQ0F2TDF4dUlDQWdJQzh2SUNwN1hDSmxkbVZ1ZENCelpXeGxZM1J2Y2x3aU9pQmNJbU5oYkd4aVlXTnJYQ0o5S2x4dUlDQWdJQzh2WEc0Z0lDQWdMeThnSUNBZ0lIdGNiaUFnSUNBdkx5QWdJQ0FnSUNBbmJXOTFjMlZrYjNkdUlDNTBhWFJzWlNjNklDQW5aV1JwZENjc1hHNGdJQ0FnTHk4Z0lDQWdJQ0FnSjJOc2FXTnJJQzVpZFhSMGIyNG5PaUFnSUNBZ0ozTmhkbVVuTEZ4dUlDQWdJQzh2SUNBZ0lDQWdJQ2RqYkdsamF5QXViM0JsYmljNklDQWdJQ0FnSUdaMWJtTjBhVzl1S0dVcElIc2dMaTR1SUgxY2JpQWdJQ0F2THlBZ0lDQWdmVnh1SUNBZ0lDOHZYRzRnSUNBZ0x5OGdjR0ZwY25NdUlFTmhiR3hpWVdOcmN5QjNhV3hzSUdKbElHSnZkVzVrSUhSdklIUm9aU0IyYVdWM0xDQjNhWFJvSUdCMGFHbHpZQ0J6WlhRZ2NISnZjR1Z5YkhrdVhHNGdJQ0FnTHk4Z1ZYTmxjeUJsZG1WdWRDQmtaV3hsWjJGMGFXOXVJR1p2Y2lCbFptWnBZMmxsYm1ONUxseHVJQ0FnSUM4dklFOXRhWFIwYVc1bklIUm9aU0J6Wld4bFkzUnZjaUJpYVc1a2N5QjBhR1VnWlhabGJuUWdkRzhnWUhSb2FYTXVaV3hnTGx4dUlDQWdJR1JsYkdWbllYUmxSWFpsYm5Sek9pQm1kVzVqZEdsdmJpaGxkbVZ1ZEhNcElIdGNiaUFnSUNBZ0lHVjJaVzUwY3lCOGZDQW9aWFpsYm5SeklEMGdYeTV5WlhOMWJIUW9kR2hwY3l3Z0oyVjJaVzUwY3ljcEtUdGNiaUFnSUNBZ0lHbG1JQ2doWlhabGJuUnpLU0J5WlhSMWNtNGdkR2hwY3p0Y2JpQWdJQ0FnSUhSb2FYTXVkVzVrWld4bFoyRjBaVVYyWlc1MGN5Z3BPMXh1SUNBZ0lDQWdabTl5SUNoMllYSWdhMlY1SUdsdUlHVjJaVzUwY3lrZ2UxeHVJQ0FnSUNBZ0lDQjJZWElnYldWMGFHOWtJRDBnWlhabGJuUnpXMnRsZVYwN1hHNGdJQ0FnSUNBZ0lHbG1JQ2doWHk1cGMwWjFibU4wYVc5dUtHMWxkR2h2WkNrcElHMWxkR2h2WkNBOUlIUm9hWE5iYldWMGFHOWtYVHRjYmlBZ0lDQWdJQ0FnYVdZZ0tDRnRaWFJvYjJRcElHTnZiblJwYm5WbE8xeHVJQ0FnSUNBZ0lDQjJZWElnYldGMFkyZ2dQU0JyWlhrdWJXRjBZMmdvWkdWc1pXZGhkR1ZGZG1WdWRGTndiR2wwZEdWeUtUdGNiaUFnSUNBZ0lDQWdkR2hwY3k1a1pXeGxaMkYwWlNodFlYUmphRnN4WFN3Z2JXRjBZMmhiTWwwc0lGOHVZbWx1WkNodFpYUm9iMlFzSUhSb2FYTXBLVHRjYmlBZ0lDQWdJSDFjYmlBZ0lDQWdJSEpsZEhWeWJpQjBhR2x6TzF4dUlDQWdJSDBzWEc1Y2JpQWdJQ0F2THlCQlpHUWdZU0J6YVc1bmJHVWdaWFpsYm5RZ2JHbHpkR1Z1WlhJZ2RHOGdkR2hsSUhacFpYY25jeUJsYkdWdFpXNTBJQ2h2Y2lCaElHTm9hV3hrSUdWc1pXMWxiblJjYmlBZ0lDQXZMeUIxYzJsdVp5QmdjMlZzWldOMGIzSmdLUzRnVkdocGN5QnZibXg1SUhkdmNtdHpJR1p2Y2lCa1pXeGxaMkYwWlMxaFlteGxJR1YyWlc1MGN6b2dibTkwSUdCbWIyTjFjMkFzWEc0Z0lDQWdMeThnWUdKc2RYSmdMQ0JoYm1RZ2JtOTBJR0JqYUdGdVoyVmdMQ0JnYzNWaWJXbDBZQ3dnWVc1a0lHQnlaWE5sZEdBZ2FXNGdTVzUwWlhKdVpYUWdSWGh3Ykc5eVpYSXVYRzRnSUNBZ1pHVnNaV2RoZEdVNklHWjFibU4wYVc5dUtHVjJaVzUwVG1GdFpTd2djMlZzWldOMGIzSXNJR3hwYzNSbGJtVnlLU0I3WEc0Z0lDQWdJQ0IwYUdsekxpUmxiQzV2YmlobGRtVnVkRTVoYldVZ0t5QW5MbVJsYkdWbllYUmxSWFpsYm5Sekp5QXJJSFJvYVhNdVkybGtMQ0J6Wld4bFkzUnZjaXdnYkdsemRHVnVaWElwTzF4dUlDQWdJQ0FnY21WMGRYSnVJSFJvYVhNN1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUM4dklFTnNaV0Z5Y3lCaGJHd2dZMkZzYkdKaFkydHpJSEJ5WlhacGIzVnpiSGtnWW05MWJtUWdkRzhnZEdobElIWnBaWGNnWW5rZ1lHUmxiR1ZuWVhSbFJYWmxiblJ6WUM1Y2JpQWdJQ0F2THlCWmIzVWdkWE4xWVd4c2VTQmtiMjRuZENCdVpXVmtJSFJ2SUhWelpTQjBhR2x6TENCaWRYUWdiV0Y1SUhkcGMyZ2dkRzhnYVdZZ2VXOTFJR2hoZG1VZ2JYVnNkR2x3YkdWY2JpQWdJQ0F2THlCQ1lXTnJZbTl1WlNCMmFXVjNjeUJoZEhSaFkyaGxaQ0IwYnlCMGFHVWdjMkZ0WlNCRVQwMGdaV3hsYldWdWRDNWNiaUFnSUNCMWJtUmxiR1ZuWVhSbFJYWmxiblJ6T2lCbWRXNWpkR2x2YmlncElIdGNiaUFnSUNBZ0lHbG1JQ2gwYUdsekxpUmxiQ2tnZEdocGN5NGtaV3d1YjJabUtDY3VaR1ZzWldkaGRHVkZkbVZ1ZEhNbklDc2dkR2hwY3k1amFXUXBPMXh1SUNBZ0lDQWdjbVYwZFhKdUlIUm9hWE03WEc0Z0lDQWdmU3hjYmx4dUlDQWdJQzh2SUVFZ1ptbHVaWEl0WjNKaGFXNWxaQ0JnZFc1a1pXeGxaMkYwWlVWMlpXNTBjMkFnWm05eUlISmxiVzkyYVc1bklHRWdjMmx1WjJ4bElHUmxiR1ZuWVhSbFpDQmxkbVZ1ZEM1Y2JpQWdJQ0F2THlCZ2MyVnNaV04wYjNKZ0lHRnVaQ0JnYkdsemRHVnVaWEpnSUdGeVpTQmliM1JvSUc5d2RHbHZibUZzTGx4dUlDQWdJSFZ1WkdWc1pXZGhkR1U2SUdaMWJtTjBhVzl1S0dWMlpXNTBUbUZ0WlN3Z2MyVnNaV04wYjNJc0lHeHBjM1JsYm1WeUtTQjdYRzRnSUNBZ0lDQjBhR2x6TGlSbGJDNXZabVlvWlhabGJuUk9ZVzFsSUNzZ0p5NWtaV3hsWjJGMFpVVjJaVzUwY3ljZ0t5QjBhR2x6TG1OcFpDd2djMlZzWldOMGIzSXNJR3hwYzNSbGJtVnlLVHRjYmlBZ0lDQWdJSEpsZEhWeWJpQjBhR2x6TzF4dUlDQWdJSDBzWEc1Y2JpQWdJQ0F2THlCUWNtOWtkV05sY3lCaElFUlBUU0JsYkdWdFpXNTBJSFJ2SUdKbElHRnpjMmxuYm1Wa0lIUnZJSGx2ZFhJZ2RtbGxkeTRnUlhod2IzTmxaQ0JtYjNKY2JpQWdJQ0F2THlCemRXSmpiR0Z6YzJWeklIVnphVzVuSUdGdUlHRnNkR1Z5Ym1GMGFYWmxJRVJQVFNCdFlXNXBjSFZzWVhScGIyNGdRVkJKTGx4dUlDQWdJRjlqY21WaGRHVkZiR1Z0Wlc1ME9pQm1kVzVqZEdsdmJpaDBZV2RPWVcxbEtTQjdYRzRnSUNBZ0lDQnlaWFIxY200Z1pHOWpkVzFsYm5RdVkzSmxZWFJsUld4bGJXVnVkQ2gwWVdkT1lXMWxLVHRjYmlBZ0lDQjlMRnh1WEc0Z0lDQWdMeThnUlc1emRYSmxJSFJvWVhRZ2RHaGxJRlpwWlhjZ2FHRnpJR0VnUkU5TklHVnNaVzFsYm5RZ2RHOGdjbVZ1WkdWeUlHbHVkRzh1WEc0Z0lDQWdMeThnU1dZZ1lIUm9hWE11Wld4Z0lHbHpJR0VnYzNSeWFXNW5MQ0J3WVhOeklHbDBJSFJvY205MVoyZ2dZQ1FvS1dBc0lIUmhhMlVnZEdobElHWnBjbk4wWEc0Z0lDQWdMeThnYldGMFkyaHBibWNnWld4bGJXVnVkQ3dnWVc1a0lISmxMV0Z6YzJsbmJpQnBkQ0IwYnlCZ1pXeGdMaUJQZEdobGNuZHBjMlVzSUdOeVpXRjBaVnh1SUNBZ0lDOHZJR0Z1SUdWc1pXMWxiblFnWm5KdmJTQjBhR1VnWUdsa1lDd2dZR05zWVhOelRtRnRaV0FnWVc1a0lHQjBZV2RPWVcxbFlDQndjbTl3WlhKMGFXVnpMbHh1SUNBZ0lGOWxibk4xY21WRmJHVnRaVzUwT2lCbWRXNWpkR2x2YmlncElIdGNiaUFnSUNBZ0lHbG1JQ2doZEdocGN5NWxiQ2tnZTF4dUlDQWdJQ0FnSUNCMllYSWdZWFIwY25NZ1BTQmZMbVY0ZEdWdVpDaDdmU3dnWHk1eVpYTjFiSFFvZEdocGN5d2dKMkYwZEhKcFluVjBaWE1uS1NrN1hHNGdJQ0FnSUNBZ0lHbG1JQ2gwYUdsekxtbGtLU0JoZEhSeWN5NXBaQ0E5SUY4dWNtVnpkV3gwS0hSb2FYTXNJQ2RwWkNjcE8xeHVJQ0FnSUNBZ0lDQnBaaUFvZEdocGN5NWpiR0Z6YzA1aGJXVXBJR0YwZEhKeld5ZGpiR0Z6Y3lkZElEMGdYeTV5WlhOMWJIUW9kR2hwY3l3Z0oyTnNZWE56VG1GdFpTY3BPMXh1SUNBZ0lDQWdJQ0IwYUdsekxuTmxkRVZzWlcxbGJuUW9kR2hwY3k1ZlkzSmxZWFJsUld4bGJXVnVkQ2hmTG5KbGMzVnNkQ2gwYUdsekxDQW5kR0ZuVG1GdFpTY3BLU2s3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVYM05sZEVGMGRISnBZblYwWlhNb1lYUjBjbk1wTzF4dUlDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnZEdocGN5NXpaWFJGYkdWdFpXNTBLRjh1Y21WemRXeDBLSFJvYVhNc0lDZGxiQ2NwS1R0Y2JpQWdJQ0FnSUgxY2JpQWdJQ0I5TEZ4dVhHNGdJQ0FnTHk4Z1UyVjBJR0YwZEhKcFluVjBaWE1nWm5KdmJTQmhJR2hoYzJnZ2IyNGdkR2hwY3lCMmFXVjNKM01nWld4bGJXVnVkQzRnSUVWNGNHOXpaV1FnWm05eVhHNGdJQ0FnTHk4Z2MzVmlZMnhoYzNObGN5QjFjMmx1WnlCaGJpQmhiSFJsY201aGRHbDJaU0JFVDAwZ2JXRnVhWEIxYkdGMGFXOXVJRUZRU1M1Y2JpQWdJQ0JmYzJWMFFYUjBjbWxpZFhSbGN6b2dablZ1WTNScGIyNG9ZWFIwY21saWRYUmxjeWtnZTF4dUlDQWdJQ0FnZEdocGN5NGtaV3d1WVhSMGNpaGhkSFJ5YVdKMWRHVnpLVHRjYmlBZ0lDQjlYRzVjYmlBZ2ZTazdYRzVjYmlBZ0x5OGdRbUZqYTJKdmJtVXVjM2x1WTF4dUlDQXZMeUF0TFMwdExTMHRMUzB0TFMwdFhHNWNiaUFnTHk4Z1QzWmxjbkpwWkdVZ2RHaHBjeUJtZFc1amRHbHZiaUIwYnlCamFHRnVaMlVnZEdobElHMWhibTVsY2lCcGJpQjNhR2xqYUNCQ1lXTnJZbTl1WlNCd1pYSnphWE4wYzF4dUlDQXZMeUJ0YjJSbGJITWdkRzhnZEdobElITmxjblpsY2k0Z1dXOTFJSGRwYkd3Z1ltVWdjR0Z6YzJWa0lIUm9aU0IwZVhCbElHOW1JSEpsY1hWbGMzUXNJR0Z1WkNCMGFHVmNiaUFnTHk4Z2JXOWtaV3dnYVc0Z2NYVmxjM1JwYjI0dUlFSjVJR1JsWm1GMWJIUXNJRzFoYTJWeklHRWdVa1ZUVkdaMWJDQkJhbUY0SUhKbGNYVmxjM1JjYmlBZ0x5OGdkRzhnZEdobElHMXZaR1ZzSjNNZ1lIVnliQ2dwWUM0Z1UyOXRaU0J3YjNOemFXSnNaU0JqZFhOMGIyMXBlbUYwYVc5dWN5QmpiM1ZzWkNCaVpUcGNiaUFnTHk5Y2JpQWdMeThnS2lCVmMyVWdZSE5sZEZScGJXVnZkWFJnSUhSdklHSmhkR05vSUhKaGNHbGtMV1pwY21VZ2RYQmtZWFJsY3lCcGJuUnZJR0VnYzJsdVoyeGxJSEpsY1hWbGMzUXVYRzRnSUM4dklDb2dVMlZ1WkNCMWNDQjBhR1VnYlc5a1pXeHpJR0Z6SUZoTlRDQnBibk4wWldGa0lHOW1JRXBUVDA0dVhHNGdJQzh2SUNvZ1VHVnljMmx6ZENCdGIyUmxiSE1nZG1saElGZGxZbE52WTJ0bGRITWdhVzV6ZEdWaFpDQnZaaUJCYW1GNExseHVJQ0F2TDF4dUlDQXZMeUJVZFhKdUlHOXVJR0JDWVdOclltOXVaUzVsYlhWc1lYUmxTRlJVVUdBZ2FXNGdiM0prWlhJZ2RHOGdjMlZ1WkNCZ1VGVlVZQ0JoYm1RZ1lFUkZURVZVUldBZ2NtVnhkV1Z6ZEhOY2JpQWdMeThnWVhNZ1lGQlBVMVJnTENCM2FYUm9JR0VnWUY5dFpYUm9iMlJnSUhCaGNtRnRaWFJsY2lCamIyNTBZV2x1YVc1bklIUm9aU0IwY25WbElFaFVWRkFnYldWMGFHOWtMRnh1SUNBdkx5QmhjeUIzWld4c0lHRnpJR0ZzYkNCeVpYRjFaWE4wY3lCM2FYUm9JSFJvWlNCaWIyUjVJR0Z6SUdCaGNIQnNhV05oZEdsdmJpOTRMWGQzZHkxbWIzSnRMWFZ5YkdWdVkyOWtaV1JnWEc0Z0lDOHZJR2x1YzNSbFlXUWdiMllnWUdGd2NHeHBZMkYwYVc5dUwycHpiMjVnSUhkcGRHZ2dkR2hsSUcxdlpHVnNJR2x1SUdFZ2NHRnlZVzBnYm1GdFpXUWdZRzF2WkdWc1lDNWNiaUFnTHk4Z1ZYTmxablZzSUhkb1pXNGdhVzUwWlhKbVlXTnBibWNnZDJsMGFDQnpaWEoyWlhJdGMybGtaU0JzWVc1bmRXRm5aWE1nYkdsclpTQXFLbEJJVUNvcUlIUm9ZWFFnYldGclpWeHVJQ0F2THlCcGRDQmthV1ptYVdOMWJIUWdkRzhnY21WaFpDQjBhR1VnWW05a2VTQnZaaUJnVUZWVVlDQnlaWEYxWlhOMGN5NWNiaUFnUW1GamEySnZibVV1YzNsdVl5QTlJR1oxYm1OMGFXOXVLRzFsZEdodlpDd2diVzlrWld3c0lHOXdkR2x2Ym5NcElIdGNiaUFnSUNCMllYSWdkSGx3WlNBOUlHMWxkR2h2WkUxaGNGdHRaWFJvYjJSZE8xeHVYRzRnSUNBZ0x5OGdSR1ZtWVhWc2RDQnZjSFJwYjI1ekxDQjFibXhsYzNNZ2MzQmxZMmxtYVdWa0xseHVJQ0FnSUY4dVpHVm1ZWFZzZEhNb2IzQjBhVzl1Y3lCOGZDQW9iM0IwYVc5dWN5QTlJSHQ5S1N3Z2UxeHVJQ0FnSUNBZ1pXMTFiR0YwWlVoVVZGQTZJRUpoWTJ0aWIyNWxMbVZ0ZFd4aGRHVklWRlJRTEZ4dUlDQWdJQ0FnWlcxMWJHRjBaVXBUVDA0NklFSmhZMnRpYjI1bExtVnRkV3hoZEdWS1UwOU9YRzRnSUNBZ2ZTazdYRzVjYmlBZ0lDQXZMeUJFWldaaGRXeDBJRXBUVDA0dGNtVnhkV1Z6ZENCdmNIUnBiMjV6TGx4dUlDQWdJSFpoY2lCd1lYSmhiWE1nUFNCN2RIbHdaVG9nZEhsd1pTd2daR0YwWVZSNWNHVTZJQ2RxYzI5dUozMDdYRzVjYmlBZ0lDQXZMeUJGYm5OMWNtVWdkR2hoZENCM1pTQm9ZWFpsSUdFZ1ZWSk1MbHh1SUNBZ0lHbG1JQ2doYjNCMGFXOXVjeTUxY213cElIdGNiaUFnSUNBZ0lIQmhjbUZ0Y3k1MWNtd2dQU0JmTG5KbGMzVnNkQ2h0YjJSbGJDd2dKM1Z5YkNjcElIeDhJSFZ5YkVWeWNtOXlLQ2s3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdMeThnUlc1emRYSmxJSFJvWVhRZ2QyVWdhR0YyWlNCMGFHVWdZWEJ3Y205d2NtbGhkR1VnY21WeGRXVnpkQ0JrWVhSaExseHVJQ0FnSUdsbUlDaHZjSFJwYjI1ekxtUmhkR0VnUFQwZ2JuVnNiQ0FtSmlCdGIyUmxiQ0FtSmlBb2JXVjBhRzlrSUQwOVBTQW5ZM0psWVhSbEp5QjhmQ0J0WlhSb2IyUWdQVDA5SUNkMWNHUmhkR1VuSUh4OElHMWxkR2h2WkNBOVBUMGdKM0JoZEdOb0p5a3BJSHRjYmlBZ0lDQWdJSEJoY21GdGN5NWpiMjUwWlc1MFZIbHdaU0E5SUNkaGNIQnNhV05oZEdsdmJpOXFjMjl1Snp0Y2JpQWdJQ0FnSUhCaGNtRnRjeTVrWVhSaElEMGdTbE5QVGk1emRISnBibWRwWm5rb2IzQjBhVzl1Y3k1aGRIUnljeUI4ZkNCdGIyUmxiQzUwYjBwVFQwNG9iM0IwYVc5dWN5a3BPMXh1SUNBZ0lIMWNibHh1SUNBZ0lDOHZJRVp2Y2lCdmJHUmxjaUJ6WlhKMlpYSnpMQ0JsYlhWc1lYUmxJRXBUVDA0Z1lua2daVzVqYjJScGJtY2dkR2hsSUhKbGNYVmxjM1FnYVc1MGJ5QmhiaUJJVkUxTUxXWnZjbTB1WEc0Z0lDQWdhV1lnS0c5d2RHbHZibk11WlcxMWJHRjBaVXBUVDA0cElIdGNiaUFnSUNBZ0lIQmhjbUZ0Y3k1amIyNTBaVzUwVkhsd1pTQTlJQ2RoY0hCc2FXTmhkR2x2Ymk5NExYZDNkeTFtYjNKdExYVnliR1Z1WTI5a1pXUW5PMXh1SUNBZ0lDQWdjR0Z5WVcxekxtUmhkR0VnUFNCd1lYSmhiWE11WkdGMFlTQS9JSHR0YjJSbGJEb2djR0Z5WVcxekxtUmhkR0Y5SURvZ2UzMDdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ0x5OGdSbTl5SUc5c1pHVnlJSE5sY25abGNuTXNJR1Z0ZFd4aGRHVWdTRlJVVUNCaWVTQnRhVzFwWTJ0cGJtY2dkR2hsSUVoVVZGQWdiV1YwYUc5a0lIZHBkR2dnWUY5dFpYUm9iMlJnWEc0Z0lDQWdMeThnUVc1a0lHRnVJR0JZTFVoVVZGQXRUV1YwYUc5a0xVOTJaWEp5YVdSbFlDQm9aV0ZrWlhJdVhHNGdJQ0FnYVdZZ0tHOXdkR2x2Ym5NdVpXMTFiR0YwWlVoVVZGQWdKaVlnS0hSNWNHVWdQVDA5SUNkUVZWUW5JSHg4SUhSNWNHVWdQVDA5SUNkRVJVeEZWRVVuSUh4OElIUjVjR1VnUFQwOUlDZFFRVlJEU0NjcEtTQjdYRzRnSUNBZ0lDQndZWEpoYlhNdWRIbHdaU0E5SUNkUVQxTlVKenRjYmlBZ0lDQWdJR2xtSUNodmNIUnBiMjV6TG1WdGRXeGhkR1ZLVTA5T0tTQndZWEpoYlhNdVpHRjBZUzVmYldWMGFHOWtJRDBnZEhsd1pUdGNiaUFnSUNBZ0lIWmhjaUJpWldadmNtVlRaVzVrSUQwZ2IzQjBhVzl1Y3k1aVpXWnZjbVZUWlc1a08xeHVJQ0FnSUNBZ2IzQjBhVzl1Y3k1aVpXWnZjbVZUWlc1a0lEMGdablZ1WTNScGIyNG9lR2h5S1NCN1hHNGdJQ0FnSUNBZ0lIaG9jaTV6WlhSU1pYRjFaWE4wU0dWaFpHVnlLQ2RZTFVoVVZGQXRUV1YwYUc5a0xVOTJaWEp5YVdSbEp5d2dkSGx3WlNrN1hHNGdJQ0FnSUNBZ0lHbG1JQ2hpWldadmNtVlRaVzVrS1NCeVpYUjFjbTRnWW1WbWIzSmxVMlZ1WkM1aGNIQnNlU2gwYUdsekxDQmhjbWQxYldWdWRITXBPMXh1SUNBZ0lDQWdmVHRjYmlBZ0lDQjlYRzVjYmlBZ0lDQXZMeUJFYjI0bmRDQndjbTlqWlhOeklHUmhkR0VnYjI0Z1lTQnViMjR0UjBWVUlISmxjWFZsYzNRdVhHNGdJQ0FnYVdZZ0tIQmhjbUZ0Y3k1MGVYQmxJQ0U5UFNBblIwVlVKeUFtSmlBaGIzQjBhVzl1Y3k1bGJYVnNZWFJsU2xOUFRpa2dlMXh1SUNBZ0lDQWdjR0Z5WVcxekxuQnliMk5sYzNORVlYUmhJRDBnWm1Gc2MyVTdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ0x5OGdVR0Z6Y3lCaGJHOXVaeUJnZEdWNGRGTjBZWFIxYzJBZ1lXNWtJR0JsY25KdmNsUm9jbTkzYm1BZ1puSnZiU0JxVVhWbGNua3VYRzRnSUNBZ2RtRnlJR1Z5Y205eUlEMGdiM0IwYVc5dWN5NWxjbkp2Y2p0Y2JpQWdJQ0J2Y0hScGIyNXpMbVZ5Y205eUlEMGdablZ1WTNScGIyNG9lR2h5TENCMFpYaDBVM1JoZEhWekxDQmxjbkp2Y2xSb2NtOTNiaWtnZTF4dUlDQWdJQ0FnYjNCMGFXOXVjeTUwWlhoMFUzUmhkSFZ6SUQwZ2RHVjRkRk4wWVhSMWN6dGNiaUFnSUNBZ0lHOXdkR2x2Ym5NdVpYSnliM0pVYUhKdmQyNGdQU0JsY25KdmNsUm9jbTkzYmp0Y2JpQWdJQ0FnSUdsbUlDaGxjbkp2Y2lrZ1pYSnliM0l1WTJGc2JDaHZjSFJwYjI1ekxtTnZiblJsZUhRc0lIaG9jaXdnZEdWNGRGTjBZWFIxY3l3Z1pYSnliM0pVYUhKdmQyNHBPMXh1SUNBZ0lIMDdYRzVjYmlBZ0lDQXZMeUJOWVd0bElIUm9aU0J5WlhGMVpYTjBMQ0JoYkd4dmQybHVaeUIwYUdVZ2RYTmxjaUIwYnlCdmRtVnljbWxrWlNCaGJua2dRV3BoZUNCdmNIUnBiMjV6TGx4dUlDQWdJSFpoY2lCNGFISWdQU0J2Y0hScGIyNXpMbmhvY2lBOUlFSmhZMnRpYjI1bExtRnFZWGdvWHk1bGVIUmxibVFvY0dGeVlXMXpMQ0J2Y0hScGIyNXpLU2s3WEc0Z0lDQWdiVzlrWld3dWRISnBaMmRsY2lnbmNtVnhkV1Z6ZENjc0lHMXZaR1ZzTENCNGFISXNJRzl3ZEdsdmJuTXBPMXh1SUNBZ0lISmxkSFZ5YmlCNGFISTdYRzRnSUgwN1hHNWNiaUFnTHk4Z1RXRndJR1p5YjIwZ1ExSlZSQ0IwYnlCSVZGUlFJR1p2Y2lCdmRYSWdaR1ZtWVhWc2RDQmdRbUZqYTJKdmJtVXVjM2x1WTJBZ2FXMXdiR1Z0Wlc1MFlYUnBiMjR1WEc0Z0lIWmhjaUJ0WlhSb2IyUk5ZWEFnUFNCN1hHNGdJQ0FnSjJOeVpXRjBaU2M2SUNkUVQxTlVKeXhjYmlBZ0lDQW5kWEJrWVhSbEp6b2dKMUJWVkNjc1hHNGdJQ0FnSjNCaGRHTm9Kem9nSUNkUVFWUkRTQ2NzWEc0Z0lDQWdKMlJsYkdWMFpTYzZJQ2RFUlV4RlZFVW5MRnh1SUNBZ0lDZHlaV0ZrSnpvZ0lDQW5SMFZVSjF4dUlDQjlPMXh1WEc0Z0lDOHZJRk5sZENCMGFHVWdaR1ZtWVhWc2RDQnBiWEJzWlcxbGJuUmhkR2x2YmlCdlppQmdRbUZqYTJKdmJtVXVZV3BoZUdBZ2RHOGdjSEp2ZUhrZ2RHaHliM1ZuYUNCMGJ5QmdKR0F1WEc0Z0lDOHZJRTkyWlhKeWFXUmxJSFJvYVhNZ2FXWWdlVzkxSjJRZ2JHbHJaU0IwYnlCMWMyVWdZU0JrYVdabVpYSmxiblFnYkdsaWNtRnllUzVjYmlBZ1FtRmphMkp2Ym1VdVlXcGhlQ0E5SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0FnSUhKbGRIVnliaUJDWVdOclltOXVaUzRrTG1GcVlYZ3VZWEJ3Ykhrb1FtRmphMkp2Ym1VdUpDd2dZWEpuZFcxbGJuUnpLVHRjYmlBZ2ZUdGNibHh1SUNBdkx5QkNZV05yWW05dVpTNVNiM1YwWlhKY2JpQWdMeThnTFMwdExTMHRMUzB0TFMwdExTMHRYRzVjYmlBZ0x5OGdVbTkxZEdWeWN5QnRZWEFnWm1GMWVDMVZVa3h6SUhSdklHRmpkR2x2Ym5Nc0lHRnVaQ0JtYVhKbElHVjJaVzUwY3lCM2FHVnVJSEp2ZFhSbGN5QmhjbVZjYmlBZ0x5OGdiV0YwWTJobFpDNGdRM0psWVhScGJtY2dZU0J1WlhjZ2IyNWxJSE5sZEhNZ2FYUnpJR0J5YjNWMFpYTmdJR2hoYzJnc0lHbG1JRzV2ZENCelpYUWdjM1JoZEdsallXeHNlUzVjYmlBZ2RtRnlJRkp2ZFhSbGNpQTlJRUpoWTJ0aWIyNWxMbEp2ZFhSbGNpQTlJR1oxYm1OMGFXOXVLRzl3ZEdsdmJuTXBJSHRjYmlBZ0lDQnZjSFJwYjI1eklIeDhJQ2h2Y0hScGIyNXpJRDBnZTMwcE8xeHVJQ0FnSUdsbUlDaHZjSFJwYjI1ekxuSnZkWFJsY3lrZ2RHaHBjeTV5YjNWMFpYTWdQU0J2Y0hScGIyNXpMbkp2ZFhSbGN6dGNiaUFnSUNCMGFHbHpMbDlpYVc1a1VtOTFkR1Z6S0NrN1hHNGdJQ0FnZEdocGN5NXBibWwwYVdGc2FYcGxMbUZ3Y0d4NUtIUm9hWE1zSUdGeVozVnRaVzUwY3lrN1hHNGdJSDA3WEc1Y2JpQWdMeThnUTJGamFHVmtJSEpsWjNWc1lYSWdaWGh3Y21WemMybHZibk1nWm05eUlHMWhkR05vYVc1bklHNWhiV1ZrSUhCaGNtRnRJSEJoY25SeklHRnVaQ0J6Y0d4aGRIUmxaRnh1SUNBdkx5QndZWEowY3lCdlppQnliM1YwWlNCemRISnBibWR6TGx4dUlDQjJZWElnYjNCMGFXOXVZV3hRWVhKaGJTQTlJQzljWENnb0xpby9LVnhjS1M5bk8xeHVJQ0IyWVhJZ2JtRnRaV1JRWVhKaGJTQWdJQ0E5SUM4b1hGd29YRncvS1Q4NlhGeDNLeTluTzF4dUlDQjJZWElnYzNCc1lYUlFZWEpoYlNBZ0lDQTlJQzljWENwY1hIY3JMMmM3WEc0Z0lIWmhjaUJsYzJOaGNHVlNaV2RGZUhBZ0lEMGdMMXRjWEMxN2ZWeGNXMXhjWFNzL0xpeGNYRnhjWEZ4ZUpId2pYRnh6WFM5bk8xeHVYRzRnSUM4dklGTmxkQ0IxY0NCaGJHd2dhVzVvWlhKcGRHRmliR1VnS2lwQ1lXTnJZbTl1WlM1U2IzVjBaWElxS2lCd2NtOXdaWEowYVdWeklHRnVaQ0J0WlhSb2IyUnpMbHh1SUNCZkxtVjRkR1Z1WkNoU2IzVjBaWEl1Y0hKdmRHOTBlWEJsTENCRmRtVnVkSE1zSUh0Y2JseHVJQ0FnSUM4dklFbHVhWFJwWVd4cGVtVWdhWE1nWVc0Z1pXMXdkSGtnWm5WdVkzUnBiMjRnWW5rZ1pHVm1ZWFZzZEM0Z1QzWmxjbkpwWkdVZ2FYUWdkMmwwYUNCNWIzVnlJRzkzYmx4dUlDQWdJQzh2SUdsdWFYUnBZV3hwZW1GMGFXOXVJR3h2WjJsakxseHVJQ0FnSUdsdWFYUnBZV3hwZW1VNklHWjFibU4wYVc5dUtDbDdmU3hjYmx4dUlDQWdJQzh2SUUxaGJuVmhiR3g1SUdKcGJtUWdZU0J6YVc1bmJHVWdibUZ0WldRZ2NtOTFkR1VnZEc4Z1lTQmpZV3hzWW1GamF5NGdSbTl5SUdWNFlXMXdiR1U2WEc0Z0lDQWdMeTljYmlBZ0lDQXZMeUFnSUNBZ2RHaHBjeTV5YjNWMFpTZ25jMlZoY21Ob0x6cHhkV1Z5ZVM5d09tNTFiU2NzSUNkelpXRnlZMmduTENCbWRXNWpkR2x2YmloeGRXVnllU3dnYm5WdEtTQjdYRzRnSUNBZ0x5OGdJQ0FnSUNBZ0xpNHVYRzRnSUNBZ0x5OGdJQ0FnSUgwcE8xeHVJQ0FnSUM4dlhHNGdJQ0FnY205MWRHVTZJR1oxYm1OMGFXOXVLSEp2ZFhSbExDQnVZVzFsTENCallXeHNZbUZqYXlrZ2UxeHVJQ0FnSUNBZ2FXWWdLQ0ZmTG1selVtVm5SWGh3S0hKdmRYUmxLU2tnY205MWRHVWdQU0IwYUdsekxsOXliM1YwWlZSdlVtVm5SWGh3S0hKdmRYUmxLVHRjYmlBZ0lDQWdJR2xtSUNoZkxtbHpSblZ1WTNScGIyNG9ibUZ0WlNrcElIdGNiaUFnSUNBZ0lDQWdZMkZzYkdKaFkyc2dQU0J1WVcxbE8xeHVJQ0FnSUNBZ0lDQnVZVzFsSUQwZ0p5YzdYRzRnSUNBZ0lDQjlYRzRnSUNBZ0lDQnBaaUFvSVdOaGJHeGlZV05yS1NCallXeHNZbUZqYXlBOUlIUm9hWE5iYm1GdFpWMDdYRzRnSUNBZ0lDQjJZWElnY205MWRHVnlJRDBnZEdocGN6dGNiaUFnSUNBZ0lFSmhZMnRpYjI1bExtaHBjM1J2Y25rdWNtOTFkR1VvY205MWRHVXNJR1oxYm1OMGFXOXVLR1p5WVdkdFpXNTBLU0I3WEc0Z0lDQWdJQ0FnSUhaaGNpQmhjbWR6SUQwZ2NtOTFkR1Z5TGw5bGVIUnlZV04wVUdGeVlXMWxkR1Z5Y3loeWIzVjBaU3dnWm5KaFoyMWxiblFwTzF4dUlDQWdJQ0FnSUNCcFppQW9jbTkxZEdWeUxtVjRaV04xZEdVb1kyRnNiR0poWTJzc0lHRnlaM01zSUc1aGJXVXBJQ0U5UFNCbVlXeHpaU2tnZTF4dUlDQWdJQ0FnSUNBZ0lISnZkWFJsY2k1MGNtbG5aMlZ5TG1Gd2NHeDVLSEp2ZFhSbGNpd2dXeWR5YjNWMFpUb25JQ3NnYm1GdFpWMHVZMjl1WTJGMEtHRnlaM01wS1R0Y2JpQWdJQ0FnSUNBZ0lDQnliM1YwWlhJdWRISnBaMmRsY2lnbmNtOTFkR1VuTENCdVlXMWxMQ0JoY21kektUdGNiaUFnSUNBZ0lDQWdJQ0JDWVdOclltOXVaUzVvYVhOMGIzSjVMblJ5YVdkblpYSW9KM0p2ZFhSbEp5d2djbTkxZEdWeUxDQnVZVzFsTENCaGNtZHpLVHRjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJQ0FnZlNrN1hHNGdJQ0FnSUNCeVpYUjFjbTRnZEdocGN6dGNiaUFnSUNCOUxGeHVYRzRnSUNBZ0x5OGdSWGhsWTNWMFpTQmhJSEp2ZFhSbElHaGhibVJzWlhJZ2QybDBhQ0IwYUdVZ2NISnZkbWxrWldRZ2NHRnlZVzFsZEdWeWN5NGdJRlJvYVhNZ2FYTWdZVzVjYmlBZ0lDQXZMeUJsZUdObGJHeGxiblFnY0d4aFkyVWdkRzhnWkc4Z2NISmxMWEp2ZFhSbElITmxkSFZ3SUc5eUlIQnZjM1F0Y205MWRHVWdZMnhsWVc1MWNDNWNiaUFnSUNCbGVHVmpkWFJsT2lCbWRXNWpkR2x2YmloallXeHNZbUZqYXl3Z1lYSm5jeXdnYm1GdFpTa2dlMXh1SUNBZ0lDQWdhV1lnS0dOaGJHeGlZV05yS1NCallXeHNZbUZqYXk1aGNIQnNlU2gwYUdsekxDQmhjbWR6S1R0Y2JpQWdJQ0I5TEZ4dVhHNGdJQ0FnTHk4Z1UybHRjR3hsSUhCeWIzaDVJSFJ2SUdCQ1lXTnJZbTl1WlM1b2FYTjBiM0o1WUNCMGJ5QnpZWFpsSUdFZ1puSmhaMjFsYm5RZ2FXNTBieUIwYUdVZ2FHbHpkRzl5ZVM1Y2JpQWdJQ0J1WVhacFoyRjBaVG9nWm5WdVkzUnBiMjRvWm5KaFoyMWxiblFzSUc5d2RHbHZibk1wSUh0Y2JpQWdJQ0FnSUVKaFkydGliMjVsTG1ocGMzUnZjbmt1Ym1GMmFXZGhkR1VvWm5KaFoyMWxiblFzSUc5d2RHbHZibk1wTzF4dUlDQWdJQ0FnY21WMGRYSnVJSFJvYVhNN1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUM4dklFSnBibVFnWVd4c0lHUmxabWx1WldRZ2NtOTFkR1Z6SUhSdklHQkNZV05yWW05dVpTNW9hWE4wYjNKNVlDNGdWMlVnYUdGMlpTQjBieUJ5WlhabGNuTmxJSFJvWlZ4dUlDQWdJQzh2SUc5eVpHVnlJRzltSUhSb1pTQnliM1YwWlhNZ2FHVnlaU0IwYnlCemRYQndiM0owSUdKbGFHRjJhVzl5SUhkb1pYSmxJSFJvWlNCdGIzTjBJR2RsYm1WeVlXeGNiaUFnSUNBdkx5QnliM1YwWlhNZ1kyRnVJR0psSUdSbFptbHVaV1FnWVhRZ2RHaGxJR0p2ZEhSdmJTQnZaaUIwYUdVZ2NtOTFkR1VnYldGd0xseHVJQ0FnSUY5aWFXNWtVbTkxZEdWek9pQm1kVzVqZEdsdmJpZ3BJSHRjYmlBZ0lDQWdJR2xtSUNnaGRHaHBjeTV5YjNWMFpYTXBJSEpsZEhWeWJqdGNiaUFnSUNBZ0lIUm9hWE11Y205MWRHVnpJRDBnWHk1eVpYTjFiSFFvZEdocGN5d2dKM0p2ZFhSbGN5Y3BPMXh1SUNBZ0lDQWdkbUZ5SUhKdmRYUmxMQ0J5YjNWMFpYTWdQU0JmTG10bGVYTW9kR2hwY3k1eWIzVjBaWE1wTzF4dUlDQWdJQ0FnZDJocGJHVWdLQ2h5YjNWMFpTQTlJSEp2ZFhSbGN5NXdiM0FvS1NrZ0lUMGdiblZzYkNrZ2UxeHVJQ0FnSUNBZ0lDQjBhR2x6TG5KdmRYUmxLSEp2ZFhSbExDQjBhR2x6TG5KdmRYUmxjMXR5YjNWMFpWMHBPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lIMHNYRzVjYmlBZ0lDQXZMeUJEYjI1MlpYSjBJR0VnY205MWRHVWdjM1J5YVc1bklHbHVkRzhnWVNCeVpXZDFiR0Z5SUdWNGNISmxjM05wYjI0c0lITjFhWFJoWW14bElHWnZjaUJ0WVhSamFHbHVaMXh1SUNBZ0lDOHZJR0ZuWVdsdWMzUWdkR2hsSUdOMWNuSmxiblFnYkc5allYUnBiMjRnYUdGemFDNWNiaUFnSUNCZmNtOTFkR1ZVYjFKbFowVjRjRG9nWm5WdVkzUnBiMjRvY205MWRHVXBJSHRjYmlBZ0lDQWdJSEp2ZFhSbElEMGdjbTkxZEdVdWNtVndiR0ZqWlNobGMyTmhjR1ZTWldkRmVIQXNJQ2RjWEZ4Y0pDWW5LVnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUM1eVpYQnNZV05sS0c5d2RHbHZibUZzVUdGeVlXMHNJQ2NvUHpva01Tay9KeWxjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBdWNtVndiR0ZqWlNodVlXMWxaRkJoY21GdExDQm1kVzVqZEdsdmJpaHRZWFJqYUN3Z2IzQjBhVzl1WVd3cElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhKbGRIVnliaUJ2Y0hScGIyNWhiQ0EvSUcxaGRHTm9JRG9nSnloYlhpOC9YU3NwSnp0Y2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQjlLVnh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUM1eVpYQnNZV05sS0hOd2JHRjBVR0Z5WVcwc0lDY29XMTQvWFNvL0tTY3BPMXh1SUNBZ0lDQWdjbVYwZFhKdUlHNWxkeUJTWldkRmVIQW9KMTRuSUNzZ2NtOTFkR1VnS3lBbktEODZYRnhjWEQ4b1cxeGNYRnh6WEZ4Y1hGTmRLaWtwUHlRbktUdGNiaUFnSUNCOUxGeHVYRzRnSUNBZ0x5OGdSMmwyWlc0Z1lTQnliM1YwWlN3Z1lXNWtJR0VnVlZKTUlHWnlZV2R0Wlc1MElIUm9ZWFFnYVhRZ2JXRjBZMmhsY3l3Z2NtVjBkWEp1SUhSb1pTQmhjbkpoZVNCdlpseHVJQ0FnSUM4dklHVjRkSEpoWTNSbFpDQmtaV052WkdWa0lIQmhjbUZ0WlhSbGNuTXVJRVZ0Y0hSNUlHOXlJSFZ1YldGMFkyaGxaQ0J3WVhKaGJXVjBaWEp6SUhkcGJHd2dZbVZjYmlBZ0lDQXZMeUIwY21WaGRHVmtJR0Z6SUdCdWRXeHNZQ0IwYnlCdWIzSnRZV3hwZW1VZ1kzSnZjM010WW5KdmQzTmxjaUJpWldoaGRtbHZjaTVjYmlBZ0lDQmZaWGgwY21GamRGQmhjbUZ0WlhSbGNuTTZJR1oxYm1OMGFXOXVLSEp2ZFhSbExDQm1jbUZuYldWdWRDa2dlMXh1SUNBZ0lDQWdkbUZ5SUhCaGNtRnRjeUE5SUhKdmRYUmxMbVY0WldNb1puSmhaMjFsYm5RcExuTnNhV05sS0RFcE8xeHVJQ0FnSUNBZ2NtVjBkWEp1SUY4dWJXRndLSEJoY21GdGN5d2dablZ1WTNScGIyNG9jR0Z5WVcwc0lHa3BJSHRjYmlBZ0lDQWdJQ0FnTHk4Z1JHOXVKM1FnWkdWamIyUmxJSFJvWlNCelpXRnlZMmdnY0dGeVlXMXpMbHh1SUNBZ0lDQWdJQ0JwWmlBb2FTQTlQVDBnY0dGeVlXMXpMbXhsYm1kMGFDQXRJREVwSUhKbGRIVnliaUJ3WVhKaGJTQjhmQ0J1ZFd4c08xeHVJQ0FnSUNBZ0lDQnlaWFIxY200Z2NHRnlZVzBnUHlCa1pXTnZaR1ZWVWtsRGIyMXdiMjVsYm5Rb2NHRnlZVzBwSURvZ2JuVnNiRHRjYmlBZ0lDQWdJSDBwTzF4dUlDQWdJSDFjYmx4dUlDQjlLVHRjYmx4dUlDQXZMeUJDWVdOclltOXVaUzVJYVhOMGIzSjVYRzRnSUM4dklDMHRMUzB0TFMwdExTMHRMUzB0TFMxY2JseHVJQ0F2THlCSVlXNWtiR1Z6SUdOeWIzTnpMV0p5YjNkelpYSWdhR2x6ZEc5eWVTQnRZVzVoWjJWdFpXNTBMQ0JpWVhObFpDQnZiaUJsYVhSb1pYSmNiaUFnTHk4Z1czQjFjMmhUZEdGMFpWMG9hSFIwY0RvdkwyUnBkbVZwYm5SdmFIUnRiRFV1YVc1bWJ5OW9hWE4wYjNKNUxtaDBiV3dwSUdGdVpDQnlaV0ZzSUZWU1RITXNJRzl5WEc0Z0lDOHZJRnR2Ym1oaGMyaGphR0Z1WjJWZEtHaDBkSEJ6T2k4dlpHVjJaV3h2Y0dWeUxtMXZlbWxzYkdFdWIzSm5MMlZ1TFZWVEwyUnZZM012UkU5TkwzZHBibVJ2ZHk1dmJtaGhjMmhqYUdGdVoyVXBYRzRnSUM4dklHRnVaQ0JWVWt3Z1puSmhaMjFsYm5SekxpQkpaaUIwYUdVZ1luSnZkM05sY2lCemRYQndiM0owY3lCdVpXbDBhR1Z5SUNodmJHUWdTVVVzSUc1aGRHTm9LU3hjYmlBZ0x5OGdabUZzYkhNZ1ltRmpheUIwYnlCd2IyeHNhVzVuTGx4dUlDQjJZWElnU0dsemRHOXllU0E5SUVKaFkydGliMjVsTGtocGMzUnZjbmtnUFNCbWRXNWpkR2x2YmlncElIdGNiaUFnSUNCMGFHbHpMbWhoYm1Sc1pYSnpJRDBnVzEwN1hHNGdJQ0FnWHk1aWFXNWtRV3hzS0hSb2FYTXNJQ2RqYUdWamExVnliQ2NwTzF4dVhHNGdJQ0FnTHk4Z1JXNXpkWEpsSUhSb1lYUWdZRWhwYzNSdmNubGdJR05oYmlCaVpTQjFjMlZrSUc5MWRITnBaR1VnYjJZZ2RHaGxJR0p5YjNkelpYSXVYRzRnSUNBZ2FXWWdLSFI1Y0dWdlppQjNhVzVrYjNjZ0lUMDlJQ2QxYm1SbFptbHVaV1FuS1NCN1hHNGdJQ0FnSUNCMGFHbHpMbXh2WTJGMGFXOXVJRDBnZDJsdVpHOTNMbXh2WTJGMGFXOXVPMXh1SUNBZ0lDQWdkR2hwY3k1b2FYTjBiM0o1SUQwZ2QybHVaRzkzTG1ocGMzUnZjbms3WEc0Z0lDQWdmVnh1SUNCOU8xeHVYRzRnSUM4dklFTmhZMmhsWkNCeVpXZGxlQ0JtYjNJZ2MzUnlhWEJ3YVc1bklHRWdiR1ZoWkdsdVp5Qm9ZWE5vTDNOc1lYTm9JR0Z1WkNCMGNtRnBiR2x1WnlCemNHRmpaUzVjYmlBZ2RtRnlJSEp2ZFhSbFUzUnlhWEJ3WlhJZ1BTQXZYbHNqWEZ3dlhYeGNYSE1ySkM5bk8xeHVYRzRnSUM4dklFTmhZMmhsWkNCeVpXZGxlQ0JtYjNJZ2MzUnlhWEJ3YVc1bklHeGxZV1JwYm1jZ1lXNWtJSFJ5WVdsc2FXNW5JSE5zWVhOb1pYTXVYRzRnSUhaaGNpQnliMjkwVTNSeWFYQndaWElnUFNBdlhseGNMeXQ4WEZ3dkt5UXZaenRjYmx4dUlDQXZMeUJEWVdOb1pXUWdjbVZuWlhnZ1ptOXlJSE4wY21sd2NHbHVaeUIxY214eklHOW1JR2hoYzJndVhHNGdJSFpoY2lCd1lYUm9VM1J5YVhCd1pYSWdQU0F2SXk0cUpDODdYRzVjYmlBZ0x5OGdTR0Z6SUhSb1pTQm9hWE4wYjNKNUlHaGhibVJzYVc1bklHRnNjbVZoWkhrZ1ltVmxiaUJ6ZEdGeWRHVmtQMXh1SUNCSWFYTjBiM0o1TG5OMFlYSjBaV1FnUFNCbVlXeHpaVHRjYmx4dUlDQXZMeUJUWlhRZ2RYQWdZV3hzSUdsdWFHVnlhWFJoWW14bElDb3FRbUZqYTJKdmJtVXVTR2x6ZEc5eWVTb3FJSEJ5YjNCbGNuUnBaWE1nWVc1a0lHMWxkR2h2WkhNdVhHNGdJRjh1WlhoMFpXNWtLRWhwYzNSdmNua3VjSEp2ZEc5MGVYQmxMQ0JGZG1WdWRITXNJSHRjYmx4dUlDQWdJQzh2SUZSb1pTQmtaV1poZFd4MElHbHVkR1Z5ZG1Gc0lIUnZJSEJ2Ykd3Z1ptOXlJR2hoYzJnZ1kyaGhibWRsY3l3Z2FXWWdibVZqWlhOellYSjVMQ0JwYzF4dUlDQWdJQzh2SUhSM1pXNTBlU0IwYVcxbGN5QmhJSE5sWTI5dVpDNWNiaUFnSUNCcGJuUmxjblpoYkRvZ05UQXNYRzVjYmlBZ0lDQXZMeUJCY21VZ2QyVWdZWFFnZEdobElHRndjQ0J5YjI5MFAxeHVJQ0FnSUdGMFVtOXZkRG9nWm5WdVkzUnBiMjRvS1NCN1hHNGdJQ0FnSUNCMllYSWdjR0YwYUNBOUlIUm9hWE11Ykc5allYUnBiMjR1Y0dGMGFHNWhiV1V1Y21Wd2JHRmpaU2d2VzE1Y1hDOWRKQzhzSUNja0ppOG5LVHRjYmlBZ0lDQWdJSEpsZEhWeWJpQndZWFJvSUQwOVBTQjBhR2x6TG5KdmIzUWdKaVlnSVhSb2FYTXVaMlYwVTJWaGNtTm9LQ2s3WEc0Z0lDQWdmU3hjYmx4dUlDQWdJQzh2SUVSdlpYTWdkR2hsSUhCaGRHaHVZVzFsSUcxaGRHTm9JSFJvWlNCeWIyOTBQMXh1SUNBZ0lHMWhkR05vVW05dmREb2dablZ1WTNScGIyNG9LU0I3WEc0Z0lDQWdJQ0IyWVhJZ2NHRjBhQ0E5SUhSb2FYTXVaR1ZqYjJSbFJuSmhaMjFsYm5Rb2RHaHBjeTVzYjJOaGRHbHZiaTV3WVhSb2JtRnRaU2s3WEc0Z0lDQWdJQ0IyWVhJZ2NtOXZkQ0E5SUhCaGRHZ3VjMnhwWTJVb01Dd2dkR2hwY3k1eWIyOTBMbXhsYm1kMGFDQXRJREVwSUNzZ0p5OG5PMXh1SUNBZ0lDQWdjbVYwZFhKdUlISnZiM1FnUFQwOUlIUm9hWE11Y205dmREdGNiaUFnSUNCOUxGeHVYRzRnSUNBZ0x5OGdWVzVwWTI5a1pTQmphR0Z5WVdOMFpYSnpJR2x1SUdCc2IyTmhkR2x2Ymk1d1lYUm9ibUZ0WldBZ1lYSmxJSEJsY21ObGJuUWdaVzVqYjJSbFpDQnpieUIwYUdWNUozSmxYRzRnSUNBZ0x5OGdaR1ZqYjJSbFpDQm1iM0lnWTI5dGNHRnlhWE52Ymk0Z1lDVXlOV0FnYzJodmRXeGtJRzV2ZENCaVpTQmtaV052WkdWa0lITnBibU5sSUdsMElHMWhlU0JpWlNCd1lYSjBYRzRnSUNBZ0x5OGdiMllnWVc0Z1pXNWpiMlJsWkNCd1lYSmhiV1YwWlhJdVhHNGdJQ0FnWkdWamIyUmxSbkpoWjIxbGJuUTZJR1oxYm1OMGFXOXVLR1p5WVdkdFpXNTBLU0I3WEc0Z0lDQWdJQ0J5WlhSMWNtNGdaR1ZqYjJSbFZWSkpLR1p5WVdkdFpXNTBMbkpsY0d4aFkyVW9MeVV5TlM5bkxDQW5KVEkxTWpVbktTazdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lDOHZJRWx1SUVsRk5pd2dkR2hsSUdoaGMyZ2dabkpoWjIxbGJuUWdZVzVrSUhObFlYSmphQ0J3WVhKaGJYTWdZWEpsSUdsdVkyOXljbVZqZENCcFppQjBhR1ZjYmlBZ0lDQXZMeUJtY21GbmJXVnVkQ0JqYjI1MFlXbHVjeUJnUDJBdVhHNGdJQ0FnWjJWMFUyVmhjbU5vT2lCbWRXNWpkR2x2YmlncElIdGNiaUFnSUNBZ0lIWmhjaUJ0WVhSamFDQTlJSFJvYVhNdWJHOWpZWFJwYjI0dWFISmxaaTV5WlhCc1lXTmxLQzhqTGlvdkxDQW5KeWt1YldGMFkyZ29MMXhjUHk0ckx5azdYRzRnSUNBZ0lDQnlaWFIxY200Z2JXRjBZMmdnUHlCdFlYUmphRnN3WFNBNklDY25PMXh1SUNBZ0lIMHNYRzVjYmlBZ0lDQXZMeUJIWlhSeklIUm9aU0IwY25WbElHaGhjMmdnZG1Gc2RXVXVJRU5oYm01dmRDQjFjMlVnYkc5allYUnBiMjR1YUdGemFDQmthWEpsWTNSc2VTQmtkV1VnZEc4Z1luVm5YRzRnSUNBZ0x5OGdhVzRnUm1seVpXWnZlQ0IzYUdWeVpTQnNiMk5oZEdsdmJpNW9ZWE5vSUhkcGJHd2dZV3gzWVhseklHSmxJR1JsWTI5a1pXUXVYRzRnSUNBZ1oyVjBTR0Z6YURvZ1puVnVZM1JwYjI0b2QybHVaRzkzS1NCN1hHNGdJQ0FnSUNCMllYSWdiV0YwWTJnZ1BTQW9kMmx1Wkc5M0lIeDhJSFJvYVhNcExteHZZMkYwYVc5dUxtaHlaV1l1YldGMFkyZ29MeU1vTGlvcEpDOHBPMXh1SUNBZ0lDQWdjbVYwZFhKdUlHMWhkR05vSUQ4Z2JXRjBZMmhiTVYwZ09pQW5KenRjYmlBZ0lDQjlMRnh1WEc0Z0lDQWdMeThnUjJWMElIUm9aU0J3WVhSb2JtRnRaU0JoYm1RZ2MyVmhjbU5vSUhCaGNtRnRjeXdnZDJsMGFHOTFkQ0IwYUdVZ2NtOXZkQzVjYmlBZ0lDQm5aWFJRWVhSb09pQm1kVzVqZEdsdmJpZ3BJSHRjYmlBZ0lDQWdJSFpoY2lCd1lYUm9JRDBnZEdocGN5NWtaV052WkdWR2NtRm5iV1Z1ZENoY2JpQWdJQ0FnSUNBZ2RHaHBjeTVzYjJOaGRHbHZiaTV3WVhSb2JtRnRaU0FySUhSb2FYTXVaMlYwVTJWaGNtTm9LQ2xjYmlBZ0lDQWdJQ2t1YzJ4cFkyVW9kR2hwY3k1eWIyOTBMbXhsYm1kMGFDQXRJREVwTzF4dUlDQWdJQ0FnY21WMGRYSnVJSEJoZEdndVkyaGhja0YwS0RBcElEMDlQU0FuTHljZ1B5QndZWFJvTG5Oc2FXTmxLREVwSURvZ2NHRjBhRHRjYmlBZ0lDQjlMRnh1WEc0Z0lDQWdMeThnUjJWMElIUm9aU0JqY205emN5MWljbTkzYzJWeUlHNXZjbTFoYkdsNlpXUWdWVkpNSUdaeVlXZHRaVzUwSUdaeWIyMGdkR2hsSUhCaGRHZ2diM0lnYUdGemFDNWNiaUFnSUNCblpYUkdjbUZuYldWdWREb2dablZ1WTNScGIyNG9abkpoWjIxbGJuUXBJSHRjYmlBZ0lDQWdJR2xtSUNobWNtRm5iV1Z1ZENBOVBTQnVkV3hzS1NCN1hHNGdJQ0FnSUNBZ0lHbG1JQ2gwYUdsekxsOTFjMlZRZFhOb1UzUmhkR1VnZkh3Z0lYUm9hWE11WDNkaGJuUnpTR0Z6YUVOb1lXNW5aU2tnZTF4dUlDQWdJQ0FnSUNBZ0lHWnlZV2R0Wlc1MElEMGdkR2hwY3k1blpYUlFZWFJvS0NrN1hHNGdJQ0FnSUNBZ0lIMGdaV3h6WlNCN1hHNGdJQ0FnSUNBZ0lDQWdabkpoWjIxbGJuUWdQU0IwYUdsekxtZGxkRWhoYzJnb0tUdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lDQWdmVnh1SUNBZ0lDQWdjbVYwZFhKdUlHWnlZV2R0Wlc1MExuSmxjR3hoWTJVb2NtOTFkR1ZUZEhKcGNIQmxjaXdnSnljcE8xeHVJQ0FnSUgwc1hHNWNiaUFnSUNBdkx5QlRkR0Z5ZENCMGFHVWdhR0Z6YUNCamFHRnVaMlVnYUdGdVpHeHBibWNzSUhKbGRIVnlibWx1WnlCZ2RISjFaV0FnYVdZZ2RHaGxJR04xY25KbGJuUWdWVkpNSUcxaGRHTm9aWE5jYmlBZ0lDQXZMeUJoYmlCbGVHbHpkR2x1WnlCeWIzVjBaU3dnWVc1a0lHQm1ZV3h6WldBZ2IzUm9aWEozYVhObExseHVJQ0FnSUhOMFlYSjBPaUJtZFc1amRHbHZiaWh2Y0hScGIyNXpLU0I3WEc0Z0lDQWdJQ0JwWmlBb1NHbHpkRzl5ZVM1emRHRnlkR1ZrS1NCMGFISnZkeUJ1WlhjZ1JYSnliM0lvSjBKaFkydGliMjVsTG1ocGMzUnZjbmtnYUdGeklHRnNjbVZoWkhrZ1ltVmxiaUJ6ZEdGeWRHVmtKeWs3WEc0Z0lDQWdJQ0JJYVhOMGIzSjVMbk4wWVhKMFpXUWdQU0IwY25WbE8xeHVYRzRnSUNBZ0lDQXZMeUJHYVdkMWNtVWdiM1YwSUhSb1pTQnBibWwwYVdGc0lHTnZibVpwWjNWeVlYUnBiMjR1SUVSdklIZGxJRzVsWldRZ1lXNGdhV1p5WVcxbFAxeHVJQ0FnSUNBZ0x5OGdTWE1nY0hWemFGTjBZWFJsSUdSbGMybHlaV1FnTGk0dUlHbHpJR2wwSUdGMllXbHNZV0pzWlQ5Y2JpQWdJQ0FnSUhSb2FYTXViM0IwYVc5dWN5QWdJQ0FnSUNBZ0lDQTlJRjh1WlhoMFpXNWtLSHR5YjI5ME9pQW5MeWQ5TENCMGFHbHpMbTl3ZEdsdmJuTXNJRzl3ZEdsdmJuTXBPMXh1SUNBZ0lDQWdkR2hwY3k1eWIyOTBJQ0FnSUNBZ0lDQWdJQ0FnSUQwZ2RHaHBjeTV2Y0hScGIyNXpMbkp2YjNRN1hHNGdJQ0FnSUNCMGFHbHpMbDkzWVc1MGMwaGhjMmhEYUdGdVoyVWdQU0IwYUdsekxtOXdkR2x2Ym5NdWFHRnphRU5vWVc1blpTQWhQVDBnWm1Gc2MyVTdYRzRnSUNBZ0lDQjBhR2x6TGw5b1lYTklZWE5vUTJoaGJtZGxJQ0FnUFNBbmIyNW9ZWE5vWTJoaGJtZGxKeUJwYmlCM2FXNWtiM2M3WEc0Z0lDQWdJQ0IwYUdsekxsOTFjMlZJWVhOb1EyaGhibWRsSUNBZ1BTQjBhR2x6TGw5M1lXNTBjMGhoYzJoRGFHRnVaMlVnSmlZZ2RHaHBjeTVmYUdGelNHRnphRU5vWVc1blpUdGNiaUFnSUNBZ0lIUm9hWE11WDNkaGJuUnpVSFZ6YUZOMFlYUmxJQ0E5SUNFaGRHaHBjeTV2Y0hScGIyNXpMbkIxYzJoVGRHRjBaVHRjYmlBZ0lDQWdJSFJvYVhNdVgyaGhjMUIxYzJoVGRHRjBaU0FnSUNBOUlDRWhLSFJvYVhNdWFHbHpkRzl5ZVNBbUppQjBhR2x6TG1ocGMzUnZjbmt1Y0hWemFGTjBZWFJsS1R0Y2JpQWdJQ0FnSUhSb2FYTXVYM1Z6WlZCMWMyaFRkR0YwWlNBZ0lDQTlJSFJvYVhNdVgzZGhiblJ6VUhWemFGTjBZWFJsSUNZbUlIUm9hWE11WDJoaGMxQjFjMmhUZEdGMFpUdGNiaUFnSUNBZ0lIUm9hWE11Wm5KaFoyMWxiblFnSUNBZ0lDQWdJQ0E5SUhSb2FYTXVaMlYwUm5KaFoyMWxiblFvS1R0Y2JseHVJQ0FnSUNBZ0x5OGdUbTl5YldGc2FYcGxJSEp2YjNRZ2RHOGdZV3gzWVhseklHbHVZMngxWkdVZ1lTQnNaV0ZrYVc1bklHRnVaQ0IwY21GcGJHbHVaeUJ6YkdGemFDNWNiaUFnSUNBZ0lIUm9hWE11Y205dmRDQTlJQ2duTHljZ0t5QjBhR2x6TG5KdmIzUWdLeUFuTHljcExuSmxjR3hoWTJVb2NtOXZkRk4wY21sd2NHVnlMQ0FuTHljcE8xeHVYRzRnSUNBZ0lDQXZMeUJVY21GdWMybDBhVzl1SUdaeWIyMGdhR0Z6YUVOb1lXNW5aU0IwYnlCd2RYTm9VM1JoZEdVZ2IzSWdkbWxqWlNCMlpYSnpZU0JwWmlCaWIzUm9JR0Z5WlZ4dUlDQWdJQ0FnTHk4Z2NtVnhkV1Z6ZEdWa0xseHVJQ0FnSUNBZ2FXWWdLSFJvYVhNdVgzZGhiblJ6U0dGemFFTm9ZVzVuWlNBbUppQjBhR2x6TGw5M1lXNTBjMUIxYzJoVGRHRjBaU2tnZTF4dVhHNGdJQ0FnSUNBZ0lDOHZJRWxtSUhkbEozWmxJSE4wWVhKMFpXUWdiMlptSUhkcGRHZ2dZU0J5YjNWMFpTQm1jbTl0SUdFZ1lIQjFjMmhUZEdGMFpXQXRaVzVoWW14bFpGeHVJQ0FnSUNBZ0lDQXZMeUJpY205M2MyVnlMQ0JpZFhRZ2QyVW5jbVVnWTNWeWNtVnVkR3g1SUdsdUlHRWdZbkp2ZDNObGNpQjBhR0YwSUdSdlpYTnVKM1FnYzNWd2NHOXlkQ0JwZEM0dUxseHVJQ0FnSUNBZ0lDQnBaaUFvSVhSb2FYTXVYMmhoYzFCMWMyaFRkR0YwWlNBbUppQWhkR2hwY3k1aGRGSnZiM1FvS1NrZ2UxeHVJQ0FnSUNBZ0lDQWdJSFpoY2lCeWIyOTBJRDBnZEdocGN5NXliMjkwTG5Oc2FXTmxLREFzSUMweEtTQjhmQ0FuTHljN1hHNGdJQ0FnSUNBZ0lDQWdkR2hwY3k1c2IyTmhkR2x2Ymk1eVpYQnNZV05sS0hKdmIzUWdLeUFuSXljZ0t5QjBhR2x6TG1kbGRGQmhkR2dvS1NrN1hHNGdJQ0FnSUNBZ0lDQWdMeThnVW1WMGRYSnVJR2x0YldWa2FXRjBaV3g1SUdGeklHSnliM2R6WlhJZ2QybHNiQ0JrYnlCeVpXUnBjbVZqZENCMGJ5QnVaWGNnZFhKc1hHNGdJQ0FnSUNBZ0lDQWdjbVYwZFhKdUlIUnlkV1U3WEc1Y2JpQWdJQ0FnSUNBZ0x5OGdUM0lnYVdZZ2QyVW5kbVVnYzNSaGNuUmxaQ0J2ZFhRZ2QybDBhQ0JoSUdoaGMyZ3RZbUZ6WldRZ2NtOTFkR1VzSUdKMWRDQjNaU2R5WlNCamRYSnlaVzUwYkhsY2JpQWdJQ0FnSUNBZ0x5OGdhVzRnWVNCaWNtOTNjMlZ5SUhkb1pYSmxJR2wwSUdOdmRXeGtJR0psSUdCd2RYTm9VM1JoZEdWZ0xXSmhjMlZrSUdsdWMzUmxZV1F1TGk1Y2JpQWdJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaDBhR2x6TGw5b1lYTlFkWE5vVTNSaGRHVWdKaVlnZEdocGN5NWhkRkp2YjNRb0tTa2dlMXh1SUNBZ0lDQWdJQ0FnSUhSb2FYTXVibUYyYVdkaGRHVW9kR2hwY3k1blpYUklZWE5vS0Nrc0lIdHlaWEJzWVdObE9pQjBjblZsZlNrN1hHNGdJQ0FnSUNBZ0lIMWNibHh1SUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0F2THlCUWNtOTRlU0JoYmlCcFpuSmhiV1VnZEc4Z2FHRnVaR3hsSUd4dlkyRjBhVzl1SUdWMlpXNTBjeUJwWmlCMGFHVWdZbkp2ZDNObGNpQmtiMlZ6YmlkMFhHNGdJQ0FnSUNBdkx5QnpkWEJ3YjNKMElIUm9aU0JnYUdGemFHTm9ZVzVuWldBZ1pYWmxiblFzSUVoVVRVdzFJR2hwYzNSdmNua3NJRzl5SUhSb1pTQjFjMlZ5SUhkaGJuUnpYRzRnSUNBZ0lDQXZMeUJnYUdGemFFTm9ZVzVuWldBZ1luVjBJRzV2ZENCZ2NIVnphRk4wWVhSbFlDNWNiaUFnSUNBZ0lHbG1JQ2doZEdocGN5NWZhR0Z6U0dGemFFTm9ZVzVuWlNBbUppQjBhR2x6TGw5M1lXNTBjMGhoYzJoRGFHRnVaMlVnSmlZZ0lYUm9hWE11WDNWelpWQjFjMmhUZEdGMFpTa2dlMXh1SUNBZ0lDQWdJQ0IwYUdsekxtbG1jbUZ0WlNBOUlHUnZZM1Z0Wlc1MExtTnlaV0YwWlVWc1pXMWxiblFvSjJsbWNtRnRaU2NwTzF4dUlDQWdJQ0FnSUNCMGFHbHpMbWxtY21GdFpTNXpjbU1nUFNBbmFtRjJZWE5qY21sd2REb3dKenRjYmlBZ0lDQWdJQ0FnZEdocGN5NXBabkpoYldVdWMzUjViR1V1WkdsemNHeGhlU0E5SUNkdWIyNWxKenRjYmlBZ0lDQWdJQ0FnZEdocGN5NXBabkpoYldVdWRHRmlTVzVrWlhnZ1BTQXRNVHRjYmlBZ0lDQWdJQ0FnZG1GeUlHSnZaSGtnUFNCa2IyTjFiV1Z1ZEM1aWIyUjVPMXh1SUNBZ0lDQWdJQ0F2THlCVmMybHVaeUJnWVhCd1pXNWtRMmhwYkdSZ0lIZHBiR3dnZEdoeWIzY2diMjRnU1VVZ1BDQTVJR2xtSUhSb1pTQmtiMk4xYldWdWRDQnBjeUJ1YjNRZ2NtVmhaSGt1WEc0Z0lDQWdJQ0FnSUhaaGNpQnBWMmx1Wkc5M0lEMGdZbTlrZVM1cGJuTmxjblJDWldadmNtVW9kR2hwY3k1cFpuSmhiV1VzSUdKdlpIa3VabWx5YzNSRGFHbHNaQ2t1WTI5dWRHVnVkRmRwYm1SdmR6dGNiaUFnSUNBZ0lDQWdhVmRwYm1SdmR5NWtiMk4xYldWdWRDNXZjR1Z1S0NrN1hHNGdJQ0FnSUNBZ0lHbFhhVzVrYjNjdVpHOWpkVzFsYm5RdVkyeHZjMlVvS1R0Y2JpQWdJQ0FnSUNBZ2FWZHBibVJ2ZHk1c2IyTmhkR2x2Ymk1b1lYTm9JRDBnSnlNbklDc2dkR2hwY3k1bWNtRm5iV1Z1ZER0Y2JpQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ0x5OGdRV1JrSUdFZ1kzSnZjM010Y0d4aGRHWnZjbTBnWUdGa1pFVjJaVzUwVEdsemRHVnVaWEpnSUhOb2FXMGdabTl5SUc5c1pHVnlJR0p5YjNkelpYSnpMbHh1SUNBZ0lDQWdkbUZ5SUdGa1pFVjJaVzUwVEdsemRHVnVaWElnUFNCM2FXNWtiM2N1WVdSa1JYWmxiblJNYVhOMFpXNWxjaUI4ZkNCbWRXNWpkR2x2YmlBb1pYWmxiblJPWVcxbExDQnNhWE4wWlc1bGNpa2dlMXh1SUNBZ0lDQWdJQ0J5WlhSMWNtNGdZWFIwWVdOb1JYWmxiblFvSjI5dUp5QXJJR1YyWlc1MFRtRnRaU3dnYkdsemRHVnVaWElwTzF4dUlDQWdJQ0FnZlR0Y2JseHVJQ0FnSUNBZ0x5OGdSR1Z3Wlc1a2FXNW5JRzl1SUhkb1pYUm9aWElnZDJVbmNtVWdkWE5wYm1jZ2NIVnphRk4wWVhSbElHOXlJR2hoYzJobGN5d2dZVzVrSUhkb1pYUm9aWEpjYmlBZ0lDQWdJQzh2SUNkdmJtaGhjMmhqYUdGdVoyVW5JR2x6SUhOMWNIQnZjblJsWkN3Z1pHVjBaWEp0YVc1bElHaHZkeUIzWlNCamFHVmpheUIwYUdVZ1ZWSk1JSE4wWVhSbExseHVJQ0FnSUNBZ2FXWWdLSFJvYVhNdVgzVnpaVkIxYzJoVGRHRjBaU2tnZTF4dUlDQWdJQ0FnSUNCaFpHUkZkbVZ1ZEV4cGMzUmxibVZ5S0Nkd2IzQnpkR0YwWlNjc0lIUm9hWE11WTJobFkydFZjbXdzSUdaaGJITmxLVHRjYmlBZ0lDQWdJSDBnWld4elpTQnBaaUFvZEdocGN5NWZkWE5sU0dGemFFTm9ZVzVuWlNBbUppQWhkR2hwY3k1cFpuSmhiV1VwSUh0Y2JpQWdJQ0FnSUNBZ1lXUmtSWFpsYm5STWFYTjBaVzVsY2lnbmFHRnphR05vWVc1blpTY3NJSFJvYVhNdVkyaGxZMnRWY213c0lHWmhiSE5sS1R0Y2JpQWdJQ0FnSUgwZ1pXeHpaU0JwWmlBb2RHaHBjeTVmZDJGdWRITklZWE5vUTJoaGJtZGxLU0I3WEc0Z0lDQWdJQ0FnSUhSb2FYTXVYMk5vWldOclZYSnNTVzUwWlhKMllXd2dQU0J6WlhSSmJuUmxjblpoYkNoMGFHbHpMbU5vWldOclZYSnNMQ0IwYUdsekxtbHVkR1Z5ZG1Gc0tUdGNiaUFnSUNBZ0lIMWNibHh1SUNBZ0lDQWdhV1lnS0NGMGFHbHpMbTl3ZEdsdmJuTXVjMmxzWlc1MEtTQnlaWFIxY200Z2RHaHBjeTVzYjJGa1ZYSnNLQ2s3WEc0Z0lDQWdmU3hjYmx4dUlDQWdJQzh2SUVScGMyRmliR1VnUW1GamEySnZibVV1YUdsemRHOXllU3dnY0dWeWFHRndjeUIwWlcxd2IzSmhjbWxzZVM0Z1RtOTBJSFZ6WldaMWJDQnBiaUJoSUhKbFlXd2dZWEJ3TEZ4dUlDQWdJQzh2SUdKMWRDQndiM056YVdKc2VTQjFjMlZtZFd3Z1ptOXlJSFZ1YVhRZ2RHVnpkR2x1WnlCU2IzVjBaWEp6TGx4dUlDQWdJSE4wYjNBNklHWjFibU4wYVc5dUtDa2dlMXh1SUNBZ0lDQWdMeThnUVdSa0lHRWdZM0p2YzNNdGNHeGhkR1p2Y20wZ1lISmxiVzkyWlVWMlpXNTBUR2x6ZEdWdVpYSmdJSE5vYVcwZ1ptOXlJRzlzWkdWeUlHSnliM2R6WlhKekxseHVJQ0FnSUNBZ2RtRnlJSEpsYlc5MlpVVjJaVzUwVEdsemRHVnVaWElnUFNCM2FXNWtiM2N1Y21WdGIzWmxSWFpsYm5STWFYTjBaVzVsY2lCOGZDQm1kVzVqZEdsdmJpQW9aWFpsYm5ST1lXMWxMQ0JzYVhOMFpXNWxjaWtnZTF4dUlDQWdJQ0FnSUNCeVpYUjFjbTRnWkdWMFlXTm9SWFpsYm5Rb0oyOXVKeUFySUdWMlpXNTBUbUZ0WlN3Z2JHbHpkR1Z1WlhJcE8xeHVJQ0FnSUNBZ2ZUdGNibHh1SUNBZ0lDQWdMeThnVW1WdGIzWmxJSGRwYm1SdmR5QnNhWE4wWlc1bGNuTXVYRzRnSUNBZ0lDQnBaaUFvZEdocGN5NWZkWE5sVUhWemFGTjBZWFJsS1NCN1hHNGdJQ0FnSUNBZ0lISmxiVzkyWlVWMlpXNTBUR2x6ZEdWdVpYSW9KM0J2Y0hOMFlYUmxKeXdnZEdocGN5NWphR1ZqYTFWeWJDd2dabUZzYzJVcE8xeHVJQ0FnSUNBZ2ZTQmxiSE5sSUdsbUlDaDBhR2x6TGw5MWMyVklZWE5vUTJoaGJtZGxJQ1ltSUNGMGFHbHpMbWxtY21GdFpTa2dlMXh1SUNBZ0lDQWdJQ0J5WlcxdmRtVkZkbVZ1ZEV4cGMzUmxibVZ5S0Nkb1lYTm9ZMmhoYm1kbEp5d2dkR2hwY3k1amFHVmphMVZ5YkN3Z1ptRnNjMlVwTzF4dUlDQWdJQ0FnZlZ4dVhHNGdJQ0FnSUNBdkx5QkRiR1ZoYmlCMWNDQjBhR1VnYVdaeVlXMWxJR2xtSUc1bFkyVnpjMkZ5ZVM1Y2JpQWdJQ0FnSUdsbUlDaDBhR2x6TG1sbWNtRnRaU2tnZTF4dUlDQWdJQ0FnSUNCa2IyTjFiV1Z1ZEM1aWIyUjVMbkpsYlc5MlpVTm9hV3hrS0hSb2FYTXVhV1p5WVcxbEtUdGNiaUFnSUNBZ0lDQWdkR2hwY3k1cFpuSmhiV1VnUFNCdWRXeHNPMXh1SUNBZ0lDQWdmVnh1WEc0Z0lDQWdJQ0F2THlCVGIyMWxJR1Z1ZG1seWIyNXRaVzUwY3lCM2FXeHNJSFJvY205M0lIZG9aVzRnWTJ4bFlYSnBibWNnWVc0Z2RXNWtaV1pwYm1Wa0lHbHVkR1Z5ZG1Gc0xseHVJQ0FnSUNBZ2FXWWdLSFJvYVhNdVgyTm9aV05yVlhKc1NXNTBaWEoyWVd3cElHTnNaV0Z5U1c1MFpYSjJZV3dvZEdocGN5NWZZMmhsWTJ0VmNteEpiblJsY25aaGJDazdYRzRnSUNBZ0lDQklhWE4wYjNKNUxuTjBZWEowWldRZ1BTQm1ZV3h6WlR0Y2JpQWdJQ0I5TEZ4dVhHNGdJQ0FnTHk4Z1FXUmtJR0VnY205MWRHVWdkRzhnWW1VZ2RHVnpkR1ZrSUhkb1pXNGdkR2hsSUdaeVlXZHRaVzUwSUdOb1lXNW5aWE11SUZKdmRYUmxjeUJoWkdSbFpDQnNZWFJsY2x4dUlDQWdJQzh2SUcxaGVTQnZkbVZ5Y21sa1pTQndjbVYyYVc5MWN5QnliM1YwWlhNdVhHNGdJQ0FnY205MWRHVTZJR1oxYm1OMGFXOXVLSEp2ZFhSbExDQmpZV3hzWW1GamF5a2dlMXh1SUNBZ0lDQWdkR2hwY3k1b1lXNWtiR1Z5Y3k1MWJuTm9hV1owS0h0eWIzVjBaVG9nY205MWRHVXNJR05oYkd4aVlXTnJPaUJqWVd4c1ltRmphMzBwTzF4dUlDQWdJSDBzWEc1Y2JpQWdJQ0F2THlCRGFHVmphM01nZEdobElHTjFjbkpsYm5RZ1ZWSk1JSFJ2SUhObFpTQnBaaUJwZENCb1lYTWdZMmhoYm1kbFpDd2dZVzVrSUdsbUlHbDBJR2hoY3l4Y2JpQWdJQ0F2THlCallXeHNjeUJnYkc5aFpGVnliR0FzSUc1dmNtMWhiR2w2YVc1bklHRmpjbTl6Y3lCMGFHVWdhR2xrWkdWdUlHbG1jbUZ0WlM1Y2JpQWdJQ0JqYUdWamExVnliRG9nWm5WdVkzUnBiMjRvWlNrZ2UxeHVJQ0FnSUNBZ2RtRnlJR04xY25KbGJuUWdQU0IwYUdsekxtZGxkRVp5WVdkdFpXNTBLQ2s3WEc1Y2JpQWdJQ0FnSUM4dklFbG1JSFJvWlNCMWMyVnlJSEJ5WlhOelpXUWdkR2hsSUdKaFkyc2dZblYwZEc5dUxDQjBhR1VnYVdaeVlXMWxKM01nYUdGemFDQjNhV3hzSUdoaGRtVmNiaUFnSUNBZ0lDOHZJR05vWVc1blpXUWdZVzVrSUhkbElITm9iM1ZzWkNCMWMyVWdkR2hoZENCbWIzSWdZMjl0Y0dGeWFYTnZiaTVjYmlBZ0lDQWdJR2xtSUNoamRYSnlaVzUwSUQwOVBTQjBhR2x6TG1aeVlXZHRaVzUwSUNZbUlIUm9hWE11YVdaeVlXMWxLU0I3WEc0Z0lDQWdJQ0FnSUdOMWNuSmxiblFnUFNCMGFHbHpMbWRsZEVoaGMyZ29kR2hwY3k1cFpuSmhiV1V1WTI5dWRHVnVkRmRwYm1SdmR5azdYRzRnSUNBZ0lDQjlYRzVjYmlBZ0lDQWdJR2xtSUNoamRYSnlaVzUwSUQwOVBTQjBhR2x6TG1aeVlXZHRaVzUwS1NCeVpYUjFjbTRnWm1Gc2MyVTdYRzRnSUNBZ0lDQnBaaUFvZEdocGN5NXBabkpoYldVcElIUm9hWE11Ym1GMmFXZGhkR1VvWTNWeWNtVnVkQ2s3WEc0Z0lDQWdJQ0IwYUdsekxteHZZV1JWY213b0tUdGNiaUFnSUNCOUxGeHVYRzRnSUNBZ0x5OGdRWFIwWlcxd2RDQjBieUJzYjJGa0lIUm9aU0JqZFhKeVpXNTBJRlZTVENCbWNtRm5iV1Z1ZEM0Z1NXWWdZU0J5YjNWMFpTQnpkV05qWldWa2N5QjNhWFJvSUdGY2JpQWdJQ0F2THlCdFlYUmphQ3dnY21WMGRYSnVjeUJnZEhKMVpXQXVJRWxtSUc1dklHUmxabWx1WldRZ2NtOTFkR1Z6SUcxaGRHTm9aWE1nZEdobElHWnlZV2R0Wlc1MExGeHVJQ0FnSUM4dklISmxkSFZ5Ym5NZ1lHWmhiSE5sWUM1Y2JpQWdJQ0JzYjJGa1ZYSnNPaUJtZFc1amRHbHZiaWhtY21GbmJXVnVkQ2tnZTF4dUlDQWdJQ0FnTHk4Z1NXWWdkR2hsSUhKdmIzUWdaRzlsYzI0bmRDQnRZWFJqYUN3Z2JtOGdjbTkxZEdWeklHTmhiaUJ0WVhSamFDQmxhWFJvWlhJdVhHNGdJQ0FnSUNCcFppQW9JWFJvYVhNdWJXRjBZMmhTYjI5MEtDa3BJSEpsZEhWeWJpQm1ZV3h6WlR0Y2JpQWdJQ0FnSUdaeVlXZHRaVzUwSUQwZ2RHaHBjeTVtY21GbmJXVnVkQ0E5SUhSb2FYTXVaMlYwUm5KaFoyMWxiblFvWm5KaFoyMWxiblFwTzF4dUlDQWdJQ0FnY21WMGRYSnVJRjh1WVc1NUtIUm9hWE11YUdGdVpHeGxjbk1zSUdaMWJtTjBhVzl1S0doaGJtUnNaWElwSUh0Y2JpQWdJQ0FnSUNBZ2FXWWdLR2hoYm1Sc1pYSXVjbTkxZEdVdWRHVnpkQ2htY21GbmJXVnVkQ2twSUh0Y2JpQWdJQ0FnSUNBZ0lDQm9ZVzVrYkdWeUxtTmhiR3hpWVdOcktHWnlZV2R0Wlc1MEtUdGNiaUFnSUNBZ0lDQWdJQ0J5WlhSMWNtNGdkSEoxWlR0Y2JpQWdJQ0FnSUNBZ2ZWeHVJQ0FnSUNBZ2ZTazdYRzRnSUNBZ2ZTeGNibHh1SUNBZ0lDOHZJRk5oZG1VZ1lTQm1jbUZuYldWdWRDQnBiblJ2SUhSb1pTQm9ZWE5vSUdocGMzUnZjbmtzSUc5eUlISmxjR3hoWTJVZ2RHaGxJRlZTVENCemRHRjBaU0JwWmlCMGFHVmNiaUFnSUNBdkx5QW5jbVZ3YkdGalpTY2diM0IwYVc5dUlHbHpJSEJoYzNObFpDNGdXVzkxSUdGeVpTQnlaWE53YjI1emFXSnNaU0JtYjNJZ2NISnZjR1Z5YkhrZ1ZWSk1MV1Z1WTI5a2FXNW5YRzRnSUNBZ0x5OGdkR2hsSUdaeVlXZHRaVzUwSUdsdUlHRmtkbUZ1WTJVdVhHNGdJQ0FnTHk5Y2JpQWdJQ0F2THlCVWFHVWdiM0IwYVc5dWN5QnZZbXBsWTNRZ1kyRnVJR052Ym5SaGFXNGdZSFJ5YVdkblpYSTZJSFJ5ZFdWZ0lHbG1JSGx2ZFNCM2FYTm9JSFJ2SUdoaGRtVWdkR2hsWEc0Z0lDQWdMeThnY205MWRHVWdZMkZzYkdKaFkyc2dZbVVnWm1seVpXUWdLRzV2ZENCMWMzVmhiR3g1SUdSbGMybHlZV0pzWlNrc0lHOXlJR0J5WlhCc1lXTmxPaUIwY25WbFlDd2dhV1pjYmlBZ0lDQXZMeUI1YjNVZ2QybHphQ0IwYnlCdGIyUnBabmtnZEdobElHTjFjbkpsYm5RZ1ZWSk1JSGRwZEdodmRYUWdZV1JrYVc1bklHRnVJR1Z1ZEhKNUlIUnZJSFJvWlNCb2FYTjBiM0o1TGx4dUlDQWdJRzVoZG1sbllYUmxPaUJtZFc1amRHbHZiaWhtY21GbmJXVnVkQ3dnYjNCMGFXOXVjeWtnZTF4dUlDQWdJQ0FnYVdZZ0tDRklhWE4wYjNKNUxuTjBZWEowWldRcElISmxkSFZ5YmlCbVlXeHpaVHRjYmlBZ0lDQWdJR2xtSUNnaGIzQjBhVzl1Y3lCOGZDQnZjSFJwYjI1eklEMDlQU0IwY25WbEtTQnZjSFJwYjI1eklEMGdlM1J5YVdkblpYSTZJQ0VoYjNCMGFXOXVjMzA3WEc1Y2JpQWdJQ0FnSUM4dklFNXZjbTFoYkdsNlpTQjBhR1VnWm5KaFoyMWxiblF1WEc0Z0lDQWdJQ0JtY21GbmJXVnVkQ0E5SUhSb2FYTXVaMlYwUm5KaFoyMWxiblFvWm5KaFoyMWxiblFnZkh3Z0p5Y3BPMXh1WEc0Z0lDQWdJQ0F2THlCRWIyNG5kQ0JwYm1Oc2RXUmxJR0VnZEhKaGFXeHBibWNnYzJ4aGMyZ2diMjRnZEdobElISnZiM1F1WEc0Z0lDQWdJQ0IyWVhJZ2NtOXZkQ0E5SUhSb2FYTXVjbTl2ZER0Y2JpQWdJQ0FnSUdsbUlDaG1jbUZuYldWdWRDQTlQVDBnSnljZ2ZId2dabkpoWjIxbGJuUXVZMmhoY2tGMEtEQXBJRDA5UFNBblB5Y3BJSHRjYmlBZ0lDQWdJQ0FnY205dmRDQTlJSEp2YjNRdWMyeHBZMlVvTUN3Z0xURXBJSHg4SUNjdkp6dGNiaUFnSUNBZ0lIMWNiaUFnSUNBZ0lIWmhjaUIxY213Z1BTQnliMjkwSUNzZ1puSmhaMjFsYm5RN1hHNWNiaUFnSUNBZ0lDOHZJRk4wY21sd0lIUm9aU0JvWVhOb0lHRnVaQ0JrWldOdlpHVWdabTl5SUcxaGRHTm9hVzVuTGx4dUlDQWdJQ0FnWm5KaFoyMWxiblFnUFNCMGFHbHpMbVJsWTI5a1pVWnlZV2R0Wlc1MEtHWnlZV2R0Wlc1MExuSmxjR3hoWTJVb2NHRjBhRk4wY21sd2NHVnlMQ0FuSnlrcE8xeHVYRzRnSUNBZ0lDQnBaaUFvZEdocGN5NW1jbUZuYldWdWRDQTlQVDBnWm5KaFoyMWxiblFwSUhKbGRIVnlianRjYmlBZ0lDQWdJSFJvYVhNdVpuSmhaMjFsYm5RZ1BTQm1jbUZuYldWdWREdGNibHh1SUNBZ0lDQWdMeThnU1dZZ2NIVnphRk4wWVhSbElHbHpJR0YyWVdsc1lXSnNaU3dnZDJVZ2RYTmxJR2wwSUhSdklITmxkQ0IwYUdVZ1puSmhaMjFsYm5RZ1lYTWdZU0J5WldGc0lGVlNUQzVjYmlBZ0lDQWdJR2xtSUNoMGFHbHpMbDkxYzJWUWRYTm9VM1JoZEdVcElIdGNiaUFnSUNBZ0lDQWdkR2hwY3k1b2FYTjBiM0o1VzI5d2RHbHZibk11Y21Wd2JHRmpaU0EvSUNkeVpYQnNZV05sVTNSaGRHVW5JRG9nSjNCMWMyaFRkR0YwWlNkZEtIdDlMQ0JrYjJOMWJXVnVkQzUwYVhSc1pTd2dkWEpzS1R0Y2JseHVJQ0FnSUNBZ0x5OGdTV1lnYUdGemFDQmphR0Z1WjJWeklHaGhkbVZ1SjNRZ1ltVmxiaUJsZUhCc2FXTnBkR3g1SUdScGMyRmliR1ZrTENCMWNHUmhkR1VnZEdobElHaGhjMmhjYmlBZ0lDQWdJQzh2SUdaeVlXZHRaVzUwSUhSdklITjBiM0psSUdocGMzUnZjbmt1WEc0Z0lDQWdJQ0I5SUdWc2MyVWdhV1lnS0hSb2FYTXVYM2RoYm5SelNHRnphRU5vWVc1blpTa2dlMXh1SUNBZ0lDQWdJQ0IwYUdsekxsOTFjR1JoZEdWSVlYTm9LSFJvYVhNdWJHOWpZWFJwYjI0c0lHWnlZV2R0Wlc1MExDQnZjSFJwYjI1ekxuSmxjR3hoWTJVcE8xeHVJQ0FnSUNBZ0lDQnBaaUFvZEdocGN5NXBabkpoYldVZ0ppWWdLR1p5WVdkdFpXNTBJQ0U5UFNCMGFHbHpMbWRsZEVoaGMyZ29kR2hwY3k1cFpuSmhiV1V1WTI5dWRHVnVkRmRwYm1SdmR5a3BLU0I3WEc0Z0lDQWdJQ0FnSUNBZ2RtRnlJR2xYYVc1a2IzY2dQU0IwYUdsekxtbG1jbUZ0WlM1amIyNTBaVzUwVjJsdVpHOTNPMXh1WEc0Z0lDQWdJQ0FnSUNBZ0x5OGdUM0JsYm1sdVp5QmhibVFnWTJ4dmMybHVaeUIwYUdVZ2FXWnlZVzFsSUhSeWFXTnJjeUJKUlRjZ1lXNWtJR1ZoY214cFpYSWdkRzhnY0hWemFDQmhYRzRnSUNBZ0lDQWdJQ0FnTHk4Z2FHbHpkRzl5ZVNCbGJuUnllU0J2YmlCb1lYTm9MWFJoWnlCamFHRnVaMlV1SUNCWGFHVnVJSEpsY0d4aFkyVWdhWE1nZEhKMVpTd2dkMlVnWkc5dUozUmNiaUFnSUNBZ0lDQWdJQ0F2THlCM1lXNTBJSFJvYVhNdVhHNGdJQ0FnSUNBZ0lDQWdhV1lnS0NGdmNIUnBiMjV6TG5KbGNHeGhZMlVwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJR2xYYVc1a2IzY3VaRzlqZFcxbGJuUXViM0JsYmlncE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnYVZkcGJtUnZkeTVrYjJOMWJXVnVkQzVqYkc5elpTZ3BPMXh1SUNBZ0lDQWdJQ0FnSUgxY2JseHVJQ0FnSUNBZ0lDQWdJSFJvYVhNdVgzVndaR0YwWlVoaGMyZ29hVmRwYm1SdmR5NXNiMk5oZEdsdmJpd2dabkpoWjIxbGJuUXNJRzl3ZEdsdmJuTXVjbVZ3YkdGalpTazdYRzRnSUNBZ0lDQWdJSDFjYmx4dUlDQWdJQ0FnTHk4Z1NXWWdlVzkxSjNabElIUnZiR1FnZFhNZ2RHaGhkQ0I1YjNVZ1pYaHdiR2xqYVhSc2VTQmtiMjRuZENCM1lXNTBJR1poYkd4aVlXTnJJR2hoYzJoamFHRnVaMlV0WEc0Z0lDQWdJQ0F2THlCaVlYTmxaQ0JvYVhOMGIzSjVMQ0IwYUdWdUlHQnVZWFpwWjJGMFpXQWdZbVZqYjIxbGN5QmhJSEJoWjJVZ2NtVm1jbVZ6YUM1Y2JpQWdJQ0FnSUgwZ1pXeHpaU0I3WEc0Z0lDQWdJQ0FnSUhKbGRIVnliaUIwYUdsekxteHZZMkYwYVc5dUxtRnpjMmxuYmloMWNtd3BPMXh1SUNBZ0lDQWdmVnh1SUNBZ0lDQWdhV1lnS0c5d2RHbHZibk11ZEhKcFoyZGxjaWtnY21WMGRYSnVJSFJvYVhNdWJHOWhaRlZ5YkNobWNtRm5iV1Z1ZENrN1hHNGdJQ0FnZlN4Y2JseHVJQ0FnSUM4dklGVndaR0YwWlNCMGFHVWdhR0Z6YUNCc2IyTmhkR2x2Yml3Z1pXbDBhR1Z5SUhKbGNHeGhZMmx1WnlCMGFHVWdZM1Z5Y21WdWRDQmxiblJ5ZVN3Z2IzSWdZV1JrYVc1blhHNGdJQ0FnTHk4Z1lTQnVaWGNnYjI1bElIUnZJSFJvWlNCaWNtOTNjMlZ5SUdocGMzUnZjbmt1WEc0Z0lDQWdYM1Z3WkdGMFpVaGhjMmc2SUdaMWJtTjBhVzl1S0d4dlkyRjBhVzl1TENCbWNtRm5iV1Z1ZEN3Z2NtVndiR0ZqWlNrZ2UxeHVJQ0FnSUNBZ2FXWWdLSEpsY0d4aFkyVXBJSHRjYmlBZ0lDQWdJQ0FnZG1GeUlHaHlaV1lnUFNCc2IyTmhkR2x2Ymk1b2NtVm1MbkpsY0d4aFkyVW9MeWhxWVhaaGMyTnlhWEIwT253aktTNHFKQzhzSUNjbktUdGNiaUFnSUNBZ0lDQWdiRzlqWVhScGIyNHVjbVZ3YkdGalpTaG9jbVZtSUNzZ0p5TW5JQ3NnWm5KaFoyMWxiblFwTzF4dUlDQWdJQ0FnZlNCbGJITmxJSHRjYmlBZ0lDQWdJQ0FnTHk4Z1UyOXRaU0JpY205M2MyVnljeUJ5WlhGMWFYSmxJSFJvWVhRZ1lHaGhjMmhnSUdOdmJuUmhhVzV6SUdFZ2JHVmhaR2x1WnlBakxseHVJQ0FnSUNBZ0lDQnNiMk5oZEdsdmJpNW9ZWE5vSUQwZ0p5TW5JQ3NnWm5KaFoyMWxiblE3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmVnh1WEc0Z0lIMHBPMXh1WEc0Z0lDOHZJRU55WldGMFpTQjBhR1VnWkdWbVlYVnNkQ0JDWVdOclltOXVaUzVvYVhOMGIzSjVMbHh1SUNCQ1lXTnJZbTl1WlM1b2FYTjBiM0o1SUQwZ2JtVjNJRWhwYzNSdmNuazdYRzVjYmlBZ0x5OGdTR1ZzY0dWeWMxeHVJQ0F2THlBdExTMHRMUzB0WEc1Y2JpQWdMeThnU0dWc2NHVnlJR1oxYm1OMGFXOXVJSFJ2SUdOdmNuSmxZM1JzZVNCelpYUWdkWEFnZEdobElIQnliM1J2ZEhsd1pTQmphR0ZwYmlCbWIzSWdjM1ZpWTJ4aGMzTmxjeTVjYmlBZ0x5OGdVMmx0YVd4aGNpQjBieUJnWjI5dlp5NXBibWhsY21sMGMyQXNJR0oxZENCMWMyVnpJR0VnYUdGemFDQnZaaUJ3Y205MGIzUjVjR1VnY0hKdmNHVnlkR2xsY3lCaGJtUmNiaUFnTHk4Z1kyeGhjM01nY0hKdmNHVnlkR2xsY3lCMGJ5QmlaU0JsZUhSbGJtUmxaQzVjYmlBZ2RtRnlJR1Y0ZEdWdVpDQTlJR1oxYm1OMGFXOXVLSEJ5YjNSdlVISnZjSE1zSUhOMFlYUnBZMUJ5YjNCektTQjdYRzRnSUNBZ2RtRnlJSEJoY21WdWRDQTlJSFJvYVhNN1hHNGdJQ0FnZG1GeUlHTm9hV3hrTzF4dVhHNGdJQ0FnTHk4Z1ZHaGxJR052Ym5OMGNuVmpkRzl5SUdaMWJtTjBhVzl1SUdadmNpQjBhR1VnYm1WM0lITjFZbU5zWVhOeklHbHpJR1ZwZEdobGNpQmtaV1pwYm1Wa0lHSjVJSGx2ZFZ4dUlDQWdJQzh2SUNoMGFHVWdYQ0pqYjI1emRISjFZM1J2Y2x3aUlIQnliM0JsY25SNUlHbHVJSGx2ZFhJZ1lHVjRkR1Z1WkdBZ1pHVm1hVzVwZEdsdmJpa3NJRzl5SUdSbFptRjFiSFJsWkZ4dUlDQWdJQzh2SUdKNUlIVnpJSFJ2SUhOcGJYQnNlU0JqWVd4c0lIUm9aU0J3WVhKbGJuUWdZMjl1YzNSeWRXTjBiM0l1WEc0Z0lDQWdhV1lnS0hCeWIzUnZVSEp2Y0hNZ0ppWWdYeTVvWVhNb2NISnZkRzlRY205d2N5d2dKMk52Ym5OMGNuVmpkRzl5SnlrcElIdGNiaUFnSUNBZ0lHTm9hV3hrSUQwZ2NISnZkRzlRY205d2N5NWpiMjV6ZEhKMVkzUnZjanRjYmlBZ0lDQjlJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ1kyaHBiR1FnUFNCbWRXNWpkR2x2YmlncGV5QnlaWFIxY200Z2NHRnlaVzUwTG1Gd2NHeDVLSFJvYVhNc0lHRnlaM1Z0Wlc1MGN5azdJSDA3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdMeThnUVdSa0lITjBZWFJwWXlCd2NtOXdaWEowYVdWeklIUnZJSFJvWlNCamIyNXpkSEoxWTNSdmNpQm1kVzVqZEdsdmJpd2dhV1lnYzNWd2NHeHBaV1F1WEc0Z0lDQWdYeTVsZUhSbGJtUW9ZMmhwYkdRc0lIQmhjbVZ1ZEN3Z2MzUmhkR2xqVUhKdmNITXBPMXh1WEc0Z0lDQWdMeThnVTJWMElIUm9aU0J3Y205MGIzUjVjR1VnWTJoaGFXNGdkRzhnYVc1b1pYSnBkQ0JtY205dElHQndZWEpsYm5SZ0xDQjNhWFJvYjNWMElHTmhiR3hwYm1kY2JpQWdJQ0F2THlCZ2NHRnlaVzUwWUNCamIyNXpkSEoxWTNSdmNpQm1kVzVqZEdsdmJpNWNiaUFnSUNCMllYSWdVM1Z5Y205bllYUmxJRDBnWm5WdVkzUnBiMjRvS1hzZ2RHaHBjeTVqYjI1emRISjFZM1J2Y2lBOUlHTm9hV3hrT3lCOU8xeHVJQ0FnSUZOMWNuSnZaMkYwWlM1d2NtOTBiM1I1Y0dVZ1BTQndZWEpsYm5RdWNISnZkRzkwZVhCbE8xeHVJQ0FnSUdOb2FXeGtMbkJ5YjNSdmRIbHdaU0E5SUc1bGR5QlRkWEp5YjJkaGRHVTdYRzVjYmlBZ0lDQXZMeUJCWkdRZ2NISnZkRzkwZVhCbElIQnliM0JsY25ScFpYTWdLR2x1YzNSaGJtTmxJSEJ5YjNCbGNuUnBaWE1wSUhSdklIUm9aU0J6ZFdKamJHRnpjeXhjYmlBZ0lDQXZMeUJwWmlCemRYQndiR2xsWkM1Y2JpQWdJQ0JwWmlBb2NISnZkRzlRY205d2N5a2dYeTVsZUhSbGJtUW9ZMmhwYkdRdWNISnZkRzkwZVhCbExDQndjbTkwYjFCeWIzQnpLVHRjYmx4dUlDQWdJQzh2SUZObGRDQmhJR052Ym5abGJtbGxibU5sSUhCeWIzQmxjblI1SUdsdUlHTmhjMlVnZEdobElIQmhjbVZ1ZENkeklIQnliM1J2ZEhsd1pTQnBjeUJ1WldWa1pXUmNiaUFnSUNBdkx5QnNZWFJsY2k1Y2JpQWdJQ0JqYUdsc1pDNWZYM04xY0dWeVgxOGdQU0J3WVhKbGJuUXVjSEp2ZEc5MGVYQmxPMXh1WEc0Z0lDQWdjbVYwZFhKdUlHTm9hV3hrTzF4dUlDQjlPMXh1WEc0Z0lDOHZJRk5sZENCMWNDQnBibWhsY21sMFlXNWpaU0JtYjNJZ2RHaGxJRzF2WkdWc0xDQmpiMnhzWldOMGFXOXVMQ0J5YjNWMFpYSXNJSFpwWlhjZ1lXNWtJR2hwYzNSdmNua3VYRzRnSUUxdlpHVnNMbVY0ZEdWdVpDQTlJRU52Ykd4bFkzUnBiMjR1WlhoMFpXNWtJRDBnVW05MWRHVnlMbVY0ZEdWdVpDQTlJRlpwWlhjdVpYaDBaVzVrSUQwZ1NHbHpkRzl5ZVM1bGVIUmxibVFnUFNCbGVIUmxibVE3WEc1Y2JpQWdMeThnVkdoeWIzY2dZVzRnWlhKeWIzSWdkMmhsYmlCaElGVlNUQ0JwY3lCdVpXVmtaV1FzSUdGdVpDQnViMjVsSUdseklITjFjSEJzYVdWa0xseHVJQ0IyWVhJZ2RYSnNSWEp5YjNJZ1BTQm1kVzVqZEdsdmJpZ3BJSHRjYmlBZ0lDQjBhSEp2ZHlCdVpYY2dSWEp5YjNJb0owRWdYQ0oxY214Y0lpQndjbTl3WlhKMGVTQnZjaUJtZFc1amRHbHZiaUJ0ZFhOMElHSmxJSE53WldOcFptbGxaQ2NwTzF4dUlDQjlPMXh1WEc0Z0lDOHZJRmR5WVhBZ1lXNGdiM0IwYVc5dVlXd2daWEp5YjNJZ1kyRnNiR0poWTJzZ2QybDBhQ0JoSUdaaGJHeGlZV05ySUdWeWNtOXlJR1YyWlc1MExseHVJQ0IyWVhJZ2QzSmhjRVZ5Y205eUlEMGdablZ1WTNScGIyNG9iVzlrWld3c0lHOXdkR2x2Ym5NcElIdGNiaUFnSUNCMllYSWdaWEp5YjNJZ1BTQnZjSFJwYjI1ekxtVnljbTl5TzF4dUlDQWdJRzl3ZEdsdmJuTXVaWEp5YjNJZ1BTQm1kVzVqZEdsdmJpaHlaWE53S1NCN1hHNGdJQ0FnSUNCcFppQW9aWEp5YjNJcElHVnljbTl5TG1OaGJHd29iM0IwYVc5dWN5NWpiMjUwWlhoMExDQnRiMlJsYkN3Z2NtVnpjQ3dnYjNCMGFXOXVjeWs3WEc0Z0lDQWdJQ0J0YjJSbGJDNTBjbWxuWjJWeUtDZGxjbkp2Y2ljc0lHMXZaR1ZzTENCeVpYTndMQ0J2Y0hScGIyNXpLVHRjYmlBZ0lDQjlPMXh1SUNCOU8xeHVYRzRnSUhKbGRIVnliaUJDWVdOclltOXVaVHRjYmx4dWZTa3BPMXh1SWwxOSIsIjsoZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0LyoqXG5cdCAqIEBwcmVzZXJ2ZSBGYXN0Q2xpY2s6IHBvbHlmaWxsIHRvIHJlbW92ZSBjbGljayBkZWxheXMgb24gYnJvd3NlcnMgd2l0aCB0b3VjaCBVSXMuXG5cdCAqXG5cdCAqIEBjb2RpbmdzdGFuZGFyZCBmdGxhYnMtanN2MlxuXHQgKiBAY29weXJpZ2h0IFRoZSBGaW5hbmNpYWwgVGltZXMgTGltaXRlZCBbQWxsIFJpZ2h0cyBSZXNlcnZlZF1cblx0ICogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKHNlZSBMSUNFTlNFLnR4dClcblx0ICovXG5cblx0Lypqc2xpbnQgYnJvd3Nlcjp0cnVlLCBub2RlOnRydWUqL1xuXHQvKmdsb2JhbCBkZWZpbmUsIEV2ZW50LCBOb2RlKi9cblxuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZSBmYXN0LWNsaWNraW5nIGxpc3RlbmVycyBvbiB0aGUgc3BlY2lmaWVkIGxheWVyLlxuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtFbGVtZW50fSBsYXllciBUaGUgbGF5ZXIgdG8gbGlzdGVuIG9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzXG5cdCAqL1xuXHRmdW5jdGlvbiBGYXN0Q2xpY2sobGF5ZXIsIG9wdGlvbnMpIHtcblx0XHR2YXIgb2xkT25DbGljaztcblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciBhIGNsaWNrIGlzIGN1cnJlbnRseSBiZWluZyB0cmFja2VkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgYm9vbGVhblxuXHRcdCAqL1xuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXG5cblx0XHQvKipcblx0XHQgKiBUaW1lc3RhbXAgZm9yIHdoZW4gY2xpY2sgdHJhY2tpbmcgc3RhcnRlZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0ID0gMDtcblxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGVsZW1lbnQgYmVpbmcgdHJhY2tlZCBmb3IgYSBjbGljay5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIEV2ZW50VGFyZ2V0XG5cdFx0ICovXG5cdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblxuXG5cdFx0LyoqXG5cdFx0ICogWC1jb29yZGluYXRlIG9mIHRvdWNoIHN0YXJ0IGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50b3VjaFN0YXJ0WCA9IDA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFktY29vcmRpbmF0ZSBvZiB0b3VjaCBzdGFydCBldmVudC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudG91Y2hTdGFydFkgPSAwO1xuXG5cblx0XHQvKipcblx0XHQgKiBJRCBvZiB0aGUgbGFzdCB0b3VjaCwgcmV0cmlldmVkIGZyb20gVG91Y2guaWRlbnRpZmllci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMubGFzdFRvdWNoSWRlbnRpZmllciA9IDA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFRvdWNobW92ZSBib3VuZGFyeSwgYmV5b25kIHdoaWNoIGEgY2xpY2sgd2lsbCBiZSBjYW5jZWxsZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRvdWNoQm91bmRhcnkgPSBvcHRpb25zLnRvdWNoQm91bmRhcnkgfHwgMTA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBGYXN0Q2xpY2sgbGF5ZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBFbGVtZW50XG5cdFx0ICovXG5cdFx0dGhpcy5sYXllciA9IGxheWVyO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG1pbmltdW0gdGltZSBiZXR3ZWVuIHRhcCh0b3VjaHN0YXJ0IGFuZCB0b3VjaGVuZCkgZXZlbnRzXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRhcERlbGF5ID0gb3B0aW9ucy50YXBEZWxheSB8fCAyMDA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbWF4aW11bSB0aW1lIGZvciBhIHRhcFxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50YXBUaW1lb3V0ID0gb3B0aW9ucy50YXBUaW1lb3V0IHx8IDcwMDtcblxuXHRcdGlmIChGYXN0Q2xpY2subm90TmVlZGVkKGxheWVyKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFNvbWUgb2xkIHZlcnNpb25zIG9mIEFuZHJvaWQgZG9uJ3QgaGF2ZSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuXHRcdGZ1bmN0aW9uIGJpbmQobWV0aG9kLCBjb250ZXh0KSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiBtZXRob2QuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTsgfTtcblx0XHR9XG5cblxuXHRcdHZhciBtZXRob2RzID0gWydvbk1vdXNlJywgJ29uQ2xpY2snLCAnb25Ub3VjaFN0YXJ0JywgJ29uVG91Y2hNb3ZlJywgJ29uVG91Y2hFbmQnLCAnb25Ub3VjaENhbmNlbCddO1xuXHRcdHZhciBjb250ZXh0ID0gdGhpcztcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG1ldGhvZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjb250ZXh0W21ldGhvZHNbaV1dID0gYmluZChjb250ZXh0W21ldGhvZHNbaV1dLCBjb250ZXh0KTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdXAgZXZlbnQgaGFuZGxlcnMgYXMgcmVxdWlyZWRcblx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdH1cblxuXHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrLCB0cnVlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQsIGZhbHNlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlLCBmYWxzZSk7XG5cdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmQsIGZhbHNlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMub25Ub3VjaENhbmNlbCwgZmFsc2UpO1xuXG5cdFx0Ly8gSGFjayBpcyByZXF1aXJlZCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IEV2ZW50I3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiAoZS5nLiBBbmRyb2lkIDIpXG5cdFx0Ly8gd2hpY2ggaXMgaG93IEZhc3RDbGljayBub3JtYWxseSBzdG9wcyBjbGljayBldmVudHMgYnViYmxpbmcgdG8gY2FsbGJhY2tzIHJlZ2lzdGVyZWQgb24gdGhlIEZhc3RDbGlja1xuXHRcdC8vIGxheWVyIHdoZW4gdGhleSBhcmUgY2FuY2VsbGVkLlxuXHRcdGlmICghRXZlbnQucHJvdG90eXBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKSB7XG5cdFx0XHRcdHZhciBybXYgPSBOb2RlLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0XHRcdHJtdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjay5oaWphY2tlZCB8fCBjYWxsYmFjaywgY2FwdHVyZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cm12LmNhbGwobGF5ZXIsIHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKSB7XG5cdFx0XHRcdHZhciBhZHYgPSBOb2RlLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0XHRcdGFkdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjay5oaWphY2tlZCB8fCAoY2FsbGJhY2suaGlqYWNrZWQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdFx0aWYgKCFldmVudC5wcm9wYWdhdGlvblN0b3BwZWQpIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soZXZlbnQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pLCBjYXB0dXJlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhZHYuY2FsbChsYXllciwgdHlwZSwgY2FsbGJhY2ssIGNhcHR1cmUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIElmIGEgaGFuZGxlciBpcyBhbHJlYWR5IGRlY2xhcmVkIGluIHRoZSBlbGVtZW50J3Mgb25jbGljayBhdHRyaWJ1dGUsIGl0IHdpbGwgYmUgZmlyZWQgYmVmb3JlXG5cdFx0Ly8gRmFzdENsaWNrJ3Mgb25DbGljayBoYW5kbGVyLiBGaXggdGhpcyBieSBwdWxsaW5nIG91dCB0aGUgdXNlci1kZWZpbmVkIGhhbmRsZXIgZnVuY3Rpb24gYW5kXG5cdFx0Ly8gYWRkaW5nIGl0IGFzIGxpc3RlbmVyLlxuXHRcdGlmICh0eXBlb2YgbGF5ZXIub25jbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuXG5cdFx0XHQvLyBBbmRyb2lkIGJyb3dzZXIgb24gYXQgbGVhc3QgMy4yIHJlcXVpcmVzIGEgbmV3IHJlZmVyZW5jZSB0byB0aGUgZnVuY3Rpb24gaW4gbGF5ZXIub25jbGlja1xuXHRcdFx0Ly8gLSB0aGUgb2xkIG9uZSB3b24ndCB3b3JrIGlmIHBhc3NlZCB0byBhZGRFdmVudExpc3RlbmVyIGRpcmVjdGx5LlxuXHRcdFx0b2xkT25DbGljayA9IGxheWVyLm9uY2xpY2s7XG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdG9sZE9uQ2xpY2soZXZlbnQpO1xuXHRcdFx0fSwgZmFsc2UpO1xuXHRcdFx0bGF5ZXIub25jbGljayA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogV2luZG93cyBQaG9uZSA4LjEgZmFrZXMgdXNlciBhZ2VudCBzdHJpbmcgdG8gbG9vayBsaWtlIEFuZHJvaWQgYW5kIGlQaG9uZS5cblx0KlxuXHQqIEB0eXBlIGJvb2xlYW5cblx0Ki9cblx0dmFyIGRldmljZUlzV2luZG93c1Bob25lID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiV2luZG93cyBQaG9uZVwiKSA+PSAwO1xuXG5cdC8qKlxuXHQgKiBBbmRyb2lkIHJlcXVpcmVzIGV4Y2VwdGlvbnMuXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0FuZHJvaWQgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0FuZHJvaWQnKSA+IDAgJiYgIWRldmljZUlzV2luZG93c1Bob25lO1xuXG5cblx0LyoqXG5cdCAqIGlPUyByZXF1aXJlcyBleGNlcHRpb25zLlxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNJT1MgPSAvaVAoYWR8aG9uZXxvZCkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIWRldmljZUlzV2luZG93c1Bob25lO1xuXG5cblx0LyoqXG5cdCAqIGlPUyA0IHJlcXVpcmVzIGFuIGV4Y2VwdGlvbiBmb3Igc2VsZWN0IGVsZW1lbnRzLlxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNJT1M0ID0gZGV2aWNlSXNJT1MgJiYgKC9PUyA0X1xcZChfXFxkKT8vKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG5cblx0LyoqXG5cdCAqIGlPUyA2LjAtNy4qIHJlcXVpcmVzIHRoZSB0YXJnZXQgZWxlbWVudCB0byBiZSBtYW51YWxseSBkZXJpdmVkXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0lPU1dpdGhCYWRUYXJnZXQgPSBkZXZpY2VJc0lPUyAmJiAoL09TIFs2LTddX1xcZC8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cblx0LyoqXG5cdCAqIEJsYWNrQmVycnkgcmVxdWlyZXMgZXhjZXB0aW9ucy5cblx0ICpcblx0ICogQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0dmFyIGRldmljZUlzQmxhY2tCZXJyeTEwID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdCQjEwJykgPiAwO1xuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIGVsZW1lbnQgcmVxdWlyZXMgYSBuYXRpdmUgY2xpY2suXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0IFRhcmdldCBET00gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IG5lZWRzIGEgbmF0aXZlIGNsaWNrXG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm5lZWRzQ2xpY2sgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRzd2l0Y2ggKHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cblx0XHQvLyBEb24ndCBzZW5kIGEgc3ludGhldGljIGNsaWNrIHRvIGRpc2FibGVkIGlucHV0cyAoaXNzdWUgIzYyKVxuXHRcdGNhc2UgJ2J1dHRvbic6XG5cdFx0Y2FzZSAnc2VsZWN0Jzpcblx0XHRjYXNlICd0ZXh0YXJlYSc6XG5cdFx0XHRpZiAodGFyZ2V0LmRpc2FibGVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdpbnB1dCc6XG5cblx0XHRcdC8vIEZpbGUgaW5wdXRzIG5lZWQgcmVhbCBjbGlja3Mgb24gaU9TIDYgZHVlIHRvIGEgYnJvd3NlciBidWcgKGlzc3VlICM2OClcblx0XHRcdGlmICgoZGV2aWNlSXNJT1MgJiYgdGFyZ2V0LnR5cGUgPT09ICdmaWxlJykgfHwgdGFyZ2V0LmRpc2FibGVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdsYWJlbCc6XG5cdFx0Y2FzZSAnaWZyYW1lJzogLy8gaU9TOCBob21lc2NyZWVuIGFwcHMgY2FuIHByZXZlbnQgZXZlbnRzIGJ1YmJsaW5nIGludG8gZnJhbWVzXG5cdFx0Y2FzZSAndmlkZW8nOlxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICgvXFxibmVlZHNjbGlja1xcYi8pLnRlc3QodGFyZ2V0LmNsYXNzTmFtZSk7XG5cdH07XG5cblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBnaXZlbiBlbGVtZW50IHJlcXVpcmVzIGEgY2FsbCB0byBmb2N1cyB0byBzaW11bGF0ZSBjbGljayBpbnRvIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0IFRhcmdldCBET00gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IHJlcXVpcmVzIGEgY2FsbCB0byBmb2N1cyB0byBzaW11bGF0ZSBuYXRpdmUgY2xpY2suXG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm5lZWRzRm9jdXMgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRzd2l0Y2ggKHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0Y2FzZSAndGV4dGFyZWEnOlxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0Y2FzZSAnc2VsZWN0Jzpcblx0XHRcdHJldHVybiAhZGV2aWNlSXNBbmRyb2lkO1xuXHRcdGNhc2UgJ2lucHV0Jzpcblx0XHRcdHN3aXRjaCAodGFyZ2V0LnR5cGUpIHtcblx0XHRcdGNhc2UgJ2J1dHRvbic6XG5cdFx0XHRjYXNlICdjaGVja2JveCc6XG5cdFx0XHRjYXNlICdmaWxlJzpcblx0XHRcdGNhc2UgJ2ltYWdlJzpcblx0XHRcdGNhc2UgJ3JhZGlvJzpcblx0XHRcdGNhc2UgJ3N1Ym1pdCc6XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTm8gcG9pbnQgaW4gYXR0ZW1wdGluZyB0byBmb2N1cyBkaXNhYmxlZCBpbnB1dHNcblx0XHRcdHJldHVybiAhdGFyZ2V0LmRpc2FibGVkICYmICF0YXJnZXQucmVhZE9ubHk7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiAoL1xcYm5lZWRzZm9jdXNcXGIvKS50ZXN0KHRhcmdldC5jbGFzc05hbWUpO1xuXHRcdH1cblx0fTtcblxuXG5cdC8qKlxuXHQgKiBTZW5kIGEgY2xpY2sgZXZlbnQgdG8gdGhlIHNwZWNpZmllZCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEVsZW1lbnR9IHRhcmdldEVsZW1lbnRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuc2VuZENsaWNrID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCwgZXZlbnQpIHtcblx0XHR2YXIgY2xpY2tFdmVudCwgdG91Y2g7XG5cblx0XHQvLyBPbiBzb21lIEFuZHJvaWQgZGV2aWNlcyBhY3RpdmVFbGVtZW50IG5lZWRzIHRvIGJlIGJsdXJyZWQgb3RoZXJ3aXNlIHRoZSBzeW50aGV0aWMgY2xpY2sgd2lsbCBoYXZlIG5vIGVmZmVjdCAoIzI0KVxuXHRcdGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHRhcmdldEVsZW1lbnQpIHtcblx0XHRcdGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuXHRcdH1cblxuXHRcdHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG5cblx0XHQvLyBTeW50aGVzaXNlIGEgY2xpY2sgZXZlbnQsIHdpdGggYW4gZXh0cmEgYXR0cmlidXRlIHNvIGl0IGNhbiBiZSB0cmFja2VkXG5cdFx0Y2xpY2tFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuXHRcdGNsaWNrRXZlbnQuaW5pdE1vdXNlRXZlbnQodGhpcy5kZXRlcm1pbmVFdmVudFR5cGUodGFyZ2V0RWxlbWVudCksIHRydWUsIHRydWUsIHdpbmRvdywgMSwgdG91Y2guc2NyZWVuWCwgdG91Y2guc2NyZWVuWSwgdG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXHRcdGNsaWNrRXZlbnQuZm9yd2FyZGVkVG91Y2hFdmVudCA9IHRydWU7XG5cdFx0dGFyZ2V0RWxlbWVudC5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuXHR9O1xuXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZGV0ZXJtaW5lRXZlbnRUeXBlID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xuXG5cdFx0Ly9Jc3N1ZSAjMTU5OiBBbmRyb2lkIENocm9tZSBTZWxlY3QgQm94IGRvZXMgbm90IG9wZW4gd2l0aCBhIHN5bnRoZXRpYyBjbGljayBldmVudFxuXHRcdGlmIChkZXZpY2VJc0FuZHJvaWQgJiYgdGFyZ2V0RWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3QnKSB7XG5cdFx0XHRyZXR1cm4gJ21vdXNlZG93bic7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICdjbGljayc7XG5cdH07XG5cblxuXHQvKipcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xuXHRcdHZhciBsZW5ndGg7XG5cblx0XHQvLyBJc3N1ZSAjMTYwOiBvbiBpT1MgNywgc29tZSBpbnB1dCBlbGVtZW50cyAoZS5nLiBkYXRlIGRhdGV0aW1lIG1vbnRoKSB0aHJvdyBhIHZhZ3VlIFR5cGVFcnJvciBvbiBzZXRTZWxlY3Rpb25SYW5nZS4gVGhlc2UgZWxlbWVudHMgZG9uJ3QgaGF2ZSBhbiBpbnRlZ2VyIHZhbHVlIGZvciB0aGUgc2VsZWN0aW9uU3RhcnQgYW5kIHNlbGVjdGlvbkVuZCBwcm9wZXJ0aWVzLCBidXQgdW5mb3J0dW5hdGVseSB0aGF0IGNhbid0IGJlIHVzZWQgZm9yIGRldGVjdGlvbiBiZWNhdXNlIGFjY2Vzc2luZyB0aGUgcHJvcGVydGllcyBhbHNvIHRocm93cyBhIFR5cGVFcnJvci4gSnVzdCBjaGVjayB0aGUgdHlwZSBpbnN0ZWFkLiBGaWxlZCBhcyBBcHBsZSBidWcgIzE1MTIyNzI0LlxuXHRcdGlmIChkZXZpY2VJc0lPUyAmJiB0YXJnZXRFbGVtZW50LnNldFNlbGVjdGlvblJhbmdlICYmIHRhcmdldEVsZW1lbnQudHlwZS5pbmRleE9mKCdkYXRlJykgIT09IDAgJiYgdGFyZ2V0RWxlbWVudC50eXBlICE9PSAndGltZScgJiYgdGFyZ2V0RWxlbWVudC50eXBlICE9PSAnbW9udGgnKSB7XG5cdFx0XHRsZW5ndGggPSB0YXJnZXRFbGVtZW50LnZhbHVlLmxlbmd0aDtcblx0XHRcdHRhcmdldEVsZW1lbnQuc2V0U2VsZWN0aW9uUmFuZ2UobGVuZ3RoLCBsZW5ndGgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXRFbGVtZW50LmZvY3VzKCk7XG5cdFx0fVxuXHR9O1xuXG5cblx0LyoqXG5cdCAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHRhcmdldCBlbGVtZW50IGlzIGEgY2hpbGQgb2YgYSBzY3JvbGxhYmxlIGxheWVyIGFuZCBpZiBzbywgc2V0IGEgZmxhZyBvbiBpdC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLnVwZGF0ZVNjcm9sbFBhcmVudCA9IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQpIHtcblx0XHR2YXIgc2Nyb2xsUGFyZW50LCBwYXJlbnRFbGVtZW50O1xuXG5cdFx0c2Nyb2xsUGFyZW50ID0gdGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQ7XG5cblx0XHQvLyBBdHRlbXB0IHRvIGRpc2NvdmVyIHdoZXRoZXIgdGhlIHRhcmdldCBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBzY3JvbGxhYmxlIGxheWVyLiBSZS1jaGVjayBpZiB0aGVcblx0XHQvLyB0YXJnZXQgZWxlbWVudCB3YXMgbW92ZWQgdG8gYW5vdGhlciBwYXJlbnQuXG5cdFx0aWYgKCFzY3JvbGxQYXJlbnQgfHwgIXNjcm9sbFBhcmVudC5jb250YWlucyh0YXJnZXRFbGVtZW50KSkge1xuXHRcdFx0cGFyZW50RWxlbWVudCA9IHRhcmdldEVsZW1lbnQ7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGlmIChwYXJlbnRFbGVtZW50LnNjcm9sbEhlaWdodCA+IHBhcmVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0KSB7XG5cdFx0XHRcdFx0c2Nyb2xsUGFyZW50ID0gcGFyZW50RWxlbWVudDtcblx0XHRcdFx0XHR0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudCA9IHBhcmVudEVsZW1lbnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwYXJlbnRFbGVtZW50ID0gcGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0fSB3aGlsZSAocGFyZW50RWxlbWVudCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWx3YXlzIHVwZGF0ZSB0aGUgc2Nyb2xsIHRvcCB0cmFja2VyIGlmIHBvc3NpYmxlLlxuXHRcdGlmIChzY3JvbGxQYXJlbnQpIHtcblx0XHRcdHNjcm9sbFBhcmVudC5mYXN0Q2xpY2tMYXN0U2Nyb2xsVG9wID0gc2Nyb2xsUGFyZW50LnNjcm9sbFRvcDtcblx0XHR9XG5cdH07XG5cblxuXHQvKipcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0RWxlbWVudFxuXHQgKiBAcmV0dXJucyB7RWxlbWVudHxFdmVudFRhcmdldH1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZ2V0VGFyZ2V0RWxlbWVudEZyb21FdmVudFRhcmdldCA9IGZ1bmN0aW9uKGV2ZW50VGFyZ2V0KSB7XG5cblx0XHQvLyBPbiBzb21lIG9sZGVyIGJyb3dzZXJzIChub3RhYmx5IFNhZmFyaSBvbiBpT1MgNC4xIC0gc2VlIGlzc3VlICM1NikgdGhlIGV2ZW50IHRhcmdldCBtYXkgYmUgYSB0ZXh0IG5vZGUuXG5cdFx0aWYgKGV2ZW50VGFyZ2V0Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuXHRcdFx0cmV0dXJuIGV2ZW50VGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50VGFyZ2V0O1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE9uIHRvdWNoIHN0YXJ0LCByZWNvcmQgdGhlIHBvc2l0aW9uIGFuZCBzY3JvbGwgb2Zmc2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUub25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdGFyZ2V0RWxlbWVudCwgdG91Y2gsIHNlbGVjdGlvbjtcblxuXHRcdC8vIElnbm9yZSBtdWx0aXBsZSB0b3VjaGVzLCBvdGhlcndpc2UgcGluY2gtdG8tem9vbSBpcyBwcmV2ZW50ZWQgaWYgYm90aCBmaW5nZXJzIGFyZSBvbiB0aGUgRmFzdENsaWNrIGVsZW1lbnQgKGlzc3VlICMxMTEpLlxuXHRcdGlmIChldmVudC50YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHRhcmdldEVsZW1lbnQgPSB0aGlzLmdldFRhcmdldEVsZW1lbnRGcm9tRXZlbnRUYXJnZXQoZXZlbnQudGFyZ2V0KTtcblx0XHR0b3VjaCA9IGV2ZW50LnRhcmdldFRvdWNoZXNbMF07XG5cblx0XHRpZiAoZGV2aWNlSXNJT1MpIHtcblxuXHRcdFx0Ly8gT25seSB0cnVzdGVkIGV2ZW50cyB3aWxsIGRlc2VsZWN0IHRleHQgb24gaU9TIChpc3N1ZSAjNDkpXG5cdFx0XHRzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgJiYgIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFkZXZpY2VJc0lPUzQpIHtcblxuXHRcdFx0XHQvLyBXZWlyZCB0aGluZ3MgaGFwcGVuIG9uIGlPUyB3aGVuIGFuIGFsZXJ0IG9yIGNvbmZpcm0gZGlhbG9nIGlzIG9wZW5lZCBmcm9tIGEgY2xpY2sgZXZlbnQgY2FsbGJhY2sgKGlzc3VlICMyMyk6XG5cdFx0XHRcdC8vIHdoZW4gdGhlIHVzZXIgbmV4dCB0YXBzIGFueXdoZXJlIGVsc2Ugb24gdGhlIHBhZ2UsIG5ldyB0b3VjaHN0YXJ0IGFuZCB0b3VjaGVuZCBldmVudHMgYXJlIGRpc3BhdGNoZWRcblx0XHRcdFx0Ly8gd2l0aCB0aGUgc2FtZSBpZGVudGlmaWVyIGFzIHRoZSB0b3VjaCBldmVudCB0aGF0IHByZXZpb3VzbHkgdHJpZ2dlcmVkIHRoZSBjbGljayB0aGF0IHRyaWdnZXJlZCB0aGUgYWxlcnQuXG5cdFx0XHRcdC8vIFNhZGx5LCB0aGVyZSBpcyBhbiBpc3N1ZSBvbiBpT1MgNCB0aGF0IGNhdXNlcyBzb21lIG5vcm1hbCB0b3VjaCBldmVudHMgdG8gaGF2ZSB0aGUgc2FtZSBpZGVudGlmaWVyIGFzIGFuXG5cdFx0XHRcdC8vIGltbWVkaWF0ZWx5IHByZWNlZWRpbmcgdG91Y2ggZXZlbnQgKGlzc3VlICM1MiksIHNvIHRoaXMgZml4IGlzIHVuYXZhaWxhYmxlIG9uIHRoYXQgcGxhdGZvcm0uXG5cdFx0XHRcdC8vIElzc3VlIDEyMDogdG91Y2guaWRlbnRpZmllciBpcyAwIHdoZW4gQ2hyb21lIGRldiB0b29scyAnRW11bGF0ZSB0b3VjaCBldmVudHMnIGlzIHNldCB3aXRoIGFuIGlPUyBkZXZpY2UgVUEgc3RyaW5nLFxuXHRcdFx0XHQvLyB3aGljaCBjYXVzZXMgYWxsIHRvdWNoIGV2ZW50cyB0byBiZSBpZ25vcmVkLiBBcyB0aGlzIGJsb2NrIG9ubHkgYXBwbGllcyB0byBpT1MsIGFuZCBpT1MgaWRlbnRpZmllcnMgYXJlIGFsd2F5cyBsb25nLFxuXHRcdFx0XHQvLyByYW5kb20gaW50ZWdlcnMsIGl0J3Mgc2FmZSB0byB0byBjb250aW51ZSBpZiB0aGUgaWRlbnRpZmllciBpcyAwIGhlcmUuXG5cdFx0XHRcdGlmICh0b3VjaC5pZGVudGlmaWVyICYmIHRvdWNoLmlkZW50aWZpZXIgPT09IHRoaXMubGFzdFRvdWNoSWRlbnRpZmllcikge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5sYXN0VG91Y2hJZGVudGlmaWVyID0gdG91Y2guaWRlbnRpZmllcjtcblxuXHRcdFx0XHQvLyBJZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgYSBjaGlsZCBvZiBhIHNjcm9sbGFibGUgbGF5ZXIgKHVzaW5nIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaCkgYW5kOlxuXHRcdFx0XHQvLyAxKSB0aGUgdXNlciBkb2VzIGEgZmxpbmcgc2Nyb2xsIG9uIHRoZSBzY3JvbGxhYmxlIGxheWVyXG5cdFx0XHRcdC8vIDIpIHRoZSB1c2VyIHN0b3BzIHRoZSBmbGluZyBzY3JvbGwgd2l0aCBhbm90aGVyIHRhcFxuXHRcdFx0XHQvLyB0aGVuIHRoZSBldmVudC50YXJnZXQgb2YgdGhlIGxhc3QgJ3RvdWNoZW5kJyBldmVudCB3aWxsIGJlIHRoZSBlbGVtZW50IHRoYXQgd2FzIHVuZGVyIHRoZSB1c2VyJ3MgZmluZ2VyXG5cdFx0XHRcdC8vIHdoZW4gdGhlIGZsaW5nIHNjcm9sbCB3YXMgc3RhcnRlZCwgY2F1c2luZyBGYXN0Q2xpY2sgdG8gc2VuZCBhIGNsaWNrIGV2ZW50IHRvIHRoYXQgbGF5ZXIgLSB1bmxlc3MgYSBjaGVja1xuXHRcdFx0XHQvLyBpcyBtYWRlIHRvIGVuc3VyZSB0aGF0IGEgcGFyZW50IGxheWVyIHdhcyBub3Qgc2Nyb2xsZWQgYmVmb3JlIHNlbmRpbmcgYSBzeW50aGV0aWMgY2xpY2sgKGlzc3VlICM0MikuXG5cdFx0XHRcdHRoaXMudXBkYXRlU2Nyb2xsUGFyZW50KHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IHRydWU7XG5cdFx0dGhpcy50cmFja2luZ0NsaWNrU3RhcnQgPSBldmVudC50aW1lU3RhbXA7XG5cdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gdGFyZ2V0RWxlbWVudDtcblxuXHRcdHRoaXMudG91Y2hTdGFydFggPSB0b3VjaC5wYWdlWDtcblx0XHR0aGlzLnRvdWNoU3RhcnRZID0gdG91Y2gucGFnZVk7XG5cblx0XHQvLyBQcmV2ZW50IHBoYW50b20gY2xpY2tzIG9uIGZhc3QgZG91YmxlLXRhcCAoaXNzdWUgIzM2KVxuXHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdGhpcy5sYXN0Q2xpY2tUaW1lKSA8IHRoaXMudGFwRGVsYXkpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblxuXHQvKipcblx0ICogQmFzZWQgb24gYSB0b3VjaG1vdmUgZXZlbnQgb2JqZWN0LCBjaGVjayB3aGV0aGVyIHRoZSB0b3VjaCBoYXMgbW92ZWQgcGFzdCBhIGJvdW5kYXJ5IHNpbmNlIGl0IHN0YXJ0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS50b3VjaEhhc01vdmVkID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSwgYm91bmRhcnkgPSB0aGlzLnRvdWNoQm91bmRhcnk7XG5cblx0XHRpZiAoTWF0aC5hYnModG91Y2gucGFnZVggLSB0aGlzLnRvdWNoU3RhcnRYKSA+IGJvdW5kYXJ5IHx8IE1hdGguYWJzKHRvdWNoLnBhZ2VZIC0gdGhpcy50b3VjaFN0YXJ0WSkgPiBib3VuZGFyeSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgbGFzdCBwb3NpdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hNb3ZlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRpZiAoIXRoaXMudHJhY2tpbmdDbGljaykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIHRvdWNoIGhhcyBtb3ZlZCwgY2FuY2VsIHRoZSBjbGljayB0cmFja2luZ1xuXHRcdGlmICh0aGlzLnRhcmdldEVsZW1lbnQgIT09IHRoaXMuZ2V0VGFyZ2V0RWxlbWVudEZyb21FdmVudFRhcmdldChldmVudC50YXJnZXQpIHx8IHRoaXMudG91Y2hIYXNNb3ZlZChldmVudCkpIHtcblx0XHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBBdHRlbXB0IHRvIGZpbmQgdGhlIGxhYmVsbGVkIGNvbnRyb2wgZm9yIHRoZSBnaXZlbiBsYWJlbCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEhUTUxMYWJlbEVsZW1lbnR9IGxhYmVsRWxlbWVudFxuXHQgKiBAcmV0dXJucyB7RWxlbWVudHxudWxsfVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5maW5kQ29udHJvbCA9IGZ1bmN0aW9uKGxhYmVsRWxlbWVudCkge1xuXG5cdFx0Ly8gRmFzdCBwYXRoIGZvciBuZXdlciBicm93c2VycyBzdXBwb3J0aW5nIHRoZSBIVE1MNSBjb250cm9sIGF0dHJpYnV0ZVxuXHRcdGlmIChsYWJlbEVsZW1lbnQuY29udHJvbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gbGFiZWxFbGVtZW50LmNvbnRyb2w7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGJyb3dzZXJzIHVuZGVyIHRlc3QgdGhhdCBzdXBwb3J0IHRvdWNoIGV2ZW50cyBhbHNvIHN1cHBvcnQgdGhlIEhUTUw1IGh0bWxGb3IgYXR0cmlidXRlXG5cdFx0aWYgKGxhYmVsRWxlbWVudC5odG1sRm9yKSB7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobGFiZWxFbGVtZW50Lmh0bWxGb3IpO1xuXHRcdH1cblxuXHRcdC8vIElmIG5vIGZvciBhdHRyaWJ1dGUgZXhpc3RzLCBhdHRlbXB0IHRvIHJldHJpZXZlIHRoZSBmaXJzdCBsYWJlbGxhYmxlIGRlc2NlbmRhbnQgZWxlbWVudFxuXHRcdC8vIHRoZSBsaXN0IG9mIHdoaWNoIGlzIGRlZmluZWQgaGVyZTogaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCNjYXRlZ29yeS1sYWJlbFxuXHRcdHJldHVybiBsYWJlbEVsZW1lbnQucXVlcnlTZWxlY3RvcignYnV0dG9uLCBpbnB1dDpub3QoW3R5cGU9aGlkZGVuXSksIGtleWdlbiwgbWV0ZXIsIG91dHB1dCwgcHJvZ3Jlc3MsIHNlbGVjdCwgdGV4dGFyZWEnKTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBPbiB0b3VjaCBlbmQsIGRldGVybWluZSB3aGV0aGVyIHRvIHNlbmQgYSBjbGljayBldmVudCBhdCBvbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUub25Ub3VjaEVuZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIGZvckVsZW1lbnQsIHRyYWNraW5nQ2xpY2tTdGFydCwgdGFyZ2V0VGFnTmFtZSwgc2Nyb2xsUGFyZW50LCB0b3VjaCwgdGFyZ2V0RWxlbWVudCA9IHRoaXMudGFyZ2V0RWxlbWVudDtcblxuXHRcdGlmICghdGhpcy50cmFja2luZ0NsaWNrKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBQcmV2ZW50IHBoYW50b20gY2xpY2tzIG9uIGZhc3QgZG91YmxlLXRhcCAoaXNzdWUgIzM2KVxuXHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdGhpcy5sYXN0Q2xpY2tUaW1lKSA8IHRoaXMudGFwRGVsYXkpIHtcblx0XHRcdHRoaXMuY2FuY2VsTmV4dENsaWNrID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdGhpcy50cmFja2luZ0NsaWNrU3RhcnQpID4gdGhpcy50YXBUaW1lb3V0KSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBSZXNldCB0byBwcmV2ZW50IHdyb25nIGNsaWNrIGNhbmNlbCBvbiBpbnB1dCAoaXNzdWUgIzE1NikuXG5cdFx0dGhpcy5jYW5jZWxOZXh0Q2xpY2sgPSBmYWxzZTtcblxuXHRcdHRoaXMubGFzdENsaWNrVGltZSA9IGV2ZW50LnRpbWVTdGFtcDtcblxuXHRcdHRyYWNraW5nQ2xpY2tTdGFydCA9IHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0O1xuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXHRcdHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0ID0gMDtcblxuXHRcdC8vIE9uIHNvbWUgaU9TIGRldmljZXMsIHRoZSB0YXJnZXRFbGVtZW50IHN1cHBsaWVkIHdpdGggdGhlIGV2ZW50IGlzIGludmFsaWQgaWYgdGhlIGxheWVyXG5cdFx0Ly8gaXMgcGVyZm9ybWluZyBhIHRyYW5zaXRpb24gb3Igc2Nyb2xsLCBhbmQgaGFzIHRvIGJlIHJlLWRldGVjdGVkIG1hbnVhbGx5LiBOb3RlIHRoYXRcblx0XHQvLyBmb3IgdGhpcyB0byBmdW5jdGlvbiBjb3JyZWN0bHksIGl0IG11c3QgYmUgY2FsbGVkICphZnRlciogdGhlIGV2ZW50IHRhcmdldCBpcyBjaGVja2VkIVxuXHRcdC8vIFNlZSBpc3N1ZSAjNTc7IGFsc28gZmlsZWQgYXMgcmRhcjovLzEzMDQ4NTg5IC5cblx0XHRpZiAoZGV2aWNlSXNJT1NXaXRoQmFkVGFyZ2V0KSB7XG5cdFx0XHR0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuXG5cdFx0XHQvLyBJbiBjZXJ0YWluIGNhc2VzIGFyZ3VtZW50cyBvZiBlbGVtZW50RnJvbVBvaW50IGNhbiBiZSBuZWdhdGl2ZSwgc28gcHJldmVudCBzZXR0aW5nIHRhcmdldEVsZW1lbnQgdG8gbnVsbFxuXHRcdFx0dGFyZ2V0RWxlbWVudCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2gucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIHRvdWNoLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KSB8fCB0YXJnZXRFbGVtZW50O1xuXHRcdFx0dGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQgPSB0aGlzLnRhcmdldEVsZW1lbnQuZmFzdENsaWNrU2Nyb2xsUGFyZW50O1xuXHRcdH1cblxuXHRcdHRhcmdldFRhZ05hbWUgPSB0YXJnZXRFbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRpZiAodGFyZ2V0VGFnTmFtZSA9PT0gJ2xhYmVsJykge1xuXHRcdFx0Zm9yRWxlbWVudCA9IHRoaXMuZmluZENvbnRyb2wodGFyZ2V0RWxlbWVudCk7XG5cdFx0XHRpZiAoZm9yRWxlbWVudCkge1xuXHRcdFx0XHR0aGlzLmZvY3VzKHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGFyZ2V0RWxlbWVudCA9IGZvckVsZW1lbnQ7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0aGlzLm5lZWRzRm9jdXModGFyZ2V0RWxlbWVudCkpIHtcblxuXHRcdFx0Ly8gQ2FzZSAxOiBJZiB0aGUgdG91Y2ggc3RhcnRlZCBhIHdoaWxlIGFnbyAoYmVzdCBndWVzcyBpcyAxMDBtcyBiYXNlZCBvbiB0ZXN0cyBmb3IgaXNzdWUgIzM2KSB0aGVuIGZvY3VzIHdpbGwgYmUgdHJpZ2dlcmVkIGFueXdheS4gUmV0dXJuIGVhcmx5IGFuZCB1bnNldCB0aGUgdGFyZ2V0IGVsZW1lbnQgcmVmZXJlbmNlIHNvIHRoYXQgdGhlIHN1YnNlcXVlbnQgY2xpY2sgd2lsbCBiZSBhbGxvd2VkIHRocm91Z2guXG5cdFx0XHQvLyBDYXNlIDI6IFdpdGhvdXQgdGhpcyBleGNlcHRpb24gZm9yIGlucHV0IGVsZW1lbnRzIHRhcHBlZCB3aGVuIHRoZSBkb2N1bWVudCBpcyBjb250YWluZWQgaW4gYW4gaWZyYW1lLCB0aGVuIGFueSBpbnB1dHRlZCB0ZXh0IHdvbid0IGJlIHZpc2libGUgZXZlbiB0aG91Z2ggdGhlIHZhbHVlIGF0dHJpYnV0ZSBpcyB1cGRhdGVkIGFzIHRoZSB1c2VyIHR5cGVzIChpc3N1ZSAjMzcpLlxuXHRcdFx0aWYgKChldmVudC50aW1lU3RhbXAgLSB0cmFja2luZ0NsaWNrU3RhcnQpID4gMTAwIHx8IChkZXZpY2VJc0lPUyAmJiB3aW5kb3cudG9wICE9PSB3aW5kb3cgJiYgdGFyZ2V0VGFnTmFtZSA9PT0gJ2lucHV0JykpIHtcblx0XHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmZvY3VzKHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0dGhpcy5zZW5kQ2xpY2sodGFyZ2V0RWxlbWVudCwgZXZlbnQpO1xuXG5cdFx0XHQvLyBTZWxlY3QgZWxlbWVudHMgbmVlZCB0aGUgZXZlbnQgdG8gZ28gdGhyb3VnaCBvbiBpT1MgNCwgb3RoZXJ3aXNlIHRoZSBzZWxlY3RvciBtZW51IHdvbid0IG9wZW4uXG5cdFx0XHQvLyBBbHNvIHRoaXMgYnJlYWtzIG9wZW5pbmcgc2VsZWN0cyB3aGVuIFZvaWNlT3ZlciBpcyBhY3RpdmUgb24gaU9TNiwgaU9TNyAoYW5kIHBvc3NpYmx5IG90aGVycylcblx0XHRcdGlmICghZGV2aWNlSXNJT1MgfHwgdGFyZ2V0VGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcblx0XHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmIChkZXZpY2VJc0lPUyAmJiAhZGV2aWNlSXNJT1M0KSB7XG5cblx0XHRcdC8vIERvbid0IHNlbmQgYSBzeW50aGV0aWMgY2xpY2sgZXZlbnQgaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBwYXJlbnQgbGF5ZXIgdGhhdCB3YXMgc2Nyb2xsZWRcblx0XHRcdC8vIGFuZCB0aGlzIHRhcCBpcyBiZWluZyB1c2VkIHRvIHN0b3AgdGhlIHNjcm9sbGluZyAodXN1YWxseSBpbml0aWF0ZWQgYnkgYSBmbGluZyAtIGlzc3VlICM0MikuXG5cdFx0XHRzY3JvbGxQYXJlbnQgPSB0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudDtcblx0XHRcdGlmIChzY3JvbGxQYXJlbnQgJiYgc2Nyb2xsUGFyZW50LmZhc3RDbGlja0xhc3RTY3JvbGxUb3AgIT09IHNjcm9sbFBhcmVudC5zY3JvbGxUb3ApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJldmVudCB0aGUgYWN0dWFsIGNsaWNrIGZyb20gZ29pbmcgdGhvdWdoIC0gdW5sZXNzIHRoZSB0YXJnZXQgbm9kZSBpcyBtYXJrZWQgYXMgcmVxdWlyaW5nXG5cdFx0Ly8gcmVhbCBjbGlja3Mgb3IgaWYgaXQgaXMgaW4gdGhlIHdoaXRlbGlzdCBpbiB3aGljaCBjYXNlIG9ubHkgbm9uLXByb2dyYW1tYXRpYyBjbGlja3MgYXJlIHBlcm1pdHRlZC5cblx0XHRpZiAoIXRoaXMubmVlZHNDbGljayh0YXJnZXRFbGVtZW50KSkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHRoaXMuc2VuZENsaWNrKHRhcmdldEVsZW1lbnQsIGV2ZW50KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblxuXHQvKipcblx0ICogT24gdG91Y2ggY2FuY2VsLCBzdG9wIHRyYWNraW5nIHRoZSBjbGljay5cblx0ICpcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hDYW5jZWwgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSBmYWxzZTtcblx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIERldGVybWluZSBtb3VzZSBldmVudHMgd2hpY2ggc2hvdWxkIGJlIHBlcm1pdHRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uTW91c2UgPSBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0Ly8gSWYgYSB0YXJnZXQgZWxlbWVudCB3YXMgbmV2ZXIgc2V0IChiZWNhdXNlIGEgdG91Y2ggZXZlbnQgd2FzIG5ldmVyIGZpcmVkKSBhbGxvdyB0aGUgZXZlbnRcblx0XHRpZiAoIXRoaXMudGFyZ2V0RWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKGV2ZW50LmZvcndhcmRlZFRvdWNoRXZlbnQpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIFByb2dyYW1tYXRpY2FsbHkgZ2VuZXJhdGVkIGV2ZW50cyB0YXJnZXRpbmcgYSBzcGVjaWZpYyBlbGVtZW50IHNob3VsZCBiZSBwZXJtaXR0ZWRcblx0XHRpZiAoIWV2ZW50LmNhbmNlbGFibGUpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIERlcml2ZSBhbmQgY2hlY2sgdGhlIHRhcmdldCBlbGVtZW50IHRvIHNlZSB3aGV0aGVyIHRoZSBtb3VzZSBldmVudCBuZWVkcyB0byBiZSBwZXJtaXR0ZWQ7XG5cdFx0Ly8gdW5sZXNzIGV4cGxpY2l0bHkgZW5hYmxlZCwgcHJldmVudCBub24tdG91Y2ggY2xpY2sgZXZlbnRzIGZyb20gdHJpZ2dlcmluZyBhY3Rpb25zLFxuXHRcdC8vIHRvIHByZXZlbnQgZ2hvc3QvZG91YmxlY2xpY2tzLlxuXHRcdGlmICghdGhpcy5uZWVkc0NsaWNrKHRoaXMudGFyZ2V0RWxlbWVudCkgfHwgdGhpcy5jYW5jZWxOZXh0Q2xpY2spIHtcblxuXHRcdFx0Ly8gUHJldmVudCBhbnkgdXNlci1hZGRlZCBsaXN0ZW5lcnMgZGVjbGFyZWQgb24gRmFzdENsaWNrIGVsZW1lbnQgZnJvbSBiZWluZyBmaXJlZC5cblx0XHRcdGlmIChldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pIHtcblx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFBhcnQgb2YgdGhlIGhhY2sgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBFdmVudCNzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gKGUuZy4gQW5kcm9pZCAyKVxuXHRcdFx0XHRldmVudC5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYW5jZWwgdGhlIGV2ZW50XG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgbW91c2UgZXZlbnQgaXMgcGVybWl0dGVkLCByZXR1cm4gdHJ1ZSBmb3IgdGhlIGFjdGlvbiB0byBnbyB0aHJvdWdoLlxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE9uIGFjdHVhbCBjbGlja3MsIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSB0b3VjaC1nZW5lcmF0ZWQgY2xpY2ssIGEgY2xpY2sgYWN0aW9uIG9jY3VycmluZ1xuXHQgKiBuYXR1cmFsbHkgYWZ0ZXIgYSBkZWxheSBhZnRlciBhIHRvdWNoICh3aGljaCBuZWVkcyB0byBiZSBjYW5jZWxsZWQgdG8gYXZvaWQgZHVwbGljYXRpb24pLCBvclxuXHQgKiBhbiBhY3R1YWwgY2xpY2sgd2hpY2ggc2hvdWxkIGJlIHBlcm1pdHRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBwZXJtaXR0ZWQ7XG5cblx0XHQvLyBJdCdzIHBvc3NpYmxlIGZvciBhbm90aGVyIEZhc3RDbGljay1saWtlIGxpYnJhcnkgZGVsaXZlcmVkIHdpdGggdGhpcmQtcGFydHkgY29kZSB0byBmaXJlIGEgY2xpY2sgZXZlbnQgYmVmb3JlIEZhc3RDbGljayBkb2VzIChpc3N1ZSAjNDQpLiBJbiB0aGF0IGNhc2UsIHNldCB0aGUgY2xpY2stdHJhY2tpbmcgZmxhZyBiYWNrIHRvIGZhbHNlIGFuZCByZXR1cm4gZWFybHkuIFRoaXMgd2lsbCBjYXVzZSBvblRvdWNoRW5kIHRvIHJldHVybiBlYXJseS5cblx0XHRpZiAodGhpcy50cmFja2luZ0NsaWNrKSB7XG5cdFx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHRcdFx0dGhpcy50cmFja2luZ0NsaWNrID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBWZXJ5IG9kZCBiZWhhdmlvdXIgb24gaU9TIChpc3N1ZSAjMTgpOiBpZiBhIHN1Ym1pdCBlbGVtZW50IGlzIHByZXNlbnQgaW5zaWRlIGEgZm9ybSBhbmQgdGhlIHVzZXIgaGl0cyBlbnRlciBpbiB0aGUgaU9TIHNpbXVsYXRvciBvciBjbGlja3MgdGhlIEdvIGJ1dHRvbiBvbiB0aGUgcG9wLXVwIE9TIGtleWJvYXJkIHRoZSBhIGtpbmQgb2YgJ2Zha2UnIGNsaWNrIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkIHdpdGggdGhlIHN1Ym1pdC10eXBlIGlucHV0IGVsZW1lbnQgYXMgdGhlIHRhcmdldC5cblx0XHRpZiAoZXZlbnQudGFyZ2V0LnR5cGUgPT09ICdzdWJtaXQnICYmIGV2ZW50LmRldGFpbCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cGVybWl0dGVkID0gdGhpcy5vbk1vdXNlKGV2ZW50KTtcblxuXHRcdC8vIE9ubHkgdW5zZXQgdGFyZ2V0RWxlbWVudCBpZiB0aGUgY2xpY2sgaXMgbm90IHBlcm1pdHRlZC4gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IHRoZSBjaGVjayBmb3IgIXRhcmdldEVsZW1lbnQgaW4gb25Nb3VzZSBmYWlscyBhbmQgdGhlIGJyb3dzZXIncyBjbGljayBkb2Vzbid0IGdvIHRocm91Z2guXG5cdFx0aWYgKCFwZXJtaXR0ZWQpIHtcblx0XHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgY2xpY2tzIGFyZSBwZXJtaXR0ZWQsIHJldHVybiB0cnVlIGZvciB0aGUgYWN0aW9uIHRvIGdvIHRocm91Z2guXG5cdFx0cmV0dXJuIHBlcm1pdHRlZDtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYWxsIEZhc3RDbGljaydzIGV2ZW50IGxpc3RlbmVycy5cblx0ICpcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLmxheWVyO1xuXG5cdFx0aWYgKGRldmljZUlzQW5kcm9pZCkge1xuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZSwgdHJ1ZSk7XG5cdFx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHR9XG5cblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljaywgdHJ1ZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Ub3VjaFN0YXJ0LCBmYWxzZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vblRvdWNoTW92ZSwgZmFsc2UpO1xuXHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kLCBmYWxzZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLm9uVG91Y2hDYW5jZWwsIGZhbHNlKTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBDaGVjayB3aGV0aGVyIEZhc3RDbGljayBpcyBuZWVkZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbGF5ZXIgVGhlIGxheWVyIHRvIGxpc3RlbiBvblxuXHQgKi9cblx0RmFzdENsaWNrLm5vdE5lZWRlZCA9IGZ1bmN0aW9uKGxheWVyKSB7XG5cdFx0dmFyIG1ldGFWaWV3cG9ydDtcblx0XHR2YXIgY2hyb21lVmVyc2lvbjtcblx0XHR2YXIgYmxhY2tiZXJyeVZlcnNpb247XG5cdFx0dmFyIGZpcmVmb3hWZXJzaW9uO1xuXG5cdFx0Ly8gRGV2aWNlcyB0aGF0IGRvbid0IHN1cHBvcnQgdG91Y2ggZG9uJ3QgbmVlZCBGYXN0Q2xpY2tcblx0XHRpZiAodHlwZW9mIHdpbmRvdy5vbnRvdWNoc3RhcnQgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBDaHJvbWUgdmVyc2lvbiAtIHplcm8gZm9yIG90aGVyIGJyb3dzZXJzXG5cdFx0Y2hyb21lVmVyc2lvbiA9ICsoL0Nocm9tZVxcLyhbMC05XSspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFssMF0pWzFdO1xuXG5cdFx0aWYgKGNocm9tZVZlcnNpb24pIHtcblxuXHRcdFx0aWYgKGRldmljZUlzQW5kcm9pZCkge1xuXHRcdFx0XHRtZXRhVmlld3BvcnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9dmlld3BvcnRdJyk7XG5cblx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydCkge1xuXHRcdFx0XHRcdC8vIENocm9tZSBvbiBBbmRyb2lkIHdpdGggdXNlci1zY2FsYWJsZT1cIm5vXCIgZG9lc24ndCBuZWVkIEZhc3RDbGljayAoaXNzdWUgIzg5KVxuXHRcdFx0XHRcdGlmIChtZXRhVmlld3BvcnQuY29udGVudC5pbmRleE9mKCd1c2VyLXNjYWxhYmxlPW5vJykgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gQ2hyb21lIDMyIGFuZCBhYm92ZSB3aXRoIHdpZHRoPWRldmljZS13aWR0aCBvciBsZXNzIGRvbid0IG5lZWQgRmFzdENsaWNrXG5cdFx0XHRcdFx0aWYgKGNocm9tZVZlcnNpb24gPiAzMSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGggPD0gd2luZG93Lm91dGVyV2lkdGgpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBDaHJvbWUgZGVza3RvcCBkb2Vzbid0IG5lZWQgRmFzdENsaWNrIChpc3N1ZSAjMTUpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZGV2aWNlSXNCbGFja0JlcnJ5MTApIHtcblx0XHRcdGJsYWNrYmVycnlWZXJzaW9uID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVmVyc2lvblxcLyhbMC05XSopXFwuKFswLTldKikvKTtcblxuXHRcdFx0Ly8gQmxhY2tCZXJyeSAxMC4zKyBkb2VzIG5vdCByZXF1aXJlIEZhc3RjbGljayBsaWJyYXJ5LlxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2Z0bGFicy9mYXN0Y2xpY2svaXNzdWVzLzI1MVxuXHRcdFx0aWYgKGJsYWNrYmVycnlWZXJzaW9uWzFdID49IDEwICYmIGJsYWNrYmVycnlWZXJzaW9uWzJdID49IDMpIHtcblx0XHRcdFx0bWV0YVZpZXdwb3J0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPXZpZXdwb3J0XScpO1xuXG5cdFx0XHRcdGlmIChtZXRhVmlld3BvcnQpIHtcblx0XHRcdFx0XHQvLyB1c2VyLXNjYWxhYmxlPW5vIGVsaW1pbmF0ZXMgY2xpY2sgZGVsYXkuXG5cdFx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydC5jb250ZW50LmluZGV4T2YoJ3VzZXItc2NhbGFibGU9bm8nKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyB3aWR0aD1kZXZpY2Utd2lkdGggKG9yIGxlc3MgdGhhbiBkZXZpY2Utd2lkdGgpIGVsaW1pbmF0ZXMgY2xpY2sgZGVsYXkuXG5cdFx0XHRcdFx0aWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aCA8PSB3aW5kb3cub3V0ZXJXaWR0aCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSUUxMCB3aXRoIC1tcy10b3VjaC1hY3Rpb246IG5vbmUgb3IgbWFuaXB1bGF0aW9uLCB3aGljaCBkaXNhYmxlcyBkb3VibGUtdGFwLXRvLXpvb20gKGlzc3VlICM5Nylcblx0XHRpZiAobGF5ZXIuc3R5bGUubXNUb3VjaEFjdGlvbiA9PT0gJ25vbmUnIHx8IGxheWVyLnN0eWxlLnRvdWNoQWN0aW9uID09PSAnbWFuaXB1bGF0aW9uJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZWZveCB2ZXJzaW9uIC0gemVybyBmb3Igb3RoZXIgYnJvd3NlcnNcblx0XHRmaXJlZm94VmVyc2lvbiA9ICsoL0ZpcmVmb3hcXC8oWzAtOV0rKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBbLDBdKVsxXTtcblxuXHRcdGlmIChmaXJlZm94VmVyc2lvbiA+PSAyNykge1xuXHRcdFx0Ly8gRmlyZWZveCAyNysgZG9lcyBub3QgaGF2ZSB0YXAgZGVsYXkgaWYgdGhlIGNvbnRlbnQgaXMgbm90IHpvb21hYmxlIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTIyODk2XG5cblx0XHRcdG1ldGFWaWV3cG9ydCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT12aWV3cG9ydF0nKTtcblx0XHRcdGlmIChtZXRhVmlld3BvcnQgJiYgKG1ldGFWaWV3cG9ydC5jb250ZW50LmluZGV4T2YoJ3VzZXItc2NhbGFibGU9bm8nKSAhPT0gLTEgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoIDw9IHdpbmRvdy5vdXRlcldpZHRoKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJRTExOiBwcmVmaXhlZCAtbXMtdG91Y2gtYWN0aW9uIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgYW5kIGl0J3MgcmVjb21lbmRlZCB0byB1c2Ugbm9uLXByZWZpeGVkIHZlcnNpb25cblx0XHQvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9hcHBzL0hoNzY3MzEzLmFzcHhcblx0XHRpZiAobGF5ZXIuc3R5bGUudG91Y2hBY3Rpb24gPT09ICdub25lJyB8fCBsYXllci5zdHlsZS50b3VjaEFjdGlvbiA9PT0gJ21hbmlwdWxhdGlvbicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBGYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBGYXN0Q2xpY2sgb2JqZWN0XG5cdCAqXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbGF5ZXIgVGhlIGxheWVyIHRvIGxpc3RlbiBvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0c1xuXHQgKi9cblx0RmFzdENsaWNrLmF0dGFjaCA9IGZ1bmN0aW9uKGxheWVyLCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG5ldyBGYXN0Q2xpY2sobGF5ZXIsIG9wdGlvbnMpO1xuXHR9O1xuXG5cblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblxuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gRmFzdENsaWNrO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBGYXN0Q2xpY2suYXR0YWNoO1xuXHRcdG1vZHVsZS5leHBvcnRzLkZhc3RDbGljayA9IEZhc3RDbGljaztcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuRmFzdENsaWNrID0gRmFzdENsaWNrO1xuXHR9XG59KCkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH07XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaW1wb3J0ID0gcmVxdWlyZSgnLi9oYW5kbGViYXJzL2Jhc2UnKTtcblxudmFyIGJhc2UgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfaW1wb3J0KTtcblxuLy8gRWFjaCBvZiB0aGVzZSBhdWdtZW50IHRoZSBIYW5kbGViYXJzIG9iamVjdC4gTm8gbmVlZCB0byBzZXR1cCBoZXJlLlxuLy8gKFRoaXMgaXMgZG9uZSB0byBlYXNpbHkgc2hhcmUgY29kZSBiZXR3ZWVuIGNvbW1vbmpzIGFuZCBicm93c2UgZW52cylcblxudmFyIF9TYWZlU3RyaW5nID0gcmVxdWlyZSgnLi9oYW5kbGViYXJzL3NhZmUtc3RyaW5nJyk7XG5cbnZhciBfU2FmZVN0cmluZzIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfU2FmZVN0cmluZyk7XG5cbnZhciBfRXhjZXB0aW9uID0gcmVxdWlyZSgnLi9oYW5kbGViYXJzL2V4Y2VwdGlvbicpO1xuXG52YXIgX0V4Y2VwdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfRXhjZXB0aW9uKTtcblxudmFyIF9pbXBvcnQyID0gcmVxdWlyZSgnLi9oYW5kbGViYXJzL3V0aWxzJyk7XG5cbnZhciBVdGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9pbXBvcnQyKTtcblxudmFyIF9pbXBvcnQzID0gcmVxdWlyZSgnLi9oYW5kbGViYXJzL3J1bnRpbWUnKTtcblxudmFyIHJ1bnRpbWUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfaW1wb3J0Myk7XG5cbnZhciBfbm9Db25mbGljdCA9IHJlcXVpcmUoJy4vaGFuZGxlYmFycy9uby1jb25mbGljdCcpO1xuXG52YXIgX25vQ29uZmxpY3QyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX25vQ29uZmxpY3QpO1xuXG4vLyBGb3IgY29tcGF0aWJpbGl0eSBhbmQgdXNhZ2Ugb3V0c2lkZSBvZiBtb2R1bGUgc3lzdGVtcywgbWFrZSB0aGUgSGFuZGxlYmFycyBvYmplY3QgYSBuYW1lc3BhY2VcbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIGhiID0gbmV3IGJhc2UuSGFuZGxlYmFyc0Vudmlyb25tZW50KCk7XG5cbiAgVXRpbHMuZXh0ZW5kKGhiLCBiYXNlKTtcbiAgaGIuU2FmZVN0cmluZyA9IF9TYWZlU3RyaW5nMlsnZGVmYXVsdCddO1xuICBoYi5FeGNlcHRpb24gPSBfRXhjZXB0aW9uMlsnZGVmYXVsdCddO1xuICBoYi5VdGlscyA9IFV0aWxzO1xuICBoYi5lc2NhcGVFeHByZXNzaW9uID0gVXRpbHMuZXNjYXBlRXhwcmVzc2lvbjtcblxuICBoYi5WTSA9IHJ1bnRpbWU7XG4gIGhiLnRlbXBsYXRlID0gZnVuY3Rpb24gKHNwZWMpIHtcbiAgICByZXR1cm4gcnVudGltZS50ZW1wbGF0ZShzcGVjLCBoYik7XG4gIH07XG5cbiAgcmV0dXJuIGhiO1xufVxuXG52YXIgaW5zdCA9IGNyZWF0ZSgpO1xuaW5zdC5jcmVhdGUgPSBjcmVhdGU7XG5cbl9ub0NvbmZsaWN0MlsnZGVmYXVsdCddKGluc3QpO1xuXG5pbnN0WydkZWZhdWx0J10gPSBpbnN0O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBpbnN0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH07XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLkhhbmRsZWJhcnNFbnZpcm9ubWVudCA9IEhhbmRsZWJhcnNFbnZpcm9ubWVudDtcbmV4cG9ydHMuY3JlYXRlRnJhbWUgPSBjcmVhdGVGcmFtZTtcblxudmFyIF9pbXBvcnQgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBVdGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9pbXBvcnQpO1xuXG52YXIgX0V4Y2VwdGlvbiA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG5cbnZhciBfRXhjZXB0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9FeGNlcHRpb24pO1xuXG52YXIgVkVSU0lPTiA9ICczLjAuMSc7XG5leHBvcnRzLlZFUlNJT04gPSBWRVJTSU9OO1xudmFyIENPTVBJTEVSX1JFVklTSU9OID0gNjtcblxuZXhwb3J0cy5DT01QSUxFUl9SRVZJU0lPTiA9IENPTVBJTEVSX1JFVklTSU9OO1xudmFyIFJFVklTSU9OX0NIQU5HRVMgPSB7XG4gIDE6ICc8PSAxLjAucmMuMicsIC8vIDEuMC5yYy4yIGlzIGFjdHVhbGx5IHJldjIgYnV0IGRvZXNuJ3QgcmVwb3J0IGl0XG4gIDI6ICc9PSAxLjAuMC1yYy4zJyxcbiAgMzogJz09IDEuMC4wLXJjLjQnLFxuICA0OiAnPT0gMS54LngnLFxuICA1OiAnPT0gMi4wLjAtYWxwaGEueCcsXG4gIDY6ICc+PSAyLjAuMC1iZXRhLjEnXG59O1xuXG5leHBvcnRzLlJFVklTSU9OX0NIQU5HRVMgPSBSRVZJU0lPTl9DSEFOR0VTO1xudmFyIGlzQXJyYXkgPSBVdGlscy5pc0FycmF5LFxuICAgIGlzRnVuY3Rpb24gPSBVdGlscy5pc0Z1bmN0aW9uLFxuICAgIHRvU3RyaW5nID0gVXRpbHMudG9TdHJpbmcsXG4gICAgb2JqZWN0VHlwZSA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG5mdW5jdGlvbiBIYW5kbGViYXJzRW52aXJvbm1lbnQoaGVscGVycywgcGFydGlhbHMpIHtcbiAgdGhpcy5oZWxwZXJzID0gaGVscGVycyB8fCB7fTtcbiAgdGhpcy5wYXJ0aWFscyA9IHBhcnRpYWxzIHx8IHt9O1xuXG4gIHJlZ2lzdGVyRGVmYXVsdEhlbHBlcnModGhpcyk7XG59XG5cbkhhbmRsZWJhcnNFbnZpcm9ubWVudC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBIYW5kbGViYXJzRW52aXJvbm1lbnQsXG5cbiAgbG9nZ2VyOiBsb2dnZXIsXG4gIGxvZzogbG9nLFxuXG4gIHJlZ2lzdGVySGVscGVyOiBmdW5jdGlvbiByZWdpc3RlckhlbHBlcihuYW1lLCBmbikge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgdGhyb3cgbmV3IF9FeGNlcHRpb24yWydkZWZhdWx0J10oJ0FyZyBub3Qgc3VwcG9ydGVkIHdpdGggbXVsdGlwbGUgaGVscGVycycpO1xuICAgICAgfVxuICAgICAgVXRpbHMuZXh0ZW5kKHRoaXMuaGVscGVycywgbmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVscGVyc1tuYW1lXSA9IGZuO1xuICAgIH1cbiAgfSxcbiAgdW5yZWdpc3RlckhlbHBlcjogZnVuY3Rpb24gdW5yZWdpc3RlckhlbHBlcihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMuaGVscGVyc1tuYW1lXTtcbiAgfSxcblxuICByZWdpc3RlclBhcnRpYWw6IGZ1bmN0aW9uIHJlZ2lzdGVyUGFydGlhbChuYW1lLCBwYXJ0aWFsKSB7XG4gICAgaWYgKHRvU3RyaW5nLmNhbGwobmFtZSkgPT09IG9iamVjdFR5cGUpIHtcbiAgICAgIFV0aWxzLmV4dGVuZCh0aGlzLnBhcnRpYWxzLCBuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBwYXJ0aWFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgX0V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnQXR0ZW1wdGluZyB0byByZWdpc3RlciBhIHBhcnRpYWwgYXMgdW5kZWZpbmVkJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnBhcnRpYWxzW25hbWVdID0gcGFydGlhbDtcbiAgICB9XG4gIH0sXG4gIHVucmVnaXN0ZXJQYXJ0aWFsOiBmdW5jdGlvbiB1bnJlZ2lzdGVyUGFydGlhbChuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMucGFydGlhbHNbbmFtZV07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdEhlbHBlcnMoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2hlbHBlck1pc3NpbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIEEgbWlzc2luZyBmaWVsZCBpbiBhIHt7Zm9vfX0gY29uc3R1Y3QuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTb21lb25lIGlzIGFjdHVhbGx5IHRyeWluZyB0byBjYWxsIHNvbWV0aGluZywgYmxvdyB1cC5cbiAgICAgIHRocm93IG5ldyBfRXhjZXB0aW9uMlsnZGVmYXVsdCddKCdNaXNzaW5nIGhlbHBlcjogXCInICsgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXS5uYW1lICsgJ1wiJyk7XG4gICAgfVxuICB9KTtcblxuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignYmxvY2tIZWxwZXJNaXNzaW5nJywgZnVuY3Rpb24gKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW52ZXJzZSA9IG9wdGlvbnMuaW52ZXJzZSxcbiAgICAgICAgZm4gPSBvcHRpb25zLmZuO1xuXG4gICAgaWYgKGNvbnRleHQgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBmbih0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRleHQgPT09IGZhbHNlIHx8IGNvbnRleHQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGludmVyc2UodGhpcyk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGNvbnRleHQpKSB7XG4gICAgICBpZiAoY29udGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmlkcykge1xuICAgICAgICAgIG9wdGlvbnMuaWRzID0gW29wdGlvbnMubmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5zdGFuY2UuaGVscGVycy5lYWNoKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGludmVyc2UodGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5pZHMpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgICAgICBkYXRhLmNvbnRleHRQYXRoID0gVXRpbHMuYXBwZW5kQ29udGV4dFBhdGgob3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoLCBvcHRpb25zLm5hbWUpO1xuICAgICAgICBvcHRpb25zID0geyBkYXRhOiBkYXRhIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbihjb250ZXh0LCBvcHRpb25zKTtcbiAgICB9XG4gIH0pO1xuXG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdlYWNoJywgZnVuY3Rpb24gKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBfRXhjZXB0aW9uMlsnZGVmYXVsdCddKCdNdXN0IHBhc3MgaXRlcmF0b3IgdG8gI2VhY2gnKTtcbiAgICB9XG5cbiAgICB2YXIgZm4gPSBvcHRpb25zLmZuLFxuICAgICAgICBpbnZlcnNlID0gb3B0aW9ucy5pbnZlcnNlLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgcmV0ID0gJycsXG4gICAgICAgIGRhdGEgPSB1bmRlZmluZWQsXG4gICAgICAgIGNvbnRleHRQYXRoID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmlkcykge1xuICAgICAgY29udGV4dFBhdGggPSBVdGlscy5hcHBlbmRDb250ZXh0UGF0aChvcHRpb25zLmRhdGEuY29udGV4dFBhdGgsIG9wdGlvbnMuaWRzWzBdKSArICcuJztcbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbihjb250ZXh0KSkge1xuICAgICAgY29udGV4dCA9IGNvbnRleHQuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICBkYXRhID0gY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleGVjSXRlcmF0aW9uKGZpZWxkLCBpbmRleCwgbGFzdCkge1xuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgZGF0YS5rZXkgPSBmaWVsZDtcbiAgICAgICAgZGF0YS5pbmRleCA9IGluZGV4O1xuICAgICAgICBkYXRhLmZpcnN0ID0gaW5kZXggPT09IDA7XG4gICAgICAgIGRhdGEubGFzdCA9ICEhbGFzdDtcblxuICAgICAgICBpZiAoY29udGV4dFBhdGgpIHtcbiAgICAgICAgICBkYXRhLmNvbnRleHRQYXRoID0gY29udGV4dFBhdGggKyBmaWVsZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXQgPSByZXQgKyBmbihjb250ZXh0W2ZpZWxkXSwge1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBibG9ja1BhcmFtczogVXRpbHMuYmxvY2tQYXJhbXMoW2NvbnRleHRbZmllbGRdLCBmaWVsZF0sIFtjb250ZXh0UGF0aCArIGZpZWxkLCBudWxsXSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0ID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGlzQXJyYXkoY29udGV4dCkpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IGNvbnRleHQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgZXhlY0l0ZXJhdGlvbihpLCBpLCBpID09PSBjb250ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJpb3JLZXkgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBydW5uaW5nIHRoZSBpdGVyYXRpb25zIG9uZSBzdGVwIG91dCBvZiBzeW5jIHNvIHdlIGNhbiBkZXRlY3RcbiAgICAgICAgICAgIC8vIHRoZSBsYXN0IGl0ZXJhdGlvbiB3aXRob3V0IGhhdmUgdG8gc2NhbiB0aGUgb2JqZWN0IHR3aWNlIGFuZCBjcmVhdGVcbiAgICAgICAgICAgIC8vIGFuIGl0ZXJtZWRpYXRlIGtleXMgYXJyYXkuXG4gICAgICAgICAgICBpZiAocHJpb3JLZXkpIHtcbiAgICAgICAgICAgICAgZXhlY0l0ZXJhdGlvbihwcmlvcktleSwgaSAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJpb3JLZXkgPSBrZXk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmlvcktleSkge1xuICAgICAgICAgIGV4ZWNJdGVyYXRpb24ocHJpb3JLZXksIGkgLSAxLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICByZXQgPSBpbnZlcnNlKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH0pO1xuXG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdpZicsIGZ1bmN0aW9uIChjb25kaXRpb25hbCwgb3B0aW9ucykge1xuICAgIGlmIChpc0Z1bmN0aW9uKGNvbmRpdGlvbmFsKSkge1xuICAgICAgY29uZGl0aW9uYWwgPSBjb25kaXRpb25hbC5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHQgYmVoYXZpb3IgaXMgdG8gcmVuZGVyIHRoZSBwb3NpdGl2ZSBwYXRoIGlmIHRoZSB2YWx1ZSBpcyB0cnV0aHkgYW5kIG5vdCBlbXB0eS5cbiAgICAvLyBUaGUgYGluY2x1ZGVaZXJvYCBvcHRpb24gbWF5IGJlIHNldCB0byB0cmVhdCB0aGUgY29uZHRpb25hbCBhcyBwdXJlbHkgbm90IGVtcHR5IGJhc2VkIG9uIHRoZVxuICAgIC8vIGJlaGF2aW9yIG9mIGlzRW1wdHkuIEVmZmVjdGl2ZWx5IHRoaXMgZGV0ZXJtaW5lcyBpZiAwIGlzIGhhbmRsZWQgYnkgdGhlIHBvc2l0aXZlIHBhdGggb3IgbmVnYXRpdmUuXG4gICAgaWYgKCFvcHRpb25zLmhhc2guaW5jbHVkZVplcm8gJiYgIWNvbmRpdGlvbmFsIHx8IFV0aWxzLmlzRW1wdHkoY29uZGl0aW9uYWwpKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5mbih0aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCd1bmxlc3MnLCBmdW5jdGlvbiAoY29uZGl0aW9uYWwsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuaGVscGVyc1snaWYnXS5jYWxsKHRoaXMsIGNvbmRpdGlvbmFsLCB7IGZuOiBvcHRpb25zLmludmVyc2UsIGludmVyc2U6IG9wdGlvbnMuZm4sIGhhc2g6IG9wdGlvbnMuaGFzaCB9KTtcbiAgfSk7XG5cbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ3dpdGgnLCBmdW5jdGlvbiAoY29udGV4dCwgb3B0aW9ucykge1xuICAgIGlmIChpc0Z1bmN0aW9uKGNvbnRleHQpKSB7XG4gICAgICBjb250ZXh0ID0gY29udGV4dC5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIHZhciBmbiA9IG9wdGlvbnMuZm47XG5cbiAgICBpZiAoIVV0aWxzLmlzRW1wdHkoY29udGV4dCkpIHtcbiAgICAgIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5pZHMpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgICAgICBkYXRhLmNvbnRleHRQYXRoID0gVXRpbHMuYXBwZW5kQ29udGV4dFBhdGgob3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoLCBvcHRpb25zLmlkc1swXSk7XG4gICAgICAgIG9wdGlvbnMgPSB7IGRhdGE6IGRhdGEgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZuKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2xvZycsIGZ1bmN0aW9uIChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgdmFyIGxldmVsID0gb3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuZGF0YS5sZXZlbCAhPSBudWxsID8gcGFyc2VJbnQob3B0aW9ucy5kYXRhLmxldmVsLCAxMCkgOiAxO1xuICAgIGluc3RhbmNlLmxvZyhsZXZlbCwgbWVzc2FnZSk7XG4gIH0pO1xuXG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdsb29rdXAnLCBmdW5jdGlvbiAob2JqLCBmaWVsZCkge1xuICAgIHJldHVybiBvYmogJiYgb2JqW2ZpZWxkXTtcbiAgfSk7XG59XG5cbnZhciBsb2dnZXIgPSB7XG4gIG1ldGhvZE1hcDogeyAwOiAnZGVidWcnLCAxOiAnaW5mbycsIDI6ICd3YXJuJywgMzogJ2Vycm9yJyB9LFxuXG4gIC8vIFN0YXRlIGVudW1cbiAgREVCVUc6IDAsXG4gIElORk86IDEsXG4gIFdBUk46IDIsXG4gIEVSUk9SOiAzLFxuICBsZXZlbDogMSxcblxuICAvLyBDYW4gYmUgb3ZlcnJpZGRlbiBpbiB0aGUgaG9zdCBlbnZpcm9ubWVudFxuICBsb2c6IGZ1bmN0aW9uIGxvZyhsZXZlbCwgbWVzc2FnZSkge1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbG9nZ2VyLmxldmVsIDw9IGxldmVsKSB7XG4gICAgICB2YXIgbWV0aG9kID0gbG9nZ2VyLm1ldGhvZE1hcFtsZXZlbF07XG4gICAgICAoY29uc29sZVttZXRob2RdIHx8IGNvbnNvbGUubG9nKS5jYWxsKGNvbnNvbGUsIG1lc3NhZ2UpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydHMubG9nZ2VyID0gbG9nZ2VyO1xudmFyIGxvZyA9IGxvZ2dlci5sb2c7XG5cbmV4cG9ydHMubG9nID0gbG9nO1xuXG5mdW5jdGlvbiBjcmVhdGVGcmFtZShvYmplY3QpIHtcbiAgdmFyIGZyYW1lID0gVXRpbHMuZXh0ZW5kKHt9LCBvYmplY3QpO1xuICBmcmFtZS5fcGFyZW50ID0gb2JqZWN0O1xuICByZXR1cm4gZnJhbWU7XG59XG5cbi8qIFthcmdzLCBdb3B0aW9ucyAqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIGVycm9yUHJvcHMgPSBbJ2Rlc2NyaXB0aW9uJywgJ2ZpbGVOYW1lJywgJ2xpbmVOdW1iZXInLCAnbWVzc2FnZScsICduYW1lJywgJ251bWJlcicsICdzdGFjayddO1xuXG5mdW5jdGlvbiBFeGNlcHRpb24obWVzc2FnZSwgbm9kZSkge1xuICB2YXIgbG9jID0gbm9kZSAmJiBub2RlLmxvYyxcbiAgICAgIGxpbmUgPSB1bmRlZmluZWQsXG4gICAgICBjb2x1bW4gPSB1bmRlZmluZWQ7XG4gIGlmIChsb2MpIHtcbiAgICBsaW5lID0gbG9jLnN0YXJ0LmxpbmU7XG4gICAgY29sdW1uID0gbG9jLnN0YXJ0LmNvbHVtbjtcblxuICAgIG1lc3NhZ2UgKz0gJyAtICcgKyBsaW5lICsgJzonICsgY29sdW1uO1xuICB9XG5cbiAgdmFyIHRtcCA9IEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuXG4gIC8vIFVuZm9ydHVuYXRlbHkgZXJyb3JzIGFyZSBub3QgZW51bWVyYWJsZSBpbiBDaHJvbWUgKGF0IGxlYXN0KSwgc28gYGZvciBwcm9wIGluIHRtcGAgZG9lc24ndCB3b3JrLlxuICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBlcnJvclByb3BzLmxlbmd0aDsgaWR4KyspIHtcbiAgICB0aGlzW2Vycm9yUHJvcHNbaWR4XV0gPSB0bXBbZXJyb3JQcm9wc1tpZHhdXTtcbiAgfVxuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEV4Y2VwdGlvbik7XG4gIH1cblxuICBpZiAobG9jKSB7XG4gICAgdGhpcy5saW5lTnVtYmVyID0gbGluZTtcbiAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgfVxufVxuXG5FeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEV4Y2VwdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbi8qZ2xvYmFsIHdpbmRvdyAqL1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBmdW5jdGlvbiAoSGFuZGxlYmFycykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB2YXIgcm9vdCA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93LFxuICAgICAgJEhhbmRsZWJhcnMgPSByb290LkhhbmRsZWJhcnM7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIEhhbmRsZWJhcnMubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocm9vdC5IYW5kbGViYXJzID09PSBIYW5kbGViYXJzKSB7XG4gICAgICByb290LkhhbmRsZWJhcnMgPSAkSGFuZGxlYmFycztcbiAgICB9XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW01dlpHVmZiVzlrZFd4bGN5OW9ZVzVrYkdWaVlYSnpMMlJwYzNRdlkycHpMMmhoYm1Sc1pXSmhjbk12Ym04dFkyOXVabXhwWTNRdWFuTWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVUZCTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTSXNJbVpwYkdVaU9pSm5aVzVsY21GMFpXUXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpSjNWelpTQnpkSEpwWTNRbk8xeHVYRzVsZUhCdmNuUnpMbDlmWlhOTmIyUjFiR1VnUFNCMGNuVmxPMXh1THlwbmJHOWlZV3dnZDJsdVpHOTNJQ292WEc1Y2JtVjRjRzl5ZEhOYkoyUmxabUYxYkhRblhTQTlJR1oxYm1OMGFXOXVJQ2hJWVc1a2JHVmlZWEp6S1NCN1hHNGdJQzhxSUdsemRHRnVZblZzSUdsbmJtOXlaU0J1WlhoMElDb3ZYRzRnSUhaaGNpQnliMjkwSUQwZ2RIbHdaVzltSUdkc2IySmhiQ0FoUFQwZ0ozVnVaR1ZtYVc1bFpDY2dQeUJuYkc5aVlXd2dPaUIzYVc1a2IzY3NYRzRnSUNBZ0lDQWtTR0Z1Wkd4bFltRnljeUE5SUhKdmIzUXVTR0Z1Wkd4bFltRnljenRjYmlBZ0x5b2dhWE4wWVc1aWRXd2dhV2R1YjNKbElHNWxlSFFnS2k5Y2JpQWdTR0Z1Wkd4bFltRnljeTV1YjBOdmJtWnNhV04wSUQwZ1puVnVZM1JwYjI0Z0tDa2dlMXh1SUNBZ0lHbG1JQ2h5YjI5MExraGhibVJzWldKaGNuTWdQVDA5SUVoaGJtUnNaV0poY25NcElIdGNiaUFnSUNBZ0lISnZiM1F1U0dGdVpHeGxZbUZ5Y3lBOUlDUklZVzVrYkdWaVlYSnpPMXh1SUNBZ0lIMWNiaUFnZlR0Y2JuMDdYRzVjYm0xdlpIVnNaUzVsZUhCdmNuUnpJRDBnWlhod2IzSjBjMXNuWkdWbVlYVnNkQ2RkT3lKZGZRPT0iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY2hlY2tSZXZpc2lvbiA9IGNoZWNrUmV2aXNpb247XG5cbi8vIFRPRE86IFJlbW92ZSB0aGlzIGxpbmUgYW5kIGJyZWFrIHVwIGNvbXBpbGVQYXJ0aWFsXG5cbmV4cG9ydHMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbmV4cG9ydHMud3JhcFByb2dyYW0gPSB3cmFwUHJvZ3JhbTtcbmV4cG9ydHMucmVzb2x2ZVBhcnRpYWwgPSByZXNvbHZlUGFydGlhbDtcbmV4cG9ydHMuaW52b2tlUGFydGlhbCA9IGludm9rZVBhcnRpYWw7XG5leHBvcnRzLm5vb3AgPSBub29wO1xuXG52YXIgX2ltcG9ydCA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIFV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2ltcG9ydCk7XG5cbnZhciBfRXhjZXB0aW9uID0gcmVxdWlyZSgnLi9leGNlcHRpb24nKTtcblxudmFyIF9FeGNlcHRpb24yID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX0V4Y2VwdGlvbik7XG5cbnZhciBfQ09NUElMRVJfUkVWSVNJT04kUkVWSVNJT05fQ0hBTkdFUyRjcmVhdGVGcmFtZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xuXG5mdW5jdGlvbiBjaGVja1JldmlzaW9uKGNvbXBpbGVySW5mbykge1xuICB2YXIgY29tcGlsZXJSZXZpc2lvbiA9IGNvbXBpbGVySW5mbyAmJiBjb21waWxlckluZm9bMF0gfHwgMSxcbiAgICAgIGN1cnJlbnRSZXZpc2lvbiA9IF9DT01QSUxFUl9SRVZJU0lPTiRSRVZJU0lPTl9DSEFOR0VTJGNyZWF0ZUZyYW1lLkNPTVBJTEVSX1JFVklTSU9OO1xuXG4gIGlmIChjb21waWxlclJldmlzaW9uICE9PSBjdXJyZW50UmV2aXNpb24pIHtcbiAgICBpZiAoY29tcGlsZXJSZXZpc2lvbiA8IGN1cnJlbnRSZXZpc2lvbikge1xuICAgICAgdmFyIHJ1bnRpbWVWZXJzaW9ucyA9IF9DT01QSUxFUl9SRVZJU0lPTiRSRVZJU0lPTl9DSEFOR0VTJGNyZWF0ZUZyYW1lLlJFVklTSU9OX0NIQU5HRVNbY3VycmVudFJldmlzaW9uXSxcbiAgICAgICAgICBjb21waWxlclZlcnNpb25zID0gX0NPTVBJTEVSX1JFVklTSU9OJFJFVklTSU9OX0NIQU5HRVMkY3JlYXRlRnJhbWUuUkVWSVNJT05fQ0hBTkdFU1tjb21waWxlclJldmlzaW9uXTtcbiAgICAgIHRocm93IG5ldyBfRXhjZXB0aW9uMlsnZGVmYXVsdCddKCdUZW1wbGF0ZSB3YXMgcHJlY29tcGlsZWQgd2l0aCBhbiBvbGRlciB2ZXJzaW9uIG9mIEhhbmRsZWJhcnMgdGhhbiB0aGUgY3VycmVudCBydW50aW1lLiAnICsgJ1BsZWFzZSB1cGRhdGUgeW91ciBwcmVjb21waWxlciB0byBhIG5ld2VyIHZlcnNpb24gKCcgKyBydW50aW1lVmVyc2lvbnMgKyAnKSBvciBkb3duZ3JhZGUgeW91ciBydW50aW1lIHRvIGFuIG9sZGVyIHZlcnNpb24gKCcgKyBjb21waWxlclZlcnNpb25zICsgJykuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVzZSB0aGUgZW1iZWRkZWQgdmVyc2lvbiBpbmZvIHNpbmNlIHRoZSBydW50aW1lIGRvZXNuJ3Qga25vdyBhYm91dCB0aGlzIHJldmlzaW9uIHlldFxuICAgICAgdGhyb3cgbmV3IF9FeGNlcHRpb24yWydkZWZhdWx0J10oJ1RlbXBsYXRlIHdhcyBwcmVjb21waWxlZCB3aXRoIGEgbmV3ZXIgdmVyc2lvbiBvZiBIYW5kbGViYXJzIHRoYW4gdGhlIGN1cnJlbnQgcnVudGltZS4gJyArICdQbGVhc2UgdXBkYXRlIHlvdXIgcnVudGltZSB0byBhIG5ld2VyIHZlcnNpb24gKCcgKyBjb21waWxlckluZm9bMV0gKyAnKS4nKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVtcGxhdGUodGVtcGxhdGVTcGVjLCBlbnYpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKCFlbnYpIHtcbiAgICB0aHJvdyBuZXcgX0V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnTm8gZW52aXJvbm1lbnQgcGFzc2VkIHRvIHRlbXBsYXRlJyk7XG4gIH1cbiAgaWYgKCF0ZW1wbGF0ZVNwZWMgfHwgIXRlbXBsYXRlU3BlYy5tYWluKSB7XG4gICAgdGhyb3cgbmV3IF9FeGNlcHRpb24yWydkZWZhdWx0J10oJ1Vua25vd24gdGVtcGxhdGUgb2JqZWN0OiAnICsgdHlwZW9mIHRlbXBsYXRlU3BlYyk7XG4gIH1cblxuICAvLyBOb3RlOiBVc2luZyBlbnYuVk0gcmVmZXJlbmNlcyByYXRoZXIgdGhhbiBsb2NhbCB2YXIgcmVmZXJlbmNlcyB0aHJvdWdob3V0IHRoaXMgc2VjdGlvbiB0byBhbGxvd1xuICAvLyBmb3IgZXh0ZXJuYWwgdXNlcnMgdG8gb3ZlcnJpZGUgdGhlc2UgYXMgcHN1ZWRvLXN1cHBvcnRlZCBBUElzLlxuICBlbnYuVk0uY2hlY2tSZXZpc2lvbih0ZW1wbGF0ZVNwZWMuY29tcGlsZXIpO1xuXG4gIGZ1bmN0aW9uIGludm9rZVBhcnRpYWxXcmFwcGVyKHBhcnRpYWwsIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5oYXNoKSB7XG4gICAgICBjb250ZXh0ID0gVXRpbHMuZXh0ZW5kKHt9LCBjb250ZXh0LCBvcHRpb25zLmhhc2gpO1xuICAgIH1cblxuICAgIHBhcnRpYWwgPSBlbnYuVk0ucmVzb2x2ZVBhcnRpYWwuY2FsbCh0aGlzLCBwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKTtcbiAgICB2YXIgcmVzdWx0ID0gZW52LlZNLmludm9rZVBhcnRpYWwuY2FsbCh0aGlzLCBwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKTtcblxuICAgIGlmIChyZXN1bHQgPT0gbnVsbCAmJiBlbnYuY29tcGlsZSkge1xuICAgICAgb3B0aW9ucy5wYXJ0aWFsc1tvcHRpb25zLm5hbWVdID0gZW52LmNvbXBpbGUocGFydGlhbCwgdGVtcGxhdGVTcGVjLmNvbXBpbGVyT3B0aW9ucywgZW52KTtcbiAgICAgIHJlc3VsdCA9IG9wdGlvbnMucGFydGlhbHNbb3B0aW9ucy5uYW1lXShjb250ZXh0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICBpZiAob3B0aW9ucy5pbmRlbnQpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gcmVzdWx0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWxpbmVzW2ldICYmIGkgKyAxID09PSBsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaW5lc1tpXSA9IG9wdGlvbnMuaW5kZW50ICsgbGluZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gbGluZXMuam9pbignXFxuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgX0V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnVGhlIHBhcnRpYWwgJyArIG9wdGlvbnMubmFtZSArICcgY291bGQgbm90IGJlIGNvbXBpbGVkIHdoZW4gcnVubmluZyBpbiBydW50aW1lLW9ubHkgbW9kZScpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEp1c3QgYWRkIHdhdGVyXG4gIHZhciBjb250YWluZXIgPSB7XG4gICAgc3RyaWN0OiBmdW5jdGlvbiBzdHJpY3Qob2JqLCBuYW1lKSB7XG4gICAgICBpZiAoIShuYW1lIGluIG9iaikpIHtcbiAgICAgICAgdGhyb3cgbmV3IF9FeGNlcHRpb24yWydkZWZhdWx0J10oJ1wiJyArIG5hbWUgKyAnXCIgbm90IGRlZmluZWQgaW4gJyArIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqW25hbWVdO1xuICAgIH0sXG4gICAgbG9va3VwOiBmdW5jdGlvbiBsb29rdXAoZGVwdGhzLCBuYW1lKSB7XG4gICAgICB2YXIgbGVuID0gZGVwdGhzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGRlcHRoc1tpXSAmJiBkZXB0aHNbaV1bbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBkZXB0aHNbaV1bbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGxhbWJkYTogZnVuY3Rpb24gbGFtYmRhKGN1cnJlbnQsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgY3VycmVudCA9PT0gJ2Z1bmN0aW9uJyA/IGN1cnJlbnQuY2FsbChjb250ZXh0KSA6IGN1cnJlbnQ7XG4gICAgfSxcblxuICAgIGVzY2FwZUV4cHJlc3Npb246IFV0aWxzLmVzY2FwZUV4cHJlc3Npb24sXG4gICAgaW52b2tlUGFydGlhbDogaW52b2tlUGFydGlhbFdyYXBwZXIsXG5cbiAgICBmbjogZnVuY3Rpb24gZm4oaSkge1xuICAgICAgcmV0dXJuIHRlbXBsYXRlU3BlY1tpXTtcbiAgICB9LFxuXG4gICAgcHJvZ3JhbXM6IFtdLFxuICAgIHByb2dyYW06IGZ1bmN0aW9uIHByb2dyYW0oaSwgZGF0YSwgZGVjbGFyZWRCbG9ja1BhcmFtcywgYmxvY2tQYXJhbXMsIGRlcHRocykge1xuICAgICAgdmFyIHByb2dyYW1XcmFwcGVyID0gdGhpcy5wcm9ncmFtc1tpXSxcbiAgICAgICAgICBmbiA9IHRoaXMuZm4oaSk7XG4gICAgICBpZiAoZGF0YSB8fCBkZXB0aHMgfHwgYmxvY2tQYXJhbXMgfHwgZGVjbGFyZWRCbG9ja1BhcmFtcykge1xuICAgICAgICBwcm9ncmFtV3JhcHBlciA9IHdyYXBQcm9ncmFtKHRoaXMsIGksIGZuLCBkYXRhLCBkZWNsYXJlZEJsb2NrUGFyYW1zLCBibG9ja1BhcmFtcywgZGVwdGhzKTtcbiAgICAgIH0gZWxzZSBpZiAoIXByb2dyYW1XcmFwcGVyKSB7XG4gICAgICAgIHByb2dyYW1XcmFwcGVyID0gdGhpcy5wcm9ncmFtc1tpXSA9IHdyYXBQcm9ncmFtKHRoaXMsIGksIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9ncmFtV3JhcHBlcjtcbiAgICB9LFxuXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSh2YWx1ZSwgZGVwdGgpIHtcbiAgICAgIHdoaWxlICh2YWx1ZSAmJiBkZXB0aC0tKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuX3BhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIG1lcmdlOiBmdW5jdGlvbiBtZXJnZShwYXJhbSwgY29tbW9uKSB7XG4gICAgICB2YXIgb2JqID0gcGFyYW0gfHwgY29tbW9uO1xuXG4gICAgICBpZiAocGFyYW0gJiYgY29tbW9uICYmIHBhcmFtICE9PSBjb21tb24pIHtcbiAgICAgICAgb2JqID0gVXRpbHMuZXh0ZW5kKHt9LCBjb21tb24sIHBhcmFtKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuXG4gICAgbm9vcDogZW52LlZNLm5vb3AsXG4gICAgY29tcGlsZXJJbmZvOiB0ZW1wbGF0ZVNwZWMuY29tcGlsZXJcbiAgfTtcblxuICBmdW5jdGlvbiByZXQoY29udGV4dCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICAgIHZhciBkYXRhID0gb3B0aW9ucy5kYXRhO1xuXG4gICAgcmV0Ll9zZXR1cChvcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMucGFydGlhbCAmJiB0ZW1wbGF0ZVNwZWMudXNlRGF0YSkge1xuICAgICAgZGF0YSA9IGluaXREYXRhKGNvbnRleHQsIGRhdGEpO1xuICAgIH1cbiAgICB2YXIgZGVwdGhzID0gdW5kZWZpbmVkLFxuICAgICAgICBibG9ja1BhcmFtcyA9IHRlbXBsYXRlU3BlYy51c2VCbG9ja1BhcmFtcyA/IFtdIDogdW5kZWZpbmVkO1xuICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlRGVwdGhzKSB7XG4gICAgICBkZXB0aHMgPSBvcHRpb25zLmRlcHRocyA/IFtjb250ZXh0XS5jb25jYXQob3B0aW9ucy5kZXB0aHMpIDogW2NvbnRleHRdO1xuICAgIH1cblxuICAgIHJldHVybiB0ZW1wbGF0ZVNwZWMubWFpbi5jYWxsKGNvbnRhaW5lciwgY29udGV4dCwgY29udGFpbmVyLmhlbHBlcnMsIGNvbnRhaW5lci5wYXJ0aWFscywgZGF0YSwgYmxvY2tQYXJhbXMsIGRlcHRocyk7XG4gIH1cbiAgcmV0LmlzVG9wID0gdHJ1ZTtcblxuICByZXQuX3NldHVwID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMucGFydGlhbCkge1xuICAgICAgY29udGFpbmVyLmhlbHBlcnMgPSBjb250YWluZXIubWVyZ2Uob3B0aW9ucy5oZWxwZXJzLCBlbnYuaGVscGVycyk7XG5cbiAgICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlUGFydGlhbCkge1xuICAgICAgICBjb250YWluZXIucGFydGlhbHMgPSBjb250YWluZXIubWVyZ2Uob3B0aW9ucy5wYXJ0aWFscywgZW52LnBhcnRpYWxzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGFpbmVyLmhlbHBlcnMgPSBvcHRpb25zLmhlbHBlcnM7XG4gICAgICBjb250YWluZXIucGFydGlhbHMgPSBvcHRpb25zLnBhcnRpYWxzO1xuICAgIH1cbiAgfTtcblxuICByZXQuX2NoaWxkID0gZnVuY3Rpb24gKGksIGRhdGEsIGJsb2NrUGFyYW1zLCBkZXB0aHMpIHtcbiAgICBpZiAodGVtcGxhdGVTcGVjLnVzZUJsb2NrUGFyYW1zICYmICFibG9ja1BhcmFtcykge1xuICAgICAgdGhyb3cgbmV3IF9FeGNlcHRpb24yWydkZWZhdWx0J10oJ211c3QgcGFzcyBibG9jayBwYXJhbXMnKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlU3BlYy51c2VEZXB0aHMgJiYgIWRlcHRocykge1xuICAgICAgdGhyb3cgbmV3IF9FeGNlcHRpb24yWydkZWZhdWx0J10oJ211c3QgcGFzcyBwYXJlbnQgZGVwdGhzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdyYXBQcm9ncmFtKGNvbnRhaW5lciwgaSwgdGVtcGxhdGVTcGVjW2ldLCBkYXRhLCAwLCBibG9ja1BhcmFtcywgZGVwdGhzKTtcbiAgfTtcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gd3JhcFByb2dyYW0oY29udGFpbmVyLCBpLCBmbiwgZGF0YSwgZGVjbGFyZWRCbG9ja1BhcmFtcywgYmxvY2tQYXJhbXMsIGRlcHRocykge1xuICBmdW5jdGlvbiBwcm9nKGNvbnRleHQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgICByZXR1cm4gZm4uY2FsbChjb250YWluZXIsIGNvbnRleHQsIGNvbnRhaW5lci5oZWxwZXJzLCBjb250YWluZXIucGFydGlhbHMsIG9wdGlvbnMuZGF0YSB8fCBkYXRhLCBibG9ja1BhcmFtcyAmJiBbb3B0aW9ucy5ibG9ja1BhcmFtc10uY29uY2F0KGJsb2NrUGFyYW1zKSwgZGVwdGhzICYmIFtjb250ZXh0XS5jb25jYXQoZGVwdGhzKSk7XG4gIH1cbiAgcHJvZy5wcm9ncmFtID0gaTtcbiAgcHJvZy5kZXB0aCA9IGRlcHRocyA/IGRlcHRocy5sZW5ndGggOiAwO1xuICBwcm9nLmJsb2NrUGFyYW1zID0gZGVjbGFyZWRCbG9ja1BhcmFtcyB8fCAwO1xuICByZXR1cm4gcHJvZztcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVBhcnRpYWwocGFydGlhbCwgY29udGV4dCwgb3B0aW9ucykge1xuICBpZiAoIXBhcnRpYWwpIHtcbiAgICBwYXJ0aWFsID0gb3B0aW9ucy5wYXJ0aWFsc1tvcHRpb25zLm5hbWVdO1xuICB9IGVsc2UgaWYgKCFwYXJ0aWFsLmNhbGwgJiYgIW9wdGlvbnMubmFtZSkge1xuICAgIC8vIFRoaXMgaXMgYSBkeW5hbWljIHBhcnRpYWwgdGhhdCByZXR1cm5lZCBhIHN0cmluZ1xuICAgIG9wdGlvbnMubmFtZSA9IHBhcnRpYWw7XG4gICAgcGFydGlhbCA9IG9wdGlvbnMucGFydGlhbHNbcGFydGlhbF07XG4gIH1cbiAgcmV0dXJuIHBhcnRpYWw7XG59XG5cbmZ1bmN0aW9uIGludm9rZVBhcnRpYWwocGFydGlhbCwgY29udGV4dCwgb3B0aW9ucykge1xuICBvcHRpb25zLnBhcnRpYWwgPSB0cnVlO1xuXG4gIGlmIChwYXJ0aWFsID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgX0V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnVGhlIHBhcnRpYWwgJyArIG9wdGlvbnMubmFtZSArICcgY291bGQgbm90IGJlIGZvdW5kJyk7XG4gIH0gZWxzZSBpZiAocGFydGlhbCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIHBhcnRpYWwoY29udGV4dCwgb3B0aW9ucyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbm9vcCgpIHtcbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YShjb250ZXh0LCBkYXRhKSB7XG4gIGlmICghZGF0YSB8fCAhKCdyb290JyBpbiBkYXRhKSkge1xuICAgIGRhdGEgPSBkYXRhID8gX0NPTVBJTEVSX1JFVklTSU9OJFJFVklTSU9OX0NIQU5HRVMkY3JlYXRlRnJhbWUuY3JlYXRlRnJhbWUoZGF0YSkgOiB7fTtcbiAgICBkYXRhLnJvb3QgPSBjb250ZXh0O1xuICB9XG4gIHJldHVybiBkYXRhO1xufSIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbi8vIEJ1aWxkIG91dCBvdXIgYmFzaWMgU2FmZVN0cmluZyB0eXBlXG5mdW5jdGlvbiBTYWZlU3RyaW5nKHN0cmluZykge1xuICB0aGlzLnN0cmluZyA9IHN0cmluZztcbn1cblxuU2FmZVN0cmluZy5wcm90b3R5cGUudG9TdHJpbmcgPSBTYWZlU3RyaW5nLnByb3RvdHlwZS50b0hUTUwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnJyArIHRoaXMuc3RyaW5nO1xufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gU2FmZVN0cmluZztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kO1xuXG4vLyBPbGRlciBJRSB2ZXJzaW9ucyBkbyBub3QgZGlyZWN0bHkgc3VwcG9ydCBpbmRleE9mIHNvIHdlIG11c3QgaW1wbGVtZW50IG91ciBvd24sIHNhZGx5LlxuZXhwb3J0cy5pbmRleE9mID0gaW5kZXhPZjtcbmV4cG9ydHMuZXNjYXBlRXhwcmVzc2lvbiA9IGVzY2FwZUV4cHJlc3Npb247XG5leHBvcnRzLmlzRW1wdHkgPSBpc0VtcHR5O1xuZXhwb3J0cy5ibG9ja1BhcmFtcyA9IGJsb2NrUGFyYW1zO1xuZXhwb3J0cy5hcHBlbmRDb250ZXh0UGF0aCA9IGFwcGVuZENvbnRleHRQYXRoO1xudmFyIGVzY2FwZSA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICAnXFwnJzogJyYjeDI3OycsXG4gICdgJzogJyYjeDYwOydcbn07XG5cbnZhciBiYWRDaGFycyA9IC9bJjw+XCInYF0vZyxcbiAgICBwb3NzaWJsZSA9IC9bJjw+XCInYF0vO1xuXG5mdW5jdGlvbiBlc2NhcGVDaGFyKGNocikge1xuICByZXR1cm4gZXNjYXBlW2Nocl07XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChvYmogLyogLCAuLi5zb3VyY2UgKi8pIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gYXJndW1lbnRzW2ldKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3VtZW50c1tpXSwga2V5KSkge1xuICAgICAgICBvYmpba2V5XSA9IGFyZ3VtZW50c1tpXVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmV4cG9ydHMudG9TdHJpbmcgPSB0b1N0cmluZztcbi8vIFNvdXJjZWQgZnJvbSBsb2Rhc2hcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXN0aWVqcy9sb2Rhc2gvYmxvYi9tYXN0ZXIvTElDRU5TRS50eHRcbi8qZXNsaW50LWRpc2FibGUgZnVuYy1zdHlsZSwgbm8tdmFyICovXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn07XG4vLyBmYWxsYmFjayBmb3Igb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmlcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAoaXNGdW5jdGlvbigveC8pKSB7XG4gIGV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICB9O1xufVxudmFyIGlzRnVuY3Rpb247XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuLyplc2xpbnQtZW5hYmxlIGZ1bmMtc3R5bGUsIG5vLXZhciAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nIDogZmFsc2U7XG59O2V4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUV4cHJlc3Npb24oc3RyaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGRvbid0IGVzY2FwZSBTYWZlU3RyaW5ncywgc2luY2UgdGhleSdyZSBhbHJlYWR5IHNhZmVcbiAgICBpZiAoc3RyaW5nICYmIHN0cmluZy50b0hUTUwpIHtcbiAgICAgIHJldHVybiBzdHJpbmcudG9IVE1MKCk7XG4gICAgfSBlbHNlIGlmIChzdHJpbmcgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSBpZiAoIXN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZyArICcnO1xuICAgIH1cblxuICAgIC8vIEZvcmNlIGEgc3RyaW5nIGNvbnZlcnNpb24gYXMgdGhpcyB3aWxsIGJlIGRvbmUgYnkgdGhlIGFwcGVuZCByZWdhcmRsZXNzIGFuZFxuICAgIC8vIHRoZSByZWdleCB0ZXN0IHdpbGwgZG8gdGhpcyB0cmFuc3BhcmVudGx5IGJlaGluZCB0aGUgc2NlbmVzLCBjYXVzaW5nIGlzc3VlcyBpZlxuICAgIC8vIGFuIG9iamVjdCdzIHRvIHN0cmluZyBoYXMgZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGl0LlxuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nO1xuICB9XG5cbiAgaWYgKCFwb3NzaWJsZS50ZXN0KHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShiYWRDaGFycywgZXNjYXBlQ2hhcik7XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBibG9ja1BhcmFtcyhwYXJhbXMsIGlkcykge1xuICBwYXJhbXMucGF0aCA9IGlkcztcbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ29udGV4dFBhdGgoY29udGV4dFBhdGgsIGlkKSB7XG4gIHJldHVybiAoY29udGV4dFBhdGggPyBjb250ZXh0UGF0aCArICcuJyA6ICcnKSArIGlkO1xufSIsIi8vIENyZWF0ZSBhIHNpbXBsZSBwYXRoIGFsaWFzIHRvIGFsbG93IGJyb3dzZXJpZnkgdG8gcmVzb2x2ZVxuLy8gdGhlIHJ1bnRpbWUgb24gYSBzdXBwb3J0ZWQgcGF0aC5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2Nqcy9oYW5kbGViYXJzLnJ1bnRpbWUnKVsnZGVmYXVsdCddO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaGFuZGxlYmFycy9ydW50aW1lXCIpW1wiZGVmYXVsdFwiXTtcbiIsIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2Mi4xLjRcbiAqIGh0dHA6Ly9qcXVlcnkuY29tL1xuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cDovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgMjAwNSwgMjAxNCBqUXVlcnkgRm91bmRhdGlvbiwgSW5jLiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE1LTA0LTI4VDE2OjAxWlxuICovXG5cbihmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxuXHRcdC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXG5cdFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBoYXZlIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGBcblx0XHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cblx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuXHRcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcblx0XHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcblx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggMTgrXG4vLyBDYW4ndCBiZSBpbiBzdHJpY3QgbW9kZSwgc2V2ZXJhbCBsaWJzIGluY2x1ZGluZyBBU1AuTkVUIHRyYWNlXG4vLyB0aGUgc3RhY2sgdmlhIGFyZ3VtZW50cy5jYWxsZXIuY2FsbGVlIGFuZCBGaXJlZm94IGRpZXMgaWZcbi8vIHlvdSB0cnkgdG8gdHJhY2UgdGhyb3VnaCBcInVzZSBzdHJpY3RcIiBjYWxsIGNoYWlucy4gKCMxMzMzNSlcbi8vXG5cbnZhciBhcnIgPSBbXTtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgY29uY2F0ID0gYXJyLmNvbmNhdDtcblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cblxuXG52YXJcblx0Ly8gVXNlIHRoZSBjb3JyZWN0IGRvY3VtZW50IGFjY29yZGluZ2x5IHdpdGggd2luZG93IGFyZ3VtZW50IChzYW5kYm94KVxuXHRkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcblxuXHR2ZXJzaW9uID0gXCIyLjEuNFwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjFcblx0Ly8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG5cdHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLFxuXG5cdC8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xuXHRybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW1xcZGEtel0pL2dpLFxuXG5cdC8vIFVzZWQgYnkgalF1ZXJ5LmNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcblx0ZmNhbWVsQ2FzZSA9IGZ1bmN0aW9uKCBhbGwsIGxldHRlciApIHtcblx0XHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG5cdH07XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gU3RhcnQgd2l0aCBhbiBlbXB0eSBzZWxlY3RvclxuXHRzZWxlY3RvcjogXCJcIixcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cdFx0cmV0dXJuIG51bSAhPSBudWxsID9cblxuXHRcdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdFx0KCBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdICkgOlxuXG5cdFx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0XHRzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXHRcdHJldC5jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdC8vIChZb3UgY2FuIHNlZWQgdGhlIGFyZ3VtZW50cyB3aXRoIGFuIGFycmF5IG9mIGFyZ3MsIGJ1dCB0aGlzIGlzXG5cdC8vIG9ubHkgdXNlZCBpbnRlcm5hbGx5Lilcblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrLCBhcmdzICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2ssIGFyZ3MgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAodGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0pKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzW2pdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKG51bGwpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24odGFyZ2V0KSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoIChvcHRpb25zID0gYXJndW1lbnRzWyBpIF0pICE9IG51bGwgKSB7XG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheShjb3B5KSkgKSApIHtcblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICkge1xuXHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNGdW5jdGlvbjogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnR5cGUob2JqKSA9PT0gXCJmdW5jdGlvblwiO1xuXHR9LFxuXG5cdGlzQXJyYXk6IEFycmF5LmlzQXJyYXksXG5cblx0aXNXaW5kb3c6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fSxcblxuXHRpc051bWVyaWM6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKG51bGx8dHJ1ZXxmYWxzZXxcIlwiKVxuXHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHQvLyBhZGRpbmcgMSBjb3JyZWN0cyBsb3NzIG9mIHByZWNpc2lvbiBmcm9tIHBhcnNlRmxvYXQgKCMxNTEwMClcblx0XHRyZXR1cm4gIWpRdWVyeS5pc0FycmF5KCBvYmogKSAmJiAob2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKyAxKSA+PSAwO1xuXHR9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0Ly8gTm90IHBsYWluIG9iamVjdHM6XG5cdFx0Ly8gLSBBbnkgb2JqZWN0IG9yIHZhbHVlIHdob3NlIGludGVybmFsIFtbQ2xhc3NdXSBwcm9wZXJ0eSBpcyBub3QgXCJbb2JqZWN0IE9iamVjdF1cIlxuXHRcdC8vIC0gRE9NIG5vZGVzXG5cdFx0Ly8gLSB3aW5kb3dcblx0XHRpZiAoIGpRdWVyeS50eXBlKCBvYmogKSAhPT0gXCJvYmplY3RcIiB8fCBvYmoubm9kZVR5cGUgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoIG9iai5jb25zdHJ1Y3RvciAmJlxuXHRcdFx0XHQhaGFzT3duLmNhbGwoIG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwiaXNQcm90b3R5cGVPZlwiICkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIGZ1bmN0aW9uIGhhc24ndCByZXR1cm5lZCBhbHJlYWR5LCB3ZSdyZSBjb25maWRlbnQgdGhhdFxuXHRcdC8vIHxvYmp8IGlzIGEgcGxhaW4gb2JqZWN0LCBjcmVhdGVkIGJ5IHt9IG9yIGNvbnN0cnVjdGVkIHdpdGggbmV3IE9iamVjdFxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIG5hbWU7XG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdHR5cGU6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0aWYgKCBvYmogPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHRcdH1cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMCwgaU9TPDYgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbChvYmopIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0XHR0eXBlb2Ygb2JqO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlICkge1xuXHRcdHZhciBzY3JpcHQsXG5cdFx0XHRpbmRpcmVjdCA9IGV2YWw7XG5cblx0XHRjb2RlID0galF1ZXJ5LnRyaW0oIGNvZGUgKTtcblxuXHRcdGlmICggY29kZSApIHtcblx0XHRcdC8vIElmIHRoZSBjb2RlIGluY2x1ZGVzIGEgdmFsaWQsIHByb2xvZ3VlIHBvc2l0aW9uXG5cdFx0XHQvLyBzdHJpY3QgbW9kZSBwcmFnbWEsIGV4ZWN1dGUgY29kZSBieSBpbmplY3RpbmcgYVxuXHRcdFx0Ly8gc2NyaXB0IHRhZyBpbnRvIHRoZSBkb2N1bWVudC5cblx0XHRcdGlmICggY29kZS5pbmRleE9mKFwidXNlIHN0cmljdFwiKSA9PT0gMSApIHtcblx0XHRcdFx0c2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcblx0XHRcdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBPdGhlcndpc2UsIGF2b2lkIHRoZSBET00gbm9kZSBjcmVhdGlvbiwgaW5zZXJ0aW9uXG5cdFx0XHQvLyBhbmQgcmVtb3ZhbCBieSB1c2luZyBhbiBpbmRpcmVjdCBnbG9iYWwgZXZhbFxuXHRcdFx0XHRpbmRpcmVjdCggY29kZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG5cdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0Ly8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuXHRjYW1lbENhc2U6IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG5cdH0sXG5cblx0bm9kZU5hbWU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHR9LFxuXG5cdC8vIGFyZ3MgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdFx0dmFyIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoLFxuXHRcdFx0aXNBcnJheSA9IGlzQXJyYXlsaWtlKCBvYmogKTtcblxuXHRcdGlmICggYXJncyApIHtcblx0XHRcdGlmICggaXNBcnJheSApIHtcblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5hcHBseSggb2JqWyBpIF0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrLmFwcGx5KCBvYmpbIGkgXSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEEgc3BlY2lhbCwgZmFzdCwgY2FzZSBmb3IgdGhlIG1vc3QgY29tbW9uIHVzZSBvZiBlYWNoXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggaXNBcnJheSApIHtcblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xXG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XCJcIiA6XG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlsaWtlKCBPYmplY3QoYXJyKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRpc0FycmF5ID0gaXNBcnJheWxpa2UoIGVsZW1zICksXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5ICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBjb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcblx0Ly8gYXJndW1lbnRzLlxuXHRwcm94eTogZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHRcdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0XHRjb250ZXh0ID0gZm47XG5cdFx0XHRmbiA9IHRtcDtcblx0XHR9XG5cblx0XHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHRcdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFNpbXVsYXRlZCBiaW5kXG5cdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRcdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0XHR9O1xuXG5cdFx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdFx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0XHRyZXR1cm4gcHJveHk7XG5cdH0sXG5cblx0bm93OiBEYXRlLm5vdyxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSk7XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yXCIuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbihpLCBuYW1lKSB7XG5cdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufSk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlsaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogaU9TIDguMiAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9IFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblxuXHRpZiAoIHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggb2JqLm5vZGVUeXBlID09PSAxICYmIGxlbmd0aCApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4yLjAtcHJlXG4gKiBodHRwOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCAyMDA4LCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uLCBJbmMuIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTQtMTItMTZcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEdlbmVyYWwtcHVycG9zZSBjb25zdGFudHNcblx0TUFYX05FR0FUSVZFID0gMSA8PCAzMSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cDovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gV2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc3ludGF4LyNjaGFyYWN0ZXJzXG5cdGNoYXJhY3RlckVuY29kaW5nID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXFxceDAwLVxcXFx4YTBdKStcIixcblxuXHQvLyBMb29zZWx5IG1vZGVsZWQgb24gQ1NTIGlkZW50aWZpZXIgY2hhcmFjdGVyc1xuXHQvLyBBbiB1bnF1b3RlZCB2YWx1ZSBzaG91bGQgYmUgYSBDU1MgaWRlbnRpZmllciBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHQvLyBQcm9wZXIgc3ludGF4OiBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcblx0aWRlbnRpZmllciA9IGNoYXJhY3RlckVuY29kaW5nLnJlcGxhY2UoIFwid1wiLCBcIncjXCIgKSxcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGNoYXJhY3RlckVuY29kaW5nICsgXCIpKD86XFxcXCgoXCIgK1xuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXG5cdHJhdHRyaWJ1dGVRdW90ZXMgPSBuZXcgUmVnRXhwKCBcIj1cIiArIHdoaXRlc3BhY2UgKyBcIiooW15cXFxcXSdcXFwiXSo/KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsIFwiZ1wiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGNoYXJhY3RlckVuY29kaW5nICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBjaGFyYWN0ZXJFbmNvZGluZy5yZXBsYWNlKCBcIndcIiwgXCJ3KlwiICkgKyBcIilcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblx0cmVzY2FwZSA9IC8nfFxcXFwvZyxcblxuXHQvLyBDU1MgZXNjYXBlcyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fChcIiArIHdoaXRlc3BhY2UgKyBcIil8LilcIiwgXCJpZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXHRcdC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyNFxuXHRcdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuXHRcdHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID9cblx0XHRcdGVzY2FwZWQgOlxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHQvLyBCTVAgY29kZXBvaW50XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHQvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH07XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdChhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG1hdGNoLCBlbGVtLCBtLCBub2RlVHlwZSxcblx0XHQvLyBRU0EgdmFyc1xuXHRcdGksIGdyb3Vwcywgb2xkLCBuaWQsIG5ld0NvbnRleHQsIG5ld1NlbGVjdG9yO1xuXG5cdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXG5cdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblx0bm9kZVR5cGUgPSBjb250ZXh0Lm5vZGVUeXBlO1xuXG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0aWYgKCAhc2VlZCAmJiBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgd2hlbiBwb3NzaWJsZSAoZS5nLiwgbm90IHVuZGVyIERvY3VtZW50RnJhZ21lbnQpXG5cdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblx0XHRcdC8vIFNwZWVkLXVwOiBTaXp6bGUoXCIjSURcIilcblx0XHRcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKTtcblx0XHRcdFx0XHQvLyBDaGVjayBwYXJlbnROb2RlIHRvIGNhdGNoIHdoZW4gQmxhY2tiZXJyeSA0LjYgcmV0dXJuc1xuXHRcdFx0XHRcdC8vIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgKGpRdWVyeSAjNjk2Mylcblx0XHRcdFx0XHRpZiAoIGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIElFLCBPcGVyYSwgYW5kIFdlYmtpdCByZXR1cm4gaXRlbXNcblx0XHRcdFx0XHRcdC8vIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBDb250ZXh0IGlzIG5vdCBhIGRvY3VtZW50XG5cdFx0XHRcdFx0aWYgKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgJiYgKGVsZW0gPSBjb250ZXh0Lm93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcblx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiYgZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFNwZWVkLXVwOiBTaXp6bGUoXCJUQUdcIilcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBTcGVlZC11cDogU2l6emxlKFwiLkNMQVNTXCIpXG5cdFx0XHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFFTQSBwYXRoXG5cdFx0aWYgKCBzdXBwb3J0LnFzYSAmJiAoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICkge1xuXHRcdFx0bmlkID0gb2xkID0gZXhwYW5kbztcblx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXHRcdFx0bmV3U2VsZWN0b3IgPSBub2RlVHlwZSAhPT0gMSAmJiBzZWxlY3RvcjtcblxuXHRcdFx0Ly8gcVNBIHdvcmtzIHN0cmFuZ2VseSBvbiBFbGVtZW50LXJvb3RlZCBxdWVyaWVzXG5cdFx0XHQvLyBXZSBjYW4gd29yayBhcm91bmQgdGhpcyBieSBzcGVjaWZ5aW5nIGFuIGV4dHJhIElEIG9uIHRoZSByb290XG5cdFx0XHQvLyBhbmQgd29ya2luZyB1cCBmcm9tIHRoZXJlIChUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhlIHRlY2huaXF1ZSlcblx0XHRcdC8vIElFIDggZG9lc24ndCB3b3JrIG9uIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gMSAmJiBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXG5cdFx0XHRcdGlmICggKG9sZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKFwiaWRcIikpICkge1xuXHRcdFx0XHRcdG5pZCA9IG9sZC5yZXBsYWNlKCByZXNjYXBlLCBcIlxcXFwkJlwiICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgbmlkICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmlkID0gXCJbaWQ9J1wiICsgbmlkICsgXCInXSBcIjtcblxuXHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0Z3JvdXBzW2ldID0gbmlkICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHQ7XG5cdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oXCIsXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG5ld1NlbGVjdG9yICkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9IGNhdGNoKHFzYUVycm9yKSB7XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0aWYgKCAhb2xkICkge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge0Z1bmN0aW9uKHN0cmluZywgT2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuIChjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBkaXYgYW5kIGV4cGVjdHMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBkaXYgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGRpdi5wYXJlbnROb2RlICkge1xuXHRcdFx0ZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGRpdiApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGRpdiA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAqL1xuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KFwifFwiKSxcblx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdCggfmIuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFICkgLVxuXHRcdFx0KCB+YS5zb3VyY2VJbmRleCB8fCBNQVhfTkVHQVRJVkUgKTtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgcGFyZW50LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBJZiBubyBkb2N1bWVudCBhbmQgZG9jdW1lbnRFbGVtZW50IGlzIGF2YWlsYWJsZSwgcmV0dXJuXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gU2V0IG91ciBkb2N1bWVudFxuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdHBhcmVudCA9IGRvYy5kZWZhdWx0VmlldztcblxuXHQvLyBTdXBwb3J0OiBJRT44XG5cdC8vIElmIGlmcmFtZSBkb2N1bWVudCBpcyBhc3NpZ25lZCB0byBcImRvY3VtZW50XCIgdmFyaWFibGUgYW5kIGlmIGlmcmFtZSBoYXMgYmVlbiByZWxvYWRlZCxcblx0Ly8gSUUgd2lsbCB0aHJvdyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBhY2Nlc3NpbmcgXCJkb2N1bWVudFwiIHZhcmlhYmxlLCBzZWUgalF1ZXJ5ICMxMzkzNlxuXHQvLyBJRTYtOCBkbyBub3Qgc3VwcG9ydCB0aGUgZGVmYXVsdFZpZXcgcHJvcGVydHkgc28gcGFyZW50IHdpbGwgYmUgdW5kZWZpbmVkXG5cdGlmICggcGFyZW50ICYmIHBhcmVudCAhPT0gcGFyZW50LnRvcCApIHtcblx0XHQvLyBJRTExIGRvZXMgbm90IGhhdmUgYXR0YWNoRXZlbnQsIHNvIGFsbCBtdXN0IHN1ZmZlclxuXHRcdGlmICggcGFyZW50LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRwYXJlbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblx0XHR9IGVsc2UgaWYgKCBwYXJlbnQuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRwYXJlbnQuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8qIFN1cHBvcnQgdGVzdHNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jICk7XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRpdi5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWRpdi5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIik7XG5cdH0pO1xuXG5cdC8qIGdldEVsZW1lbnQocylCeSpcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRpdi5hcHBlbmRDaGlsZCggZG9jLmNyZWF0ZUNvbW1lbnQoXCJcIikgKTtcblx0XHRyZXR1cm4gIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jLmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvYy5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jLmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBJRCBmaW5kIGFuZCBmaWx0ZXJcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdC8vIENoZWNrIHBhcmVudE5vZGUgdG8gY2F0Y2ggd2hlbiBCbGFja2JlcnJ5IDQuNiByZXR1cm5zXG5cdFx0XHRcdC8vIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgIzY5NjNcblx0XHRcdFx0cmV0dXJuIG0gJiYgbS5wYXJlbnROb2RlID8gWyBtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHQvLyBTdXBwb3J0OiBJRTYvN1xuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRkZWxldGUgRXhwci5maW5kW1wiSURcIl07XG5cblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jLnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZGl2ICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxmXScgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuMissIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS43K1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2liaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKCAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoIChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XG5cdFx0ZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpICkpICkge1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBkaXYsIFwiZGl2XCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBkaXYsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgZG9lcyBub3QgaW1wbGVtZW50IGluY2x1c2l2ZSBkZXNjZW5kZW50XG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoIChiID0gYi5wYXJlbnROb2RlKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHRpZiAoIGEgPT09IGRvYyB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvYyB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9IDpcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cdFx0XHRyZXR1cm4gYSA9PT0gZG9jID8gLTEgOlxuXHRcdFx0XHRiID09PSBkb2MgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2M7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG5cdGV4cHIgPSBleHByLnJlcGxhY2UoIHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIgKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIGRpZmYsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDogbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gcGFyZW50WyBleHBhbmRvIF0gfHwgKHBhcmVudFsgZXhwYW5kbyBdID0ge30pO1xuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IG91dGVyQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbMF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbMV07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBjYWNoZVswXSA9PT0gZGlycnVucyAmJiBjYWNoZVsyXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB1c2VDYWNoZSAmJiAoY2FjaGUgPSAoZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSkpWyB0eXBlIF0pICYmIGNhY2hlWzBdID09PSBkaXJydW5zICkge1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gY2FjaGVbMV07XG5cblx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLikgb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgPyBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOiBub2RlLm5vZGVUeXBlID09PSAxICkgJiYgKytkaWZmICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0KG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pKVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcblx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WzBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFswXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG5cdFx0fSxcblxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2U7XG5cdFx0fSxcblxuXHRcdFwiZGlzYWJsZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkKSB8fCAobm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0XCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1tcImVtcHR5XCJdKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0pLFxuXG5cdFx0XCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSksXG5cblx0XHRcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1tcIm50aFwiXSA9IEV4cHIucHNldWRvc1tcImVxXCJdO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbnRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFswXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAodG9rZW5zID0gW10pICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG5cdFx0XHR9KTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoIChtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkpICYmICghcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdChtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSkpICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdHJldHVybiBwYXJzZU9ubHkgP1xuXHRcdHNvRmFyLmxlbmd0aCA6XG5cdFx0c29GYXIgP1xuXHRcdFx0U2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBkaXIgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gZGlyIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXHRcdFx0XHRcdFx0aWYgKCAob2xkQ2FjaGUgPSBvdXRlckNhY2hlWyBkaXIgXSkgJiZcblx0XHRcdFx0XHRcdFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZVsgZGlyIF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ICE9PSBkb2N1bWVudCAmJiBjb250ZXh0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gS2VlcCBgaWAgYSBzdHJpbmcgaWYgdGhlcmUgYXJlIG5vIGVsZW1lbnRzIHNvIGBtYXRjaGVkQ291bnRgIHdpbGwgYmUgXCIwMFwiIGJlbG93XG5cdFx0XHQvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcblx0XHRcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuXHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbaV0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn07XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBubyBzZWVkIGFuZCBvbmx5IG9uZSBncm91cFxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFRha2UgYSBzaG9ydGN1dCBhbmQgc2V0IHRoZSBjb250ZXh0IGlmIHRoZSByb290IHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0c3VwcG9ydC5nZXRCeUlkICYmIGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHRcdFx0RXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkpICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0cnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXCJcIikgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYxICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGRpdjEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIiA7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRkaXYuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRyZXR1cm4gZGl2LmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XG59KSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9KTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSkoIHdpbmRvdyApO1xuXG5cblxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5qUXVlcnkuZXhwcltcIjpcIl0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcblxuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG52YXIgcnNpbmdsZVRhZyA9ICgvXjwoXFx3KylcXHMqXFwvPz4oPzo8XFwvXFwxPnwpJC8pO1xuXG5cblxudmFyIHJpc1NpbXBsZSA9IC9eLlteOiNcXFtcXC4sXSokLztcblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuXHRcdH0pO1xuXG5cdH1cblxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSk7XG5cblx0fVxuXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRpZiAoIHJpc1NpbXBsZS50ZXN0KCBxdWFsaWZpZXIgKSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcblx0XHR9XG5cblx0XHRxdWFsaWZpZXIgPSBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzICk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID49IDAgKSAhPT0gbm90O1xuXHR9KTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdHJldHVybiBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSA/XG5cdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdIDpcblx0XHRqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdFx0fSkpO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSkgKTtcblx0XHR9XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdC8vIE5lZWRlZCBiZWNhdXNlICQoIHNlbGVjdG9yLCBjb250ZXh0ICkgYmVjb21lcyAkKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKVxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZSggcmV0ICkgOiByZXQgKTtcblx0XHRyZXQuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yID8gdGhpcy5zZWxlY3RvciArIFwiIFwiICsgc2VsZWN0b3IgOiBzZWxlY3Rvcjtcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyh0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UpICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0pO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKikpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3RvclswXSA9PT0gXCI8XCIgJiYgc2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiYgc2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAobWF0Y2hbMV0gfHwgIWNvbnRleHQpICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWzFdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFswXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWzFdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWzFdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWzJdICk7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBCbGFja2JlcnJ5IDQuNlxuXHRcdFx0XHRcdC8vIGdFQklEIHJldHVybnMgbm9kZXMgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCAoIzY5NjMpXG5cdFx0XHRcdFx0aWYgKCBlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0XHR0aGlzWzBdID0gZWxlbTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLmNvbnRleHQgPSBkb2N1bWVudDtcblx0XHRcdFx0XHR0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3RqUXVlcnkgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSB0aGlzWzBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiB0eXBlb2Ygcm9vdGpRdWVyeS5yZWFkeSAhPT0gXCJ1bmRlZmluZWRcIiA/XG5cdFx0XHRcdHJvb3RqUXVlcnkucmVhZHkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yLnNlbGVjdG9yICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3Iuc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSBzZWxlY3Rvci5jb250ZXh0O1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRkaXI6IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHRcdHZhciBtYXRjaGVkID0gW10sXG5cdFx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cblx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtYXRjaGVkO1xuXHR9LFxuXG5cdHNpYmxpbmc6IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuXHRcdHZhciBtYXRjaGVkID0gW107XG5cblx0XHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG5cdFx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVkO1xuXHR9XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzW2ldICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHBvcyA9IHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgfHwgdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3JzLCBjb250ZXh0IHx8IHRoaXMuY29udGV4dCApIDpcblx0XHRcdFx0MDtcblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGZvciAoIGN1ciA9IHRoaXNbaV07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAocG9zID9cblx0XHRcdFx0XHRwb3MuaW5kZXgoY3VyKSA+IC0xIDpcblxuXHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKGN1ciwgc2VsZWN0b3JzKSkgKSB7XG5cblx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlKCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBJbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggdGhpcyxcblxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cblx0XHQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWUoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlcihzZWxlY3Rvcilcblx0XHQpO1xuXHR9XG59KTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKGN1ciA9IGN1cltkaXJdKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCh7XG5cdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHR9LFxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnNpYmxpbmcoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5zaWJsaW5nKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudCB8fCBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZSggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0pO1xudmFyIHJub3R3aGl0ZSA9ICgvXFxTKy9nKTtcblxuXG5cbi8vIFN0cmluZyB0byBPYmplY3Qgb3B0aW9ucyBmb3JtYXQgY2FjaGVcbnZhciBvcHRpb25zQ2FjaGUgPSB7fTtcblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXMgYW5kIHN0b3JlIGluIGNhY2hlXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0gb3B0aW9uc0NhY2hlWyBvcHRpb25zIF0gPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0pO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdCggb3B0aW9uc0NhY2hlWyBvcHRpb25zIF0gfHwgY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIExhc3QgZmlyZSB2YWx1ZSAoZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0cylcblx0XHRtZW1vcnksXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXHRcdC8vIEZpcnN0IGNhbGxiYWNrIHRvIGZpcmUgKHVzZWQgaW50ZXJuYWxseSBieSBhZGQgYW5kIGZpcmVXaXRoKVxuXHRcdGZpcmluZ1N0YXJ0LFxuXHRcdC8vIEVuZCBvZiB0aGUgbG9vcCB3aGVuIGZpcmluZ1xuXHRcdGZpcmluZ0xlbmd0aCxcblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSByZW1vdmUgaWYgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4LFxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXHRcdC8vIFN0YWNrIG9mIGZpcmUgY2FsbHMgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRzdGFjayA9ICFvcHRpb25zLm9uY2UgJiYgW10sXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0XHRtZW1vcnkgPSBvcHRpb25zLm1lbW9yeSAmJiBkYXRhO1xuXHRcdFx0ZmlyZWQgPSB0cnVlO1xuXHRcdFx0ZmlyaW5nSW5kZXggPSBmaXJpbmdTdGFydCB8fCAwO1xuXHRcdFx0ZmlyaW5nU3RhcnQgPSAwO1xuXHRcdFx0ZmlyaW5nTGVuZ3RoID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBsaXN0ICYmIGZpcmluZ0luZGV4IDwgZmlyaW5nTGVuZ3RoOyBmaXJpbmdJbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIGRhdGFbIDAgXSwgZGF0YVsgMSBdICkgPT09IGZhbHNlICYmIG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7IC8vIFRvIHByZXZlbnQgZnVydGhlciBjYWxscyB1c2luZyBhZGRcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdGlmICggc3RhY2sgKSB7XG5cdFx0XHRcdFx0aWYgKCBzdGFjay5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCBzdGFjay5zaGlmdCgpICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYuZGlzYWJsZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0Ly8gRmlyc3QsIHdlIHNhdmUgdGhlIGN1cnJlbnQgbGVuZ3RoXG5cdFx0XHRcdFx0dmFyIHN0YXJ0ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0KGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9KSggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0Ly8gRG8gd2UgbmVlZCB0byBhZGQgdGhlIGNhbGxiYWNrcyB0byB0aGVcblx0XHRcdFx0XHQvLyBjdXJyZW50IGZpcmluZyBiYXRjaD9cblx0XHRcdFx0XHRpZiAoIGZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0xlbmd0aCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdC8vIFdpdGggbWVtb3J5LCBpZiB3ZSdyZSBub3QgZmlyaW5nIHRoZW5cblx0XHRcdFx0XHQvLyB3ZSBzaG91bGQgY2FsbCByaWdodCBhd2F5XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nU3RhcnQgPSBzdGFydDtcblx0XHRcdFx0XHRcdGZpcmUoIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRcdGlmICggZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nTGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZmlyaW5nTGVuZ3RoLS07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gPyBqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDogISEoIGxpc3QgJiYgbGlzdC5sZW5ndGggKTtcblx0XHRcdH0sXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0ZmlyaW5nTGVuZ3RoID0gMDtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gSGF2ZSB0aGUgbGlzdCBkbyBub3RoaW5nIGFueW1vcmVcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsaXN0ID0gc3RhY2sgPSBtZW1vcnkgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIElzIGl0IGRpc2FibGVkP1xuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gTG9jayB0aGUgbGlzdCBpbiBpdHMgY3VycmVudCBzdGF0ZVxuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHN0YWNrID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgKSB7XG5cdFx0XHRcdFx0c2VsZi5kaXNhYmxlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gSXMgaXQgbG9ja2VkP1xuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFzdGFjaztcblx0XHRcdH0sXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggbGlzdCAmJiAoICFmaXJlZCB8fCBzdGFjayApICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0aWYgKCBmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRzdGFjay5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGZpcmUoIGFyZ3MgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmpRdWVyeS5leHRlbmQoe1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgbGlzdGVuZXIgbGlzdCwgZmluYWwgc3RhdGVcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwgXCJyZWplY3RlZFwiIF0sXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKFwibWVtb3J5XCIpIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZChmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBmbnNbIGkgXSApICYmIGZuc1sgaSBdO1xuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZFsgZG9uZSB8IGZhaWwgfCBwcm9ncmVzcyBdIGZvciBmb3J3YXJkaW5nIGFjdGlvbnMgdG8gbmV3RGVmZXJcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWzFdIF0oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IHByb21pc2UgPyBuZXdEZWZlci5wcm9taXNlKCkgOiB0aGlzLCBmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdHByb21pc2UucGlwZSA9IHByb21pc2UudGhlbjtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDMgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZVsgZG9uZSB8IGZhaWwgfCBwcm9ncmVzcyBdID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWzFdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQvLyBzdGF0ZSA9IFsgcmVzb2x2ZWQgfCByZWplY3RlZCBdXG5cdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblxuXHRcdFx0XHQvLyBbIHJlamVjdF9saXN0IHwgcmVzb2x2ZV9saXN0IF0uZGlzYWJsZTsgcHJvZ3Jlc3NfbGlzdC5sb2NrXG5cdFx0XHRcdH0sIHR1cGxlc1sgaSBeIDEgXVsgMiBdLmRpc2FibGUsIHR1cGxlc1sgMiBdWyAyIF0ubG9jayApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBkZWZlcnJlZFsgcmVzb2x2ZSB8IHJlamVjdCB8IG5vdGlmeSBdXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbMF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbMF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHByb21pc2UgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWzBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzdWJvcmRpbmF0ZSAvKiAsIC4uLiwgc3Vib3JkaW5hdGVOICovICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblx0XHRcdGxlbmd0aCA9IHJlc29sdmVWYWx1ZXMubGVuZ3RoLFxuXG5cdFx0XHQvLyB0aGUgY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBsZW5ndGggIT09IDEgfHwgKCBzdWJvcmRpbmF0ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggc3Vib3JkaW5hdGUucHJvbWlzZSApICkgPyBsZW5ndGggOiAwLFxuXG5cdFx0XHQvLyB0aGUgbWFzdGVyIERlZmVycmVkLiBJZiByZXNvbHZlVmFsdWVzIGNvbnNpc3Qgb2Ygb25seSBhIHNpbmdsZSBEZWZlcnJlZCwganVzdCB1c2UgdGhhdC5cblx0XHRcdGRlZmVycmVkID0gcmVtYWluaW5nID09PSAxID8gc3Vib3JkaW5hdGUgOiBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gVXBkYXRlIGZ1bmN0aW9uIGZvciBib3RoIHJlc29sdmUgYW5kIHByb2dyZXNzIHZhbHVlc1xuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpLCBjb250ZXh0cywgdmFsdWVzICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdGNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggdmFsdWVzID09PSBwcm9ncmVzc1ZhbHVlcyApIHtcblx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGNvbnRleHRzLCB2YWx1ZXMgKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNvbnRleHRzLCB2YWx1ZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXG5cdFx0XHRwcm9ncmVzc1ZhbHVlcywgcHJvZ3Jlc3NDb250ZXh0cywgcmVzb2x2ZUNvbnRleHRzO1xuXG5cdFx0Ly8gQWRkIGxpc3RlbmVycyB0byBEZWZlcnJlZCBzdWJvcmRpbmF0ZXM7IHRyZWF0IG90aGVycyBhcyByZXNvbHZlZFxuXHRcdGlmICggbGVuZ3RoID4gMSApIHtcblx0XHRcdHByb2dyZXNzVmFsdWVzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcblx0XHRcdHByb2dyZXNzQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0ucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHQuZG9uZSggdXBkYXRlRnVuYyggaSwgcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICkgKVxuXHRcdFx0XHRcdFx0LmZhaWwoIGRlZmVycmVkLnJlamVjdCApXG5cdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIHVwZGF0ZUZ1bmMoIGksIHByb2dyZXNzQ29udGV4dHMsIHByb2dyZXNzVmFsdWVzICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQtLXJlbWFpbmluZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElmIHdlJ3JlIG5vdCB3YWl0aW5nIG9uIGFueXRoaW5nLCByZXNvbHZlIHRoZSBtYXN0ZXJcblx0XHRpZiAoICFyZW1haW5pbmcgKSB7XG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcblx0fVxufSk7XG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0O1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cdC8vIEFkZCB0aGUgY2FsbGJhY2tcblx0alF1ZXJ5LnJlYWR5LnByb21pc2UoKS5kb25lKCBmbiApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhvbGQgKG9yIHJlbGVhc2UpIHRoZSByZWFkeSBldmVudFxuXHRob2xkUmVhZHk6IGZ1bmN0aW9uKCBob2xkICkge1xuXHRcdGlmICggaG9sZCApIHtcblx0XHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0XHR9IGVsc2Uge1xuXHRcdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblxuXHRcdC8vIFRyaWdnZXIgYW55IGJvdW5kIHJlYWR5IGV2ZW50c1xuXHRcdGlmICggalF1ZXJ5LmZuLnRyaWdnZXJIYW5kbGVyICkge1xuXHRcdFx0alF1ZXJ5KCBkb2N1bWVudCApLnRyaWdnZXJIYW5kbGVyKCBcInJlYWR5XCIgKTtcblx0XHRcdGpRdWVyeSggZG9jdW1lbnQgKS5vZmYoIFwicmVhZHlcIiApO1xuXHRcdH1cblx0fVxufSk7XG5cbi8qKlxuICogVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbiAqL1xuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkLCBmYWxzZSApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCwgZmFsc2UgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbmpRdWVyeS5yZWFkeS5wcm9taXNlID0gZnVuY3Rpb24oIG9iaiApIHtcblx0aWYgKCAhcmVhZHlMaXN0ICkge1xuXG5cdFx0cmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cblx0XHQvLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZCBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cblx0XHQvLyBXZSBvbmNlIHRyaWVkIHRvIHVzZSByZWFkeVN0YXRlIFwiaW50ZXJhY3RpdmVcIiBoZXJlLCBidXQgaXQgY2F1c2VkIGlzc3VlcyBsaWtlIHRoZSBvbmVcblx0XHQvLyBkaXNjb3ZlcmVkIGJ5IENocmlzUyBoZXJlOiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjI4MiNjb21tZW50OjE1XG5cdFx0aWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgKSB7XG5cdFx0XHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0XHRcdHNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCwgZmFsc2UgKTtcblxuXHRcdFx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkLCBmYWxzZSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVhZHlMaXN0LnByb21pc2UoIG9iaiApO1xufTtcblxuLy8gS2ljayBvZmYgdGhlIERPTSByZWFkeSBjaGVjayBldmVuIGlmIHRoZSB1c2VyIGRvZXMgbm90XG5qUXVlcnkucmVhZHkucHJvbWlzZSgpO1xuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGpRdWVyeS5hY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCBqUXVlcnkudHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGpRdWVyeS5hY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5W2ldLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbiggZWxlbXNbaV0sIGtleSwgcmF3ID8gdmFsdWUgOiB2YWx1ZS5jYWxsKCBlbGVtc1tpXSwgaSwgZm4oIGVsZW1zW2ldLCBrZXkgKSApICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNoYWluYWJsZSA/XG5cdFx0ZWxlbXMgOlxuXG5cdFx0Ly8gR2V0c1xuXHRcdGJ1bGsgP1xuXHRcdFx0Zm4uY2FsbCggZWxlbXMgKSA6XG5cdFx0XHRsZW4gPyBmbiggZWxlbXNbMF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIG9iamVjdCBjYW4gaGF2ZSBkYXRhXG4gKi9cbmpRdWVyeS5hY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0LyoganNoaW50IC1XMDE4ICovXG5cdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcbn07XG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LFxuXHQvLyBPbGQgV2ViS2l0IGRvZXMgbm90IGhhdmUgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zL2ZyZWV6ZSBtZXRob2QsXG5cdC8vIHJldHVybiBuZXcgZW1wdHkgb2JqZWN0IGluc3RlYWQgd2l0aCBubyBbW3NldF1dIGFjY2Vzc29yXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcy5jYWNoZSA9IHt9LCAwLCB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB7fTtcblx0XHR9XG5cdH0pO1xuXG5cdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbn1cblxuRGF0YS51aWQgPSAxO1xuRGF0YS5hY2NlcHRzID0galF1ZXJ5LmFjY2VwdERhdGE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXHRrZXk6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdC8vIEFsd2F5cyByZXR1cm4gdGhlIGtleSBmb3IgYSBmcm96ZW4gb2JqZWN0LlxuXHRcdGlmICggIURhdGEuYWNjZXB0cyggb3duZXIgKSApIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBkZXNjcmlwdG9yID0ge30sXG5cdFx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGUga2V5XG5cdFx0XHR1bmxvY2sgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF1bmxvY2sgKSB7XG5cdFx0XHR1bmxvY2sgPSBEYXRhLnVpZCsrO1xuXG5cdFx0XHQvLyBTZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSwgbm9uLXdyaXRhYmxlIHByb3BlcnR5XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkZXNjcmlwdG9yWyB0aGlzLmV4cGFuZG8gXSA9IHsgdmFsdWU6IHVubG9jayB9O1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggb3duZXIsIGRlc2NyaXB0b3IgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0XG5cdFx0XHQvLyBGYWxsYmFjayB0byBhIGxlc3Mgc2VjdXJlIGRlZmluaXRpb25cblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRkZXNjcmlwdG9yWyB0aGlzLmV4cGFuZG8gXSA9IHVubG9jaztcblx0XHRcdFx0alF1ZXJ5LmV4dGVuZCggb3duZXIsIGRlc2NyaXB0b3IgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBFbnN1cmUgdGhlIGNhY2hlIG9iamVjdFxuXHRcdGlmICggIXRoaXMuY2FjaGVbIHVubG9jayBdICkge1xuXHRcdFx0dGhpcy5jYWNoZVsgdW5sb2NrIF0gPSB7fTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdW5sb2NrO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHQvLyBUaGVyZSBtYXkgYmUgYW4gdW5sb2NrIGFzc2lnbmVkIHRvIHRoaXMgbm9kZSxcblx0XHRcdC8vIGlmIHRoZXJlIGlzIG5vIGVudHJ5IGZvciB0aGlzIFwib3duZXJcIiwgY3JlYXRlIG9uZSBpbmxpbmVcblx0XHRcdC8vIGFuZCBzZXQgdGhlIHVubG9jayBhcyB0aG91Z2ggYW4gb3duZXIgZW50cnkgaGFkIGFsd2F5cyBleGlzdGVkXG5cdFx0XHR1bmxvY2sgPSB0aGlzLmtleSggb3duZXIgKSxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZVsgdW5sb2NrIF07XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBkYXRhIF0gPSB2YWx1ZTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEZyZXNoIGFzc2lnbm1lbnRzIGJ5IG9iamVjdCBhcmUgc2hhbGxvdyBjb3BpZWRcblx0XHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5leHRlbmQoIHRoaXMuY2FjaGVbIHVubG9jayBdLCBkYXRhICk7XG5cdFx0XHQvLyBPdGhlcndpc2UsIGNvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0Y2FjaGVbIHByb3AgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0Ly8gRWl0aGVyIGEgdmFsaWQgY2FjaGUgaXMgZm91bmQsIG9yIHdpbGwgYmUgY3JlYXRlZC5cblx0XHQvLyBOZXcgY2FjaGVzIHdpbGwgYmUgY3JlYXRlZCBhbmQgdGhlIHVubG9jayByZXR1cm5lZCxcblx0XHQvLyBhbGxvd2luZyBkaXJlY3QgYWNjZXNzIHRvIHRoZSBuZXdseSBjcmVhdGVkXG5cdFx0Ly8gZW1wdHkgZGF0YSBvYmplY3QuIEEgdmFsaWQgb3duZXIgb2JqZWN0IG11c3QgYmUgcHJvdmlkZWQuXG5cdFx0dmFyIGNhY2hlID0gdGhpcy5jYWNoZVsgdGhpcy5rZXkoIG93bmVyICkgXTtcblxuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRjYWNoZSA6IGNhY2hlWyBrZXkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIHN0b3JlZDtcblx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG5cdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG5cdFx0Ly9cblx0XHQvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcblx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG5cdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuXHRcdC8vXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoKGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSApIHtcblxuXHRcdFx0c3RvcmVkID0gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblxuXHRcdFx0cmV0dXJuIHN0b3JlZCAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0c3RvcmVkIDogdGhpcy5nZXQoIG93bmVyLCBqUXVlcnkuY2FtZWxDYXNlKGtleSkgKTtcblx0XHR9XG5cblx0XHQvLyBbKl1XaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGNhbWVsLFxuXHRcdFx0dW5sb2NrID0gdGhpcy5rZXkoIG93bmVyICksXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGVbIHVubG9jayBdO1xuXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMuY2FjaGVbIHVubG9jayBdID0ge307XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIGtleSApICkge1xuXHRcdFx0XHQvLyBJZiBcIm5hbWVcIiBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdoZW4gZGF0YSBpcyBpbml0aWFsbHkgY3JlYXRlZCwgdmlhIChcImtleVwiLCBcInZhbFwiKSBzaWduYXR1cmUsXG5cdFx0XHRcdC8vIGtleXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlLlxuXHRcdFx0XHQvLyBTaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gdGVsbCBfaG93XyBhIGtleSB3YXMgYWRkZWQsIHJlbW92ZVxuXHRcdFx0XHQvLyBib3RoIHBsYWluIGtleSBhbmQgY2FtZWxDYXNlIGtleS4gIzEyNzg2XG5cdFx0XHRcdC8vIFRoaXMgd2lsbCBvbmx5IHBlbmFsaXplIHRoZSBhcnJheSBhcmd1bWVudCBwYXRoLlxuXHRcdFx0XHRuYW1lID0ga2V5LmNvbmNhdCgga2V5Lm1hcCggalF1ZXJ5LmNhbWVsQ2FzZSApICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYW1lbCA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXHRcdFx0XHQvLyBUcnkgdGhlIHN0cmluZyBhcyBhIGtleSBiZWZvcmUgYW55IG1hbmlwdWxhdGlvblxuXHRcdFx0XHRpZiAoIGtleSBpbiBjYWNoZSApIHtcblx0XHRcdFx0XHRuYW1lID0gWyBrZXksIGNhbWVsIF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0bmFtZSA9IGNhbWVsO1xuXHRcdFx0XHRcdG5hbWUgPSBuYW1lIGluIGNhY2hlID9cblx0XHRcdFx0XHRcdFsgbmFtZSBdIDogKCBuYW1lLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBuYW1lLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIG5hbWVbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHJldHVybiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoXG5cdFx0XHR0aGlzLmNhY2hlWyBvd25lclsgdGhpcy5leHBhbmRvIF0gXSB8fCB7fVxuXHRcdCk7XG5cdH0sXG5cdGRpc2NhcmQ6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHRpZiAoIG93bmVyWyB0aGlzLmV4cGFuZG8gXSApIHtcblx0XHRcdGRlbGV0ZSB0aGlzLmNhY2hlWyBvd25lclsgdGhpcy5leHBhbmRvIF0gXTtcblx0XHR9XG5cdH1cbn07XG52YXIgZGF0YV9wcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFfdXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvKFtBLVpdKS9nO1xuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJDFcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGRhdGEgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6XG5cdFx0XHRcdFx0ZGF0YSA9PT0gXCJmYWxzZVwiID8gZmFsc2UgOlxuXHRcdFx0XHRcdGRhdGEgPT09IFwibnVsbFwiID8gbnVsbCA6XG5cdFx0XHRcdFx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0XHRcdFx0XHQrZGF0YSArIFwiXCIgPT09IGRhdGEgPyArZGF0YSA6XG5cdFx0XHRcdFx0cmJyYWNlLnRlc3QoIGRhdGEgKSA/IGpRdWVyeS5wYXJzZUpTT04oIGRhdGEgKSA6XG5cdFx0XHRcdFx0ZGF0YTtcblx0XHRcdH0gY2F0Y2goIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFfdXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCh7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhX3VzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFfcHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFfdXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhX3VzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YV9wcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFfcHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YV9wcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFfdXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFfcHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTExK1xuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZS5zbGljZSg1KSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhX3ByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhX3VzZXIuc2V0KCB0aGlzLCBrZXkgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhLFxuXHRcdFx0XHRjYW1lbEtleSA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gd2l0aCB0aGUga2V5IGFzLWlzXG5cdFx0XHRcdGRhdGEgPSBkYXRhX3VzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIHdpdGggdGhlIGtleSBjYW1lbGl6ZWRcblx0XHRcdFx0ZGF0YSA9IGRhdGFfdXNlci5nZXQoIGVsZW0sIGNhbWVsS2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGNhbWVsS2V5LCB1bmRlZmluZWQgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIEZpcnN0LCBhdHRlbXB0IHRvIHN0b3JlIGEgY29weSBvciByZWZlcmVuY2Ugb2YgYW55XG5cdFx0XHRcdC8vIGRhdGEgdGhhdCBtaWdodCd2ZSBiZWVuIHN0b3JlIHdpdGggYSBjYW1lbENhc2VkIGtleS5cblx0XHRcdFx0dmFyIGRhdGEgPSBkYXRhX3VzZXIuZ2V0KCB0aGlzLCBjYW1lbEtleSApO1xuXG5cdFx0XHRcdC8vIEZvciBIVE1MNSBkYXRhLSogYXR0cmlidXRlIGludGVyb3AsIHdlIGhhdmUgdG9cblx0XHRcdFx0Ly8gc3RvcmUgcHJvcGVydHkgbmFtZXMgd2l0aCBkYXNoZXMgaW4gYSBjYW1lbENhc2UgZm9ybS5cblx0XHRcdFx0Ly8gVGhpcyBtaWdodCBub3QgYXBwbHkgdG8gYWxsIHByb3BlcnRpZXMuLi4qXG5cdFx0XHRcdGRhdGFfdXNlci5zZXQoIHRoaXMsIGNhbWVsS2V5LCB2YWx1ZSApO1xuXG5cdFx0XHRcdC8vICouLi4gSW4gdGhlIGNhc2Ugb2YgcHJvcGVydGllcyB0aGF0IG1pZ2h0IF9hY3R1YWxseV9cblx0XHRcdFx0Ly8gaGF2ZSBkYXNoZXMsIHdlIG5lZWQgdG8gYWxzbyBzdG9yZSBhIGNvcHkgb2YgdGhhdFxuXHRcdFx0XHQvLyB1bmNoYW5nZWQgcHJvcGVydHkuXG5cdFx0XHRcdGlmICgga2V5LmluZGV4T2YoXCItXCIpICE9PSAtMSAmJiBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0ZGF0YV91c2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhX3VzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHR9KTtcblx0fVxufSk7XG5cblxualF1ZXJ5LmV4dGVuZCh7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBkYXRhX3ByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgalF1ZXJ5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFfcHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoZGF0YSkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YV9wcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YV9wcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLmFkZChmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YV9wcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSlcblx0XHR9KTtcblx0fVxufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1swXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWzBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhX3ByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59KTtcbnZhciBwbnVtID0gKC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvKS5zb3VyY2U7XG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGlzSGlkZGVuID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXHRcdC8vIGlzSGlkZGVuIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiIHx8ICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHR9O1xuXG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoL14oPzpjaGVja2JveHxyYWRpbykkL2kpO1xuXG5cblxuKGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogU2FmYXJpPD01LjFcblx0Ly8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcblx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cblx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdC8vIFN1cHBvcnQ6IFNhZmFyaTw9NS4xLCBBbmRyb2lkPDQuMlxuXHQvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcblx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIFN1cHBvcnQ6IElFPD0xMStcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcbn0pKCk7XG52YXIgc3RydW5kZWZpbmVkID0gdHlwZW9mIHVuZGVmaW5lZDtcblxuXG5cbnN1cHBvcnQuZm9jdXNpbkJ1YmJsZXMgPSBcIm9uZm9jdXNpblwiIGluIHdpbmRvdztcblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudSl8Y2xpY2svLFxuXHRyZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkkLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YV9wcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcblx0XHRpZiAoICFlbGVtRGF0YSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IHt9O1xuXHRcdH1cblx0XHRpZiAoICEoZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUpICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gc3RydW5kZWZpbmVkICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1t0XSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWzFdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWzJdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoe1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbihcIi5cIilcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHwgc3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUsIGZhbHNlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YV9wcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhX3ByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cykgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1t0XSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWzFdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWzJdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsyXSAmJiBuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8IHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRlbGV0ZSBlbGVtRGF0YS5oYW5kbGU7XG5cdFx0XHRkYXRhX3ByaXYucmVtb3ZlKCBlbGVtLCBcImV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdChcIi5cIikgOiBbXTtcblxuXHRcdGN1ciA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoXCIuXCIpID49IDAgKSB7XG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdChcIi5cIik7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZihcIjpcIikgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbihcIi5cIik7XG5cdFx0ZXZlbnQubmFtZXNwYWNlX3JlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09IChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKGN1ciA9IGV2ZW50UGF0aFtpKytdKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YV9wcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdICYmIGRhdGFfcHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBqUXVlcnkuYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCFzcGVjaWFsLl9kZWZhdWx0IHx8IHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSkgJiZcblx0XHRcdFx0alF1ZXJ5LmFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0ZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApO1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cdFx0XHRoYW5kbGVycyA9ICggZGF0YV9wcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWzBdID0gZXZlbnQ7XG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAobWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0pICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoIChoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSkgJiYgIWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvciAyKSBoYXZlIG5hbWVzcGFjZShzKVxuXHRcdFx0XHQvLyBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cblx0XHRcdFx0aWYgKCAhZXZlbnQubmFtZXNwYWNlX3JlIHx8IGV2ZW50Lm5hbWVzcGFjZV9yZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9KS5oYW5kbGUgfHwgaGFuZGxlT2JqLmhhbmRsZXIgKVxuXHRcdFx0XHRcdFx0XHQuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKGV2ZW50LnJlc3VsdCA9IHJldCkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgbWF0Y2hlcywgc2VsLCBoYW5kbGVPYmosXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICgjMTMxODApXG5cdFx0Ly8gQXZvaWQgbm9uLWxlZnQtY2xpY2sgYnViYmxpbmcgaW4gRmlyZWZveCAoIzM4NjEpXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmIGN1ci5ub2RlVHlwZSAmJiAoIWV2ZW50LmJ1dHRvbiB8fCBldmVudC50eXBlICE9PSBcImNsaWNrXCIpICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIuZGlzYWJsZWQgIT09IHRydWUgfHwgZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiICkge1xuXHRcdFx0XHRcdG1hdGNoZXMgPSBbXTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID49IDAgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVzIH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCh7IGVsZW06IHRoaXMsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0Ly8gSW5jbHVkZXMgc29tZSBldmVudCBwcm9wcyBzaGFyZWQgYnkgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnRcblx0cHJvcHM6IFwiYWx0S2V5IGJ1YmJsZXMgY2FuY2VsYWJsZSBjdHJsS2V5IGN1cnJlbnRUYXJnZXQgZXZlbnRQaGFzZSBtZXRhS2V5IHJlbGF0ZWRUYXJnZXQgc2hpZnRLZXkgdGFyZ2V0IHRpbWVTdGFtcCB2aWV3IHdoaWNoXCIuc3BsaXQoXCIgXCIpLFxuXG5cdGZpeEhvb2tzOiB7fSxcblxuXHRrZXlIb29rczoge1xuXHRcdHByb3BzOiBcImNoYXIgY2hhckNvZGUga2V5IGtleUNvZGVcIi5zcGxpdChcIiBcIiksXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkge1xuXG5cdFx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCApIHtcblx0XHRcdFx0ZXZlbnQud2hpY2ggPSBvcmlnaW5hbC5jaGFyQ29kZSAhPSBudWxsID8gb3JpZ2luYWwuY2hhckNvZGUgOiBvcmlnaW5hbC5rZXlDb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXHR9LFxuXG5cdG1vdXNlSG9va3M6IHtcblx0XHRwcm9wczogXCJidXR0b24gYnV0dG9ucyBjbGllbnRYIGNsaWVudFkgb2Zmc2V0WCBvZmZzZXRZIHBhZ2VYIHBhZ2VZIHNjcmVlblggc2NyZWVuWSB0b0VsZW1lbnRcIi5zcGxpdChcIiBcIiksXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkge1xuXHRcdFx0dmFyIGV2ZW50RG9jLCBkb2MsIGJvZHksXG5cdFx0XHRcdGJ1dHRvbiA9IG9yaWdpbmFsLmJ1dHRvbjtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHBhZ2VYL1kgaWYgbWlzc2luZyBhbmQgY2xpZW50WC9ZIGF2YWlsYWJsZVxuXHRcdFx0aWYgKCBldmVudC5wYWdlWCA9PSBudWxsICYmIG9yaWdpbmFsLmNsaWVudFggIT0gbnVsbCApIHtcblx0XHRcdFx0ZXZlbnREb2MgPSBldmVudC50YXJnZXQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcblx0XHRcdFx0ZG9jID0gZXZlbnREb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0XHRib2R5ID0gZXZlbnREb2MuYm9keTtcblxuXHRcdFx0XHRldmVudC5wYWdlWCA9IG9yaWdpbmFsLmNsaWVudFggKyAoIGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwICkgLSAoIGRvYyAmJiBkb2MuY2xpZW50TGVmdCB8fCBib2R5ICYmIGJvZHkuY2xpZW50TGVmdCB8fCAwICk7XG5cdFx0XHRcdGV2ZW50LnBhZ2VZID0gb3JpZ2luYWwuY2xpZW50WSArICggZG9jICYmIGRvYy5zY3JvbGxUb3AgIHx8IGJvZHkgJiYgYm9keS5zY3JvbGxUb3AgIHx8IDAgKSAtICggZG9jICYmIGRvYy5jbGllbnRUb3AgIHx8IGJvZHkgJiYgYm9keS5jbGllbnRUb3AgIHx8IDAgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdFx0Ly8gTm90ZTogYnV0dG9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyBkb24ndCB1c2UgaXRcblx0XHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRldmVudC53aGljaCA9ICggYnV0dG9uICYgMSA/IDEgOiAoIGJ1dHRvbiAmIDIgPyAzIDogKCBidXR0b24gJiA0ID8gMiA6IDAgKSApICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSApIHtcblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cblx0XHQvLyBDcmVhdGUgYSB3cml0YWJsZSBjb3B5IG9mIHRoZSBldmVudCBvYmplY3QgYW5kIG5vcm1hbGl6ZSBzb21lIHByb3BlcnRpZXNcblx0XHR2YXIgaSwgcHJvcCwgY29weSxcblx0XHRcdHR5cGUgPSBldmVudC50eXBlLFxuXHRcdFx0b3JpZ2luYWxFdmVudCA9IGV2ZW50LFxuXHRcdFx0Zml4SG9vayA9IHRoaXMuZml4SG9va3NbIHR5cGUgXTtcblxuXHRcdGlmICggIWZpeEhvb2sgKSB7XG5cdFx0XHR0aGlzLmZpeEhvb2tzWyB0eXBlIF0gPSBmaXhIb29rID1cblx0XHRcdFx0cm1vdXNlRXZlbnQudGVzdCggdHlwZSApID8gdGhpcy5tb3VzZUhvb2tzIDpcblx0XHRcdFx0cmtleUV2ZW50LnRlc3QoIHR5cGUgKSA/IHRoaXMua2V5SG9va3MgOlxuXHRcdFx0XHR7fTtcblx0XHR9XG5cdFx0Y29weSA9IGZpeEhvb2sucHJvcHMgPyB0aGlzLnByb3BzLmNvbmNhdCggZml4SG9vay5wcm9wcyApIDogdGhpcy5wcm9wcztcblxuXHRcdGV2ZW50ID0gbmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXG5cdFx0aSA9IGNvcHkubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0cHJvcCA9IGNvcHlbIGkgXTtcblx0XHRcdGV2ZW50WyBwcm9wIF0gPSBvcmlnaW5hbEV2ZW50WyBwcm9wIF07XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQ29yZG92YSAyLjUgKFdlYktpdCkgKCMxMzI1NSlcblx0XHQvLyBBbGwgZXZlbnRzIHNob3VsZCBoYXZlIGEgdGFyZ2V0OyBDb3Jkb3ZhIGRldmljZXJlYWR5IGRvZXNuJ3Rcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBkb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgNi4wKywgQ2hyb21lPDI4XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHRpZiAoIGV2ZW50LnRhcmdldC5ub2RlVHlwZSA9PT0gMyApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGV2ZW50LnRhcmdldC5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmaXhIb29rLmZpbHRlciA/IGZpeEhvb2suZmlsdGVyKCBldmVudCwgb3JpZ2luYWxFdmVudCApIDogZXZlbnQ7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRmb2N1czoge1xuXHRcdFx0Ly8gRmlyZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMgKSB7XG5cdFx0XHRcdFx0dGhpcy5mb2N1cygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJcblx0XHR9LFxuXHRcdGJsdXI6IHtcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5ibHVyICkge1xuXHRcdFx0XHRcdHRoaXMuYmx1cigpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c291dFwiXG5cdFx0fSxcblx0XHRjbGljazoge1xuXHRcdFx0Ly8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmIHRoaXMuY2xpY2sgJiYgalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR0aGlzLmNsaWNrKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubm9kZU5hbWUoIGV2ZW50LnRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQsIGJ1YmJsZSApIHtcblx0XHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmUuXG5cdFx0Ly8gRmFrZSBvcmlnaW5hbEV2ZW50IHRvIGF2b2lkIGRvbm9yJ3Mgc3RvcFByb3BhZ2F0aW9uLCBidXQgaWYgdGhlXG5cdFx0Ly8gc2ltdWxhdGVkIGV2ZW50IHByZXZlbnRzIGRlZmF1bHQgdGhlbiB3ZSBkbyB0aGUgc2FtZSBvbiB0aGUgZG9ub3IuXG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlLFxuXHRcdFx0XHRvcmlnaW5hbEV2ZW50OiB7fVxuXHRcdFx0fVxuXHRcdCk7XG5cdFx0aWYgKCBidWJibGUgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guY2FsbCggZWxlbSwgZSApO1xuXHRcdH1cblx0XHRpZiAoIGUuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUsIGZhbHNlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQpICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IGpRdWVyeS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiBlLnByZXZlbnREZWZhdWx0ICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmIGUuc3RvcFByb3BhZ2F0aW9uICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiApIHtcblx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxufTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTUrXG5qUXVlcnkuZWFjaCh7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSk7XG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3gsIENocm9tZSwgU2FmYXJpXG4vLyBDcmVhdGUgXCJidWJibGluZ1wiIGZvY3VzIGFuZCBibHVyIGV2ZW50c1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luQnViYmxlcyApIHtcblx0alF1ZXJ5LmVhY2goeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSwgdHJ1ZSApO1xuXHRcdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YV9wcml2LmFjY2VzcyggZG9jLCBmaXggKTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFfcHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFfcHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0ZGF0YV9wcml2LnJlbW92ZSggZG9jLCBmaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFfcHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgLypJTlRFUk5BTCovIG9uZSApIHtcblx0XHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdFx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vbiggdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblx0XHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRcdGZuID0gZGF0YTtcblx0XHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlmICggb25lID09PSAxICkge1xuXHRcdFx0b3JpZ0ZuID0gZm47XG5cdFx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHR9O1xuXHRcdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0XHR9KTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID8gaGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDogaGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSk7XG5cdH0sXG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbMF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59KTtcblxuXG52YXJcblx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcdzpdKylbXj5dKilcXC8+L2dpLFxuXHRydGFnTmFtZSA9IC88KFtcXHc6XSspLyxcblx0cmh0bWwgPSAvPHwmIz9cXHcrOy8sXG5cdHJub0lubmVyaHRtbCA9IC88KD86c2NyaXB0fHN0eWxlfGxpbmspL2ksXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJzY3JpcHRUeXBlID0gL14kfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSxcblx0cnNjcmlwdFR5cGVNYXNrZWQgPSAvXnRydWVcXC8oLiopLyxcblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nLFxuXG5cdC8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG5cdHdyYXBNYXAgPSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRTlcblx0XHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHRcdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0XHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHRcdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0XHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0XHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cblx0fTtcblxuLy8gU3VwcG9ydDogSUU5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuLy8gU3VwcG9ydDogMS54IGNvbXBhdGliaWxpdHlcbi8vIE1hbmlwdWxhdGluZyB0YWJsZXMgcmVxdWlyZXMgYSB0Ym9keVxuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRyZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdGpRdWVyeS5ub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSA/XG5cblx0XHRlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGJvZHlcIilbMF0gfHxcblx0XHRcdGVsZW0uYXBwZW5kQ2hpbGQoIGVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGJvZHlcIikgKSA6XG5cdFx0ZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSAhPT0gbnVsbCkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHR2YXIgbWF0Y2ggPSByc2NyaXB0VHlwZU1hc2tlZC5leGVjKCBlbGVtLnR5cGUgKTtcblxuXHRpZiAoIG1hdGNoICkge1xuXHRcdGVsZW0udHlwZSA9IG1hdGNoWyAxIF07XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YV9wcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sIFwiZ2xvYmFsRXZhbFwiLCAhcmVmRWxlbWVudHMgfHwgZGF0YV9wcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YV9wcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHBkYXRhT2xkID0gZGF0YV9wcml2LmFjY2Vzcyggc3JjICk7XG5cdFx0cGRhdGFDdXIgPSBkYXRhX3ByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcblx0XHRcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhX3VzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0dWRhdGFPbGQgPSBkYXRhX3VzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YV91c2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblx0dmFyIHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPyBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKSA6XG5cdFx0XHRjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgPyBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApIDpcblx0XHRcdFtdO1xuXG5cdHJldHVybiB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSA/XG5cdFx0alF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICkgOlxuXHRcdHJldDtcbn1cblxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG5mdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdH1cbn1cblxualF1ZXJ5LmV4dGVuZCh7XG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cDovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRidWlsZEZyYWdtZW50OiBmdW5jdGlvbiggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiApIHtcblx0XHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuXHRcdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRcdG5vZGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRcdGlmICggalF1ZXJ5LnR5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBRdFdlYktpdCwgUGhhbnRvbUpTXG5cdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudChcImRpdlwiKSApO1xuXG5cdFx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBlbGVtLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cdFx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogUXRXZWJLaXQsIFBoYW50b21KU1xuXHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdFx0Ly8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxuXHRcdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdFx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoZWxlbSA9IG5vZGVzWyBpKysgXSkgKSB7XG5cblx0XHRcdC8vICM0MDg3IC0gSWYgb3JpZ2luIGFuZCBkZXN0aW5hdGlvbiBlbGVtZW50cyBhcmUgdGhlIHNhbWUsIGFuZCB0aGlzIGlzXG5cdFx0XHQvLyB0aGF0IGVsZW1lbnQsIGRvIG5vdCBkbyBhbnl0aGluZ1xuXHRcdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApICE9PSAtMSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdFx0aWYgKCBjb250YWlucyApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSB0bXBbIGorKyBdKSApIHtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZnJhZ21lbnQ7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsIGtleSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoZWxlbSA9IGVsZW1zWyBpIF0pICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdGlmICggalF1ZXJ5LmFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0a2V5ID0gZWxlbVsgZGF0YV9wcml2LmV4cGFuZG8gXTtcblxuXHRcdFx0XHRpZiAoIGtleSAmJiAoZGF0YSA9IGRhdGFfcHJpdi5jYWNoZVsga2V5IF0pICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGRhdGFfcHJpdi5jYWNoZVsga2V5IF0gKSB7XG5cdFx0XHRcdFx0XHQvLyBEaXNjYXJkIGFueSByZW1haW5pbmcgYHByaXZhdGVgIGRhdGFcblx0XHRcdFx0XHRcdGRlbGV0ZSBkYXRhX3ByaXYuY2FjaGVbIGtleSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gRGlzY2FyZCBhbnkgcmVtYWluaW5nIGB1c2VyYCBkYXRhXG5cdFx0XHRkZWxldGUgZGF0YV91c2VyLmNhY2hlWyBlbGVtWyBkYXRhX3VzZXIuZXhwYW5kbyBdIF07XG5cdFx0fVxuXHR9XG59KTtcblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCBrZWVwRGF0YSAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGVsZW1zID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgdGhpcyApIDogdGhpcyxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoICFrZWVwRGF0YSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0gKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICkge1xuXHRcdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IChlbGVtID0gdGhpc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdH0pO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcmcgPSBhcmd1bWVudHNbIDAgXTtcblxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdHRoaXMuZG9tTWFuaXAoIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRhcmcgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cblx0XHRcdGlmICggYXJnICkge1xuXHRcdFx0XHRhcmcucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBGb3JjZSByZW1vdmFsIGlmIHRoZXJlIHdhcyBubyBuZXcgY29udGVudCAoZS5nLiwgZnJvbSBlbXB0eSBhcmd1bWVudHMpXG5cdFx0cmV0dXJuIGFyZyAmJiAoYXJnLmxlbmd0aCB8fCBhcmcubm9kZVR5cGUpID8gdGhpcyA6IHRoaXMucmVtb3ZlKCk7XG5cdH0sXG5cblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlKCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdGRvbU1hbmlwOiBmdW5jdGlvbiggYXJncywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0YXJncyA9IGNvbmNhdC5hcHBseSggW10sIGFyZ3MgKTtcblxuXHRcdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2V0ID0gdGhpcyxcblx0XHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRcdGlmICggaXNGdW5jdGlvbiB8fFxuXHRcdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHRcdHZhciBzZWxmID0gc2V0LmVxKCBpbmRleCApO1xuXHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi5kb21NYW5pcCggYXJncywgY2FsbGJhY2sgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICggbCApIHtcblx0XHRcdGZyYWdtZW50ID0galF1ZXJ5LmJ1aWxkRnJhZ21lbnQoIGFyZ3MsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgdGhpcyApO1xuXHRcdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGZpcnN0ICkge1xuXHRcdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG5cdFx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBRdFdlYktpdFxuXHRcdFx0XHRcdFx0XHQvLyBqUXVlcnkubWVyZ2UgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKCB0aGlzWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdFx0IWRhdGFfcHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiYgalF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSk7XG5cbmpRdWVyeS5lYWNoKHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogUXRXZWJLaXRcblx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Ncblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSk7XG5cblxudmFyIGlmcmFtZSxcblx0ZWxlbWRpc3BsYXkgPSB7fTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgYWN0dWFsIGRpc3BsYXkgb2YgYSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBub2RlTmFtZSBvZiB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IGRvYyBEb2N1bWVudCBvYmplY3RcbiAqL1xuLy8gQ2FsbGVkIG9ubHkgZnJvbSB3aXRoaW4gZGVmYXVsdERpc3BsYXlcbmZ1bmN0aW9uIGFjdHVhbERpc3BsYXkoIG5hbWUsIGRvYyApIHtcblx0dmFyIHN0eWxlLFxuXHRcdGVsZW0gPSBqUXVlcnkoIGRvYy5jcmVhdGVFbGVtZW50KCBuYW1lICkgKS5hcHBlbmRUbyggZG9jLmJvZHkgKSxcblxuXHRcdC8vIGdldERlZmF1bHRDb21wdXRlZFN0eWxlIG1pZ2h0IGJlIHJlbGlhYmx5IHVzZWQgb25seSBvbiBhdHRhY2hlZCBlbGVtZW50XG5cdFx0ZGlzcGxheSA9IHdpbmRvdy5nZXREZWZhdWx0Q29tcHV0ZWRTdHlsZSAmJiAoIHN0eWxlID0gd2luZG93LmdldERlZmF1bHRDb21wdXRlZFN0eWxlKCBlbGVtWyAwIF0gKSApID9cblxuXHRcdFx0Ly8gVXNlIG9mIHRoaXMgbWV0aG9kIGlzIGEgdGVtcG9yYXJ5IGZpeCAobW9yZSBsaWtlIG9wdGltaXphdGlvbikgdW50aWwgc29tZXRoaW5nIGJldHRlciBjb21lcyBhbG9uZyxcblx0XHRcdC8vIHNpbmNlIGl0IHdhcyByZW1vdmVkIGZyb20gc3BlY2lmaWNhdGlvbiBhbmQgc3VwcG9ydGVkIG9ubHkgaW4gRkZcblx0XHRcdHN0eWxlLmRpc3BsYXkgOiBqUXVlcnkuY3NzKCBlbGVtWyAwIF0sIFwiZGlzcGxheVwiICk7XG5cblx0Ly8gV2UgZG9uJ3QgaGF2ZSBhbnkgZGF0YSBzdG9yZWQgb24gdGhlIGVsZW1lbnQsXG5cdC8vIHNvIHVzZSBcImRldGFjaFwiIG1ldGhvZCBhcyBmYXN0IHdheSB0byBnZXQgcmlkIG9mIHRoZSBlbGVtZW50XG5cdGVsZW0uZGV0YWNoKCk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbi8qKlxuICogVHJ5IHRvIGRldGVybWluZSB0aGUgZGVmYXVsdCBkaXNwbGF5IHZhbHVlIG9mIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBub2RlTmFtZVxuICovXG5mdW5jdGlvbiBkZWZhdWx0RGlzcGxheSggbm9kZU5hbWUgKSB7XG5cdHZhciBkb2MgPSBkb2N1bWVudCxcblx0XHRkaXNwbGF5ID0gZWxlbWRpc3BsYXlbIG5vZGVOYW1lIF07XG5cblx0aWYgKCAhZGlzcGxheSApIHtcblx0XHRkaXNwbGF5ID0gYWN0dWFsRGlzcGxheSggbm9kZU5hbWUsIGRvYyApO1xuXG5cdFx0Ly8gSWYgdGhlIHNpbXBsZSB3YXkgZmFpbHMsIHJlYWQgZnJvbSBpbnNpZGUgYW4gaWZyYW1lXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiB8fCAhZGlzcGxheSApIHtcblxuXHRcdFx0Ly8gVXNlIHRoZSBhbHJlYWR5LWNyZWF0ZWQgaWZyYW1lIGlmIHBvc3NpYmxlXG5cdFx0XHRpZnJhbWUgPSAoaWZyYW1lIHx8IGpRdWVyeSggXCI8aWZyYW1lIGZyYW1lYm9yZGVyPScwJyB3aWR0aD0nMCcgaGVpZ2h0PScwJy8+XCIgKSkuYXBwZW5kVG8oIGRvYy5kb2N1bWVudEVsZW1lbnQgKTtcblxuXHRcdFx0Ly8gQWx3YXlzIHdyaXRlIGEgbmV3IEhUTUwgc2tlbGV0b24gc28gV2Via2l0IGFuZCBGaXJlZm94IGRvbid0IGNob2tlIG9uIHJldXNlXG5cdFx0XHRkb2MgPSBpZnJhbWVbIDAgXS5jb250ZW50RG9jdW1lbnQ7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFXG5cdFx0XHRkb2Mud3JpdGUoKTtcblx0XHRcdGRvYy5jbG9zZSgpO1xuXG5cdFx0XHRkaXNwbGF5ID0gYWN0dWFsRGlzcGxheSggbm9kZU5hbWUsIGRvYyApO1xuXHRcdFx0aWZyYW1lLmRldGFjaCgpO1xuXHRcdH1cblxuXHRcdC8vIFN0b3JlIHRoZSBjb3JyZWN0IGRlZmF1bHQgZGlzcGxheVxuXHRcdGVsZW1kaXNwbGF5WyBub2RlTmFtZSBdID0gZGlzcGxheTtcblx0fVxuXG5cdHJldHVybiBkaXNwbGF5O1xufVxudmFyIHJtYXJnaW4gPSAoL15tYXJnaW4vKTtcblxudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0Ly8gU3VwcG9ydDogSUU8PTExKywgRmlyZWZveDw9MzArICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHRpZiAoIGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5vcGVuZXIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0sIG51bGwgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGVsZW0sIG51bGwgKTtcblx0fTtcblxuXG5cbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gU3VwcG9ydDogSUU5XG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgb25seSBuZWVkZWQgZm9yIC5jc3MoJ2ZpbHRlcicpICgjMTI1MzcpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cdH1cblxuXHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBpT1MgPCA2XG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIGlPUyA8IDYgKGF0IGxlYXN0KSByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIGEgbGFyZ2VyIHNldCBvZiB2YWx1ZXMsIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHNcblx0XHQvLyB0aGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6IGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiBybWFyZ2luLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cdFx0Ly8gU3VwcG9ydDogSUVcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICh0aGlzLmdldCA9IGhvb2tGbikuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG4oZnVuY3Rpb24oKSB7XG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCxcblx0XHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjowO3dpZHRoOjA7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4O21hcmdpbi10b3A6MXB4O1wiICtcblx0XHRcInBvc2l0aW9uOmFic29sdXRlXCI7XG5cdGNvbnRhaW5lci5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVQaXhlbFBvc2l0aW9uQW5kQm94U2l6aW5nUmVsaWFibGUoKSB7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyOSwgQW5kcm9pZCAyLjNcblx0XHRcdC8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZ1xuXHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDstbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDtcIiArXG5cdFx0XHRcImJveC1zaXppbmc6Ym9yZGVyLWJveDtkaXNwbGF5OmJsb2NrO21hcmdpbi10b3A6MSU7dG9wOjElO1wiICtcblx0XHRcdFwiYm9yZGVyOjFweDtwYWRkaW5nOjFweDt3aWR0aDo0cHg7cG9zaXRpb246YWJzb2x1dGVcIjtcblx0XHRkaXYuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYsIG51bGwgKTtcblx0XHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSBkaXZTdHlsZS53aWR0aCA9PT0gXCI0cHhcIjtcblxuXHRcdGRvY0VsZW0ucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogbm9kZS5qcyBqc2RvbVxuXHQvLyBEb24ndCBhc3N1bWUgdGhhdCBnZXRDb21wdXRlZFN0eWxlIGlzIGEgcHJvcGVydHkgb2YgdGhlIGdsb2JhbCBvYmplY3Rcblx0aWYgKCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBUaGlzIHRlc3QgaXMgZXhlY3V0ZWQgb25seSBvbmNlIGJ1dCB3ZSBzdGlsbCBkbyBtZW1vaXppbmdcblx0XHRcdFx0Ly8gc2luY2Ugd2UgY2FuIHVzZSB0aGUgYm94U2l6aW5nUmVsaWFibGUgcHJlLWNvbXB1dGluZy5cblx0XHRcdFx0Ly8gTm8gbmVlZCB0byBjaGVjayBpZiB0aGUgdGVzdCB3YXMgYWxyZWFkeSBwZXJmb3JtZWQsIHRob3VnaC5cblx0XHRcdFx0Y29tcHV0ZVBpeGVsUG9zaXRpb25BbmRCb3hTaXppbmdSZWxpYWJsZSgpO1xuXHRcdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHRcdH0sXG5cdFx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggYm94U2l6aW5nUmVsaWFibGVWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRjb21wdXRlUGl4ZWxQb3NpdGlvbkFuZEJveFNpemluZ1JlbGlhYmxlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdFx0fSxcblx0XHRcdHJlbGlhYmxlTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG5cdFx0XHRcdC8vIENoZWNrIGlmIGRpdiB3aXRoIGV4cGxpY2l0IHdpZHRoIGFuZCBubyBtYXJnaW4tcmlnaHQgaW5jb3JyZWN0bHlcblx0XHRcdFx0Ly8gZ2V0cyBjb21wdXRlZCBtYXJnaW4tcmlnaHQgYmFzZWQgb24gd2lkdGggb2YgY29udGFpbmVyLiAoIzMzMzMpXG5cdFx0XHRcdC8vIFdlYktpdCBCdWcgMTMzNDMgLSBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgd3JvbmcgdmFsdWUgZm9yIG1hcmdpbi1yaWdodFxuXHRcdFx0XHQvLyBUaGlzIHN1cHBvcnQgZnVuY3Rpb24gaXMgb25seSBleGVjdXRlZCBvbmNlIHNvIG5vIG1lbW9pemluZyBpcyBuZWVkZWQuXG5cdFx0XHRcdHZhciByZXQsXG5cdFx0XHRcdFx0bWFyZ2luRGl2ID0gZGl2LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHQvLyBSZXNldCBDU1M6IGJveC1zaXppbmc7IGRpc3BsYXk7IG1hcmdpbjsgYm9yZGVyOyBwYWRkaW5nXG5cdFx0XHRcdG1hcmdpbkRpdi5zdHlsZS5jc3NUZXh0ID0gZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjksIEFuZHJvaWQgMi4zXG5cdFx0XHRcdFx0Ly8gVmVuZG9yLXByZWZpeCBib3gtc2l6aW5nXG5cdFx0XHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7LW1vei1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O1wiICtcblx0XHRcdFx0XHRcImJveC1zaXppbmc6Y29udGVudC1ib3g7ZGlzcGxheTpibG9jazttYXJnaW46MDtib3JkZXI6MDtwYWRkaW5nOjBcIjtcblx0XHRcdFx0bWFyZ2luRGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gbWFyZ2luRGl2LnN0eWxlLndpZHRoID0gXCIwXCI7XG5cdFx0XHRcdGRpdi5zdHlsZS53aWR0aCA9IFwiMXB4XCI7XG5cdFx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0XHRcdHJldCA9ICFwYXJzZUZsb2F0KCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggbWFyZ2luRGl2LCBudWxsICkubWFyZ2luUmlnaHQgKTtcblxuXHRcdFx0XHRkb2NFbGVtLnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblx0XHRcdFx0ZGl2LnJlbW92ZUNoaWxkKCBtYXJnaW5EaXYgKTtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59KSgpO1xuXG5cbi8vIEEgbWV0aG9kIGZvciBxdWlja2x5IHN3YXBwaW5nIGluL291dCBDU1MgcHJvcGVydGllcyB0byBnZXQgY29ycmVjdCBjYWxjdWxhdGlvbnMuXG5qUXVlcnkuc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cbnZhclxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHRybnVtc3BsaXQgPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKC4qKSRcIiwgXCJpXCIgKSxcblx0cnJlbE51bSA9IG5ldyBSZWdFeHAoIFwiXihbKy1dKT0oXCIgKyBwbnVtICsgXCIpXCIsIFwiaVwiICksXG5cblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH0sXG5cblx0Y3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiT1wiLCBcIk1velwiLCBcIm1zXCIgXTtcblxuLy8gUmV0dXJuIGEgY3NzIHByb3BlcnR5IG1hcHBlZCB0byBhIHBvdGVudGlhbGx5IHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIHN0eWxlLCBuYW1lICkge1xuXG5cdC8vIFNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXG5cdGlmICggbmFtZSBpbiBzdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLFxuXHRcdG9yaWdOYW1lID0gbmFtZSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb3JpZ05hbWU7XG59XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cdHZhciBtYXRjaGVzID0gcm51bXNwbGl0LmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAxIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAyIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBhdWdtZW50V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMgKSB7XG5cdHZhciBpID0gZXh0cmEgPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSA/XG5cdFx0Ly8gSWYgd2UgYWxyZWFkeSBoYXZlIHRoZSByaWdodCBtZWFzdXJlbWVudCwgYXZvaWQgYXVnbWVudGF0aW9uXG5cdFx0NCA6XG5cdFx0Ly8gT3RoZXJ3aXNlIGluaXRpYWxpemUgZm9yIGhvcml6b250YWwgb3IgdmVydGljYWwgcHJvcGVydGllc1xuXHRcdG5hbWUgPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuXG5cdFx0dmFsID0gMDtcblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luLCBzbyBhZGQgaXQgaWYgd2Ugd2FudCBpdFxuXHRcdGlmICggZXh0cmEgPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgZXh0cmEgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0JvcmRlckJveCApIHtcblx0XHRcdC8vIGJvcmRlci1ib3ggaW5jbHVkZXMgcGFkZGluZywgc28gcmVtb3ZlIGl0IGlmIHdlIHdhbnQgY29udGVudFxuXHRcdFx0aWYgKCBleHRyYSA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgYm9yZGVyIG5vciBtYXJnaW4sIHNvIHJlbW92ZSBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50LCBzbyBhZGQgcGFkZGluZ1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50IG5vciBwYWRkaW5nLCBzbyBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBvZmZzZXQgcHJvcGVydHksIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGJvcmRlci1ib3ggdmFsdWVcblx0dmFyIHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlLFxuXHRcdHZhbCA9IG5hbWUgPT09IFwid2lkdGhcIiA/IGVsZW0ub2Zmc2V0V2lkdGggOiBlbGVtLm9mZnNldEhlaWdodCxcblx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0Ly8gU29tZSBub24taHRtbCBlbGVtZW50cyByZXR1cm4gdW5kZWZpbmVkIGZvciBvZmZzZXRXaWR0aCwgc28gY2hlY2sgZm9yIG51bGwvdW5kZWZpbmVkXG5cdC8vIHN2ZyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY0OTI4NVxuXHQvLyBNYXRoTUwgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD00OTE2Njhcblx0aWYgKCB2YWwgPD0gMCB8fCB2YWwgPT0gbnVsbCApIHtcblx0XHQvLyBGYWxsIGJhY2sgdG8gY29tcHV0ZWQgdGhlbiB1bmNvbXB1dGVkIGNzcyBpZiBuZWNlc3Nhcnlcblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdGlmICggdmFsIDwgMCB8fCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdHZhbCA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBDb21wdXRlZCB1bml0IGlzIG5vdCBwaXhlbHMuIFN0b3AgaGVyZSBhbmQgcmV0dXJuLlxuXHRcdGlmICggcm51bW5vbnB4LnRlc3QodmFsKSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcblx0XHQvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94ICYmXG5cdFx0XHQoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIG5hbWUgXSApO1xuXG5cdFx0Ly8gTm9ybWFsaXplIFwiXCIsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuXHRcdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cdH1cblxuXHQvLyBVc2UgdGhlIGFjdGl2ZSBib3gtc2l6aW5nIG1vZGVsIHRvIGFkZC9zdWJ0cmFjdCBpcnJlbGV2YW50IHN0eWxlc1xuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0ZWxlbSxcblx0XHRcdG5hbWUsXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLCBoaWRkZW4sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YV9wcml2LmdldCggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKTtcblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblx0XHRcdC8vIFJlc2V0IHRoZSBpbmxpbmUgZGlzcGxheSBvZiB0aGlzIGVsZW1lbnQgdG8gbGVhcm4gaWYgaXQgaXNcblx0XHRcdC8vIGJlaW5nIGhpZGRlbiBieSBjYXNjYWRlZCBydWxlcyBvciBub3Rcblx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSAmJiBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGVsZW1lbnRzIHdoaWNoIGhhdmUgYmVlbiBvdmVycmlkZGVuIHdpdGggZGlzcGxheTogbm9uZVxuXHRcdFx0Ly8gaW4gYSBzdHlsZXNoZWV0IHRvIHdoYXRldmVyIHRoZSBkZWZhdWx0IGJyb3dzZXIgc3R5bGUgaXNcblx0XHRcdC8vIGZvciBzdWNoIGFuIGVsZW1lbnRcblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFfcHJpdi5hY2Nlc3MoIGVsZW0sIFwib2xkZGlzcGxheVwiLCBkZWZhdWx0RGlzcGxheShlbGVtLm5vZGVOYW1lKSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRoaWRkZW4gPSBpc0hpZGRlbiggZWxlbSApO1xuXG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiIHx8ICFoaWRkZW4gKSB7XG5cdFx0XHRcdGRhdGFfcHJpdi5zZXQoIGVsZW0sIFwib2xkZGlzcGxheVwiLCBoaWRkZW4gPyBkaXNwbGF5IDogalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiBtb3N0IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wXG5cdC8vIHRvIGF2b2lkIHRoZSBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0XHRpZiAoICFzaG93IHx8IGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHwgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gc2hvdyA/IHZhbHVlc1sgaW5kZXggXSB8fCBcIlwiIDogXCJub25lXCI7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZXh0ZW5kKHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwibGluZUhlaWdodFwiOiB0cnVlLFxuXHRcdFwib3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwib3JkZXJcIjogdHJ1ZSxcblx0XHRcIm9ycGhhbnNcIjogdHJ1ZSxcblx0XHRcIndpZG93c1wiOiB0cnVlLFxuXHRcdFwiekluZGV4XCI6IHRydWUsXG5cdFx0XCJ6b29tXCI6IHRydWVcblx0fSxcblxuXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG5cdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0Y3NzUHJvcHM6IHtcblx0XHRcImZsb2F0XCI6IFwiY3NzRmxvYXRcIlxuXHR9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHwgKCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggc3R5bGUsIG9yaWdOYW1lICkgKTtcblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKHJldCA9IHJyZWxOdW0uZXhlYyggdmFsdWUgKSkgKSB7XG5cdFx0XHRcdHZhbHVlID0gKCByZXRbMV0gKyAxICkgKiByZXRbMl0gKyBwYXJzZUZsb2F0KCBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICkgKTtcblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciwgYWRkICdweCcgdG8gdGhlIChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgJiYgIWpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gKSB7XG5cdFx0XHRcdHZhbHVlICs9IFwicHhcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHRcdFx0Ly8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgIShcInNldFwiIGluIGhvb2tzKSB8fCAodmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkpICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8ICggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIGVsZW0uc3R5bGUsIG9yaWdOYW1lICkgKTtcblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgalF1ZXJ5LmlzTnVtZXJpYyggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSk7XG5cbmpRdWVyeS5lYWNoKFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJiBlbGVtLm9mZnNldFdpZHRoID09PSAwID9cblx0XHRcdFx0XHRqUXVlcnkuc3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIHN0eWxlcyA9IGV4dHJhICYmIGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgZXh0cmEgP1xuXHRcdFx0XHRhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0KSA6IDBcblx0XHRcdCk7XG5cdFx0fVxuXHR9O1xufSk7XG5cbi8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luUmlnaHQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5SaWdodCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnN3YXAoIGVsZW0sIHsgXCJkaXNwbGF5XCI6IFwiaW5saW5lLWJsb2NrXCIgfSxcblx0XHRcdFx0Y3VyQ1NTLCBbIGVsZW0sIFwibWFyZ2luUmlnaHRcIiBdICk7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCh7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdChcIiBcIikgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoICFybWFyZ2luLnRlc3QoIHByZWZpeCApICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW4oIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59KTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgXCJzd2luZ1wiO1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJlxuXHRcdFx0XHQoIXR3ZWVuLmVsZW0uc3R5bGUgfHwgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwpICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLnN0eWxlICYmICggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8IGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUU5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9XG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBDb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgdGltZXJJZCxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJmeG51bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICksXG5cdHJydW4gPSAvcXVldWVIb29rcyQvLFxuXHRhbmltYXRpb25QcmVmaWx0ZXJzID0gWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cdHR3ZWVuZXJzID0ge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICksXG5cdFx0XHRcdHRhcmdldCA9IHR3ZWVuLmN1cigpLFxuXHRcdFx0XHRwYXJ0cyA9IHJmeG51bS5leGVjKCB2YWx1ZSApLFxuXHRcdFx0XHR1bml0ID0gcGFydHMgJiYgcGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdFx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdFx0XHRzdGFydCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiArdGFyZ2V0ICkgJiZcblx0XHRcdFx0XHRyZnhudW0uZXhlYyggalF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgcHJvcCApICksXG5cdFx0XHRcdHNjYWxlID0gMSxcblx0XHRcdFx0bWF4SXRlcmF0aW9ucyA9IDIwO1xuXG5cdFx0XHRpZiAoIHN0YXJ0ICYmIHN0YXJ0WyAzIF0gIT09IHVuaXQgKSB7XG5cdFx0XHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHRcdFx0dW5pdCA9IHVuaXQgfHwgc3RhcnRbIDMgXTtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0XHRcdHBhcnRzID0gcGFydHMgfHwgW107XG5cblx0XHRcdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRcdFx0c3RhcnQgPSArdGFyZ2V0IHx8IDE7XG5cblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdC8vIElmIHByZXZpb3VzIGl0ZXJhdGlvbiB6ZXJvZWQgb3V0LCBkb3VibGUgdW50aWwgd2UgZ2V0ICpzb21ldGhpbmcqLlxuXHRcdFx0XHRcdC8vIFVzZSBzdHJpbmcgZm9yIGRvdWJsaW5nIHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBzZWUgc2NhbGUgYXMgdW5jaGFuZ2VkIGJlbG93XG5cdFx0XHRcdFx0c2NhbGUgPSBzY2FsZSB8fCBcIi41XCI7XG5cblx0XHRcdFx0XHQvLyBBZGp1c3QgYW5kIGFwcGx5XG5cdFx0XHRcdFx0c3RhcnQgPSBzdGFydCAvIHNjYWxlO1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgcHJvcCwgc3RhcnQgKyB1bml0ICk7XG5cblx0XHRcdFx0Ly8gVXBkYXRlIHNjYWxlLCB0b2xlcmF0aW5nIHplcm8gb3IgTmFOIGZyb20gdHdlZW4uY3VyKCksXG5cdFx0XHRcdC8vIGJyZWFrIHRoZSBsb29wIGlmIHNjYWxlIGlzIHVuY2hhbmdlZCBvciBwZXJmZWN0LCBvciBpZiB3ZSd2ZSBqdXN0IGhhZCBlbm91Z2hcblx0XHRcdFx0fSB3aGlsZSAoIHNjYWxlICE9PSAoc2NhbGUgPSB0d2Vlbi5jdXIoKSAvIHRhcmdldCkgJiYgc2NhbGUgIT09IDEgJiYgLS1tYXhJdGVyYXRpb25zICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVwZGF0ZSB0d2VlbiBwcm9wZXJ0aWVzXG5cdFx0XHRpZiAoIHBhcnRzICkge1xuXHRcdFx0XHRzdGFydCA9IHR3ZWVuLnN0YXJ0ID0gK3N0YXJ0IHx8ICt0YXJnZXQgfHwgMDtcblx0XHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHRcdC8vIElmIGEgKz0vLT0gdG9rZW4gd2FzIHByb3ZpZGVkLCB3ZSdyZSBkb2luZyBhIHJlbGF0aXZlIGFuaW1hdGlvblxuXHRcdFx0XHR0d2Vlbi5lbmQgPSBwYXJ0c1sgMSBdID9cblx0XHRcdFx0XHRzdGFydCArICggcGFydHNbIDEgXSArIDEgKSAqIHBhcnRzWyAyIF0gOlxuXHRcdFx0XHRcdCtwYXJ0c1sgMiBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH07XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9KTtcblx0cmV0dXJuICggZnhOb3cgPSBqUXVlcnkubm93KCkgKTtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdHZhciB3aGljaCxcblx0XHRpID0gMCxcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cblx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNCA7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCB0d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCB0d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICh0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApKSApIHtcblxuXHRcdFx0Ly8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIHR3ZWVuLCBob29rcywgb2xkZmlyZSwgZGlzcGxheSwgY2hlY2tEaXNwbGF5LFxuXHRcdGFuaW0gPSB0aGlzLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbiggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YV9wcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIEhhbmRsZSBxdWV1ZTogZmFsc2UgcHJvbWlzZXNcblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xuXHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gSGVpZ2h0L3dpZHRoIG92ZXJmbG93IHBhc3Ncblx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCJoZWlnaHRcIiBpbiBwcm9wcyB8fCBcIndpZHRoXCIgaW4gcHJvcHMgKSApIHtcblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBub3RoaW5nIHNuZWFrcyBvdXRcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFOS0xMCBkbyBub3Rcblx0XHQvLyBjaGFuZ2UgdGhlIG92ZXJmbG93IGF0dHJpYnV0ZSB3aGVuIG92ZXJmbG93WCBhbmRcblx0XHQvLyBvdmVyZmxvd1kgYXJlIHNldCB0byB0aGUgc2FtZSB2YWx1ZVxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gU2V0IGRpc3BsYXkgcHJvcGVydHkgdG8gaW5saW5lLWJsb2NrIGZvciBoZWlnaHQvd2lkdGhcblx0XHQvLyBhbmltYXRpb25zIG9uIGlubGluZSBlbGVtZW50cyB0aGF0IGFyZSBoYXZpbmcgd2lkdGgvaGVpZ2h0IGFuaW1hdGVkXG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cblx0XHQvLyBUZXN0IGRlZmF1bHQgZGlzcGxheSBpZiBkaXNwbGF5IGlzIGN1cnJlbnRseSBcIm5vbmVcIlxuXHRcdGNoZWNrRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID9cblx0XHRcdGRhdGFfcHJpdi5nZXQoIGVsZW0sIFwib2xkZGlzcGxheVwiICkgfHwgZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKSA6IGRpc3BsYXk7XG5cblx0XHRpZiAoIGNoZWNrRGlzcGxheSA9PT0gXCJpbmxpbmVcIiAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGFuaW0uYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBzaG93L2hpZGUgcGFzc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLmV4ZWMoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGRhdGFTaG93IGxlZnQgb3ZlciBmcm9tIGEgc3RvcHBlZCBoaWRlIG9yIHNob3cgYW5kIHdlIGFyZSBnb2luZyB0byBwcm9jZWVkIHdpdGggc2hvdywgd2Ugc2hvdWxkIHByZXRlbmQgdG8gYmUgaGlkZGVuXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXG5cdFx0Ly8gQW55IG5vbi1meCB2YWx1ZSBzdG9wcyB1cyBmcm9tIHJlc3RvcmluZyB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXNwbGF5ID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhU2hvdyA9IGRhdGFfcHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHt9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3RvcmUgc3RhdGUgaWYgaXRzIHRvZ2dsZSAtIGVuYWJsZXMgLnN0b3AoKS50b2dnbGUoKSB0byBcInJldmVyc2VcIlxuXHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHR9XG5cdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRqUXVlcnkoIGVsZW0gKS5zaG93KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFuaW0uZG9uZShmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5KCBlbGVtICkuaGlkZSgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGFuaW0uZG9uZShmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwcm9wO1xuXG5cdFx0XHRkYXRhX3ByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0dHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblxuXHRcdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSB0d2Vlbi5zdGFydDtcblx0XHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdFx0dHdlZW4uZW5kID0gdHdlZW4uc3RhcnQ7XG5cdFx0XHRcdFx0dHdlZW4uc3RhcnQgPSBwcm9wID09PSBcIndpZHRoXCIgfHwgcHJvcCA9PT0gXCJoZWlnaHRcIiA/IDEgOiAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdC8vIElmIHRoaXMgaXMgYSBub29wIGxpa2UgLmhpZGUoKS5oaWRlKCksIHJlc3RvcmUgYW4gb3ZlcndyaXR0ZW4gZGlzcGxheSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCAoZGlzcGxheSA9PT0gXCJub25lXCIgPyBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApIDogZGlzcGxheSkgPT09IFwiaW5saW5lXCIgKSB7XG5cdFx0c3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBpbmRleCApO1xuXHRcdGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGFuaW1hdGlvblByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9KSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjNcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSk7XG5cblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSh7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7IHNwZWNpYWxFYXNpbmc6IHt9IH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9KSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IGFuaW1hdGlvblByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9KVxuXHQpO1xuXG5cdC8vIGF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdHJldHVybiBhbmltYXRpb24ucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5zcGxpdChcIiBcIik7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdHR3ZWVuZXJzWyBwcm9wIF0gPSB0d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0dHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRhbmltYXRpb25QcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFuaW1hdGlvblByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5vZmYgPyAwIDogdHlwZW9mIG9wdC5kdXJhdGlvbiA9PT0gXCJudW1iZXJcIiA/IG9wdC5kdXJhdGlvbiA6XG5cdFx0b3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgPyBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXSA6IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbiApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSh7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFfcHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGRhdGFfcHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmICh0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlKSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YV9wcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9KTtcblx0fVxufSk7XG5cbmpRdWVyeS5lYWNoKFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKHtcblx0c2xpZGVEb3duOiBnZW5GeChcInNob3dcIiksXG5cdHNsaWRlVXA6IGdlbkZ4KFwiaGlkZVwiKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KFwidG9nZ2xlXCIpLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0pO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IGpRdWVyeS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblx0XHQvLyBDaGVja3MgdGhlIHRpbWVyIGhhcyBub3QgYWxyZWFkeSBiZWVuIHJlbW92ZWRcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRpZiAoIHRpbWVyKCkgKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnRpbWVycy5wb3AoKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5cbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoICF0aW1lcklkICkge1xuXHRcdHRpbWVySWQgPSBzZXRJbnRlcnZhbCggalF1ZXJ5LmZ4LnRpY2ssIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRjbGVhckludGVydmFsKCB0aW1lcklkICk7XG5cdHRpbWVySWQgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSk7XG59O1xuXG5cbihmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBpT1M8PTUuMSwgQW5kcm9pZDw9NC4yK1xuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUU8PTExK1xuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8PTIuM1xuXHQvLyBPcHRpb25zIGluc2lkZSBkaXNhYmxlZCBzZWxlY3RzIGFyZSBpbmNvcnJlY3RseSBtYXJrZWQgYXMgZGlzYWJsZWRcblx0c2VsZWN0LmRpc2FibGVkID0gdHJ1ZTtcblx0c3VwcG9ydC5vcHREaXNhYmxlZCA9ICFvcHQuZGlzYWJsZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUU8PTExK1xuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59KSgpO1xuXG5cbnZhciBub2RlSG9vaywgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9KTtcblx0fVxufSk7XG5cbmpRdWVyeS5leHRlbmQoe1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBkb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBzdHJ1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGF0dHJpYnV0ZXMgYXJlIGxvd2VyY2FzZVxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiBub2RlSG9vayApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdFx0cmV0dXJuIHJldCA9PSBudWxsID9cblx0XHRcdFx0dW5kZWZpbmVkIDpcblx0XHRcdFx0cmV0O1xuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsIHByb3BOYW1lLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAobmFtZSA9IGF0dHJOYW1lc1tpKytdKSApIHtcblx0XHRcdFx0cHJvcE5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cblx0XHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGdldCBzcGVjaWFsIHRyZWF0bWVudCAoIzEwODcwKVxuXHRcdFx0XHRpZiAoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRcdC8vIFNldCBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHRvIGZhbHNlXG5cdFx0XHRcdFx0ZWxlbVsgcHJvcE5hbWUgXSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0alF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGU7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBuYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBuYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBuYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59KTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0pO1xuXHR9XG59KTtcblxualF1ZXJ5LmV4dGVuZCh7XG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fSxcblxuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsIG5vdHhtbCxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG5vdHhtbCA9IG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKTtcblxuXHRcdGlmICggbm90eG1sICkge1xuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkpICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyZXQgOlxuXHRcdFx0XHQoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApKSAhPT0gbnVsbCA/XG5cdFx0XHRcdHJldCA6XG5cdFx0XHRcdGVsZW1bIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmhhc0F0dHJpYnV0ZSggXCJ0YWJpbmRleFwiICkgfHwgcmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHwgZWxlbS5ocmVmID9cblx0XHRcdFx0XHRlbGVtLnRhYkluZGV4IDpcblx0XHRcdFx0XHQtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59KTtcblxuXG5cblxudmFyIHJjbGFzcyA9IC9bXFx0XFxyXFxuXFxmXS9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdHByb2NlZWQgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCB0aGlzLmNsYXNzTmFtZSApICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIHByb2NlZWQgKSB7XG5cdFx0XHQvLyBUaGUgZGlzanVuY3Rpb24gaGVyZSBpcyBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIHJlbW92ZUNsYXNzKVxuXHRcdFx0Y2xhc3NlcyA9ICggdmFsdWUgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF07XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBlbGVtLmNsYXNzTmFtZSA/XG5cdFx0XHRcdFx0KCBcIiBcIiArIGVsZW0uY2xhc3NOYW1lICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiICkgOlxuXHRcdFx0XHRcdFwiIFwiXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoY2xhenogPSBjbGFzc2VzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhenogKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBvbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBqUXVlcnkudHJpbSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLmNsYXNzTmFtZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uY2xhc3NOYW1lID0gZmluYWxWYWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0cHJvY2VlZCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgdGhpcy5jbGFzc05hbWUgKSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGlmICggcHJvY2VlZCApIHtcblx0XHRcdGNsYXNzZXMgPSAoIHZhbHVlIHx8IFwiXCIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdO1xuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggZWxlbS5jbGFzc05hbWUgP1xuXHRcdFx0XHRcdCggXCIgXCIgKyBlbGVtLmNsYXNzTmFtZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApIDpcblx0XHRcdFx0XHRcIlwiXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoY2xhenogPSBjbGFzc2VzW2orK10pICkge1xuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPj0gMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSB2YWx1ZSA/IGpRdWVyeS50cmltKCBjdXIgKSA6IFwiXCI7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLmNsYXNzTmFtZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uY2xhc3NOYW1lID0gZmluYWxWYWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKCB2YWx1ZS5jYWxsKHRoaXMsIGksIHRoaXMuY2xhc3NOYW1lLCBzdGF0ZVZhbCksIHN0YXRlVmFsICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHR2YXIgY2xhc3NOYW1lLFxuXHRcdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0XHRjbGFzc05hbWVzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHRcdHdoaWxlICggKGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdKSApIHtcblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gc3RydW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuY2xhc3NOYW1lICkge1xuXHRcdFx0XHRcdC8vIHN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhX3ByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgdGhpcy5jbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0dGhpcy5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgPyBcIlwiIDogZGF0YV9wcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGlmICggdGhpc1tpXS5ub2RlVHlwZSA9PT0gMSAmJiAoXCIgXCIgKyB0aGlzW2ldLmNsYXNzTmFtZSArIFwiIFwiKS5yZXBsYWNlKHJjbGFzcywgXCIgXCIpLmluZGV4T2YoIGNsYXNzTmFtZSApID49IDAgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIGlzRnVuY3Rpb24sXG5cdFx0XHRlbGVtID0gdGhpc1swXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRcdHJldC5yZXBsYWNlKHJyZXR1cm4sIFwiXCIpIDpcblx0XHRcdFx0XHQvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblx0XHRcdFx0XHRyZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoXCJzZXRcIiBpbiBob29rcykgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5qUXVlcnkuZXh0ZW5kKHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFMTAtMTErXG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuXHRcdFx0XHRcdGpRdWVyeS50cmltKCBqUXVlcnkudGV4dCggZWxlbSApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIiB8fCBpbmRleCA8IDAsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoLFxuXHRcdFx0XHRcdGkgPSBpbmRleCA8IDAgP1xuXHRcdFx0XHRcdFx0bWF4IDpcblx0XHRcdFx0XHRcdG9uZSA/IGluZGV4IDogMDtcblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIElFNi05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCggc3VwcG9ydC5vcHREaXNhYmxlZCA/ICFvcHRpb24uZGlzYWJsZWQgOiBvcHRpb24uZ2V0QXR0cmlidXRlKCBcImRpc2FibGVkXCIgKSA9PT0gbnVsbCApICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8ICFqUXVlcnkubm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cdFx0XHRcdFx0aWYgKCAob3B0aW9uLnNlbGVjdGVkID0galF1ZXJ5LmluQXJyYXkoIG9wdGlvbi52YWx1ZSwgdmFsdWVzICkgPj0gMCkgKSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5qUXVlcnkuZWFjaChbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoZWxlbSkudmFsKCksIHZhbHVlICkgPj0gMCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0pO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxualF1ZXJ5LmVhY2goIChcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCBsb2FkIHJlc2l6ZSBzY3JvbGwgdW5sb2FkIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBlcnJvciBjb250ZXh0bWVudVwiKS5zcGxpdChcIiBcIiksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHR9O1xufSk7XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH0sXG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyB0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDogdGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH1cbn0pO1xuXG5cbnZhciBub25jZSA9IGpRdWVyeS5ub3coKTtcblxudmFyIHJxdWVyeSA9ICgvXFw/Lyk7XG5cblxuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuLy8gV29ya2Fyb3VuZCBmYWlsdXJlIHRvIHN0cmluZy1jYXN0IG51bGwgaW5wdXRcbmpRdWVyeS5wYXJzZUpTT04gPSBmdW5jdGlvbiggZGF0YSApIHtcblx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKyBcIlwiICk7XG59O1xuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sLCB0bXA7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRTlcblx0dHJ5IHtcblx0XHR0bXAgPSBuZXcgRE9NUGFyc2VyKCk7XG5cdFx0eG1sID0gdG1wLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHRyaGFzaCA9IC8jLiokLyxcblx0cnRzID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXHRydXJsID0gL14oW1xcdy4rLV0rOikoPzpcXC9cXC8oPzpbXlxcLz8jXSpAfCkoW15cXC8/IzpdKikoPzo6KFxcZCspfCl8KS8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHQvLyBEb2N1bWVudCBsb2NhdGlvblxuXHRhamF4TG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb24uaHJlZixcblxuXHQvLyBTZWdtZW50IGxvY2F0aW9uIGludG8gcGFydHNcblx0YWpheExvY1BhcnRzID0gcnVybC5leGVjKCBhamF4TG9jYXRpb24udG9Mb3dlckNhc2UoKSApIHx8IFtdO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZnVuYyApICkge1xuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoZGF0YVR5cGUgPSBkYXRhVHlwZXNbaSsrXSkgKSB7XG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGVbMF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdChzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10pLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiYgIXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyAjOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoZGVlcCA9IHt9KSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1UeXBlXCIpO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWzBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgc1sgXCJ0aHJvd3NcIiBdICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHsgc3RhdGU6IFwicGFyc2VyZXJyb3JcIiwgZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50IH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBhamF4TG9jYXRpb24sXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBhamF4TG9jUGFydHNbIDEgXSApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL3htbC8sXG5cdFx0XHRodG1sOiAvaHRtbC8sXG5cdFx0XHRqc29uOiAvanNvbi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogalF1ZXJ5LnBhcnNlSlNPTixcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXHRcdFx0Ly8gQ3Jvc3MtZG9tYWluIGRldGVjdGlvbiB2YXJzXG5cdFx0XHRwYXJ0cyxcblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiYgKCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdGpRdWVyeS5ldmVudCxcblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXHRcdFx0Ly8gVGhlIGpxWEhSIHN0YXRlXG5cdFx0XHRzdGF0ZSA9IDAsXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgXSA9IG1hdGNoWyAyIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlID09PSAyID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0dmFyIGxuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdGlmICggIXN0YXRlICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIGxuYW1lIF0gPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggIXN0YXRlICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHN0YXRlIDwgMiApIHtcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFjayBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApLmNvbXBsZXRlID0gY29tcGxldGVEZWZlcnJlZC5hZGQ7XG5cdFx0anFYSFIuc3VjY2VzcyA9IGpxWEhSLmRvbmU7XG5cdFx0anFYSFIuZXJyb3IgPSBqcVhIUi5mYWlsO1xuXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggY2hhcmFjdGVyICgjNzUzMTogYW5kIHN0cmluZyBwcm9tb3Rpb24pXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG5cdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgYWpheExvY2F0aW9uICkgKyBcIlwiICkucmVwbGFjZSggcmhhc2gsIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgYWpheExvY1BhcnRzWyAxIF0gKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSBqUXVlcnkudHJpbSggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHdlIGhhdmUgYSBwcm90b2NvbDpob3N0OnBvcnQgbWlzbWF0Y2hcblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHBhcnRzID0gcnVybC5leGVjKCBzLnVybC50b0xvd2VyQ2FzZSgpICk7XG5cdFx0XHRzLmNyb3NzRG9tYWluID0gISEoIHBhcnRzICYmXG5cdFx0XHRcdCggcGFydHNbIDEgXSAhPT0gYWpheExvY1BhcnRzWyAxIF0gfHwgcGFydHNbIDIgXSAhPT0gYWpheExvY1BhcnRzWyAyIF0gfHxcblx0XHRcdFx0XHQoIHBhcnRzWyAzIF0gfHwgKCBwYXJ0c1sgMSBdID09PSBcImh0dHA6XCIgPyBcIjgwXCIgOiBcIjQ0M1wiICkgKSAhPT1cblx0XHRcdFx0XHRcdCggYWpheExvY1BhcnRzWyAzIF0gfHwgKCBhamF4TG9jUGFydHNbIDEgXSA9PT0gXCJodHRwOlwiID8gXCI4MFwiIDogXCI0NDNcIiApICkgKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcihcImFqYXhTdGFydFwiKTtcblx0XHR9XG5cblx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG5cdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2Vcblx0XHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cblx0XHRjYWNoZVVSTCA9IHMudXJsO1xuXG5cdFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcblx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XG5cblx0XHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlLCBhcHBlbmQgZGF0YSB0byB1cmxcblx0XHRcdGlmICggcy5kYXRhICkge1xuXHRcdFx0XHRjYWNoZVVSTCA9ICggcy51cmwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YSApO1xuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBhbnRpLWNhY2hlIGluIHVybCBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHMudXJsID0gcnRzLnRlc3QoIGNhY2hlVVJMICkgP1xuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYWxyZWFkeSBhICdfJyBwYXJhbWV0ZXIsIHNldCBpdHMgdmFsdWVcblx0XHRcdFx0XHRjYWNoZVVSTC5yZXBsYWNlKCBydHMsIFwiJDFfPVwiICsgbm9uY2UrKyApIDpcblxuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSBhZGQgb25lIHRvIHRoZSBlbmRcblx0XHRcdFx0XHRjYWNoZVVSTCArICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyBub25jZSsrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWzBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWzBdIF0gKyAoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJiAoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IHN0YXRlID09PSAyICkgKSB7XG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Zm9yICggaSBpbiB7IHN1Y2Nlc3M6IDEsIGVycm9yOiAxLCBjb21wbGV0ZTogMSB9ICkge1xuXHRcdFx0anFYSFJbIGkgXSggc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KFwidGltZW91dFwiKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHN0YXRlID0gMTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0Ly8gUHJvcGFnYXRlIGV4Y2VwdGlvbiBhcyBlcnJvciBpZiBub3QgZG9uZVxuXHRcdFx0XHRpZiAoIHN0YXRlIDwgMiApIHtcblx0XHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0XHQvLyBTaW1wbHkgcmV0aHJvdyBvdGhlcndpc2Vcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gQ2FsbGVkIG9uY2Vcblx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdGUgaXMgXCJkb25lXCIgbm93XG5cdFx0XHRzdGF0ZSA9IDI7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJMYXN0LU1vZGlmaWVkXCIpO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJldGFnXCIpO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcihcImFqYXhTdG9wXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59KTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXHRcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkuYWpheCh7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSk7XG5cdH07XG59KTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoe1xuXHRcdHVybDogdXJsLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cdFx0XCJ0aHJvd3NcIjogdHJ1ZVxuXHR9KTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCh7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbC5jYWxsKHRoaXMsIGkpICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9KS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKHRoaXMsIGkpICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGlzRnVuY3Rpb24gPyBodG1sLmNhbGwodGhpcywgaSkgOiBodG1sICk7XG5cdFx0fSk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImJvZHlcIiApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0XHR9XG5cdFx0fSkuZW5kKCk7XG5cdH1cbn0pO1xuXG5cbmpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdC8vIFN1cHBvcnQ6IE9wZXJhIDw9IDEyLjEyXG5cdC8vIE9wZXJhIHJlcG9ydHMgb2Zmc2V0V2lkdGhzIGFuZCBvZmZzZXRIZWlnaHRzIGxlc3MgdGhhbiB6ZXJvIG9uIHNvbWUgZWxlbWVudHNcblx0cmV0dXJuIGVsZW0ub2Zmc2V0V2lkdGggPD0gMCAmJiBlbGVtLm9mZnNldEhlaWdodCA8PSAwO1xufTtcbmpRdWVyeS5leHByLmZpbHRlcnMudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuKCBlbGVtICk7XG59O1xuXG5cblxuXG52YXIgcjIwID0gLyUyMC9nLFxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIGpRdWVyeS5pc0FycmF5KCBvYmogKSApIHtcblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgPyBpIDogXCJcIiApICsgXCJdXCIsIHYsIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgalF1ZXJ5LnR5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHJldHVybiBpdHMgdmFsdWVcblx0XHRcdHZhbHVlID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgPyB2YWx1ZSgpIDogKCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSApO1xuXHRcdH07XG5cblx0Ly8gU2V0IHRyYWRpdGlvbmFsIHRvIHRydWUgZm9yIGpRdWVyeSA8PSAxLjMuMiBiZWhhdmlvci5cblx0aWYgKCB0cmFkaXRpb25hbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHRyYWRpdGlvbmFsID0galF1ZXJ5LmFqYXhTZXR0aW5ncyAmJiBqUXVlcnkuYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsO1xuXHR9XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0pO1xuXG5cdH0gZWxzZSB7XG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoe1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSlcblx0XHQuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9KVxuXHRcdC5tYXAoZnVuY3Rpb24oIGksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdHJldHVybiB2YWwgPT0gbnVsbCA/XG5cdFx0XHRcdG51bGwgOlxuXHRcdFx0XHRqUXVlcnkuaXNBcnJheSggdmFsICkgP1xuXHRcdFx0XHRcdGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9KS5nZXQoKTtcblx0fVxufSk7XG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2goIGUgKSB7fVxufTtcblxudmFyIHhocklkID0gMCxcblx0eGhyQ2FsbGJhY2tzID0ge30sXG5cdHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cdFx0Ly8gZmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHQwOiAyMDAsXG5cdFx0Ly8gU3VwcG9ydDogSUU5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbi8vIFN1cHBvcnQ6IElFOVxuLy8gT3BlbiByZXF1ZXN0cyBtdXN0IGJlIG1hbnVhbGx5IGFib3J0ZWQgb24gdW5sb2FkICgjNTI4MClcbi8vIFNlZSBodHRwczovL3N1cHBvcnQubWljcm9zb2Z0LmNvbS9rYi8yODU2NzQ2IGZvciBtb3JlIGluZm9cbmlmICggd2luZG93LmF0dGFjaEV2ZW50ICkge1xuXHR3aW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICggdmFyIGtleSBpbiB4aHJDYWxsYmFja3MgKSB7XG5cdFx0XHR4aHJDYWxsYmFja3NbIGtleSBdKCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKSxcblx0XHRcdFx0XHRpZCA9ICsreGhySWQ7XG5cblx0XHRcdFx0eGhyLm9wZW4oIG9wdGlvbnMudHlwZSwgb3B0aW9ucy51cmwsIG9wdGlvbnMuYXN5bmMsIG9wdGlvbnMudXNlcm5hbWUsIG9wdGlvbnMucGFzc3dvcmQgKTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIHhockNhbGxiYWNrc1sgaWQgXTtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSB4aHIub25sb2FkID0geGhyLm9uZXJyb3IgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBmaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEFjY2Vzc2luZyBiaW5hcnktZGF0YSByZXNwb25zZVRleHQgdGhyb3dzIGFuIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gKCMxMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ID09PSBcInN0cmluZ1wiID8ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ZXh0OiB4aHIucmVzcG9uc2VUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHR9IDogdW5kZWZpbmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0eGhyLm9uZXJyb3IgPSBjYWxsYmFjayhcImVycm9yXCIpO1xuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSB4aHJDYWxsYmFja3NbIGlkIF0gPSBjYWxsYmFjayhcImFib3J0XCIpO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0Ly8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSk7XG5cblxuXG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvKD86amF2YXxlY21hKXNjcmlwdC9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0pO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KFwiPHNjcmlwdD5cIikucHJvcCh7XG5cdFx0XHRcdFx0YXN5bmM6IHRydWUsXG5cdFx0XHRcdFx0Y2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LFxuXHRcdFx0XHRcdHNyYzogcy51cmxcblx0XHRcdFx0fSkub24oXG5cdFx0XHRcdFx0XCJsb2FkIGVycm9yXCIsXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0pO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoe1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZSsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0pO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmICEoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIikgJiYgcmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbXCJzY3JpcHQganNvblwiXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIGZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBSZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXHRcdFx0XHQvLyBtYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIHNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSk7XG5cblxuXG5cbi8vIGRhdGE6IHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0dmFyIHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApLFxuXHRcdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsxXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBqUXVlcnkuYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLy8gS2VlcCBhIGNvcHkgb2YgdGhlIG9sZCBsb2FkIG1ldGhvZFxudmFyIF9sb2FkID0galF1ZXJ5LmZuLmxvYWQ7XG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdGlmICggdHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIiAmJiBfbG9hZCApIHtcblx0XHRyZXR1cm4gX2xvYWQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHR9XG5cblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZihcIiBcIik7XG5cblx0aWYgKCBvZmYgPj0gMCApIHtcblx0XHRzZWxlY3RvciA9IGpRdWVyeS50cmltKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoe1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIGlmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWRcblx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9KS5kb25lKGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KFwiPGRpdj5cIikuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0fSkuY29tcGxldGUoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBjYWxsYmFjaywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG4vLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xualF1ZXJ5LmVhY2goIFsgXCJhamF4U3RhcnRcIiwgXCJhamF4U3RvcFwiLCBcImFqYXhDb21wbGV0ZVwiLCBcImFqYXhFcnJvclwiLCBcImFqYXhTdWNjZXNzXCIsIFwiYWpheFNlbmRcIiBdLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59KTtcblxuXG5cblxualF1ZXJ5LmV4cHIuZmlsdGVycy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9KS5sZW5ndGg7XG59O1xuXG5cblxuXG52YXIgZG9jRWxlbSA9IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbi8qKlxuICogR2V0cyBhIHdpbmRvdyBmcm9tIGFuIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmlzV2luZG93KCBlbGVtICkgPyBlbGVtIDogZWxlbS5ub2RlVHlwZSA9PT0gOSAmJiBlbGVtLmRlZmF1bHRWaWV3O1xufVxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoXCJhdXRvXCIpID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgY3VyT2Zmc2V0ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKHtcblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIgZG9jRWxlbSwgd2luLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGJveCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH0sXG5cdFx0XHRkb2MgPSBlbGVtICYmIGVsZW0ub3duZXJEb2N1bWVudDtcblxuXHRcdGlmICggIWRvYyApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdC8vIE1ha2Ugc3VyZSBpdCdzIG5vdCBhIGRpc2Nvbm5lY3RlZCBET00gbm9kZVxuXHRcdGlmICggIWpRdWVyeS5jb250YWlucyggZG9jRWxlbSwgZWxlbSApICkge1xuXHRcdFx0cmV0dXJuIGJveDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBCbGFja0JlcnJ5IDUsIGlPUyAzIChvcmlnaW5hbCBpUGhvbmUpXG5cdFx0Ly8gSWYgd2UgZG9uJ3QgaGF2ZSBnQkNSLCBqdXN0IHVzZSAwLDAgcmF0aGVyIHRoYW4gZXJyb3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPT0gc3RydW5kZWZpbmVkICkge1xuXHRcdFx0Ym94ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR9XG5cdFx0d2luID0gZ2V0V2luZG93KCBkb2MgKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBib3gudG9wICsgd2luLnBhZ2VZT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRUb3AsXG5cdFx0XHRsZWZ0OiBib3gubGVmdCArIHdpbi5wYWdlWE9mZnNldCAtIGRvY0VsZW0uY2xpZW50TGVmdFxuXHRcdH07XG5cdH0sXG5cblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIEZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB3aW5kb3cgKHBhcmVudE9mZnNldCA9IHt0b3A6MCwgbGVmdDogMH0sIGJlY2F1c2UgaXQgaXMgaXRzIG9ubHkgb2Zmc2V0IHBhcmVudFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblx0XHRcdC8vIEFzc3VtZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgdGhlcmUgd2hlbiBjb21wdXRlZCBwb3NpdGlvbiBpcyBmaXhlZFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxuXHRcdFx0b2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQoKTtcblxuXHRcdFx0Ly8gR2V0IGNvcnJlY3Qgb2Zmc2V0c1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggb2Zmc2V0UGFyZW50WyAwIF0sIFwiaHRtbFwiICkgKSB7XG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IG9mZnNldFBhcmVudC5vZmZzZXQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9mZnNldFBhcmVudCBib3JkZXJzXG5cdFx0XHRwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50IHx8IGRvY0VsZW07XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmICggIWpRdWVyeS5ub2RlTmFtZSggb2Zmc2V0UGFyZW50LCBcImh0bWxcIiApICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2NFbGVtO1xuXHRcdH0pO1xuXHR9XG59KTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXHRcdFx0dmFyIHdpbiA9IGdldFdpbmRvdyggZWxlbSApO1xuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbmRvdy5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCwgbnVsbCApO1xuXHR9O1xufSk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaTw3KywgQ2hyb21lPDM3K1xuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MjgwXG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSwgZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXHRcdFx0XHRcdC8vIEFzIG9mIDUvOC8yMDEyIHRoaXMgd2lsbCB5aWVsZCBpbmNvcnJlY3QgcmVzdWx0cyBmb3IgTW9iaWxlIFNhZmFyaSwgYnV0IHRoZXJlXG5cdFx0XHRcdFx0Ly8gaXNuJ3QgYSB3aG9sZSBsb3Qgd2UgY2FuIGRvLiBTZWUgcHVsbCByZXF1ZXN0IGF0IHRoaXMgVVJMIGZvciBkaXNjdXNzaW9uOlxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNzY0XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSwgbnVsbCApO1xuXHRcdH07XG5cdH0pO1xufSk7XG5cblxuLy8gVGhlIG51bWJlciBvZiBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXRcbmpRdWVyeS5mbi5zaXplID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmxlbmd0aDtcbn07XG5cbmpRdWVyeS5mbi5hbmRTZWxmID0galF1ZXJ5LmZuLmFkZEJhY2s7XG5cblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSk7XG59XG5cblxuXG5cbnZhclxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG5pZiAoIHR5cGVvZiBub0dsb2JhbCA9PT0gc3RydW5kZWZpbmVkICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxuXG5cbnJldHVybiBqUXVlcnk7XG5cbn0pKTtcbiIsIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuOC4zXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhclxuICAgIHB1c2ggICAgICAgICAgICAgPSBBcnJheVByb3RvLnB1c2gsXG4gICAgc2xpY2UgICAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhclxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQsXG4gICAgbmF0aXZlQ3JlYXRlICAgICAgID0gT2JqZWN0LmNyZWF0ZTtcblxuICAvLyBOYWtlZCBmdW5jdGlvbiByZWZlcmVuY2UgZm9yIHN1cnJvZ2F0ZS1wcm90b3R5cGUtc3dhcHBpbmcuXG4gIHZhciBDdG9yID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LlxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfKSkgcmV0dXJuIG5ldyBfKG9iaik7XG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdC5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS44LjMnO1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcbiAgLy8gZnVuY3Rpb25zLlxuICB2YXIgb3B0aW1pemVDYiA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgb3RoZXIpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEEgbW9zdGx5LWludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGNhbGxiYWNrcyB0aGF0IGNhbiBiZSBhcHBsaWVkXG4gIC8vIHRvIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZGVzaXJlZCByZXN1bHQg4oCUIGVpdGhlclxuICAvLyBpZGVudGl0eSwgYW4gYXJiaXRyYXJ5IGNhbGxiYWNrLCBhIHByb3BlcnR5IG1hdGNoZXIsIG9yIGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gIHZhciBjYiA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gXy5pZGVudGl0eTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIG9wdGltaXplQ2IodmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KTtcbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHJldHVybiBfLm1hdGNoZXIodmFsdWUpO1xuICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcbiAgfTtcbiAgXy5pdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNiKHZhbHVlLCBjb250ZXh0LCBJbmZpbml0eSk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFzc2lnbmVyIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUFzc2lnbmVyID0gZnVuY3Rpb24oa2V5c0Z1bmMsIHVuZGVmaW5lZE9ubHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPCAyIHx8IG9iaiA9PSBudWxsKSByZXR1cm4gb2JqO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XSxcbiAgICAgICAgICAgIGtleXMgPSBrZXlzRnVuYyhzb3VyY2UpLFxuICAgICAgICAgICAgbCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmICghdW5kZWZpbmVkT25seSB8fCBvYmpba2V5XSA9PT0gdm9pZCAwKSBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gYW5vdGhlci5cbiAgdmFyIGJhc2VDcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICBpZiAoIV8uaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIHt9O1xuICAgIGlmIChuYXRpdmVDcmVhdGUpIHJldHVybiBuYXRpdmVDcmVhdGUocHJvdG90eXBlKTtcbiAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEN0b3I7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIHByb3BlcnR5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBIZWxwZXIgZm9yIGNvbGxlY3Rpb24gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhIGNvbGxlY3Rpb25cbiAgLy8gc2hvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIGFycmF5IG9yIGFzIGFuIG9iamVjdFxuICAvLyBSZWxhdGVkOiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aFxuICAvLyBBdm9pZHMgYSB2ZXJ5IG5hc3R5IGlPUyA4IEpJVCBidWcgb24gQVJNLTY0LiAjMjA5NFxuICB2YXIgTUFYX0FSUkFZX0lOREVYID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcbiAgdmFyIGdldExlbmd0aCA9IHByb3BlcnR5KCdsZW5ndGgnKTtcbiAgdmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfTtcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG4gIF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBpLCBsZW5ndGg7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgcmVkdWNpbmcgZnVuY3Rpb24gaXRlcmF0aW5nIGxlZnQgb3IgcmlnaHQuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZShkaXIpIHtcbiAgICAvLyBPcHRpbWl6ZWQgaXRlcmF0b3IgZnVuY3Rpb24gYXMgdXNpbmcgYXJndW1lbnRzLmxlbmd0aFxuICAgIC8vIGluIHRoZSBtYWluIGZ1bmN0aW9uIHdpbGwgZGVvcHRpbWl6ZSB0aGUsIHNlZSAjMTk5MS5cbiAgICBmdW5jdGlvbiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCA0KTtcbiAgICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIGluaXRpYWwgdmFsdWUgaWYgbm9uZSBpcyBwcm92aWRlZC5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4XTtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpO1xuICAgIH07XG4gIH1cblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gY3JlYXRlUmVkdWNlKDEpO1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGNyZWF0ZVJlZHVjZSgtMSk7XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAga2V5ID0gXy5maW5kSW5kZXgob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBfLmZpbmRLZXkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gaXRlbSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlc2AgYW5kIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZXMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIGl0ZW0sIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgZ3VhcmQpIGZyb21JbmRleCA9IDA7XG4gICAgcmV0dXJuIF8uaW5kZXhPZihvYmosIGl0ZW0sIGZyb21JbmRleCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSBmdW5jdGlvbihvYmosIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IGZ1bmMgOiBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhIGNvbGxlY3Rpb24sIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgc2V0ID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IHNldC5sZW5ndGg7XG4gICAgdmFyIHNodWZmbGVkID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIHJhbmQ7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByYW5kID0gXy5yYW5kb20oMCwgaW5kZXgpO1xuICAgICAgaWYgKHJhbmQgIT09IGluZGV4KSBzaHVmZmxlZFtpbmRleF0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gc2V0W2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdGVlLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuICB2YXIgZ3JvdXAgPSBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIHZhbHVlLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldKys7IGVsc2UgcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gIC8vIHByZWRpY2F0ZSwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgXy5wYXJ0aXRpb24gPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIHBhc3MgPSBbXSwgZmFpbCA9IFtdO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgICAgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmopID8gcGFzcyA6IGZhaWwpLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBbcGFzcywgZmFpbF07XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgICByZXR1cm4gXy5pbml0aWFsKGFycmF5LCBhcnJheS5sZW5ndGggLSBuKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gXy5yZXN0KGFycmF5LCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSBuKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBzdHJpY3QsIHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgb3V0cHV0ID0gW10sIGlkeCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGlucHV0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiYgKF8uaXNBcnJheSh2YWx1ZSkgfHwgXy5pc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIC8vZmxhdHRlbiBjdXJyZW50IGxldmVsIG9mIGFycmF5IG9yIGFyZ3VtZW50cyBvYmplY3RcbiAgICAgICAgaWYgKCFzaGFsbG93KSB2YWx1ZSA9IGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIHN0cmljdCk7XG4gICAgICAgIHZhciBqID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBvdXRwdXQubGVuZ3RoICs9IGxlbjtcbiAgICAgICAgd2hpbGUgKGogPCBsZW4pIHtcbiAgICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWVbaisrXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc3RyaWN0KSB7XG4gICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIGZhbHNlKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFfLmlzQm9vbGVhbihpc1NvcnRlZCkpIHtcbiAgICAgIGNvbnRleHQgPSBpdGVyYXRlZTtcbiAgICAgIGl0ZXJhdGVlID0gaXNTb3J0ZWQ7XG4gICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXRlcmF0ZWUgIT0gbnVsbCkgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV0sXG4gICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpLCBhcnJheSkgOiB2YWx1ZTtcbiAgICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgICBpZiAoIWkgfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIV8uY29udGFpbnMocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuaXEoZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgICBpZiAoXy5jb250YWlucyhyZXN1bHQsIGl0ZW0pKSBjb250aW51ZTtcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhhcmd1bWVudHNbal0sIGl0ZW0pKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChqID09PSBhcmdzTGVuZ3RoKSByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgMSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG4gIF8uemlwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW56aXAoYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBDb21wbGVtZW50IG9mIF8uemlwLiBVbnppcCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyBhbmQgZ3JvdXBzXG4gIC8vIGVhY2ggYXJyYXkncyBlbGVtZW50cyBvbiBzaGFyZWQgaW5kaWNlc1xuICBfLnVuemlwID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgJiYgXy5tYXgoYXJyYXksIGdldExlbmd0aCkubGVuZ3RoIHx8IDA7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gXy5wbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChsaXN0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgZmluZEluZGV4IGFuZCBmaW5kTGFzdEluZGV4IGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcihkaXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgdmFyIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvbiBhbiBhcnJheS1saWtlIHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3RcbiAgXy5maW5kSW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigxKTtcbiAgXy5maW5kTGFzdEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoLTEpO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGluZGV4T2YgYW5kIGxhc3RJbmRleE9mIGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVJbmRleEZpbmRlcihkaXIsIHByZWRpY2F0ZUZpbmQsIHNvcnRlZEluZGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpZHgpIHtcbiAgICAgIHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIGlmICh0eXBlb2YgaWR4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICBpID0gaWR4ID49IDAgPyBpZHggOiBNYXRoLm1heChpZHggKyBsZW5ndGgsIGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVuZ3RoID0gaWR4ID49IDAgPyBNYXRoLm1pbihpZHggKyAxLCBsZW5ndGgpIDogaWR4ICsgbGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzb3J0ZWRJbmRleCAmJiBpZHggJiYgbGVuZ3RoKSB7XG4gICAgICAgIGlkeCA9IHNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2lkeF0gPT09IGl0ZW0gPyBpZHggOiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG4gICAgICAgIGlkeCA9IHByZWRpY2F0ZUZpbmQoc2xpY2UuY2FsbChhcnJheSwgaSwgbGVuZ3RoKSwgXy5pc05hTik7XG4gICAgICAgIHJldHVybiBpZHggPj0gMCA/IGlkeCArIGkgOiAtMTtcbiAgICAgIH1cbiAgICAgIGZvciAoaWR4ID0gZGlyID4gMCA/IGkgOiBsZW5ndGggLSAxOyBpZHggPj0gMCAmJiBpZHggPCBsZW5ndGg7IGlkeCArPSBkaXIpIHtcbiAgICAgICAgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKDEsIF8uZmluZEluZGV4LCBfLnNvcnRlZEluZGV4KTtcbiAgXy5sYXN0SW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKC0xLCBfLmZpbmRMYXN0SW5kZXgpO1xuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKHN0b3AgPT0gbnVsbCkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBzdGVwIHx8IDE7XG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciByYW5nZSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrLCBzdGFydCArPSBzdGVwKSB7XG4gICAgICByYW5nZVtpZHhdID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGV4ZWN1dGUgYSBmdW5jdGlvbiBhcyBhIGNvbnN0cnVjdG9yXG4gIC8vIG9yIGEgbm9ybWFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50c1xuICB2YXIgZXhlY3V0ZUJvdW5kID0gZnVuY3Rpb24oc291cmNlRnVuYywgYm91bmRGdW5jLCBjb250ZXh0LCBjYWxsaW5nQ29udGV4dCwgYXJncykge1xuICAgIGlmICghKGNhbGxpbmdDb250ZXh0IGluc3RhbmNlb2YgYm91bmRGdW5jKSkgcmV0dXJuIHNvdXJjZUZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgdmFyIHNlbGYgPSBiYXNlQ3JlYXRlKHNvdXJjZUZ1bmMucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gc291cmNlRnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICBpZiAoXy5pc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCBjb250ZXh0LCB0aGlzLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbiAgfTtcblxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gIC8vIGFyZ3VtZW50cyBwcmUtZmlsbGVkLCB3aXRob3V0IGNoYW5naW5nIGl0cyBkeW5hbWljIGB0aGlzYCBjb250ZXh0LiBfIGFjdHNcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciwgYWxsb3dpbmcgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyB0byBiZSBwcmUtZmlsbGVkLlxuICBfLnBhcnRpYWwgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDAsIGxlbmd0aCA9IGJvdW5kQXJncy5sZW5ndGg7XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBib3VuZEFyZ3NbaV0gPT09IF8gPyBhcmd1bWVudHNbcG9zaXRpb24rK10gOiBib3VuZEFyZ3NbaV07XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIHRoaXMsIHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwga2V5O1xuICAgIGlmIChsZW5ndGggPD0gMSkgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWxsIG11c3QgYmUgcGFzc2VkIGZ1bmN0aW9uIG5hbWVzJyk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbaV07XG4gICAgICBvYmpba2V5XSA9IF8uYmluZChvYmpba2V5XSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcbiAgICAgIHZhciBhZGRyZXNzID0gJycgKyAoaGFzaGVyID8gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXkpO1xuICAgICAgaWYgKCFfLmhhcyhjYWNoZSwgYWRkcmVzcykpIGNhY2hlW2FkZHJlc3NdID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNhY2hlW2FkZHJlc3NdO1xuICAgIH07XG4gICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xuICAgIHJldHVybiBtZW1vaXplO1xuICB9O1xuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9LCB3YWl0KTtcbiAgfTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgXy5kZWZlciA9IF8ucGFydGlhbChfLmRlbGF5LCBfLCAxKTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxhc3QgPSBfLm5vdygpIC0gdGltZXN0YW1wO1xuXG4gICAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBfLnBhcnRpYWwod3JhcHBlciwgZnVuYyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cbiAgXy5uZWdhdGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gc3RhcnQ7XG4gICAgICB2YXIgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlIChpLS0pIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBvbiBhbmQgYWZ0ZXIgdGhlIE50aCBjYWxsLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHRoZSBOdGggY2FsbC5cbiAgXy5iZWZvcmUgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHZhciBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xuICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVzIDw9IDEpIGZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gXy5wYXJ0aWFsKF8uYmVmb3JlLCAyKTtcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBLZXlzIGluIElFIDwgOSB0aGF0IHdvbid0IGJlIGl0ZXJhdGVkIGJ5IGBmb3Iga2V5IGluIC4uLmAgYW5kIHRodXMgbWlzc2VkLlxuICB2YXIgaGFzRW51bUJ1ZyA9ICF7dG9TdHJpbmc6IG51bGx9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWyd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKSB7XG4gICAgdmFyIG5vbkVudW1JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG8gPSAoXy5pc0Z1bmN0aW9uKGNvbnN0cnVjdG9yKSAmJiBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpIHx8IE9ialByb3RvO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgdmFyIHByb3AgPSAnY29uc3RydWN0b3InO1xuICAgIGlmIChfLmhhcyhvYmosIHByb3ApICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSBrZXlzLnB1c2gocHJvcCk7XG5cbiAgICB3aGlsZSAobm9uRW51bUlkeC0tKSB7XG4gICAgICBwcm9wID0gbm9uRW51bWVyYWJsZVByb3BzW25vbkVudW1JZHhdO1xuICAgICAgaWYgKHByb3AgaW4gb2JqICYmIG9ialtwcm9wXSAhPT0gcHJvdG9bcHJvcF0gJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIHtcbiAgICAgICAga2V5cy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYFxuICBfLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIGlmIChuYXRpdmVLZXlzKSByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgYWxsIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG4gIF8uYWxsS2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgb2JqZWN0XG4gIC8vIEluIGNvbnRyYXN0IHRvIF8ubWFwIGl0IHJldHVybnMgYW4gb2JqZWN0XG4gIF8ubWFwT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdHMgPSB7fSxcbiAgICAgICAgICBjdXJyZW50S2V5O1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjdXJyZW50S2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgIHJlc3VsdHNbY3VycmVudEtleV0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBwYWlycyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcGFpcnNbaV0gPSBba2V5c1tpXSwgb2JqW2tleXNbaV1dXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cbiAgXy5pbnZlcnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W29ialtrZXlzW2ldXV0gPSBrZXlzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cyk7XG5cbiAgLy8gQXNzaWducyBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgb3duIHByb3BlcnRpZXMgaW4gdGhlIHBhc3NlZC1pbiBvYmplY3QocylcbiAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24pXG4gIF8uZXh0ZW5kT3duID0gXy5hc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihfLmtleXMpO1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGtleSBvbiBhbiBvYmplY3QgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRLZXkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKSwga2V5O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpba2V5XSwga2V5LCBvYmopKSByZXR1cm4ga2V5O1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSBmdW5jdGlvbihvYmplY3QsIG9pdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSB7fSwgb2JqID0gb2JqZWN0LCBpdGVyYXRlZSwga2V5cztcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihvaXRlcmF0ZWUpKSB7XG4gICAgICBrZXlzID0gXy5hbGxLZXlzKG9iaik7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2Iob2l0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHsgcmV0dXJuIGtleSBpbiBvYmo7IH07XG4gICAgICBvYmogPSBPYmplY3Qob2JqKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaXRlcmF0ZWUgPSBfLm5lZ2F0ZShpdGVyYXRlZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5tYXAoZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSksIFN0cmluZyk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKGtleXMsIGtleSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gXy5waWNrKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMsIHRydWUpO1xuXG4gIC8vIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gcHJvdG90eXBlIG9iamVjdC5cbiAgLy8gSWYgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGFyZSBwcm92aWRlZCB0aGVuIHRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGVcbiAgLy8gY3JlYXRlZCBvYmplY3QuXG4gIF8uY3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlLCBwcm9wcykge1xuICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgaWYgKHByb3BzKSBfLmV4dGVuZE93bihyZXN1bHQsIHByb3BzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5pc01hdGNoID0gZnVuY3Rpb24ob2JqZWN0LCBhdHRycykge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKGF0dHJzKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcbiAgICB2YXIgb2JqID0gT2JqZWN0KG9iamVjdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoYXR0cnNba2V5XSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIHZhciBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiAnJyArIGEgPT09ICcnICsgYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOXG4gICAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgIH1cblxuICAgIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHMgb3IgYEFycmF5YHNcbiAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG5cbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgICBpZiAoXy5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKCEoXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopICYmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikgfHwgXy5pc0FyZ3VtZW50cyhvYmopKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgcmV0dXJuIF8ua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cCwgaXNFcnJvci5cbiAgXy5lYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnLCAnRXJyb3InXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFIDwgOSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaGFzKG9iaiwgJ2NhbGxlZScpO1xuICAgIH07XG4gIH1cblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgdHlwZW9mIGJ1Z3MgaW4gb2xkIHY4LFxuICAvLyBJRSAxMSAoIzE2MjEpLCBhbmQgaW4gU2FmYXJpIDggKCMxOTI5KS5cbiAgaWYgKHR5cGVvZiAvLi8gIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSW50OEFycmF5ICE9ICdvYmplY3QnKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/IChOYU4gaXMgdGhlIG9ubHkgbnVtYmVyIHdoaWNoIGRvZXMgbm90IGVxdWFsIGl0c2VsZikuXG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb25zLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcblxuICBfLm5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgXy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuXG4gIC8vIEdlbmVyYXRlcyBhIGZ1bmN0aW9uIGZvciBhIGdpdmVuIG9iamVjdCB0aGF0IHJldHVybnMgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgXy5wcm9wZXJ0eU9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PSBudWxsID8gZnVuY3Rpb24oKXt9IDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgcHJlZGljYXRlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2ZcbiAgLy8gYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ubWF0Y2hlciA9IF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgYXR0cnMgPSBfLmV4dGVuZE93bih7fSwgYXR0cnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmlzTWF0Y2gob2JqLCBhdHRycyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAnYCc6ICcmI3g2MDsnXG4gIH07XG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkXG4gICAgdmFyIHNvdXJjZSA9ICcoPzonICsgXy5rZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIF8uZXNjYXBlID0gY3JlYXRlRXNjYXBlcihlc2NhcGVNYXApO1xuICBfLnVuZXNjYXBlID0gY3JlYXRlRXNjYXBlcih1bmVzY2FwZU1hcCk7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBgcHJvcGVydHlgIGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQgd2l0aCB0aGVcbiAgLy8gYG9iamVjdGAgYXMgY29udGV4dDsgb3RoZXJ3aXNlLCByZXR1cm4gaXQuXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgZmFsbGJhY2spIHtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gZmFsbGJhY2s7XG4gICAgfVxuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6ICAgICAgXCInXCIsXG4gICAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAgICdcXHInOiAgICAgJ3InLFxuICAgICdcXG4nOiAgICAgJ24nLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZXIsIGVzY2FwZUNoYXIpO1xuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcbiAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oaW5zdGFuY2UsIG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZS5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PT0gJ3NoaWZ0JyB8fCBuYW1lID09PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBQcm92aWRlIHVud3JhcHBpbmcgcHJveHkgZm9yIHNvbWUgbWV0aG9kcyB1c2VkIGluIGVuZ2luZSBvcGVyYXRpb25zXG4gIC8vIHN1Y2ggYXMgYXJpdGhtZXRpYyBhbmQgSlNPTiBzdHJpbmdpZmljYXRpb24uXG4gIF8ucHJvdG90eXBlLnZhbHVlT2YgPSBfLnByb3RvdHlwZS50b0pTT04gPSBfLnByb3RvdHlwZS52YWx1ZTtcblxuICBfLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gQU1EIHJlZ2lzdHJhdGlvbiBoYXBwZW5zIGF0IHRoZSBlbmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQgbG9hZGVyc1xuICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xuICAvLyBhcyBhIG5hbWVkIG1vZHVsZSBiZWNhdXNlLCBsaWtlIGpRdWVyeSwgaXQgaXMgYSBiYXNlIGxpYnJhcnkgdGhhdCBpc1xuICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxuICAvLyBhbm9ueW1vdXMgZGVmaW5lKCkgaXMgY2FsbGVkIG91dHNpZGUgb2YgYSBsb2FkZXIgcmVxdWVzdC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgndW5kZXJzY29yZScsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xudmFyICQgPSBnbG9iYWwuJCA9IGdsb2JhbC5qUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyk7XG52YXIgXyA9IGdsb2JhbC5fID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuQmFja2JvbmUuJCA9ICQ7XG52YXIgTWFyaW9uZXR0ZSA9IHJlcXVpcmUoJ2JhY2tib25lLm1hcmlvbmV0dGUnKTtcblxuYXBwID0gbmV3IE1hcmlvbmV0dGUuQXBwbGljYXRpb24oKTtcblxuYXBwLmFkZFJlZ2lvbnMoe1xuICAgIHJlZ2lvbk1haW46ICcucmVnaW9uLW1haW4nXG59KTtcblxuYXBwLkJlaGF2aW9ycyA9IGFwcC5CZWhhdmlvcnMgfHwge307XG5cbk1hcmlvbmV0dGUuQmVoYXZpb3JzLmJlaGF2aW9yc0xvb2t1cCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcHAuQmVoYXZpb3JzO1xufTtcblxuYXBwLmFkZEluaXRpYWxpemVyKGZ1bmN0aW9uKCkge1xuXG4gICAgQmFja2JvbmUuaGlzdG9yeS5zdGFydCh7XG4gICAgICAgIHB1c2hTdGF0ZTogdHJ1ZSxcbiAgICAgICAgcm9vdDogJy8nXG4gICAgfSk7XG5cbn0pO1xuXG53aW5kb3cuYXBwID0gYXBwO1xubW9kdWxlLmV4cG9ydHMgPSBhcHA7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW5OeVl5OXFZWFpoYzJOeWFYQjBMMkZ3Y0M5aGNIQXVhbk1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFTSXNJbVpwYkdVaU9pSm5aVzVsY21GMFpXUXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpZG1GeUlDUWdQU0JuYkc5aVlXd3VKQ0E5SUdkc2IySmhiQzVxVVhWbGNua2dQU0J5WlhGMWFYSmxLQ2RxY1hWbGNua25LVHRjYm5aaGNpQkNZV05yWW05dVpTQTlJSEpsY1hWcGNtVW9KMkpoWTJ0aWIyNWxKeWs3WEc1MllYSWdYeUE5SUdkc2IySmhiQzVmSUQwZ2NtVnhkV2x5WlNnbmRXNWtaWEp6WTI5eVpTY3BPMXh1UW1GamEySnZibVV1SkNBOUlDUTdYRzUyWVhJZ1RXRnlhVzl1WlhSMFpTQTlJSEpsY1hWcGNtVW9KMkpoWTJ0aWIyNWxMbTFoY21sdmJtVjBkR1VuS1R0Y2JseHVZWEJ3SUQwZ2JtVjNJRTFoY21sdmJtVjBkR1V1UVhCd2JHbGpZWFJwYjI0b0tUdGNibHh1WVhCd0xtRmtaRkpsWjJsdmJuTW9lMXh1SUNBZ0lISmxaMmx2YmsxaGFXNDZJQ2N1Y21WbmFXOXVMVzFoYVc0blhHNTlLVHRjYmx4dVlYQndMa0psYUdGMmFXOXljeUE5SUdGd2NDNUNaV2hoZG1sdmNuTWdmSHdnZTMwN1hHNWNiazFoY21sdmJtVjBkR1V1UW1Wb1lYWnBiM0p6TG1KbGFHRjJhVzl5YzB4dmIydDFjQ0E5SUdaMWJtTjBhVzl1S0NrZ2UxeHVJQ0FnSUhKbGRIVnliaUJoY0hBdVFtVm9ZWFpwYjNKek8xeHVmVHRjYmx4dVlYQndMbUZrWkVsdWFYUnBZV3hwZW1WeUtHWjFibU4wYVc5dUtDa2dlMXh1WEc0Z0lDQWdRbUZqYTJKdmJtVXVhR2x6ZEc5eWVTNXpkR0Z5ZENoN1hHNGdJQ0FnSUNBZ0lIQjFjMmhUZEdGMFpUb2dkSEoxWlN4Y2JpQWdJQ0FnSUNBZ2NtOXZkRG9nSnk4blhHNGdJQ0FnZlNrN1hHNWNibjBwTzF4dVhHNTNhVzVrYjNjdVlYQndJRDBnWVhCd08xeHViVzlrZFd4bExtVjRjRzl5ZEhNZ1BTQmhjSEE3WEc0aVhYMD0iLCJ2YXIgYXBwID0gcmVxdWlyZSgnLi8uLi9hcHAnKTtcbnZhciBjaGFubmVscyA9IHJlcXVpcmUoJy4vLi4vY2hhbm5lbHMnKTtcbnZhciBNYXJpb25ldHRlID0gcmVxdWlyZSgnYmFja2JvbmUubWFyaW9uZXR0ZScpO1xudmFyIFR3ZWVuTWF4ICAgICAgID0gcmVxdWlyZSgnLi4vLi4vbGlicy9Ud2Vlbk1heC9Ud2Vlbk1heCcpO1xudmFyIFRpbWVsaW5lTGl0ZSAgID0gcmVxdWlyZSgnLi4vLi4vbGlicy9Ud2Vlbk1heC9UaW1lbGluZUxpdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhcHAuQmVoYXZpb3JzLk5hdmlnYXRvciA9IE1hcmlvbmV0dGUuQmVoYXZpb3IuZXh0ZW5kKHtcblxuICAgIHVpOiB7XG4gICAgICAgIGxpbmtzOiAnW2RhdGEtbmF2aWdhdGVdLCBhW2hyZWZePVwiL1wiXScsXG4gICAgICAgIGxvYWRlcjogJy5sb2FkZXItY29udGFpbmVyJyxcbiAgICAgICAgcGFnZTogJy5wYWdlJyxcbiAgICAgICAgcGF0aDogJy5zdDAnXG4gICAgfSxcblxuICAgIGV2ZW50czoge1xuICAgICAgICAnY2xpY2sgQHVpLmxpbmtzJzogJ29uQ2xpY2tOYXZpZ2F0ZSdcbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGNoYW5uZWxzLmxvYWRlckNoYW5uZWwub24oJ2hpZGVMb2FkZXInLCB0aGlzLmhpZGVMb2FkZXIsIHRoaXMpO1xuICAgIH0sXG5cbiAgICBvbkNsaWNrTmF2aWdhdGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICgkKGUuY3VycmVudFRhcmdldCkuaGFzQ2xhc3MoJ25vLWNhcHR1cmUnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIGN1cnJlbnRVcmwgPSBcIi9cIitCYWNrYm9uZS5oaXN0b3J5LmdldEZyYWdtZW50KCk7XG4gICAgICAgIHRoaXMudXJsID0gJChlLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ25hdmlnYXRlJykgfHwgJChlLmN1cnJlbnRUYXJnZXQpLmF0dHIoJ2hyZWYnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIGlmKGN1cnJlbnRVcmwgIT0gdGhpcy51cmwpIHtcblxuICAgICAgICAvLyAgICAgY3VycmVudFVybCA9IHRoaXMudXJsO1xuXG4gICAgICAgIC8vICAgICB0aGlzLnNob3dMb2FkZXIoKTtcbiAgICAgICAgLy8gICAgIHJldHVyblxuICAgICAgICAvLyB9XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyTmF2aWdhdGUoKTtcbiAgICB9LFxuXG4gICAgdHJpZ2dlck5hdmlnYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoYW5uZWxzLmdsb2JhbENoYW5uZWwudHJpZ2dlcignbmF2aWdhdGUnLCB7XG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgdHJpZ2dlcjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gc2hvd0xvYWRlcjogZnVuY3Rpb24oKSB7XG4gICAgLy8gICAgIHZhciAkd2luZG93ID0gJCh3aW5kb3cpO1xuXG4gICAgLy8gICAgIG5ldyBUaW1lbGluZUxpdGUoe29uQ29tcGxldGU6IF8uYmluZCh0aGlzLnRyaWdnZXJOYXZpZ2F0ZSwgdGhpcyl9KVxuICAgIC8vICAgICAgICAgLnRvKHRoaXMudWkucGF0aCwgMCwgeydhbmltYXRpb24taXRlcmF0aW9uLWNvdW50JzogJ2luZmluaXRlJywgJ3N0cm9rZS1kYXNob2Zmc2V0JzogXCJcIn0pXG4gICAgLy8gICAgICAgICAudG8odGhpcy51aS5wYWdlLCAwLjgsIHt5OiAtNTAsIGFscGhhOiAwfSlcbiAgICAvLyAgICAgICAgIC50byh0aGlzLnVpLmxvYWRlciwgMC44LCB7eTogMCwgYWxwaGE6IDF9KVxuICAgIC8vICAgICAgICAgLnRvKCR3aW5kb3csIDAsIHtzY3JvbGxUb3A6MCB9KVxuICAgIC8vIH0sXG5cbiAgICAvLyBoaWRlTG9hZGVyOiBmdW5jdGlvbigpIHtcbiAgICAvLyAgICAgbmV3IFRpbWVsaW5lTGl0ZSgpLmRlbGF5KDAuNSlcbiAgICAvLyAgICAgICAgIC50byh0aGlzLnVpLnBhdGgsIDEsIHsnYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudCc6ICcxJywgJ3N0cm9rZS1kYXNob2Zmc2V0JzogMH0pXG4gICAgLy8gICAgICAgICAudG8odGhpcy51aS5sb2FkZXIsIDAuOCwge3k6IDUwLCBhbHBoYTogMH0pXG4gICAgLy8gICAgICAgICAudG8odGhpcy51aS5wYWdlLCAwLjgsIHt5OiAwLCBhbHBoYTogMX0pXG4gICAgLy8gfVxuXG59KTtcbiIsIkJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbkJhY2tib25lLlJhZGlvID0gcmVxdWlyZSgnYmFja2JvbmUucmFkaW8nKTtcblxubW9kdWxlLmV4cG9ydHMuZ2xvYmFsQ2hhbm5lbCA9IEJhY2tib25lLlJhZGlvLmNoYW5uZWwoJ2dsb2JhbCcpO1xubW9kdWxlLmV4cG9ydHMudXNlckNoYW5uZWwgPSBCYWNrYm9uZS5SYWRpby5jaGFubmVsKCd1c2VyJyk7XG5tb2R1bGUuZXhwb3J0cy5uYXZDaGFubmVsID0gQmFja2JvbmUuUmFkaW8uY2hhbm5lbCgnbmF2Jyk7XG4iLCJ2YXIgV29ya01vZGVsID0gcmVxdWlyZSgnLi8uLi9tb2RlbHMvV29ya01vZGVsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xuICAgIG1vZGVsOiBXb3JrTW9kZWxcbn0pIiwidmFyIGFwcCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vLi4vYXBwJyk7XG52YXIgQmFja2JvbmUgICAgICAgICAgID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbnZhciBjaGFubmVscyAgICAgICAgICAgPSByZXF1aXJlKCcuLy4uL2NoYW5uZWxzJyk7XG4vLyBWaWV3c1xudmFyIEdsb2JhbFZpZXcgICAgICAgICA9IHJlcXVpcmUoJy4vLi4vdmlld3MvR2xvYmFsVmlldycpO1xudmFyIEJhc2VWaWV3ICAgICAgICAgICA9IHJlcXVpcmUoJy4vLi4vdmlld3MvQmFzZVZpZXcnKTtcbnZhciBJbmRleFZpZXcgICAgICAgICAgPSByZXF1aXJlKCcuLy4uL3ZpZXdzL0luZGV4VmlldycpO1xudmFyIFByb2plY3RWaWV3ICAgICAgICAgID0gcmVxdWlyZSgnLi8uLi92aWV3cy9Qcm9qZWN0VmlldycpO1xuXG52YXIgV29ya0NvbGxlY3Rpb24gPSByZXF1aXJlKCcuLy4uL2NvbGxlY3Rpb25zL1dvcmtDb2xsZWN0aW9uJyk7XG52YXIgd29ya01vZGVsICAgICAgID0gcmVxdWlyZSgnLi8uLi9tb2RlbHMvV29ya01vZGVsJyk7IFxudmFyIHdvcmtEYXRhICAgICAgID0gcmVxdWlyZSgnLi8uLi9kYXRhcy93b3JrRGF0YScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tib25lLk1hcmlvbmV0dGUuQ29udHJvbGxlci5leHRlbmQoe1xuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIC8vIFN0YXRlIGNoZWNrc1xuICAgICAgICBhcHAub25sb2FkID0gdHJ1ZTtcblxuICAgICAgICAvLyBCb290c3RyYXAgaXQsIGd1cnJsXG4gICAgICAgIHRoaXMuYm9vdHN0cmFwKCk7XG5cbiAgICB9LFxuXG4gICAgYm9vdHN0cmFwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsVmlldyA9IG5ldyBHbG9iYWxWaWV3KCk7XG4gICAgICAgIHRoaXMuYmFzZVZpZXcgPSBuZXcgQmFzZVZpZXcoKTtcblxuICAgICAgICBhcHAud29ya0NvbGxlY3Rpb24gPSBuZXcgV29ya0NvbGxlY3Rpb24od29ya0RhdGEpO1xuXG4gICAgICAgIGNoYW5uZWxzLmdsb2JhbENoYW5uZWwub24oJ25hdmlnYXRlJywgdGhpcy5uYXZpZ2F0ZSwgdGhpcyk7XG5cbiAgICB9LFxuXG4gICAgbmF2aWdhdGU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICAgICAgLy8gSWYgbmF2aWdhdGUoKSBpcyBiZWluZyBjYWxsZWQuLi5cbiAgICAgICAgLy8gd2UgbXVzdCBiZSBwYXN0IG91ciBpbml0aWFsIHBhZ2UgbG9hZFxuICAgICAgICAvLyBzbyB3ZSdsbCBzZXQgb25sb2FkIHRvICdmYWxzZSdcbiAgICAgICAgYXBwLm9ubG9hZCA9IGZhbHNlO1xuXG4gICAgICAgIHZhciB1cmwgPSBvcHRpb25zLnVybDtcbiAgICAgICAgdmFyIHRyaWdnZXIgPSBvcHRpb25zLnRyaWdnZXIgPyBvcHRpb25zLnRyaWdnZXIgOiBmYWxzZTtcblxuICAgICAgICBhcHAuYXBwUm91dGVyLm5hdmlnYXRlKHVybCwge1xuICAgICAgICAgICAgdHJpZ2dlcjogdHJpZ2dlclxuICAgICAgICB9KTtcblxuICAgIH0sXG5cbiAgICAvKiBWaWV3IFJvdXRlc1xuICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuICAgIGluZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbmRleFZpZXcgPSBuZXcgSW5kZXhWaWV3KCk7XG4gICAgICAgIGFwcC5yZWdpb25NYWluLnNob3coaW5kZXhWaWV3KTtcbiAgICB9LFxuXG4gICAgcHJvamVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvamVjdFZpZXcgPSBuZXcgUHJvamVjdFZpZXcoKTtcbiAgICAgICAgYXBwLnJlZ2lvbk1haW4uc2hvdyhwcm9qZWN0Vmlldyk7XG4gICAgfSxcblxuICAgIGRlZmF1bHRIYW5kbGVyOiBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJyVjUm91dGUgLyVzIGRvZXMgbm90IGV4aXN0JywgJ2NvbG9yOndoaXRlOyBiYWNrZ3JvdW5kOmdyYXk7IHBhZGRpbmc6IDAgMC4yNWVtJywgcm91dGUpO1xuICAgIH1cblxufSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFtcbiAgICB7XG4gICAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgdGl0bGU6ICdFZGllICZhbXAgV2F0c29uJyxcbiAgICAgICAgc2x1ZzogJ2VkaWUtd2F0c29uJyxcbiAgICAgICAgY292ZXI6ICcvaW1hZ2VzL3Byb2plY3RzL2VkaWUtd2F0c29uL2NvdmVyLmpwZycsXG4gICAgICAgIHN1YnBhcnQ6IHtcbiAgICAgICAgICAgICd3ZWItZGVzaWduJzogJ1dlYmRlc2lnbicsXG4gICAgICAgICAgICAncHJpbnQnOiAnUHJpbnQnLFxuICAgICAgICAgICAgJ2RhLXBob3RvJzogJ0RBIHBob3RvJyxcbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICB0aXRsZTogJ0xlIFNhbG9uIGRlcyBEYW1lcycsXG4gICAgICAgIHNsdWc6ICdzYWxvbi1kZXMtZGFtZXMnLFxuICAgICAgICBjb3ZlcjogJy9pbWFnZXMvcHJvamVjdHMvZWRpZS13YXRzb24vY292ZXIuanBnJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGl0bGU6ICdTYW4gTWFyaW5hJyxcbiAgICAgICAgc2x1ZzogJ3Nhbi1tYXJpbmEnLFxuICAgICAgICBjb3ZlcjogJy9pbWFnZXMvcHJvamVjdHMvZWRpZS13YXRzb24vY292ZXIuanBnJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGl0bGU6ICdCw6luw6lkaWN0ZSBTYWNoaS1TYWlsbGFyZCcsXG4gICAgICAgIHNsdWc6ICdiZW5lZGljdGUtc2FjaGktc2FpbGxhcmQnLFxuICAgICAgICBjb3ZlcjogJy9pbWFnZXMvcHJvamVjdHMvZWRpZS13YXRzb24vY292ZXIuanBnJyxcbiAgICB9XG5dIiwidmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe30pO1xuIiwidmFyIE1hcmlvbmV0dGUgPSByZXF1aXJlKCdiYWNrYm9uZS5tYXJpb25ldHRlJyk7XG52YXIgQXBwQ29udHJvbGxlciA9IHJlcXVpcmUoJy4vLi4vY29udHJvbGxlcnMvQXBwQ29udHJvbGxlci5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcmlvbmV0dGUuQXBwUm91dGVyLmV4dGVuZCh7XG5cbiAgICBhcHBSb3V0ZXM6IHtcbiAgICAgICAgJygvKSc6ICdpbmRleCcsXG4gICAgICAgICdwcm9qZWN0LzpzbHVnKC8pJzogJ3Byb2plY3QnLFxuICAgICAgICAnKmRlZmF1bHQnOiAnZGVmYXVsdEhhbmRsZXInXG4gICAgfSxcblxuICAgIGNvbnRyb2xsZXI6IG5ldyBBcHBDb250cm9sbGVyKClcblxufSk7XG4iLCJtb2R1bGUuZXhwb3J0cy5GUkFNRV9SQVRFID0gMjQ7XG5tb2R1bGUuZXhwb3J0cy5TSE9XX0NMQVNTID0gJ3Nob3cnO1xubW9kdWxlLmV4cG9ydHMuSU5JVElOR19DTEFTUyA9ICdpcy1pbml0aW5nJztcbm1vZHVsZS5leHBvcnRzLlJFQURZX0NMQVNTID0gJ2lzLXJlYWR5JztcbiIsInZhciBNYXJpb25ldHRlID0gcmVxdWlyZSgnYmFja2JvbmUubWFyaW9uZXR0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcmlvbmV0dGUuSXRlbVZpZXcuZXh0ZW5kKHtcblxufSk7XG4iLCJ2YXIgYXBwICAgICAgICAgICA9IHJlcXVpcmUoJy4vLi4vYXBwJyk7XG52YXIgY2hhbm5lbHMgICAgICA9IHJlcXVpcmUoJy4vLi4vY2hhbm5lbHMnKTtcbnZhciBNYXJpb25ldHRlICAgID0gcmVxdWlyZSgnYmFja2JvbmUubWFyaW9uZXR0ZScpO1xuXG52YXIgSW5kZXhJdGVtVmlldyA9IHJlcXVpcmUoJy4vSW5kZXhJdGVtVmlldycpO1xudmFyIHRlbXBsYXRlICAgICAgPSByZXF1aXJlKCcuLy4uLy4uL3RlbXBsYXRlcy9pbmRleC1saXN0LmhicycpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTWFyaW9uZXR0ZS5Db21wb3NpdGVWaWV3LmV4dGVuZCh7XG4gICAgY2xhc3NOYW1lOiAnaW5kZXgtbGlzdC1jb250YWluZXInLFxuICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcblxuICAgIGNoaWxkVmlldzogSW5kZXhJdGVtVmlldyxcbiAgICBjaGlsZFZpZXdDb250YWluZXI6IFwiLmluZGV4LWxpc3QtanNcIixcblxuICAgIHVpOiB7XG4gICAgICAgIGluZGV4QXJyb3c6ICcuaW5kZXgtYXJyb3ctanMnLFxuICAgICAgICBpbmRleExpc3Q6ICcuaW5kZXgtbGlzdC1qcycsXG4gICAgICAgIGluZGV4SXRlbTogJy5pbmRleC1pdGVtLWpzJyxcbiAgICB9LFxuXG4gICAgZXZlbnRzOiB7XG4gICAgICAgICdjbGljayBAdWkuaW5kZXhBcnJvdyc6ICdvbkNsaWNrSW5kZXhBcnJvdycsXG4gICAgfSxcblxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjaGFubmVscy5uYXZDaGFubmVsLm9uKCdob3ZlclN1Ykl0ZW1OYXYnLCB0aGlzLmhvdmVyU3ViSXRlbU5hdiwgdGhpcyk7XG4gICAgfSxcblxuICAgIG9uQmVmb3JlUmVuZGVyOiBmdW5jdGlvbiAoKSB7fSxcblxuICAgIG9uUmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgfSxcblxuICAgIG9uU2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBiaW5kcyB2aWV3IGVsZW1lbnRzIHRvIHVpIGhhc2hcbiAgICAgICAgdGhpcy5iaW5kVUlFbGVtZW50cygpO1xuICAgICAgICB0aGlzLnVpLmluZGV4SXRlbS5maXJzdCgpLmFkZENsYXNzKCdhY3RpdmUnKS5jc3MoJ29wYWNpdHknLCAxKTtcbiAgICB9LFxuXG4gICAgb25DbGlja0luZGV4QXJyb3c6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciAkYXJyb3cgPSAkKGUuY3VycmVudFRhcmdldCksXG4gICAgICAgICAgICAkbGlzdCA9IHRoaXMudWkuaW5kZXhMaXN0LFxuICAgICAgICAgICAgJGl0ZW1zID0gJGxpc3QuY2hpbGRyZW4oKSxcbiAgICAgICAgICAgIGxlbmd0aCA9ICRpdGVtcy5sZW5ndGgtMSxcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9ICRsaXN0LmZpbmQoJy5hY3RpdmUnKS5pbmRleCgpLFxuICAgICAgICAgICAgbmV3SW5kZXggPSBjdXJyZW50SW5kZXgsXG4gICAgICAgICAgICBkaXJlY3Rpb24gPSAnbmV4dCc7XG5cblxuICAgICAgICBpZiAoJGFycm93Lmhhc0NsYXNzKCdwcmV2LWFycm93JykpIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9ICdwcmV2JztcbiAgICAgICAgICAgIG5ld0luZGV4ID0gbmV3SW5kZXgtMTtcbiAgICAgICAgICAgIGlmIChuZXdJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBuZXdJbmRleCA9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3SW5kZXggPSBuZXdJbmRleCsxO1xuICAgICAgICAgICAgaWYgKG5ld0luZGV4ID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbmV3SW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBjaGFubmVscy5uYXZDaGFubmVsLnRyaWdnZXIoJ2NsaWNrSW5kZXhBcnJvdycsIHtcbiAgICAgICAgICAgIGluZGV4OiBuZXdJbmRleFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm1vdmVJbmRleEl0ZW0oZGlyZWN0aW9uLCBuZXdJbmRleCwgJGl0ZW1zLCAkbGlzdCk7XG4gICAgfSxcblxuICAgIGhvdmVyU3ViSXRlbU5hdjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyICRsaXN0ID0gdGhpcy51aS5pbmRleExpc3QsXG4gICAgICAgICAgICAkaXRlbXMgPSAkbGlzdC5jaGlsZHJlbigpLFxuICAgICAgICAgICAgbmV3SW5kZXggPSBvcHRpb25zLmluZGV4LFxuICAgICAgICAgICAgZGlyZWN0aW9uID0gJ25leHQnO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5tb3ZlSW5kZXhJdGVtKGRpcmVjdGlvbiwgbmV3SW5kZXgsICRpdGVtcywgJGxpc3QpO1xuICAgIH0sXG5cbiAgICBtb3ZlSW5kZXhJdGVtOiBmdW5jdGlvbiAoZGlyZWN0aW9uLCBuZXdJbmRleCwgJGl0ZW1zLCAkbGlzdCkge1xuICAgICAgICB2YXIgbmV3SXRlbSA9ICRpdGVtc1tuZXdJbmRleF0sXG4gICAgICAgICAgICAkY3VycmVudEl0ZW0gPSAkbGlzdC5maW5kKCcuYWN0aXZlJyk7XG5cbiAgICAgICAgdmFyIHRsID0gbmV3IFRpbWVsaW5lTWF4KCk7XG5cbiAgICAgICAgdGwudG90YWxQcm9ncmVzcygxLCBmYWxzZSk7XG5cbiAgICAgICAgdGwudG8oJGl0ZW1zLCAwLjIsIHthbHBoYTowLCBkaXNwbGF5Oidub25lJywgY2xhc3NOYW1lOiAnLT1hY3RpdmUnfSlcbiAgICAgICAgICAuZnJvbVRvKG5ld0l0ZW0sIDAuMiwge2FscGhhOiAwLCBkaXNwbGF5Oidub25lJywgY2xhc3NOYW1lOiAnKz1hY3RpdmUnfSwge2FscGhhOjEsIGRpc3BsYXk6J2Jsb2NrJ30pXG4gICAgICAgIFxuICAgIH1cblxufSk7XG4iLCJ2YXIgTWFyaW9uZXR0ZSA9IHJlcXVpcmUoJ2JhY2tib25lLm1hcmlvbmV0dGUnKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzL2NvbnN0YW50cycpO1xudmFyIGF0dGFjaEZhc3RDbGljayA9IHJlcXVpcmUoJ2Zhc3RjbGljaycpO1xuXG4vLyBWaWV3IEJlaGF2aW9yc1xucmVxdWlyZSgnLi4vYmVoYXZpb3JzL05hdmlnYXRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcmlvbmV0dGUuSXRlbVZpZXcuZXh0ZW5kKHtcblxuICAgIGVsOiAnYm9keScsXG5cbiAgICBldmVudHM6IHtcbiAgICAgICAgJ2tleXVwJzogJ2tleXVwJ1xuICAgIH0sXG5cbiAgICBiZWhhdmlvcnM6IHtcbiAgICAgICAgTmF2aWdhdG9yOiB7fVxuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBKYXZhc2NyaXB0IGlzIHJlYWR5Li4uIGdvIVxuICAgICAgICB0aGlzLiRlbC5yZW1vdmVDbGFzcyhjb25zdGFudHMuSU5JVElOR19DTEFTUyk7XG5cbiAgICAgICAgLy8gTm8gY2xpY2sgZGVsYXkgZm9yIGlPU1xuICAgICAgICBhdHRhY2hGYXN0Q2xpY2soZG9jdW1lbnQuYm9keSk7XG5cbiAgICAgICAgLy8gRm9yY2UgdG91Y2ggZGV2aWNlcyB0byByZXNwZWN0IDphY3RpdmUgc3R5bGVzIGluIENTU1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24oKSB7fSwgdHJ1ZSk7XG5cbiAgICAgICAgLy8gUGFnZSB2aXNpYmlsaXR5IGRldGVjdGlvblxuICAgICAgICB0aGlzLmxpc3RlbkZvclBhZ2VWaXNpYmlsaXR5KCk7XG5cbiAgICB9LFxuXG4gICAgbGlzdGVuRm9yUGFnZVZpc2liaWxpdHk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBoaWRkZW4sIHZpc2liaWxpdHlDaGFuZ2U7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudC5oaWRkZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBoaWRkZW4gPSAnaGlkZGVuJztcbiAgICAgICAgICAgIHZpc2liaWxpdHlDaGFuZ2UgPSAndmlzaWJpbGl0eWNoYW5nZSc7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50Lm1vekhpZGRlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGhpZGRlbiA9ICdtb3pIaWRkZW4nO1xuICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICdtb3p2aXNpYmlsaXR5Y2hhbmdlJztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQubXNIaWRkZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBoaWRkZW4gPSAnbXNIaWRkZW4nO1xuICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICdtc3Zpc2liaWxpdHljaGFuZ2UnO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudC53ZWJraXRIaWRkZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBoaWRkZW4gPSAnd2Via2l0SGlkZGVuJztcbiAgICAgICAgICAgIHZpc2liaWxpdHlDaGFuZ2UgPSAnd2Via2l0dmlzaWJpbGl0eWNoYW5nZSc7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKCkge1xuICAgICAgICAgICAgLy8gY2hhbm5lbHMuZ2xvYmFsQ2hhbm5lbC50cmlnZ2VyKCdhcHA6dmlzaWJpbGl0eScsICFkb2N1bWVudFtoaWRkZW5dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2aXNpYmlsaXR5Q2hhbmdlICYmIHR5cGVvZiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih2aXNpYmlsaXR5Q2hhbmdlLCBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgIH1cblxufSk7XG4iLCJ2YXIgYXBwICAgICAgICA9IHJlcXVpcmUoJy4vLi4vYXBwJyk7XG52YXIgY2hhbm5lbHMgICA9IHJlcXVpcmUoJy4vLi4vY2hhbm5lbHMnKTtcbnZhciBNYXJpb25ldHRlID0gcmVxdWlyZSgnYmFja2JvbmUubWFyaW9uZXR0ZScpO1xudmFyIHRlbXBsYXRlICAgPSByZXF1aXJlKCcuLy4uLy4uL3RlbXBsYXRlcy9pbmRleC1pdGVtLmhicycpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTWFyaW9uZXR0ZS5JdGVtVmlldy5leHRlbmQoe1xuXG4gICAgdGFnTmFtZTogJ2xpJyxcbiAgICBjbGFzc05hbWU6ICdpbmRleC1pdGVtIGluZGV4LWl0ZW0tanMnLFxuICAgIFxuICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcblxuICAgIHRlbXBsYXRlSGVscGVyczogZnVuY3Rpb24oKSB7cmV0dXJuIHt9fSxcblxuICAgIHVpOiB7fSxcblxuICAgIGV2ZW50czoge30sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7fSxcblxuXG4gICAgbW9kZWxDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7fVxuXG59KTtcbiIsIi8vIHZhciBhcHAgICAgICAgICAgID0gcmVxdWlyZSgnYXBwL2FwcCcpO1xudmFyIGNoYW5uZWxzICAgICAgPSByZXF1aXJlKCcuLy4uL2NoYW5uZWxzJyk7XG52YXIgTWFyaW9uZXR0ZSAgICA9IHJlcXVpcmUoJ2JhY2tib25lLm1hcmlvbmV0dGUnKTtcbnZhciB0ZW1wbGF0ZSAgICAgID0gcmVxdWlyZSgnLi8uLi8uLi90ZW1wbGF0ZXMvaW5kZXguaGJzJyk7XG5cblxuLy8gVklFV1xudmFyIE5hdlZpZXcgICAgICAgPSByZXF1aXJlKCcuL05hdlZpZXcnKTsgXG52YXIgQ29udGVudFZpZXcgICA9IHJlcXVpcmUoJy4vQ29udGVudFZpZXcnKTsgXG4vLyB2YXIgUHJvamVjdHNMaXN0VmlldyAgPSByZXF1aXJlKCd2aWV3cy9Qcm9qZWN0c0xpc3RWaWV3Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFyaW9uZXR0ZS5MYXlvdXRWaWV3LmV4dGVuZCh7XG5cbiAgICBjbGFzc05hbWU6ICdwYWdlIHBhZ2UtaW5kZXgnLFxuXG4gICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuXG4gICAgcmVnaW9uczoge1xuICAgICAgICByZWdpb25OYXY6ICcucmVnaW9uLW5hdicsXG4gICAgICAgIHJlZ2lvbkNvbnRlbnQ6ICcucmVnaW9uLWNvbnRlbnQnXG4gICAgfSxcblxuICAgIHVpOiB7fSxcblxuICAgIGV2ZW50czoge30sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7fSxcblxuICAgIG9uU2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm5hdlZpZXcgPSBuZXcgTmF2VmlldygpO1xuICAgICAgICB0aGlzLnJlZ2lvbk5hdi5zaG93KHRoaXMubmF2Vmlldyk7XG5cbiAgICAgICAgdGhpcy5jb250ZW50VmlldyA9IG5ldyBDb250ZW50Vmlldyh7XG4gICAgICAgICAgICBjb2xsZWN0aW9uOiBhcHAud29ya0NvbGxlY3Rpb24sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZ2lvbkNvbnRlbnQuc2hvdyh0aGlzLmNvbnRlbnRWaWV3KTtcbiAgICB9XG5cbn0pO1xuIiwidmFyIGFwcCAgICAgICAgPSByZXF1aXJlKCcuLy4uL2FwcCcpO1xudmFyIGNoYW5uZWxzICAgPSByZXF1aXJlKCcuLy4uL2NoYW5uZWxzJyk7XG52YXIgTWFyaW9uZXR0ZSA9IHJlcXVpcmUoJ2JhY2tib25lLm1hcmlvbmV0dGUnKTtcbnZhciB0ZW1wbGF0ZSAgID0gcmVxdWlyZSgnLi8uLi8uLi90ZW1wbGF0ZXMvbmF2LmhicycpO1xuXG52YXIgV29ya0xpc3RWaWV3ID0gcmVxdWlyZSgnLi9Xb3JrTGlzdFZpZXcnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcmlvbmV0dGUuTGF5b3V0Vmlldy5leHRlbmQoe1xuICAgIGNsYXNzTmFtZTogJ25hdi13cmFwcGVyIHdyYXBwZXInLFxuXG4gICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuXG4gICAgcmVnaW9uczoge1xuICAgICAgICB3b3JrTGlzdDogJy53b3JrLWxpc3QtanMnLFxuICAgICAgICBhYm91dExpc3Q6ICcuYWJvdXQtbGlzdC1qcydcbiAgICB9LFxuXG4gICAgZXZlbnRzOiB7fSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHt9LFxuXG4gICAgb25CZWZvcmVSZW5kZXI6IGZ1bmN0aW9uICgpIHt9LFxuXG4gICAgb25SZW5kZXI6IGZ1bmN0aW9uICgpIHt9LFxuXG4gICAgb25TaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMud29ya0xpc3RWaWV3ID0gbmV3IFdvcmtMaXN0Vmlldyh7XG4gICAgICAgICAgICBjb2xsZWN0aW9uOiBhcHAud29ya0NvbGxlY3Rpb25cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud29ya0xpc3Quc2hvdyh0aGlzLndvcmtMaXN0Vmlldyk7XG4gICAgfSxcblxuICAgIG9uQmVmb3JlRGVzdHJveTogZnVuY3Rpb24gKCkge30sXG5cbiAgICBvbkRlc3Ryb3k6IGZ1bmN0aW9uICgpIHt9LFxuXG59KTtcbiIsInZhciBhcHAgICAgICAgID0gcmVxdWlyZSgnLi8uLi9hcHAnKTtcbnZhciBjaGFubmVscyAgID0gcmVxdWlyZSgnLi8uLi9jaGFubmVscycpO1xudmFyIE1hcmlvbmV0dGUgPSByZXF1aXJlKCdiYWNrYm9uZS5tYXJpb25ldHRlJyk7XG52YXIgdGVtcGxhdGUgICA9IHJlcXVpcmUoJy4vLi4vLi4vdGVtcGxhdGVzL3dvcmstaXRlbS5oYnMnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcmlvbmV0dGUuSXRlbVZpZXcuZXh0ZW5kKHtcblxuICAgIHRhZ05hbWU6ICdsaScsXG4gICAgY2xhc3NOYW1lOiAnc3ViLW5hdi1pdGVtIHN1Yi1uYXYtaXRlbS1qcycsXG4gICAgXG4gICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuXG4gICAgdGVtcGxhdGVIZWxwZXJzOiBmdW5jdGlvbigpIHtyZXR1cm4ge319LFxuXG4gICAgdWk6IHtcbiAgICAgICAgc3ViUGFydE5hbWU6ICcuc3ViLXBhcnQtbmFtZS1qcydcbiAgICB9LFxuXG4gICAgZXZlbnRzOiB7XG4gICAgICAgICdtb3VzZWVudGVyIEB1aS5zdWJQYXJ0TmFtZSc6ICdvbk1vdXNlRW50ZXJTdWJQYXJ0TmFtZSdcbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge30sXG5cbiAgICBvbk1vdXNlRW50ZXJTdWJQYXJ0TmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJGVsID0gdGhpcy4kZWw7XG5cbiAgICAgICAgaWYgKCRlbC5oYXNDbGFzcygnaG92ZXInKSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAkKCcuc3ViLW5hdi1pdGVtLWpzJykucmVtb3ZlQ2xhc3MoJ2hvdmVyJyk7XG4gICAgICAgICRlbC5hZGRDbGFzcygnaG92ZXInKTtcblxuICAgICAgICB2YXIgaW5kZXggPSAkZWwucGFyZW50KCkuY2hpbGRyZW4oJy5ob3ZlcicpLmluZGV4KCk7XG5cbiAgICAgICAgY2hhbm5lbHMubmF2Q2hhbm5lbC50cmlnZ2VyKCdob3ZlclN1Ykl0ZW1OYXYnLCB7XG4gICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgfSk7XG4gICAgfVxuXG59KTtcbiIsInZhciBhcHAgICAgICAgID0gcmVxdWlyZSgnLi8uLi9hcHAnKTtcbnZhciBjaGFubmVscyAgID0gcmVxdWlyZSgnLi8uLi9jaGFubmVscycpO1xudmFyIE1hcmlvbmV0dGUgPSByZXF1aXJlKCdiYWNrYm9uZS5tYXJpb25ldHRlJyk7XG5cbnZhciBXb3JrSXRlbVZpZXcgPSByZXF1aXJlKCcuL1dvcmtJdGVtVmlldycpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTWFyaW9uZXR0ZS5Db2xsZWN0aW9uVmlldy5leHRlbmQoe1xuICAgIHRhZ05hbWU6ICd1bCcsXG4gICAgY2hpbGRWaWV3OiBXb3JrSXRlbVZpZXcsXG5cbiAgICBjaGlsZEV2ZW50czogZnVuY3Rpb24gKCkge3JldHVybiB7fX0sXG5cbiAgICB1aToge1xuICAgICAgICBzdWJOYXZJdGVtOiAnLnN1Yi1uYXYtaXRlbS1qcycsXG4gICAgfSxcblxuICAgIGV2ZW50czoge30sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoYW5uZWxzLm5hdkNoYW5uZWwub24oJ2NsaWNrSW5kZXhBcnJvdycsIHRoaXMuY2xpY2tJbmRleEFycm93LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgb25TaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGJpbmRzIHZpZXcgZWxlbWVudHMgdG8gdWkgaGFzaFxuICAgICAgICB0aGlzLmJpbmRVSUVsZW1lbnRzKCk7XG5cbiAgICAgICAgdGhpcy51aS5zdWJOYXZJdGVtLmZpcnN0KCkuYWRkQ2xhc3MoJ2hvdmVyJyk7XG4gICAgfSxcblxuICAgIGNsaWNrSW5kZXhBcnJvdzogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyICRlbCA9IHRoaXMuJGVsLFxuICAgICAgICAgICAgaW5kZXggPSBvcHRpb25zLmluZGV4LFxuICAgICAgICAgICAgJHN1Yk5hdkl0ZW0gPSAkZWwuY2hpbGRyZW4oJy5zdWItbmF2LWl0ZW0tanMnKTtcblxuICAgICAgICAkc3ViTmF2SXRlbS5yZW1vdmVDbGFzcygnaG92ZXInKTtcblxuICAgICAgICAkKCRzdWJOYXZJdGVtW2luZGV4XSkuYWRkQ2xhc3MoJ2hvdmVyJyk7XG4gICAgfVxuXG4gICAgXG5cbn0pO1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyohXG4gKiBWRVJTSU9OOiAxLjE4LjBcbiAqIERBVEU6IDIwMTUtMDgtMjlcbiAqIFVQREFURVMgQU5EIERPQ1MgQVQ6IGh0dHA6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDA4LTIwMTUsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgd29yayBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIHNvZnR3YXJlIGFncmVlbWVudCB0aGF0IHdhcyBpc3N1ZWQgd2l0aCB5b3VyIG1lbWJlcnNoaXAuXG4gKiBcbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuICovXG52YXIgX2dzU2NvcGU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOnRoaXN8fHdpbmRvdzsoX2dzU2NvcGUuX2dzUXVldWV8fChfZ3NTY29wZS5fZ3NRdWV1ZT1bXSkpLnB1c2goZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtfZ3NTY29wZS5fZ3NEZWZpbmUoXCJUaW1lbGluZUxpdGVcIixbXCJjb3JlLkFuaW1hdGlvblwiLFwiY29yZS5TaW1wbGVUaW1lbGluZVwiLFwiVHdlZW5MaXRlXCJdLGZ1bmN0aW9uKHQsZSxpKXt2YXIgcz1mdW5jdGlvbih0KXtlLmNhbGwodGhpcyx0KSx0aGlzLl9sYWJlbHM9e30sdGhpcy5hdXRvUmVtb3ZlQ2hpbGRyZW49dGhpcy52YXJzLmF1dG9SZW1vdmVDaGlsZHJlbj09PSEwLHRoaXMuc21vb3RoQ2hpbGRUaW1pbmc9dGhpcy52YXJzLnNtb290aENoaWxkVGltaW5nPT09ITAsdGhpcy5fc29ydENoaWxkcmVuPSEwLHRoaXMuX29uVXBkYXRlPXRoaXMudmFycy5vblVwZGF0ZTt2YXIgaSxzLHI9dGhpcy52YXJzO2ZvcihzIGluIHIpaT1yW3NdLGwoaSkmJi0xIT09aS5qb2luKFwiXCIpLmluZGV4T2YoXCJ7c2VsZn1cIikmJihyW3NdPXRoaXMuX3N3YXBTZWxmSW5QYXJhbXMoaSkpO2woci50d2VlbnMpJiZ0aGlzLmFkZChyLnR3ZWVucywwLHIuYWxpZ24sci5zdGFnZ2VyKX0scj0xZS0xMCxuPWkuX2ludGVybmFscyxhPXMuX2ludGVybmFscz17fSxvPW4uaXNTZWxlY3RvcixsPW4uaXNBcnJheSxoPW4ubGF6eVR3ZWVucyxfPW4ubGF6eVJlbmRlcix1PV9nc1Njb3BlLl9nc0RlZmluZS5nbG9iYWxzLGY9ZnVuY3Rpb24odCl7dmFyIGUsaT17fTtmb3IoZSBpbiB0KWlbZV09dFtlXTtyZXR1cm4gaX0sYz1mdW5jdGlvbih0LGUsaSl7dmFyIHMscixuPXQuY3ljbGU7Zm9yKHMgaW4gbilyPW5bc10sdFtzXT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByP3IuY2FsbChlW2ldLGkpOnJbaSVyLmxlbmd0aF07ZGVsZXRlIHQuY3ljbGV9LHA9YS5wYXVzZUNhbGxiYWNrPWZ1bmN0aW9uKCl7fSxtPWZ1bmN0aW9uKHQpe3ZhciBlLGk9W10scz10Lmxlbmd0aDtmb3IoZT0wO2UhPT1zO2kucHVzaCh0W2UrK10pKTtyZXR1cm4gaX0sZD1zLnByb3RvdHlwZT1uZXcgZTtyZXR1cm4gcy52ZXJzaW9uPVwiMS4xOC4wXCIsZC5jb25zdHJ1Y3Rvcj1zLGQua2lsbCgpLl9nYz1kLl9mb3JjaW5nUGxheWhlYWQ9ZC5faGFzUGF1c2U9ITEsZC50bz1mdW5jdGlvbih0LGUscyxyKXt2YXIgbj1zLnJlcGVhdCYmdS5Ud2Vlbk1heHx8aTtyZXR1cm4gZT90aGlzLmFkZChuZXcgbih0LGUscykscik6dGhpcy5zZXQodCxzLHIpfSxkLmZyb209ZnVuY3Rpb24odCxlLHMscil7cmV0dXJuIHRoaXMuYWRkKChzLnJlcGVhdCYmdS5Ud2Vlbk1heHx8aSkuZnJvbSh0LGUscykscil9LGQuZnJvbVRvPWZ1bmN0aW9uKHQsZSxzLHIsbil7dmFyIGE9ci5yZXBlYXQmJnUuVHdlZW5NYXh8fGk7cmV0dXJuIGU/dGhpcy5hZGQoYS5mcm9tVG8odCxlLHMsciksbik6dGhpcy5zZXQodCxyLG4pfSxkLnN0YWdnZXJUbz1mdW5jdGlvbih0LGUscixuLGEsbCxoLF8pe3ZhciB1LHAsZD1uZXcgcyh7b25Db21wbGV0ZTpsLG9uQ29tcGxldGVQYXJhbXM6aCxjYWxsYmFja1Njb3BlOl8sc21vb3RoQ2hpbGRUaW1pbmc6dGhpcy5zbW9vdGhDaGlsZFRpbWluZ30pLGc9ci5jeWNsZTtmb3IoXCJzdHJpbmdcIj09dHlwZW9mIHQmJih0PWkuc2VsZWN0b3IodCl8fHQpLHQ9dHx8W10sbyh0KSYmKHQ9bSh0KSksbj1ufHwwLDA+biYmKHQ9bSh0KSx0LnJldmVyc2UoKSxuKj0tMSkscD0wO3QubGVuZ3RoPnA7cCsrKXU9ZihyKSx1LnN0YXJ0QXQmJih1LnN0YXJ0QXQ9Zih1LnN0YXJ0QXQpLHUuc3RhcnRBdC5jeWNsZSYmYyh1LnN0YXJ0QXQsdCxwKSksZyYmYyh1LHQscCksZC50byh0W3BdLGUsdSxwKm4pO3JldHVybiB0aGlzLmFkZChkLGEpfSxkLnN0YWdnZXJGcm9tPWZ1bmN0aW9uKHQsZSxpLHMscixuLGEsbyl7cmV0dXJuIGkuaW1tZWRpYXRlUmVuZGVyPTAhPWkuaW1tZWRpYXRlUmVuZGVyLGkucnVuQmFja3dhcmRzPSEwLHRoaXMuc3RhZ2dlclRvKHQsZSxpLHMscixuLGEsbyl9LGQuc3RhZ2dlckZyb21Ubz1mdW5jdGlvbih0LGUsaSxzLHIsbixhLG8sbCl7cmV0dXJuIHMuc3RhcnRBdD1pLHMuaW1tZWRpYXRlUmVuZGVyPTAhPXMuaW1tZWRpYXRlUmVuZGVyJiYwIT1pLmltbWVkaWF0ZVJlbmRlcix0aGlzLnN0YWdnZXJUbyh0LGUscyxyLG4sYSxvLGwpfSxkLmNhbGw9ZnVuY3Rpb24odCxlLHMscil7cmV0dXJuIHRoaXMuYWRkKGkuZGVsYXllZENhbGwoMCx0LGUscykscil9LGQuc2V0PWZ1bmN0aW9uKHQsZSxzKXtyZXR1cm4gcz10aGlzLl9wYXJzZVRpbWVPckxhYmVsKHMsMCwhMCksbnVsbD09ZS5pbW1lZGlhdGVSZW5kZXImJihlLmltbWVkaWF0ZVJlbmRlcj1zPT09dGhpcy5fdGltZSYmIXRoaXMuX3BhdXNlZCksdGhpcy5hZGQobmV3IGkodCwwLGUpLHMpfSxzLmV4cG9ydFJvb3Q9ZnVuY3Rpb24odCxlKXt0PXR8fHt9LG51bGw9PXQuc21vb3RoQ2hpbGRUaW1pbmcmJih0LnNtb290aENoaWxkVGltaW5nPSEwKTt2YXIgcixuLGE9bmV3IHModCksbz1hLl90aW1lbGluZTtmb3IobnVsbD09ZSYmKGU9ITApLG8uX3JlbW92ZShhLCEwKSxhLl9zdGFydFRpbWU9MCxhLl9yYXdQcmV2VGltZT1hLl90aW1lPWEuX3RvdGFsVGltZT1vLl90aW1lLHI9by5fZmlyc3Q7cjspbj1yLl9uZXh0LGUmJnIgaW5zdGFuY2VvZiBpJiZyLnRhcmdldD09PXIudmFycy5vbkNvbXBsZXRlfHxhLmFkZChyLHIuX3N0YXJ0VGltZS1yLl9kZWxheSkscj1uO3JldHVybiBvLmFkZChhLDApLGF9LGQuYWRkPWZ1bmN0aW9uKHIsbixhLG8pe3ZhciBoLF8sdSxmLGMscDtpZihcIm51bWJlclwiIT10eXBlb2YgbiYmKG49dGhpcy5fcGFyc2VUaW1lT3JMYWJlbChuLDAsITAscikpLCEociBpbnN0YW5jZW9mIHQpKXtpZihyIGluc3RhbmNlb2YgQXJyYXl8fHImJnIucHVzaCYmbChyKSl7Zm9yKGE9YXx8XCJub3JtYWxcIixvPW98fDAsaD1uLF89ci5sZW5ndGgsdT0wO18+dTt1KyspbChmPXJbdV0pJiYoZj1uZXcgcyh7dHdlZW5zOmZ9KSksdGhpcy5hZGQoZixoKSxcInN0cmluZ1wiIT10eXBlb2YgZiYmXCJmdW5jdGlvblwiIT10eXBlb2YgZiYmKFwic2VxdWVuY2VcIj09PWE/aD1mLl9zdGFydFRpbWUrZi50b3RhbER1cmF0aW9uKCkvZi5fdGltZVNjYWxlOlwic3RhcnRcIj09PWEmJihmLl9zdGFydFRpbWUtPWYuZGVsYXkoKSkpLGgrPW87cmV0dXJuIHRoaXMuX3VuY2FjaGUoITApfWlmKFwic3RyaW5nXCI9PXR5cGVvZiByKXJldHVybiB0aGlzLmFkZExhYmVsKHIsbik7aWYoXCJmdW5jdGlvblwiIT10eXBlb2Ygcil0aHJvd1wiQ2Fubm90IGFkZCBcIityK1wiIGludG8gdGhlIHRpbWVsaW5lOyBpdCBpcyBub3QgYSB0d2VlbiwgdGltZWxpbmUsIGZ1bmN0aW9uLCBvciBzdHJpbmcuXCI7cj1pLmRlbGF5ZWRDYWxsKDAscil9aWYoZS5wcm90b3R5cGUuYWRkLmNhbGwodGhpcyxyLG4pLCh0aGlzLl9nY3x8dGhpcy5fdGltZT09PXRoaXMuX2R1cmF0aW9uKSYmIXRoaXMuX3BhdXNlZCYmdGhpcy5fZHVyYXRpb248dGhpcy5kdXJhdGlvbigpKWZvcihjPXRoaXMscD1jLnJhd1RpbWUoKT5yLl9zdGFydFRpbWU7Yy5fdGltZWxpbmU7KXAmJmMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nP2MudG90YWxUaW1lKGMuX3RvdGFsVGltZSwhMCk6Yy5fZ2MmJmMuX2VuYWJsZWQoITAsITEpLGM9Yy5fdGltZWxpbmU7cmV0dXJuIHRoaXN9LGQucmVtb3ZlPWZ1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiB0KXt0aGlzLl9yZW1vdmUoZSwhMSk7dmFyIGk9ZS5fdGltZWxpbmU9ZS52YXJzLnVzZUZyYW1lcz90Ll9yb290RnJhbWVzVGltZWxpbmU6dC5fcm9vdFRpbWVsaW5lO3JldHVybiBlLl9zdGFydFRpbWU9KGUuX3BhdXNlZD9lLl9wYXVzZVRpbWU6aS5fdGltZSktKGUuX3JldmVyc2VkP2UudG90YWxEdXJhdGlvbigpLWUuX3RvdGFsVGltZTplLl90b3RhbFRpbWUpL2UuX3RpbWVTY2FsZSx0aGlzfWlmKGUgaW5zdGFuY2VvZiBBcnJheXx8ZSYmZS5wdXNoJiZsKGUpKXtmb3IodmFyIHM9ZS5sZW5ndGg7LS1zPi0xOyl0aGlzLnJlbW92ZShlW3NdKTtyZXR1cm4gdGhpc31yZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZT90aGlzLnJlbW92ZUxhYmVsKGUpOnRoaXMua2lsbChudWxsLGUpfSxkLl9yZW1vdmU9ZnVuY3Rpb24odCxpKXtlLnByb3RvdHlwZS5fcmVtb3ZlLmNhbGwodGhpcyx0LGkpO3ZhciBzPXRoaXMuX2xhc3Q7cmV0dXJuIHM/dGhpcy5fdGltZT5zLl9zdGFydFRpbWUrcy5fdG90YWxEdXJhdGlvbi9zLl90aW1lU2NhbGUmJih0aGlzLl90aW1lPXRoaXMuZHVyYXRpb24oKSx0aGlzLl90b3RhbFRpbWU9dGhpcy5fdG90YWxEdXJhdGlvbik6dGhpcy5fdGltZT10aGlzLl90b3RhbFRpbWU9dGhpcy5fZHVyYXRpb249dGhpcy5fdG90YWxEdXJhdGlvbj0wLHRoaXN9LGQuYXBwZW5kPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYWRkKHQsdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChudWxsLGUsITAsdCkpfSxkLmluc2VydD1kLmluc2VydE11bHRpcGxlPWZ1bmN0aW9uKHQsZSxpLHMpe3JldHVybiB0aGlzLmFkZCh0LGV8fDAsaSxzKX0sZC5hcHBlbmRNdWx0aXBsZT1mdW5jdGlvbih0LGUsaSxzKXtyZXR1cm4gdGhpcy5hZGQodCx0aGlzLl9wYXJzZVRpbWVPckxhYmVsKG51bGwsZSwhMCx0KSxpLHMpfSxkLmFkZExhYmVsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2xhYmVsc1t0XT10aGlzLl9wYXJzZVRpbWVPckxhYmVsKGUpLHRoaXN9LGQuYWRkUGF1c2U9ZnVuY3Rpb24odCxlLHMscil7dmFyIG49aS5kZWxheWVkQ2FsbCgwLHAscyxyfHx0aGlzKTtyZXR1cm4gbi52YXJzLm9uQ29tcGxldGU9bi52YXJzLm9uUmV2ZXJzZUNvbXBsZXRlPWUsbi5kYXRhPVwiaXNQYXVzZVwiLHRoaXMuX2hhc1BhdXNlPSEwLHRoaXMuYWRkKG4sdCl9LGQucmVtb3ZlTGFiZWw9ZnVuY3Rpb24odCl7cmV0dXJuIGRlbGV0ZSB0aGlzLl9sYWJlbHNbdF0sdGhpc30sZC5nZXRMYWJlbFRpbWU9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPXRoaXMuX2xhYmVsc1t0XT90aGlzLl9sYWJlbHNbdF06LTF9LGQuX3BhcnNlVGltZU9yTGFiZWw9ZnVuY3Rpb24oZSxpLHMscil7dmFyIG47aWYociBpbnN0YW5jZW9mIHQmJnIudGltZWxpbmU9PT10aGlzKXRoaXMucmVtb3ZlKHIpO2Vsc2UgaWYociYmKHIgaW5zdGFuY2VvZiBBcnJheXx8ci5wdXNoJiZsKHIpKSlmb3Iobj1yLmxlbmd0aDstLW4+LTE7KXJbbl1pbnN0YW5jZW9mIHQmJnJbbl0udGltZWxpbmU9PT10aGlzJiZ0aGlzLnJlbW92ZShyW25dKTtpZihcInN0cmluZ1wiPT10eXBlb2YgaSlyZXR1cm4gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChpLHMmJlwibnVtYmVyXCI9PXR5cGVvZiBlJiZudWxsPT10aGlzLl9sYWJlbHNbaV0/ZS10aGlzLmR1cmF0aW9uKCk6MCxzKTtpZihpPWl8fDAsXCJzdHJpbmdcIiE9dHlwZW9mIGV8fCFpc05hTihlKSYmbnVsbD09dGhpcy5fbGFiZWxzW2VdKW51bGw9PWUmJihlPXRoaXMuZHVyYXRpb24oKSk7ZWxzZXtpZihuPWUuaW5kZXhPZihcIj1cIiksLTE9PT1uKXJldHVybiBudWxsPT10aGlzLl9sYWJlbHNbZV0/cz90aGlzLl9sYWJlbHNbZV09dGhpcy5kdXJhdGlvbigpK2k6aTp0aGlzLl9sYWJlbHNbZV0raTtpPXBhcnNlSW50KGUuY2hhckF0KG4tMSkrXCIxXCIsMTApKk51bWJlcihlLnN1YnN0cihuKzEpKSxlPW4+MT90aGlzLl9wYXJzZVRpbWVPckxhYmVsKGUuc3Vic3RyKDAsbi0xKSwwLHMpOnRoaXMuZHVyYXRpb24oKX1yZXR1cm4gTnVtYmVyKGUpK2l9LGQuc2Vlaz1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRvdGFsVGltZShcIm51bWJlclwiPT10eXBlb2YgdD90OnRoaXMuX3BhcnNlVGltZU9yTGFiZWwodCksZSE9PSExKX0sZC5zdG9wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGF1c2VkKCEwKX0sZC5nb3RvQW5kUGxheT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnBsYXkodCxlKX0sZC5nb3RvQW5kU3RvcD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnBhdXNlKHQsZSl9LGQucmVuZGVyPWZ1bmN0aW9uKHQsZSxpKXt0aGlzLl9nYyYmdGhpcy5fZW5hYmxlZCghMCwhMSk7dmFyIHMsbixhLG8sbCx1LGY9dGhpcy5fZGlydHk/dGhpcy50b3RhbER1cmF0aW9uKCk6dGhpcy5fdG90YWxEdXJhdGlvbixjPXRoaXMuX3RpbWUscD10aGlzLl9zdGFydFRpbWUsbT10aGlzLl90aW1lU2NhbGUsZD10aGlzLl9wYXVzZWQ7aWYodD49Zil0aGlzLl90b3RhbFRpbWU9dGhpcy5fdGltZT1mLHRoaXMuX3JldmVyc2VkfHx0aGlzLl9oYXNQYXVzZWRDaGlsZCgpfHwobj0hMCxvPVwib25Db21wbGV0ZVwiLGw9ISF0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4sMD09PXRoaXMuX2R1cmF0aW9uJiYoMD09PXR8fDA+dGhpcy5fcmF3UHJldlRpbWV8fHRoaXMuX3Jhd1ByZXZUaW1lPT09cikmJnRoaXMuX3Jhd1ByZXZUaW1lIT09dCYmdGhpcy5fZmlyc3QmJihsPSEwLHRoaXMuX3Jhd1ByZXZUaW1lPnImJihvPVwib25SZXZlcnNlQ29tcGxldGVcIikpKSx0aGlzLl9yYXdQcmV2VGltZT10aGlzLl9kdXJhdGlvbnx8IWV8fHR8fHRoaXMuX3Jhd1ByZXZUaW1lPT09dD90OnIsdD1mKzFlLTQ7ZWxzZSBpZigxZS03PnQpaWYodGhpcy5fdG90YWxUaW1lPXRoaXMuX3RpbWU9MCwoMCE9PWN8fDA9PT10aGlzLl9kdXJhdGlvbiYmdGhpcy5fcmF3UHJldlRpbWUhPT1yJiYodGhpcy5fcmF3UHJldlRpbWU+MHx8MD50JiZ0aGlzLl9yYXdQcmV2VGltZT49MCkpJiYobz1cIm9uUmV2ZXJzZUNvbXBsZXRlXCIsbj10aGlzLl9yZXZlcnNlZCksMD50KXRoaXMuX2FjdGl2ZT0hMSx0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4mJnRoaXMuX3JldmVyc2VkPyhsPW49ITAsbz1cIm9uUmV2ZXJzZUNvbXBsZXRlXCIpOnRoaXMuX3Jhd1ByZXZUaW1lPj0wJiZ0aGlzLl9maXJzdCYmKGw9ITApLHRoaXMuX3Jhd1ByZXZUaW1lPXQ7ZWxzZXtpZih0aGlzLl9yYXdQcmV2VGltZT10aGlzLl9kdXJhdGlvbnx8IWV8fHR8fHRoaXMuX3Jhd1ByZXZUaW1lPT09dD90OnIsMD09PXQmJm4pZm9yKHM9dGhpcy5fZmlyc3Q7cyYmMD09PXMuX3N0YXJ0VGltZTspcy5fZHVyYXRpb258fChuPSExKSxzPXMuX25leHQ7dD0wLHRoaXMuX2luaXR0ZWR8fChsPSEwKX1lbHNle2lmKHRoaXMuX2hhc1BhdXNlJiYhdGhpcy5fZm9yY2luZ1BsYXloZWFkJiYhZSl7aWYodD49Yylmb3Iocz10aGlzLl9maXJzdDtzJiZ0Pj1zLl9zdGFydFRpbWUmJiF1OylzLl9kdXJhdGlvbnx8XCJpc1BhdXNlXCIhPT1zLmRhdGF8fHMucmF0aW98fDA9PT1zLl9zdGFydFRpbWUmJjA9PT10aGlzLl9yYXdQcmV2VGltZXx8KHU9cykscz1zLl9uZXh0O2Vsc2UgZm9yKHM9dGhpcy5fbGFzdDtzJiZzLl9zdGFydFRpbWU+PXQmJiF1OylzLl9kdXJhdGlvbnx8XCJpc1BhdXNlXCI9PT1zLmRhdGEmJnMuX3Jhd1ByZXZUaW1lPjAmJih1PXMpLHM9cy5fcHJldjt1JiYodGhpcy5fdGltZT10PXUuX3N0YXJ0VGltZSx0aGlzLl90b3RhbFRpbWU9dCt0aGlzLl9jeWNsZSoodGhpcy5fdG90YWxEdXJhdGlvbit0aGlzLl9yZXBlYXREZWxheSkpfXRoaXMuX3RvdGFsVGltZT10aGlzLl90aW1lPXRoaXMuX3Jhd1ByZXZUaW1lPXR9aWYodGhpcy5fdGltZSE9PWMmJnRoaXMuX2ZpcnN0fHxpfHxsfHx1KXtpZih0aGlzLl9pbml0dGVkfHwodGhpcy5faW5pdHRlZD0hMCksdGhpcy5fYWN0aXZlfHwhdGhpcy5fcGF1c2VkJiZ0aGlzLl90aW1lIT09YyYmdD4wJiYodGhpcy5fYWN0aXZlPSEwKSwwPT09YyYmdGhpcy52YXJzLm9uU3RhcnQmJjAhPT10aGlzLl90aW1lJiYoZXx8dGhpcy5fY2FsbGJhY2soXCJvblN0YXJ0XCIpKSx0aGlzLl90aW1lPj1jKWZvcihzPXRoaXMuX2ZpcnN0O3MmJihhPXMuX25leHQsIXRoaXMuX3BhdXNlZHx8ZCk7KShzLl9hY3RpdmV8fHMuX3N0YXJ0VGltZTw9dGhpcy5fdGltZSYmIXMuX3BhdXNlZCYmIXMuX2djKSYmKHU9PT1zJiZ0aGlzLnBhdXNlKCkscy5fcmV2ZXJzZWQ/cy5yZW5kZXIoKHMuX2RpcnR5P3MudG90YWxEdXJhdGlvbigpOnMuX3RvdGFsRHVyYXRpb24pLSh0LXMuX3N0YXJ0VGltZSkqcy5fdGltZVNjYWxlLGUsaSk6cy5yZW5kZXIoKHQtcy5fc3RhcnRUaW1lKSpzLl90aW1lU2NhbGUsZSxpKSkscz1hO2Vsc2UgZm9yKHM9dGhpcy5fbGFzdDtzJiYoYT1zLl9wcmV2LCF0aGlzLl9wYXVzZWR8fGQpOyl7aWYocy5fYWN0aXZlfHxjPj1zLl9zdGFydFRpbWUmJiFzLl9wYXVzZWQmJiFzLl9nYyl7aWYodT09PXMpe2Zvcih1PXMuX3ByZXY7dSYmdS5lbmRUaW1lKCk+dGhpcy5fdGltZTspdS5yZW5kZXIodS5fcmV2ZXJzZWQ/dS50b3RhbER1cmF0aW9uKCktKHQtdS5fc3RhcnRUaW1lKSp1Ll90aW1lU2NhbGU6KHQtdS5fc3RhcnRUaW1lKSp1Ll90aW1lU2NhbGUsZSxpKSx1PXUuX3ByZXY7dT1udWxsLHRoaXMucGF1c2UoKX1zLl9yZXZlcnNlZD9zLnJlbmRlcigocy5fZGlydHk/cy50b3RhbER1cmF0aW9uKCk6cy5fdG90YWxEdXJhdGlvbiktKHQtcy5fc3RhcnRUaW1lKSpzLl90aW1lU2NhbGUsZSxpKTpzLnJlbmRlcigodC1zLl9zdGFydFRpbWUpKnMuX3RpbWVTY2FsZSxlLGkpfXM9YX10aGlzLl9vblVwZGF0ZSYmKGV8fChoLmxlbmd0aCYmXygpLHRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIikpKSxvJiYodGhpcy5fZ2N8fChwPT09dGhpcy5fc3RhcnRUaW1lfHxtIT09dGhpcy5fdGltZVNjYWxlKSYmKDA9PT10aGlzLl90aW1lfHxmPj10aGlzLnRvdGFsRHVyYXRpb24oKSkmJihuJiYoaC5sZW5ndGgmJl8oKSx0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4mJnRoaXMuX2VuYWJsZWQoITEsITEpLHRoaXMuX2FjdGl2ZT0hMSksIWUmJnRoaXMudmFyc1tvXSYmdGhpcy5fY2FsbGJhY2sobykpKX19LGQuX2hhc1BhdXNlZENoaWxkPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuX2ZpcnN0O3Q7KXtpZih0Ll9wYXVzZWR8fHQgaW5zdGFuY2VvZiBzJiZ0Ll9oYXNQYXVzZWRDaGlsZCgpKXJldHVybiEwO3Q9dC5fbmV4dH1yZXR1cm4hMX0sZC5nZXRDaGlsZHJlbj1mdW5jdGlvbih0LGUscyxyKXtyPXJ8fC05OTk5OTk5OTk5O2Zvcih2YXIgbj1bXSxhPXRoaXMuX2ZpcnN0LG89MDthOylyPmEuX3N0YXJ0VGltZXx8KGEgaW5zdGFuY2VvZiBpP2UhPT0hMSYmKG5bbysrXT1hKToocyE9PSExJiYobltvKytdPWEpLHQhPT0hMSYmKG49bi5jb25jYXQoYS5nZXRDaGlsZHJlbighMCxlLHMpKSxvPW4ubGVuZ3RoKSkpLGE9YS5fbmV4dDtyZXR1cm4gbn0sZC5nZXRUd2VlbnNPZj1mdW5jdGlvbih0LGUpe3ZhciBzLHIsbj10aGlzLl9nYyxhPVtdLG89MDtmb3IobiYmdGhpcy5fZW5hYmxlZCghMCwhMCkscz1pLmdldFR3ZWVuc09mKHQpLHI9cy5sZW5ndGg7LS1yPi0xOykoc1tyXS50aW1lbGluZT09PXRoaXN8fGUmJnRoaXMuX2NvbnRhaW5zKHNbcl0pKSYmKGFbbysrXT1zW3JdKTtyZXR1cm4gbiYmdGhpcy5fZW5hYmxlZCghMSwhMCksYX0sZC5yZWNlbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmVjZW50fSxkLl9jb250YWlucz1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC50aW1lbGluZTtlOyl7aWYoZT09PXRoaXMpcmV0dXJuITA7ZT1lLnRpbWVsaW5lfXJldHVybiExfSxkLnNoaWZ0Q2hpbGRyZW49ZnVuY3Rpb24odCxlLGkpe2k9aXx8MDtmb3IodmFyIHMscj10aGlzLl9maXJzdCxuPXRoaXMuX2xhYmVscztyOylyLl9zdGFydFRpbWU+PWkmJihyLl9zdGFydFRpbWUrPXQpLHI9ci5fbmV4dDtpZihlKWZvcihzIGluIG4pbltzXT49aSYmKG5bc10rPXQpO3JldHVybiB0aGlzLl91bmNhY2hlKCEwKX0sZC5fa2lsbD1mdW5jdGlvbih0LGUpe2lmKCF0JiYhZSlyZXR1cm4gdGhpcy5fZW5hYmxlZCghMSwhMSk7Zm9yKHZhciBpPWU/dGhpcy5nZXRUd2VlbnNPZihlKTp0aGlzLmdldENoaWxkcmVuKCEwLCEwLCExKSxzPWkubGVuZ3RoLHI9ITE7LS1zPi0xOylpW3NdLl9raWxsKHQsZSkmJihyPSEwKTtyZXR1cm4gcn0sZC5jbGVhcj1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldENoaWxkcmVuKCExLCEwLCEwKSxpPWUubGVuZ3RoO2Zvcih0aGlzLl90aW1lPXRoaXMuX3RvdGFsVGltZT0wOy0taT4tMTspZVtpXS5fZW5hYmxlZCghMSwhMSk7cmV0dXJuIHQhPT0hMSYmKHRoaXMuX2xhYmVscz17fSksdGhpcy5fdW5jYWNoZSghMCl9LGQuaW52YWxpZGF0ZT1mdW5jdGlvbigpe2Zvcih2YXIgZT10aGlzLl9maXJzdDtlOyllLmludmFsaWRhdGUoKSxlPWUuX25leHQ7cmV0dXJuIHQucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKX0sZC5fZW5hYmxlZD1mdW5jdGlvbih0LGkpe2lmKHQ9PT10aGlzLl9nYylmb3IodmFyIHM9dGhpcy5fZmlyc3Q7czspcy5fZW5hYmxlZCh0LCEwKSxzPXMuX25leHQ7cmV0dXJuIGUucHJvdG90eXBlLl9lbmFibGVkLmNhbGwodGhpcyx0LGkpfSxkLnRvdGFsVGltZT1mdW5jdGlvbigpe3RoaXMuX2ZvcmNpbmdQbGF5aGVhZD0hMDt2YXIgZT10LnByb3RvdHlwZS50b3RhbFRpbWUuYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB0aGlzLl9mb3JjaW5nUGxheWhlYWQ9ITEsZX0sZC5kdXJhdGlvbj1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oMCE9PXRoaXMuZHVyYXRpb24oKSYmMCE9PXQmJnRoaXMudGltZVNjYWxlKHRoaXMuX2R1cmF0aW9uL3QpLHRoaXMpOih0aGlzLl9kaXJ0eSYmdGhpcy50b3RhbER1cmF0aW9uKCksdGhpcy5fZHVyYXRpb24pfSxkLnRvdGFsRHVyYXRpb249ZnVuY3Rpb24odCl7aWYoIWFyZ3VtZW50cy5sZW5ndGgpe2lmKHRoaXMuX2RpcnR5KXtmb3IodmFyIGUsaSxzPTAscj10aGlzLl9sYXN0LG49OTk5OTk5OTk5OTk5O3I7KWU9ci5fcHJldixyLl9kaXJ0eSYmci50b3RhbER1cmF0aW9uKCksci5fc3RhcnRUaW1lPm4mJnRoaXMuX3NvcnRDaGlsZHJlbiYmIXIuX3BhdXNlZD90aGlzLmFkZChyLHIuX3N0YXJ0VGltZS1yLl9kZWxheSk6bj1yLl9zdGFydFRpbWUsMD5yLl9zdGFydFRpbWUmJiFyLl9wYXVzZWQmJihzLT1yLl9zdGFydFRpbWUsdGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcmJih0aGlzLl9zdGFydFRpbWUrPXIuX3N0YXJ0VGltZS90aGlzLl90aW1lU2NhbGUpLHRoaXMuc2hpZnRDaGlsZHJlbigtci5fc3RhcnRUaW1lLCExLC05OTk5OTk5OTk5KSxuPTApLGk9ci5fc3RhcnRUaW1lK3IuX3RvdGFsRHVyYXRpb24vci5fdGltZVNjYWxlLGk+cyYmKHM9aSkscj1lO3RoaXMuX2R1cmF0aW9uPXRoaXMuX3RvdGFsRHVyYXRpb249cyx0aGlzLl9kaXJ0eT0hMX1yZXR1cm4gdGhpcy5fdG90YWxEdXJhdGlvbn1yZXR1cm4gMCE9PXRoaXMudG90YWxEdXJhdGlvbigpJiYwIT09dCYmdGhpcy50aW1lU2NhbGUodGhpcy5fdG90YWxEdXJhdGlvbi90KSx0aGlzfSxkLnBhdXNlZD1mdW5jdGlvbihlKXtpZighZSlmb3IodmFyIGk9dGhpcy5fZmlyc3Qscz10aGlzLl90aW1lO2k7KWkuX3N0YXJ0VGltZT09PXMmJlwiaXNQYXVzZVwiPT09aS5kYXRhJiYoaS5fcmF3UHJldlRpbWU9MCksaT1pLl9uZXh0O3JldHVybiB0LnByb3RvdHlwZS5wYXVzZWQuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxkLnVzZXNGcmFtZXM9ZnVuY3Rpb24oKXtmb3IodmFyIGU9dGhpcy5fdGltZWxpbmU7ZS5fdGltZWxpbmU7KWU9ZS5fdGltZWxpbmU7cmV0dXJuIGU9PT10Ll9yb290RnJhbWVzVGltZWxpbmV9LGQucmF3VGltZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9wYXVzZWQ/dGhpcy5fdG90YWxUaW1lOih0aGlzLl90aW1lbGluZS5yYXdUaW1lKCktdGhpcy5fc3RhcnRUaW1lKSp0aGlzLl90aW1lU2NhbGV9LHN9LCEwKX0pLF9nc1Njb3BlLl9nc0RlZmluZSYmX2dzU2NvcGUuX2dzUXVldWUucG9wKCkoKSxmdW5jdGlvbih0KXtcInVzZSBzdHJpY3RcIjt2YXIgZT1mdW5jdGlvbigpe3JldHVybihfZ3NTY29wZS5HcmVlblNvY2tHbG9iYWxzfHxfZ3NTY29wZSlbdF19O1wiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wiVHdlZW5MaXRlXCJdLGUpOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzJiYocmVxdWlyZShcIi4vVHdlZW5MaXRlLmpzXCIpLG1vZHVsZS5leHBvcnRzPWUoKSl9KFwiVGltZWxpbmVMaXRlXCIpO1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldDp1dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbk55WXk5cVlYWmhjMk55YVhCMEwyeHBZbk12VkhkbFpXNU5ZWGd2VkdsdFpXeHBibVZNYVhSbExtcHpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFaUxDSm1hV3hsSWpvaVoyVnVaWEpoZEdWa0xtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJaThxSVZ4dUlDb2dWa1ZTVTBsUFRqb2dNUzR4T0M0d1hHNGdLaUJFUVZSRk9pQXlNREUxTFRBNExUSTVYRzRnS2lCVlVFUkJWRVZUSUVGT1JDQkVUME5USUVGVU9pQm9kSFJ3T2k4dlozSmxaVzV6YjJOckxtTnZiVnh1SUNwY2JpQXFJRUJzYVdObGJuTmxJRU52Y0hseWFXZG9kQ0FvWXlrZ01qQXdPQzB5TURFMUxDQkhjbVZsYmxOdlkyc3VJRUZzYkNCeWFXZG9kSE1nY21WelpYSjJaV1F1WEc0Z0tpQlVhR2x6SUhkdmNtc2dhWE1nYzNWaWFtVmpkQ0IwYnlCMGFHVWdkR1Z5YlhNZ1lYUWdhSFIwY0RvdkwyZHlaV1Z1YzI5amF5NWpiMjB2YzNSaGJtUmhjbVF0YkdsalpXNXpaU0J2Y2lCbWIzSmNiaUFxSUVOc2RXSWdSM0psWlc1VGIyTnJJRzFsYldKbGNuTXNJSFJvWlNCemIyWjBkMkZ5WlNCaFozSmxaVzFsYm5RZ2RHaGhkQ0IzWVhNZ2FYTnpkV1ZrSUhkcGRHZ2dlVzkxY2lCdFpXMWlaWEp6YUdsd0xseHVJQ29nWEc0Z0tpQkFZWFYwYUc5eU9pQktZV05ySUVSdmVXeGxMQ0JxWVdOclFHZHlaV1Z1YzI5amF5NWpiMjFjYmlBcUwxeHVkbUZ5SUY5bmMxTmpiM0JsUFZ3aWRXNWtaV1pwYm1Wa1hDSWhQWFI1Y0dWdlppQnRiMlIxYkdVbUptMXZaSFZzWlM1bGVIQnZjblJ6SmlaY0luVnVaR1ZtYVc1bFpGd2lJVDEwZVhCbGIyWWdaMnh2WW1Gc1AyZHNiMkpoYkRwMGFHbHpmSHgzYVc1a2IzYzdLRjluYzFOamIzQmxMbDluYzFGMVpYVmxmSHdvWDJkelUyTnZjR1V1WDJkelVYVmxkV1U5VzEwcEtTNXdkWE5vS0daMWJtTjBhVzl1S0NsN1hDSjFjMlVnYzNSeWFXTjBYQ0k3WDJkelUyTnZjR1V1WDJkelJHVm1hVzVsS0Z3aVZHbHRaV3hwYm1WTWFYUmxYQ0lzVzF3aVkyOXlaUzVCYm1sdFlYUnBiMjVjSWl4Y0ltTnZjbVV1VTJsdGNHeGxWR2x0Wld4cGJtVmNJaXhjSWxSM1pXVnVUR2wwWlZ3aVhTeG1kVzVqZEdsdmJpaDBMR1VzYVNsN2RtRnlJSE05Wm5WdVkzUnBiMjRvZENsN1pTNWpZV3hzS0hSb2FYTXNkQ2tzZEdocGN5NWZiR0ZpWld4elBYdDlMSFJvYVhNdVlYVjBiMUpsYlc5MlpVTm9hV3hrY21WdVBYUm9hWE11ZG1GeWN5NWhkWFJ2VW1WdGIzWmxRMmhwYkdSeVpXNDlQVDBoTUN4MGFHbHpMbk50YjI5MGFFTm9hV3hrVkdsdGFXNW5QWFJvYVhNdWRtRnljeTV6Ylc5dmRHaERhR2xzWkZScGJXbHVaejA5UFNFd0xIUm9hWE11WDNOdmNuUkRhR2xzWkhKbGJqMGhNQ3gwYUdsekxsOXZibFZ3WkdGMFpUMTBhR2x6TG5aaGNuTXViMjVWY0dSaGRHVTdkbUZ5SUdrc2N5eHlQWFJvYVhNdWRtRnljenRtYjNJb2N5QnBiaUJ5S1drOWNsdHpYU3hzS0drcEppWXRNU0U5UFdrdWFtOXBiaWhjSWx3aUtTNXBibVJsZUU5bUtGd2llM05sYkdaOVhDSXBKaVlvY2x0elhUMTBhR2x6TGw5emQyRndVMlZzWmtsdVVHRnlZVzF6S0drcEtUdHNLSEl1ZEhkbFpXNXpLU1ltZEdocGN5NWhaR1FvY2k1MGQyVmxibk1zTUN4eUxtRnNhV2R1TEhJdWMzUmhaMmRsY2lsOUxISTlNV1V0TVRBc2JqMXBMbDlwYm5SbGNtNWhiSE1zWVQxekxsOXBiblJsY201aGJITTllMzBzYnoxdUxtbHpVMlZzWldOMGIzSXNiRDF1TG1selFYSnlZWGtzYUQxdUxteGhlbmxVZDJWbGJuTXNYejF1TG14aGVubFNaVzVrWlhJc2RUMWZaM05UWTI5d1pTNWZaM05FWldacGJtVXVaMnh2WW1Gc2N5eG1QV1oxYm1OMGFXOXVLSFFwZTNaaGNpQmxMR2s5ZTMwN1ptOXlLR1VnYVc0Z2RDbHBXMlZkUFhSYlpWMDdjbVYwZFhKdUlHbDlMR005Wm5WdVkzUnBiMjRvZEN4bExHa3BlM1poY2lCekxISXNiajEwTG1ONVkyeGxPMlp2Y2loeklHbHVJRzRwY2oxdVczTmRMSFJiYzEwOVhDSm1kVzVqZEdsdmJsd2lQVDEwZVhCbGIyWWdjajl5TG1OaGJHd29aVnRwWFN4cEtUcHlXMmtsY2k1c1pXNW5kR2hkTzJSbGJHVjBaU0IwTG1ONVkyeGxmU3h3UFdFdWNHRjFjMlZEWVd4c1ltRmphejFtZFc1amRHbHZiaWdwZTMwc2JUMW1kVzVqZEdsdmJpaDBLWHQyWVhJZ1pTeHBQVnRkTEhNOWRDNXNaVzVuZEdnN1ptOXlLR1U5TUR0bElUMDljenRwTG5CMWMyZ29kRnRsS3l0ZEtTazdjbVYwZFhKdUlHbDlMR1E5Y3k1d2NtOTBiM1I1Y0dVOWJtVjNJR1U3Y21WMGRYSnVJSE11ZG1WeWMybHZiajFjSWpFdU1UZ3VNRndpTEdRdVkyOXVjM1J5ZFdOMGIzSTljeXhrTG10cGJHd29LUzVmWjJNOVpDNWZabTl5WTJsdVoxQnNZWGxvWldGa1BXUXVYMmhoYzFCaGRYTmxQU0V4TEdRdWRHODlablZ1WTNScGIyNG9kQ3hsTEhNc2NpbDdkbUZ5SUc0OWN5NXlaWEJsWVhRbUpuVXVWSGRsWlc1TllYaDhmR2s3Y21WMGRYSnVJR1UvZEdocGN5NWhaR1FvYm1WM0lHNG9kQ3hsTEhNcExISXBPblJvYVhNdWMyVjBLSFFzY3l4eUtYMHNaQzVtY205dFBXWjFibU4wYVc5dUtIUXNaU3h6TEhJcGUzSmxkSFZ5YmlCMGFHbHpMbUZrWkNnb2N5NXlaWEJsWVhRbUpuVXVWSGRsWlc1TllYaDhmR2twTG1aeWIyMG9kQ3hsTEhNcExISXBmU3hrTG1aeWIyMVViejFtZFc1amRHbHZiaWgwTEdVc2N5eHlMRzRwZTNaaGNpQmhQWEl1Y21Wd1pXRjBKaVoxTGxSM1pXVnVUV0Y0Zkh4cE8zSmxkSFZ5YmlCbFAzUm9hWE11WVdSa0tHRXVabkp2YlZSdktIUXNaU3h6TEhJcExHNHBPblJvYVhNdWMyVjBLSFFzY2l4dUtYMHNaQzV6ZEdGbloyVnlWRzg5Wm5WdVkzUnBiMjRvZEN4bExISXNiaXhoTEd3c2FDeGZLWHQyWVhJZ2RTeHdMR1E5Ym1WM0lITW9lMjl1UTI5dGNHeGxkR1U2YkN4dmJrTnZiWEJzWlhSbFVHRnlZVzF6T21nc1kyRnNiR0poWTJ0VFkyOXdaVHBmTEhOdGIyOTBhRU5vYVd4a1ZHbHRhVzVuT25Sb2FYTXVjMjF2YjNSb1EyaHBiR1JVYVcxcGJtZDlLU3huUFhJdVkzbGpiR1U3Wm05eUtGd2ljM1J5YVc1blhDSTlQWFI1Y0dWdlppQjBKaVlvZEQxcExuTmxiR1ZqZEc5eUtIUXBmSHgwS1N4MFBYUjhmRnRkTEc4b2RDa21KaWgwUFcwb2RDa3BMRzQ5Ym54OE1Dd3dQbTRtSmloMFBXMG9kQ2tzZEM1eVpYWmxjbk5sS0Nrc2JpbzlMVEVwTEhBOU1EdDBMbXhsYm1kMGFENXdPM0FyS3lsMVBXWW9jaWtzZFM1emRHRnlkRUYwSmlZb2RTNXpkR0Z5ZEVGMFBXWW9kUzV6ZEdGeWRFRjBLU3gxTG5OMFlYSjBRWFF1WTNsamJHVW1KbU1vZFM1emRHRnlkRUYwTEhRc2NDa3BMR2NtSm1Nb2RTeDBMSEFwTEdRdWRHOG9kRnR3WFN4bExIVXNjQ3B1S1R0eVpYUjFjbTRnZEdocGN5NWhaR1FvWkN4aEtYMHNaQzV6ZEdGbloyVnlSbkp2YlQxbWRXNWpkR2x2YmloMExHVXNhU3h6TEhJc2JpeGhMRzhwZTNKbGRIVnliaUJwTG1sdGJXVmthV0YwWlZKbGJtUmxjajB3SVQxcExtbHRiV1ZrYVdGMFpWSmxibVJsY2l4cExuSjFia0poWTJ0M1lYSmtjejBoTUN4MGFHbHpMbk4wWVdkblpYSlVieWgwTEdVc2FTeHpMSElzYml4aExHOHBmU3hrTG5OMFlXZG5aWEpHY205dFZHODlablZ1WTNScGIyNG9kQ3hsTEdrc2N5eHlMRzRzWVN4dkxHd3BlM0psZEhWeWJpQnpMbk4wWVhKMFFYUTlhU3h6TG1sdGJXVmthV0YwWlZKbGJtUmxjajB3SVQxekxtbHRiV1ZrYVdGMFpWSmxibVJsY2lZbU1DRTlhUzVwYlcxbFpHbGhkR1ZTWlc1a1pYSXNkR2hwY3k1emRHRm5aMlZ5Vkc4b2RDeGxMSE1zY2l4dUxHRXNieXhzS1gwc1pDNWpZV3hzUFdaMWJtTjBhVzl1S0hRc1pTeHpMSElwZTNKbGRIVnliaUIwYUdsekxtRmtaQ2hwTG1SbGJHRjVaV1JEWVd4c0tEQXNkQ3hsTEhNcExISXBmU3hrTG5ObGREMW1kVzVqZEdsdmJpaDBMR1VzY3lsN2NtVjBkWEp1SUhNOWRHaHBjeTVmY0dGeWMyVlVhVzFsVDNKTVlXSmxiQ2h6TERBc0lUQXBMRzUxYkd3OVBXVXVhVzF0WldScFlYUmxVbVZ1WkdWeUppWW9aUzVwYlcxbFpHbGhkR1ZTWlc1a1pYSTljejA5UFhSb2FYTXVYM1JwYldVbUppRjBhR2x6TGw5d1lYVnpaV1FwTEhSb2FYTXVZV1JrS0c1bGR5QnBLSFFzTUN4bEtTeHpLWDBzY3k1bGVIQnZjblJTYjI5MFBXWjFibU4wYVc5dUtIUXNaU2w3ZEQxMGZIeDdmU3h1ZFd4c1BUMTBMbk50YjI5MGFFTm9hV3hrVkdsdGFXNW5KaVlvZEM1emJXOXZkR2hEYUdsc1pGUnBiV2x1WnowaE1DazdkbUZ5SUhJc2JpeGhQVzVsZHlCektIUXBMRzg5WVM1ZmRHbHRaV3hwYm1VN1ptOXlLRzUxYkd3OVBXVW1KaWhsUFNFd0tTeHZMbDl5WlcxdmRtVW9ZU3doTUNrc1lTNWZjM1JoY25SVWFXMWxQVEFzWVM1ZmNtRjNVSEpsZGxScGJXVTlZUzVmZEdsdFpUMWhMbDkwYjNSaGJGUnBiV1U5Ynk1ZmRHbHRaU3h5UFc4dVgyWnBjbk4wTzNJN0tXNDljaTVmYm1WNGRDeGxKaVp5SUdsdWMzUmhibU5sYjJZZ2FTWW1jaTUwWVhKblpYUTlQVDF5TG5aaGNuTXViMjVEYjIxd2JHVjBaWHg4WVM1aFpHUW9jaXh5TGw5emRHRnlkRlJwYldVdGNpNWZaR1ZzWVhrcExISTlianR5WlhSMWNtNGdieTVoWkdRb1lTd3dLU3hoZlN4a0xtRmtaRDFtZFc1amRHbHZiaWh5TEc0c1lTeHZLWHQyWVhJZ2FDeGZMSFVzWml4akxIQTdhV1lvWENKdWRXMWlaWEpjSWlFOWRIbHdaVzltSUc0bUppaHVQWFJvYVhNdVgzQmhjbk5sVkdsdFpVOXlUR0ZpWld3b2Jpd3dMQ0V3TEhJcEtTd2hLSElnYVc1emRHRnVZMlZ2WmlCMEtTbDdhV1lvY2lCcGJuTjBZVzVqWlc5bUlFRnljbUY1Zkh4eUppWnlMbkIxYzJnbUptd29jaWtwZTJadmNpaGhQV0Y4ZkZ3aWJtOXliV0ZzWENJc2J6MXZmSHd3TEdnOWJpeGZQWEl1YkdWdVozUm9MSFU5TUR0ZlBuVTdkU3NyS1d3b1pqMXlXM1ZkS1NZbUtHWTlibVYzSUhNb2UzUjNaV1Z1Y3pwbWZTa3BMSFJvYVhNdVlXUmtLR1lzYUNrc1hDSnpkSEpwYm1kY0lpRTlkSGx3Wlc5bUlHWW1KbHdpWm5WdVkzUnBiMjVjSWlFOWRIbHdaVzltSUdZbUppaGNJbk5sY1hWbGJtTmxYQ0k5UFQxaFAyZzlaaTVmYzNSaGNuUlVhVzFsSzJZdWRHOTBZV3hFZFhKaGRHbHZiaWdwTDJZdVgzUnBiV1ZUWTJGc1pUcGNJbk4wWVhKMFhDSTlQVDFoSmlZb1ppNWZjM1JoY25SVWFXMWxMVDFtTG1SbGJHRjVLQ2twS1N4b0t6MXZPM0psZEhWeWJpQjBhR2x6TGw5MWJtTmhZMmhsS0NFd0tYMXBaaWhjSW5OMGNtbHVaMXdpUFQxMGVYQmxiMllnY2lseVpYUjFjbTRnZEdocGN5NWhaR1JNWVdKbGJDaHlMRzRwTzJsbUtGd2lablZ1WTNScGIyNWNJaUU5ZEhsd1pXOW1JSElwZEdoeWIzZGNJa05oYm01dmRDQmhaR1FnWENJcmNpdGNJaUJwYm5SdklIUm9aU0IwYVcxbGJHbHVaVHNnYVhRZ2FYTWdibTkwSUdFZ2RIZGxaVzRzSUhScGJXVnNhVzVsTENCbWRXNWpkR2x2Yml3Z2IzSWdjM1J5YVc1bkxsd2lPM0k5YVM1a1pXeGhlV1ZrUTJGc2JDZ3dMSElwZldsbUtHVXVjSEp2ZEc5MGVYQmxMbUZrWkM1allXeHNLSFJvYVhNc2NpeHVLU3dvZEdocGN5NWZaMk44ZkhSb2FYTXVYM1JwYldVOVBUMTBhR2x6TGw5a2RYSmhkR2x2YmlrbUppRjBhR2x6TGw5d1lYVnpaV1FtSm5Sb2FYTXVYMlIxY21GMGFXOXVQSFJvYVhNdVpIVnlZWFJwYjI0b0tTbG1iM0lvWXoxMGFHbHpMSEE5WXk1eVlYZFVhVzFsS0NrK2NpNWZjM1JoY25SVWFXMWxPMk11WDNScGJXVnNhVzVsT3lsd0ppWmpMbDkwYVcxbGJHbHVaUzV6Ylc5dmRHaERhR2xzWkZScGJXbHVaejlqTG5SdmRHRnNWR2x0WlNoakxsOTBiM1JoYkZScGJXVXNJVEFwT21NdVgyZGpKaVpqTGw5bGJtRmliR1ZrS0NFd0xDRXhLU3hqUFdNdVgzUnBiV1ZzYVc1bE8zSmxkSFZ5YmlCMGFHbHpmU3hrTG5KbGJXOTJaVDFtZFc1amRHbHZiaWhsS1h0cFppaGxJR2x1YzNSaGJtTmxiMllnZENsN2RHaHBjeTVmY21WdGIzWmxLR1VzSVRFcE8zWmhjaUJwUFdVdVgzUnBiV1ZzYVc1bFBXVXVkbUZ5Y3k1MWMyVkdjbUZ0WlhNL2RDNWZjbTl2ZEVaeVlXMWxjMVJwYldWc2FXNWxPblF1WDNKdmIzUlVhVzFsYkdsdVpUdHlaWFIxY200Z1pTNWZjM1JoY25SVWFXMWxQU2hsTGw5d1lYVnpaV1EvWlM1ZmNHRjFjMlZVYVcxbE9ta3VYM1JwYldVcExTaGxMbDl5WlhabGNuTmxaRDlsTG5SdmRHRnNSSFZ5WVhScGIyNG9LUzFsTGw5MGIzUmhiRlJwYldVNlpTNWZkRzkwWVd4VWFXMWxLUzlsTGw5MGFXMWxVMk5oYkdVc2RHaHBjMzFwWmlobElHbHVjM1JoYm1ObGIyWWdRWEp5WVhsOGZHVW1KbVV1Y0hWemFDWW1iQ2hsS1NsN1ptOXlLSFpoY2lCelBXVXViR1Z1WjNSb095MHRjejR0TVRzcGRHaHBjeTV5WlcxdmRtVW9aVnR6WFNrN2NtVjBkWEp1SUhSb2FYTjljbVYwZFhKdVhDSnpkSEpwYm1kY0lqMDlkSGx3Wlc5bUlHVS9kR2hwY3k1eVpXMXZkbVZNWVdKbGJDaGxLVHAwYUdsekxtdHBiR3dvYm5Wc2JDeGxLWDBzWkM1ZmNtVnRiM1psUFdaMWJtTjBhVzl1S0hRc2FTbDdaUzV3Y205MGIzUjVjR1V1WDNKbGJXOTJaUzVqWVd4c0tIUm9hWE1zZEN4cEtUdDJZWElnY3oxMGFHbHpMbDlzWVhOME8zSmxkSFZ5YmlCelAzUm9hWE11WDNScGJXVStjeTVmYzNSaGNuUlVhVzFsSzNNdVgzUnZkR0ZzUkhWeVlYUnBiMjR2Y3k1ZmRHbHRaVk5qWVd4bEppWW9kR2hwY3k1ZmRHbHRaVDEwYUdsekxtUjFjbUYwYVc5dUtDa3NkR2hwY3k1ZmRHOTBZV3hVYVcxbFBYUm9hWE11WDNSdmRHRnNSSFZ5WVhScGIyNHBPblJvYVhNdVgzUnBiV1U5ZEdocGN5NWZkRzkwWVd4VWFXMWxQWFJvYVhNdVgyUjFjbUYwYVc5dVBYUm9hWE11WDNSdmRHRnNSSFZ5WVhScGIyNDlNQ3gwYUdsemZTeGtMbUZ3Y0dWdVpEMW1kVzVqZEdsdmJpaDBMR1VwZTNKbGRIVnliaUIwYUdsekxtRmtaQ2gwTEhSb2FYTXVYM0JoY25ObFZHbHRaVTl5VEdGaVpXd29iblZzYkN4bExDRXdMSFFwS1gwc1pDNXBibk5sY25ROVpDNXBibk5sY25STmRXeDBhWEJzWlQxbWRXNWpkR2x2YmloMExHVXNhU3h6S1h0eVpYUjFjbTRnZEdocGN5NWhaR1FvZEN4bGZId3dMR2tzY3lsOUxHUXVZWEJ3Wlc1a1RYVnNkR2x3YkdVOVpuVnVZM1JwYjI0b2RDeGxMR2tzY3lsN2NtVjBkWEp1SUhSb2FYTXVZV1JrS0hRc2RHaHBjeTVmY0dGeWMyVlVhVzFsVDNKTVlXSmxiQ2h1ZFd4c0xHVXNJVEFzZENrc2FTeHpLWDBzWkM1aFpHUk1ZV0psYkQxbWRXNWpkR2x2YmloMExHVXBlM0psZEhWeWJpQjBhR2x6TGw5c1lXSmxiSE5iZEYwOWRHaHBjeTVmY0dGeWMyVlVhVzFsVDNKTVlXSmxiQ2hsS1N4MGFHbHpmU3hrTG1Ga1pGQmhkWE5sUFdaMWJtTjBhVzl1S0hRc1pTeHpMSElwZTNaaGNpQnVQV2t1WkdWc1lYbGxaRU5oYkd3b01DeHdMSE1zY254OGRHaHBjeWs3Y21WMGRYSnVJRzR1ZG1GeWN5NXZia052YlhCc1pYUmxQVzR1ZG1GeWN5NXZibEpsZG1WeWMyVkRiMjF3YkdWMFpUMWxMRzR1WkdGMFlUMWNJbWx6VUdGMWMyVmNJaXgwYUdsekxsOW9ZWE5RWVhWelpUMGhNQ3gwYUdsekxtRmtaQ2h1TEhRcGZTeGtMbkpsYlc5MlpVeGhZbVZzUFdaMWJtTjBhVzl1S0hRcGUzSmxkSFZ5YmlCa1pXeGxkR1VnZEdocGN5NWZiR0ZpWld4elczUmRMSFJvYVhOOUxHUXVaMlYwVEdGaVpXeFVhVzFsUFdaMWJtTjBhVzl1S0hRcGUzSmxkSFZ5YmlCdWRXeHNJVDEwYUdsekxsOXNZV0psYkhOYmRGMC9kR2hwY3k1ZmJHRmlaV3h6VzNSZE9pMHhmU3hrTGw5d1lYSnpaVlJwYldWUGNreGhZbVZzUFdaMWJtTjBhVzl1S0dVc2FTeHpMSElwZTNaaGNpQnVPMmxtS0hJZ2FXNXpkR0Z1WTJWdlppQjBKaVp5TG5ScGJXVnNhVzVsUFQwOWRHaHBjeWwwYUdsekxuSmxiVzkyWlNoeUtUdGxiSE5sSUdsbUtISW1KaWh5SUdsdWMzUmhibU5sYjJZZ1FYSnlZWGw4ZkhJdWNIVnphQ1ltYkNoeUtTa3BabTl5S0c0OWNpNXNaVzVuZEdnN0xTMXVQaTB4T3lseVcyNWRhVzV6ZEdGdVkyVnZaaUIwSmlaeVcyNWRMblJwYldWc2FXNWxQVDA5ZEdocGN5WW1kR2hwY3k1eVpXMXZkbVVvY2x0dVhTazdhV1lvWENKemRISnBibWRjSWowOWRIbHdaVzltSUdrcGNtVjBkWEp1SUhSb2FYTXVYM0JoY25ObFZHbHRaVTl5VEdGaVpXd29hU3h6SmlaY0ltNTFiV0psY2x3aVBUMTBlWEJsYjJZZ1pTWW1iblZzYkQwOWRHaHBjeTVmYkdGaVpXeHpXMmxkUDJVdGRHaHBjeTVrZFhKaGRHbHZiaWdwT2pBc2N5azdhV1lvYVQxcGZId3dMRndpYzNSeWFXNW5YQ0loUFhSNWNHVnZaaUJsZkh3aGFYTk9ZVTRvWlNrbUptNTFiR3c5UFhSb2FYTXVYMnhoWW1Wc2MxdGxYU2x1ZFd4c1BUMWxKaVlvWlQxMGFHbHpMbVIxY21GMGFXOXVLQ2twTzJWc2MyVjdhV1lvYmoxbExtbHVaR1Y0VDJZb1hDSTlYQ0lwTEMweFBUMDliaWx5WlhSMWNtNGdiblZzYkQwOWRHaHBjeTVmYkdGaVpXeHpXMlZkUDNNL2RHaHBjeTVmYkdGaVpXeHpXMlZkUFhSb2FYTXVaSFZ5WVhScGIyNG9LU3RwT21rNmRHaHBjeTVmYkdGaVpXeHpXMlZkSzJrN2FUMXdZWEp6WlVsdWRDaGxMbU5vWVhKQmRDaHVMVEVwSzF3aU1Wd2lMREV3S1NwT2RXMWlaWElvWlM1emRXSnpkSElvYmlzeEtTa3NaVDF1UGpFL2RHaHBjeTVmY0dGeWMyVlVhVzFsVDNKTVlXSmxiQ2hsTG5OMVluTjBjaWd3TEc0dE1Ta3NNQ3h6S1RwMGFHbHpMbVIxY21GMGFXOXVLQ2w5Y21WMGRYSnVJRTUxYldKbGNpaGxLU3RwZlN4a0xuTmxaV3M5Wm5WdVkzUnBiMjRvZEN4bEtYdHlaWFIxY200Z2RHaHBjeTUwYjNSaGJGUnBiV1VvWENKdWRXMWlaWEpjSWowOWRIbHdaVzltSUhRL2REcDBhR2x6TGw5d1lYSnpaVlJwYldWUGNreGhZbVZzS0hRcExHVWhQVDBoTVNsOUxHUXVjM1J2Y0QxbWRXNWpkR2x2YmlncGUzSmxkSFZ5YmlCMGFHbHpMbkJoZFhObFpDZ2hNQ2w5TEdRdVoyOTBiMEZ1WkZCc1lYazlablZ1WTNScGIyNG9kQ3hsS1h0eVpYUjFjbTRnZEdocGN5NXdiR0Y1S0hRc1pTbDlMR1F1WjI5MGIwRnVaRk4wYjNBOVpuVnVZM1JwYjI0b2RDeGxLWHR5WlhSMWNtNGdkR2hwY3k1d1lYVnpaU2gwTEdVcGZTeGtMbkpsYm1SbGNqMW1kVzVqZEdsdmJpaDBMR1VzYVNsN2RHaHBjeTVmWjJNbUpuUm9hWE11WDJWdVlXSnNaV1FvSVRBc0lURXBPM1poY2lCekxHNHNZU3h2TEd3c2RTeG1QWFJvYVhNdVgyUnBjblI1UDNSb2FYTXVkRzkwWVd4RWRYSmhkR2x2YmlncE9uUm9hWE11WDNSdmRHRnNSSFZ5WVhScGIyNHNZejEwYUdsekxsOTBhVzFsTEhBOWRHaHBjeTVmYzNSaGNuUlVhVzFsTEcwOWRHaHBjeTVmZEdsdFpWTmpZV3hsTEdROWRHaHBjeTVmY0dGMWMyVmtPMmxtS0hRK1BXWXBkR2hwY3k1ZmRHOTBZV3hVYVcxbFBYUm9hWE11WDNScGJXVTlaaXgwYUdsekxsOXlaWFpsY25ObFpIeDhkR2hwY3k1ZmFHRnpVR0YxYzJWa1EyaHBiR1FvS1h4OEtHNDlJVEFzYnoxY0ltOXVRMjl0Y0d4bGRHVmNJaXhzUFNFaGRHaHBjeTVmZEdsdFpXeHBibVV1WVhWMGIxSmxiVzkyWlVOb2FXeGtjbVZ1TERBOVBUMTBhR2x6TGw5a2RYSmhkR2x2YmlZbUtEQTlQVDEwZkh3d1BuUm9hWE11WDNKaGQxQnlaWFpVYVcxbGZIeDBhR2x6TGw5eVlYZFFjbVYyVkdsdFpUMDlQWElwSmlaMGFHbHpMbDl5WVhkUWNtVjJWR2x0WlNFOVBYUW1KblJvYVhNdVgyWnBjbk4wSmlZb2JEMGhNQ3gwYUdsekxsOXlZWGRRY21WMlZHbHRaVDV5SmlZb2J6MWNJbTl1VW1WMlpYSnpaVU52YlhCc1pYUmxYQ0lwS1Nrc2RHaHBjeTVmY21GM1VISmxkbFJwYldVOWRHaHBjeTVmWkhWeVlYUnBiMjU4ZkNGbGZIeDBmSHgwYUdsekxsOXlZWGRRY21WMlZHbHRaVDA5UFhRL2REcHlMSFE5WmlzeFpTMDBPMlZzYzJVZ2FXWW9NV1V0Tno1MEtXbG1LSFJvYVhNdVgzUnZkR0ZzVkdsdFpUMTBhR2x6TGw5MGFXMWxQVEFzS0RBaFBUMWpmSHd3UFQwOWRHaHBjeTVmWkhWeVlYUnBiMjRtSm5Sb2FYTXVYM0poZDFCeVpYWlVhVzFsSVQwOWNpWW1LSFJvYVhNdVgzSmhkMUJ5WlhaVWFXMWxQakI4ZkRBK2RDWW1kR2hwY3k1ZmNtRjNVSEpsZGxScGJXVStQVEFwS1NZbUtHODlYQ0p2YmxKbGRtVnljMlZEYjIxd2JHVjBaVndpTEc0OWRHaHBjeTVmY21WMlpYSnpaV1FwTERBK2RDbDBhR2x6TGw5aFkzUnBkbVU5SVRFc2RHaHBjeTVmZEdsdFpXeHBibVV1WVhWMGIxSmxiVzkyWlVOb2FXeGtjbVZ1SmlaMGFHbHpMbDl5WlhabGNuTmxaRDhvYkQxdVBTRXdMRzg5WENKdmJsSmxkbVZ5YzJWRGIyMXdiR1YwWlZ3aUtUcDBhR2x6TGw5eVlYZFFjbVYyVkdsdFpUNDlNQ1ltZEdocGN5NWZabWx5YzNRbUppaHNQU0V3S1N4MGFHbHpMbDl5WVhkUWNtVjJWR2x0WlQxME8yVnNjMlY3YVdZb2RHaHBjeTVmY21GM1VISmxkbFJwYldVOWRHaHBjeTVmWkhWeVlYUnBiMjU4ZkNGbGZIeDBmSHgwYUdsekxsOXlZWGRRY21WMlZHbHRaVDA5UFhRL2REcHlMREE5UFQxMEppWnVLV1p2Y2loelBYUm9hWE11WDJacGNuTjBPM01tSmpBOVBUMXpMbDl6ZEdGeWRGUnBiV1U3S1hNdVgyUjFjbUYwYVc5dWZId29iajBoTVNrc2N6MXpMbDl1WlhoME8zUTlNQ3gwYUdsekxsOXBibWwwZEdWa2ZId29iRDBoTUNsOVpXeHpaWHRwWmloMGFHbHpMbDlvWVhOUVlYVnpaU1ltSVhSb2FYTXVYMlp2Y21OcGJtZFFiR0Y1YUdWaFpDWW1JV1VwZTJsbUtIUStQV01wWm05eUtITTlkR2hwY3k1ZlptbHljM1E3Y3lZbWRENDljeTVmYzNSaGNuUlVhVzFsSmlZaGRUc3BjeTVmWkhWeVlYUnBiMjU4ZkZ3aWFYTlFZWFZ6WlZ3aUlUMDljeTVrWVhSaGZIeHpMbkpoZEdsdmZId3dQVDA5Y3k1ZmMzUmhjblJVYVcxbEppWXdQVDA5ZEdocGN5NWZjbUYzVUhKbGRsUnBiV1Y4ZkNoMVBYTXBMSE05Y3k1ZmJtVjRkRHRsYkhObElHWnZjaWh6UFhSb2FYTXVYMnhoYzNRN2N5WW1jeTVmYzNSaGNuUlVhVzFsUGoxMEppWWhkVHNwY3k1ZlpIVnlZWFJwYjI1OGZGd2lhWE5RWVhWelpWd2lQVDA5Y3k1a1lYUmhKaVp6TGw5eVlYZFFjbVYyVkdsdFpUNHdKaVlvZFQxektTeHpQWE11WDNCeVpYWTdkU1ltS0hSb2FYTXVYM1JwYldVOWREMTFMbDl6ZEdGeWRGUnBiV1VzZEdocGN5NWZkRzkwWVd4VWFXMWxQWFFyZEdocGN5NWZZM2xqYkdVcUtIUm9hWE11WDNSdmRHRnNSSFZ5WVhScGIyNHJkR2hwY3k1ZmNtVndaV0YwUkdWc1lYa3BLWDEwYUdsekxsOTBiM1JoYkZScGJXVTlkR2hwY3k1ZmRHbHRaVDEwYUdsekxsOXlZWGRRY21WMlZHbHRaVDEwZldsbUtIUm9hWE11WDNScGJXVWhQVDFqSmlaMGFHbHpMbDltYVhKemRIeDhhWHg4Ykh4OGRTbDdhV1lvZEdocGN5NWZhVzVwZEhSbFpIeDhLSFJvYVhNdVgybHVhWFIwWldROUlUQXBMSFJvYVhNdVgyRmpkR2wyWlh4OElYUm9hWE11WDNCaGRYTmxaQ1ltZEdocGN5NWZkR2x0WlNFOVBXTW1KblErTUNZbUtIUm9hWE11WDJGamRHbDJaVDBoTUNrc01EMDlQV01tSm5Sb2FYTXVkbUZ5Y3k1dmJsTjBZWEowSmlZd0lUMDlkR2hwY3k1ZmRHbHRaU1ltS0dWOGZIUm9hWE11WDJOaGJHeGlZV05yS0Z3aWIyNVRkR0Z5ZEZ3aUtTa3NkR2hwY3k1ZmRHbHRaVDQ5WXlsbWIzSW9jejEwYUdsekxsOW1hWEp6ZER0ekppWW9ZVDF6TGw5dVpYaDBMQ0YwYUdsekxsOXdZWFZ6WldSOGZHUXBPeWtvY3k1ZllXTjBhWFpsZkh4ekxsOXpkR0Z5ZEZScGJXVThQWFJvYVhNdVgzUnBiV1VtSmlGekxsOXdZWFZ6WldRbUppRnpMbDluWXlrbUppaDFQVDA5Y3lZbWRHaHBjeTV3WVhWelpTZ3BMSE11WDNKbGRtVnljMlZrUDNNdWNtVnVaR1Z5S0NoekxsOWthWEowZVQ5ekxuUnZkR0ZzUkhWeVlYUnBiMjRvS1RwekxsOTBiM1JoYkVSMWNtRjBhVzl1S1Mwb2RDMXpMbDl6ZEdGeWRGUnBiV1VwS25NdVgzUnBiV1ZUWTJGc1pTeGxMR2twT25NdWNtVnVaR1Z5S0NoMExYTXVYM04wWVhKMFZHbHRaU2txY3k1ZmRHbHRaVk5qWVd4bExHVXNhU2twTEhNOVlUdGxiSE5sSUdadmNpaHpQWFJvYVhNdVgyeGhjM1E3Y3lZbUtHRTljeTVmY0hKbGRpd2hkR2hwY3k1ZmNHRjFjMlZrZkh4a0tUc3BlMmxtS0hNdVgyRmpkR2wyWlh4OFl6NDljeTVmYzNSaGNuUlVhVzFsSmlZaGN5NWZjR0YxYzJWa0ppWWhjeTVmWjJNcGUybG1LSFU5UFQxektYdG1iM0lvZFQxekxsOXdjbVYyTzNVbUpuVXVaVzVrVkdsdFpTZ3BQblJvYVhNdVgzUnBiV1U3S1hVdWNtVnVaR1Z5S0hVdVgzSmxkbVZ5YzJWa1AzVXVkRzkwWVd4RWRYSmhkR2x2YmlncExTaDBMWFV1WDNOMFlYSjBWR2x0WlNrcWRTNWZkR2x0WlZOallXeGxPaWgwTFhVdVgzTjBZWEowVkdsdFpTa3FkUzVmZEdsdFpWTmpZV3hsTEdVc2FTa3NkVDExTGw5d2NtVjJPM1U5Ym5Wc2JDeDBhR2x6TG5CaGRYTmxLQ2w5Y3k1ZmNtVjJaWEp6WldRL2N5NXlaVzVrWlhJb0tITXVYMlJwY25SNVAzTXVkRzkwWVd4RWRYSmhkR2x2YmlncE9uTXVYM1J2ZEdGc1JIVnlZWFJwYjI0cExTaDBMWE11WDNOMFlYSjBWR2x0WlNrcWN5NWZkR2x0WlZOallXeGxMR1VzYVNrNmN5NXlaVzVrWlhJb0tIUXRjeTVmYzNSaGNuUlVhVzFsS1NwekxsOTBhVzFsVTJOaGJHVXNaU3hwS1gxelBXRjlkR2hwY3k1ZmIyNVZjR1JoZEdVbUppaGxmSHdvYUM1c1pXNW5kR2dtSmw4b0tTeDBhR2x6TGw5allXeHNZbUZqYXloY0ltOXVWWEJrWVhSbFhDSXBLU2tzYnlZbUtIUm9hWE11WDJkamZId29jRDA5UFhSb2FYTXVYM04wWVhKMFZHbHRaWHg4YlNFOVBYUm9hWE11WDNScGJXVlRZMkZzWlNrbUppZ3dQVDA5ZEdocGN5NWZkR2x0Wlh4OFpqNDlkR2hwY3k1MGIzUmhiRVIxY21GMGFXOXVLQ2twSmlZb2JpWW1LR2d1YkdWdVozUm9KaVpmS0Nrc2RHaHBjeTVmZEdsdFpXeHBibVV1WVhWMGIxSmxiVzkyWlVOb2FXeGtjbVZ1SmlaMGFHbHpMbDlsYm1GaWJHVmtLQ0V4TENFeEtTeDBhR2x6TGw5aFkzUnBkbVU5SVRFcExDRmxKaVowYUdsekxuWmhjbk5iYjEwbUpuUm9hWE11WDJOaGJHeGlZV05yS0c4cEtTbDlmU3hrTGw5b1lYTlFZWFZ6WldSRGFHbHNaRDFtZFc1amRHbHZiaWdwZTJadmNpaDJZWElnZEQxMGFHbHpMbDltYVhKemREdDBPeWw3YVdZb2RDNWZjR0YxYzJWa2ZIeDBJR2x1YzNSaGJtTmxiMllnY3lZbWRDNWZhR0Z6VUdGMWMyVmtRMmhwYkdRb0tTbHlaWFIxY200aE1EdDBQWFF1WDI1bGVIUjljbVYwZFhKdUlURjlMR1F1WjJWMFEyaHBiR1J5Wlc0OVpuVnVZM1JwYjI0b2RDeGxMSE1zY2lsN2NqMXlmSHd0T1RrNU9UazVPVGs1T1R0bWIzSW9kbUZ5SUc0OVcxMHNZVDEwYUdsekxsOW1hWEp6ZEN4dlBUQTdZVHNwY2o1aExsOXpkR0Z5ZEZScGJXVjhmQ2hoSUdsdWMzUmhibU5sYjJZZ2FUOWxJVDA5SVRFbUppaHVXMjhySzEwOVlTazZLSE1oUFQwaE1TWW1LRzViYnlzclhUMWhLU3gwSVQwOUlURW1KaWh1UFc0dVkyOXVZMkYwS0dFdVoyVjBRMmhwYkdSeVpXNG9JVEFzWlN4ektTa3NiejF1TG14bGJtZDBhQ2twS1N4aFBXRXVYMjVsZUhRN2NtVjBkWEp1SUc1OUxHUXVaMlYwVkhkbFpXNXpUMlk5Wm5WdVkzUnBiMjRvZEN4bEtYdDJZWElnY3l4eUxHNDlkR2hwY3k1ZloyTXNZVDFiWFN4dlBUQTdabTl5S0c0bUpuUm9hWE11WDJWdVlXSnNaV1FvSVRBc0lUQXBMSE05YVM1blpYUlVkMlZsYm5OUFppaDBLU3h5UFhNdWJHVnVaM1JvT3kwdGNqNHRNVHNwS0hOYmNsMHVkR2x0Wld4cGJtVTlQVDEwYUdsemZIeGxKaVowYUdsekxsOWpiMjUwWVdsdWN5aHpXM0pkS1NrbUppaGhXMjhySzEwOWMxdHlYU2s3Y21WMGRYSnVJRzRtSm5Sb2FYTXVYMlZ1WVdKc1pXUW9JVEVzSVRBcExHRjlMR1F1Y21WalpXNTBQV1oxYm1OMGFXOXVLQ2w3Y21WMGRYSnVJSFJvYVhNdVgzSmxZMlZ1ZEgwc1pDNWZZMjl1ZEdGcGJuTTlablZ1WTNScGIyNG9kQ2w3Wm05eUtIWmhjaUJsUFhRdWRHbHRaV3hwYm1VN1pUc3BlMmxtS0dVOVBUMTBhR2x6S1hKbGRIVnliaUV3TzJVOVpTNTBhVzFsYkdsdVpYMXlaWFIxY200aE1YMHNaQzV6YUdsbWRFTm9hV3hrY21WdVBXWjFibU4wYVc5dUtIUXNaU3hwS1h0cFBXbDhmREE3Wm05eUtIWmhjaUJ6TEhJOWRHaHBjeTVmWm1seWMzUXNiajEwYUdsekxsOXNZV0psYkhNN2Nqc3BjaTVmYzNSaGNuUlVhVzFsUGoxcEppWW9jaTVmYzNSaGNuUlVhVzFsS3oxMEtTeHlQWEl1WDI1bGVIUTdhV1lvWlNsbWIzSW9jeUJwYmlCdUtXNWJjMTArUFdrbUppaHVXM05kS3oxMEtUdHlaWFIxY200Z2RHaHBjeTVmZFc1allXTm9aU2doTUNsOUxHUXVYMnRwYkd3OVpuVnVZM1JwYjI0b2RDeGxLWHRwWmlnaGRDWW1JV1VwY21WMGRYSnVJSFJvYVhNdVgyVnVZV0pzWldRb0lURXNJVEVwTzJadmNpaDJZWElnYVQxbFAzUm9hWE11WjJWMFZIZGxaVzV6VDJZb1pTazZkR2hwY3k1blpYUkRhR2xzWkhKbGJpZ2hNQ3doTUN3aE1Ta3NjejFwTG14bGJtZDBhQ3h5UFNFeE95MHRjejR0TVRzcGFWdHpYUzVmYTJsc2JDaDBMR1VwSmlZb2NqMGhNQ2s3Y21WMGRYSnVJSEo5TEdRdVkyeGxZWEk5Wm5WdVkzUnBiMjRvZENsN2RtRnlJR1U5ZEdocGN5NW5aWFJEYUdsc1pISmxiaWdoTVN3aE1Dd2hNQ2tzYVQxbExteGxibWQwYUR0bWIzSW9kR2hwY3k1ZmRHbHRaVDEwYUdsekxsOTBiM1JoYkZScGJXVTlNRHN0TFdrK0xURTdLV1ZiYVYwdVgyVnVZV0pzWldRb0lURXNJVEVwTzNKbGRIVnliaUIwSVQwOUlURW1KaWgwYUdsekxsOXNZV0psYkhNOWUzMHBMSFJvYVhNdVgzVnVZMkZqYUdVb0lUQXBmU3hrTG1sdWRtRnNhV1JoZEdVOVpuVnVZM1JwYjI0b0tYdG1iM0lvZG1GeUlHVTlkR2hwY3k1ZlptbHljM1E3WlRzcFpTNXBiblpoYkdsa1lYUmxLQ2tzWlQxbExsOXVaWGgwTzNKbGRIVnliaUIwTG5CeWIzUnZkSGx3WlM1cGJuWmhiR2xrWVhSbExtTmhiR3dvZEdocGN5bDlMR1F1WDJWdVlXSnNaV1E5Wm5WdVkzUnBiMjRvZEN4cEtYdHBaaWgwUFQwOWRHaHBjeTVmWjJNcFptOXlLSFpoY2lCelBYUm9hWE11WDJacGNuTjBPM003S1hNdVgyVnVZV0pzWldRb2RDd2hNQ2tzY3oxekxsOXVaWGgwTzNKbGRIVnliaUJsTG5CeWIzUnZkSGx3WlM1ZlpXNWhZbXhsWkM1allXeHNLSFJvYVhNc2RDeHBLWDBzWkM1MGIzUmhiRlJwYldVOVpuVnVZM1JwYjI0b0tYdDBhR2x6TGw5bWIzSmphVzVuVUd4aGVXaGxZV1E5SVRBN2RtRnlJR1U5ZEM1d2NtOTBiM1I1Y0dVdWRHOTBZV3hVYVcxbExtRndjR3g1S0hSb2FYTXNZWEpuZFcxbGJuUnpLVHR5WlhSMWNtNGdkR2hwY3k1ZlptOXlZMmx1WjFCc1lYbG9aV0ZrUFNFeExHVjlMR1F1WkhWeVlYUnBiMjQ5Wm5WdVkzUnBiMjRvZENsN2NtVjBkWEp1SUdGeVozVnRaVzUwY3k1c1pXNW5kR2cvS0RBaFBUMTBhR2x6TG1SMWNtRjBhVzl1S0NrbUpqQWhQVDEwSmlaMGFHbHpMblJwYldWVFkyRnNaU2gwYUdsekxsOWtkWEpoZEdsdmJpOTBLU3gwYUdsektUb29kR2hwY3k1ZlpHbHlkSGttSm5Sb2FYTXVkRzkwWVd4RWRYSmhkR2x2YmlncExIUm9hWE11WDJSMWNtRjBhVzl1S1gwc1pDNTBiM1JoYkVSMWNtRjBhVzl1UFdaMWJtTjBhVzl1S0hRcGUybG1LQ0ZoY21kMWJXVnVkSE11YkdWdVozUm9LWHRwWmloMGFHbHpMbDlrYVhKMGVTbDdabTl5S0haaGNpQmxMR2tzY3owd0xISTlkR2hwY3k1ZmJHRnpkQ3h1UFRrNU9UazVPVGs1T1RrNU9UdHlPeWxsUFhJdVgzQnlaWFlzY2k1ZlpHbHlkSGttSm5JdWRHOTBZV3hFZFhKaGRHbHZiaWdwTEhJdVgzTjBZWEowVkdsdFpUNXVKaVowYUdsekxsOXpiM0owUTJocGJHUnlaVzRtSmlGeUxsOXdZWFZ6WldRL2RHaHBjeTVoWkdRb2NpeHlMbDl6ZEdGeWRGUnBiV1V0Y2k1ZlpHVnNZWGtwT200OWNpNWZjM1JoY25SVWFXMWxMREErY2k1ZmMzUmhjblJVYVcxbEppWWhjaTVmY0dGMWMyVmtKaVlvY3kwOWNpNWZjM1JoY25SVWFXMWxMSFJvYVhNdVgzUnBiV1ZzYVc1bExuTnRiMjkwYUVOb2FXeGtWR2x0YVc1bkppWW9kR2hwY3k1ZmMzUmhjblJVYVcxbEt6MXlMbDl6ZEdGeWRGUnBiV1V2ZEdocGN5NWZkR2x0WlZOallXeGxLU3gwYUdsekxuTm9hV1owUTJocGJHUnlaVzRvTFhJdVgzTjBZWEowVkdsdFpTd2hNU3d0T1RrNU9UazVPVGs1T1Nrc2JqMHdLU3hwUFhJdVgzTjBZWEowVkdsdFpTdHlMbDkwYjNSaGJFUjFjbUYwYVc5dUwzSXVYM1JwYldWVFkyRnNaU3hwUG5NbUppaHpQV2twTEhJOVpUdDBhR2x6TGw5a2RYSmhkR2x2YmoxMGFHbHpMbDkwYjNSaGJFUjFjbUYwYVc5dVBYTXNkR2hwY3k1ZlpHbHlkSGs5SVRGOWNtVjBkWEp1SUhSb2FYTXVYM1J2ZEdGc1JIVnlZWFJwYjI1OWNtVjBkWEp1SURBaFBUMTBhR2x6TG5SdmRHRnNSSFZ5WVhScGIyNG9LU1ltTUNFOVBYUW1KblJvYVhNdWRHbHRaVk5qWVd4bEtIUm9hWE11WDNSdmRHRnNSSFZ5WVhScGIyNHZkQ2tzZEdocGMzMHNaQzV3WVhWelpXUTlablZ1WTNScGIyNG9aU2w3YVdZb0lXVXBabTl5S0haaGNpQnBQWFJvYVhNdVgyWnBjbk4wTEhNOWRHaHBjeTVmZEdsdFpUdHBPeWxwTGw5emRHRnlkRlJwYldVOVBUMXpKaVpjSW1selVHRjFjMlZjSWowOVBXa3VaR0YwWVNZbUtHa3VYM0poZDFCeVpYWlVhVzFsUFRBcExHazlhUzVmYm1WNGREdHlaWFIxY200Z2RDNXdjbTkwYjNSNWNHVXVjR0YxYzJWa0xtRndjR3g1S0hSb2FYTXNZWEpuZFcxbGJuUnpLWDBzWkM1MWMyVnpSbkpoYldWelBXWjFibU4wYVc5dUtDbDdabTl5S0haaGNpQmxQWFJvYVhNdVgzUnBiV1ZzYVc1bE8yVXVYM1JwYldWc2FXNWxPeWxsUFdVdVgzUnBiV1ZzYVc1bE8zSmxkSFZ5YmlCbFBUMDlkQzVmY205dmRFWnlZVzFsYzFScGJXVnNhVzVsZlN4a0xuSmhkMVJwYldVOVpuVnVZM1JwYjI0b0tYdHlaWFIxY200Z2RHaHBjeTVmY0dGMWMyVmtQM1JvYVhNdVgzUnZkR0ZzVkdsdFpUb29kR2hwY3k1ZmRHbHRaV3hwYm1VdWNtRjNWR2x0WlNncExYUm9hWE11WDNOMFlYSjBWR2x0WlNrcWRHaHBjeTVmZEdsdFpWTmpZV3hsZlN4emZTd2hNQ2w5S1N4ZlozTlRZMjl3WlM1ZlozTkVaV1pwYm1VbUpsOW5jMU5qYjNCbExsOW5jMUYxWlhWbExuQnZjQ2dwS0Nrc1puVnVZM1JwYjI0b2RDbDdYQ0oxYzJVZ2MzUnlhV04wWENJN2RtRnlJR1U5Wm5WdVkzUnBiMjRvS1h0eVpYUjFjbTRvWDJkelUyTnZjR1V1UjNKbFpXNVRiMk5yUjJ4dlltRnNjM3g4WDJkelUyTnZjR1VwVzNSZGZUdGNJbVoxYm1OMGFXOXVYQ0k5UFhSNWNHVnZaaUJrWldacGJtVW1KbVJsWm1sdVpTNWhiV1EvWkdWbWFXNWxLRnRjSWxSM1pXVnVUR2wwWlZ3aVhTeGxLVHBjSW5WdVpHVm1hVzVsWkZ3aUlUMTBlWEJsYjJZZ2JXOWtkV3hsSmladGIyUjFiR1V1Wlhod2IzSjBjeVltS0hKbGNYVnBjbVVvWENJdUwxUjNaV1Z1VEdsMFpTNXFjMXdpS1N4dGIyUjFiR1V1Wlhod2IzSjBjejFsS0NrcGZTaGNJbFJwYldWc2FXNWxUR2wwWlZ3aUtUc2lYWDA9IiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyohXG4gKiBWRVJTSU9OOiAxLjE4LjBcbiAqIERBVEU6IDIwMTUtMDktMDNcbiAqIFVQREFURVMgQU5EIERPQ1MgQVQ6IGh0dHA6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDA4LTIwMTUsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgd29yayBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIHNvZnR3YXJlIGFncmVlbWVudCB0aGF0IHdhcyBpc3N1ZWQgd2l0aCB5b3VyIG1lbWJlcnNoaXAuXG4gKiBcbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuICovXG4oZnVuY3Rpb24odCxlKXtcInVzZSBzdHJpY3RcIjt2YXIgaT10LkdyZWVuU29ja0dsb2JhbHM9dC5HcmVlblNvY2tHbG9iYWxzfHx0O2lmKCFpLlR3ZWVuTGl0ZSl7dmFyIHMscixuLGEsbyxsPWZ1bmN0aW9uKHQpe3ZhciBlLHM9dC5zcGxpdChcIi5cIikscj1pO2ZvcihlPTA7cy5sZW5ndGg+ZTtlKyspcltzW2VdXT1yPXJbc1tlXV18fHt9O3JldHVybiByfSxoPWwoXCJjb20uZ3JlZW5zb2NrXCIpLF89MWUtMTAsdT1mdW5jdGlvbih0KXt2YXIgZSxpPVtdLHM9dC5sZW5ndGg7Zm9yKGU9MDtlIT09cztpLnB1c2godFtlKytdKSk7cmV0dXJuIGl9LGY9ZnVuY3Rpb24oKXt9LGM9ZnVuY3Rpb24oKXt2YXIgdD1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLGU9dC5jYWxsKFtdKTtyZXR1cm4gZnVuY3Rpb24oaSl7cmV0dXJuIG51bGwhPWkmJihpIGluc3RhbmNlb2YgQXJyYXl8fFwib2JqZWN0XCI9PXR5cGVvZiBpJiYhIWkucHVzaCYmdC5jYWxsKGkpPT09ZSl9fSgpLG09e30scD1mdW5jdGlvbihzLHIsbixhKXt0aGlzLnNjPW1bc10/bVtzXS5zYzpbXSxtW3NdPXRoaXMsdGhpcy5nc0NsYXNzPW51bGwsdGhpcy5mdW5jPW47dmFyIG89W107dGhpcy5jaGVjaz1mdW5jdGlvbihoKXtmb3IodmFyIF8sdSxmLGMsZCx2PXIubGVuZ3RoLGc9djstLXY+LTE7KShfPW1bclt2XV18fG5ldyBwKHJbdl0sW10pKS5nc0NsYXNzPyhvW3ZdPV8uZ3NDbGFzcyxnLS0pOmgmJl8uc2MucHVzaCh0aGlzKTtpZigwPT09ZyYmbilmb3IodT0oXCJjb20uZ3JlZW5zb2NrLlwiK3MpLnNwbGl0KFwiLlwiKSxmPXUucG9wKCksYz1sKHUuam9pbihcIi5cIikpW2ZdPXRoaXMuZ3NDbGFzcz1uLmFwcGx5KG4sbyksYSYmKGlbZl09YyxkPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzLCFkJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKCh0LkdyZWVuU29ja0FNRFBhdGg/dC5HcmVlblNvY2tBTURQYXRoK1wiL1wiOlwiXCIpK3Muc3BsaXQoXCIuXCIpLnBvcCgpLFtdLGZ1bmN0aW9uKCl7cmV0dXJuIGN9KTpzPT09ZSYmZCYmKG1vZHVsZS5leHBvcnRzPWMpKSx2PTA7dGhpcy5zYy5sZW5ndGg+djt2KyspdGhpcy5zY1t2XS5jaGVjaygpfSx0aGlzLmNoZWNrKCEwKX0sZD10Ll9nc0RlZmluZT1mdW5jdGlvbih0LGUsaSxzKXtyZXR1cm4gbmV3IHAodCxlLGkscyl9LHY9aC5fY2xhc3M9ZnVuY3Rpb24odCxlLGkpe3JldHVybiBlPWV8fGZ1bmN0aW9uKCl7fSxkKHQsW10sZnVuY3Rpb24oKXtyZXR1cm4gZX0saSksZX07ZC5nbG9iYWxzPWk7dmFyIGc9WzAsMCwxLDFdLFQ9W10seT12KFwiZWFzaW5nLkVhc2VcIixmdW5jdGlvbih0LGUsaSxzKXt0aGlzLl9mdW5jPXQsdGhpcy5fdHlwZT1pfHwwLHRoaXMuX3Bvd2VyPXN8fDAsdGhpcy5fcGFyYW1zPWU/Zy5jb25jYXQoZSk6Z30sITApLHc9eS5tYXA9e30sUD15LnJlZ2lzdGVyPWZ1bmN0aW9uKHQsZSxpLHMpe2Zvcih2YXIgcixuLGEsbyxsPWUuc3BsaXQoXCIsXCIpLF89bC5sZW5ndGgsdT0oaXx8XCJlYXNlSW4sZWFzZU91dCxlYXNlSW5PdXRcIikuc3BsaXQoXCIsXCIpOy0tXz4tMTspZm9yKG49bFtfXSxyPXM/dihcImVhc2luZy5cIituLG51bGwsITApOmguZWFzaW5nW25dfHx7fSxhPXUubGVuZ3RoOy0tYT4tMTspbz11W2FdLHdbbitcIi5cIitvXT13W28rbl09cltvXT10LmdldFJhdGlvP3Q6dFtvXXx8bmV3IHR9O2ZvcihuPXkucHJvdG90eXBlLG4uX2NhbGNFbmQ9ITEsbi5nZXRSYXRpbz1mdW5jdGlvbih0KXtpZih0aGlzLl9mdW5jKXJldHVybiB0aGlzLl9wYXJhbXNbMF09dCx0aGlzLl9mdW5jLmFwcGx5KG51bGwsdGhpcy5fcGFyYW1zKTt2YXIgZT10aGlzLl90eXBlLGk9dGhpcy5fcG93ZXIscz0xPT09ZT8xLXQ6Mj09PWU/dDouNT50PzIqdDoyKigxLXQpO3JldHVybiAxPT09aT9zKj1zOjI9PT1pP3MqPXMqczozPT09aT9zKj1zKnMqczo0PT09aSYmKHMqPXMqcypzKnMpLDE9PT1lPzEtczoyPT09ZT9zOi41PnQ/cy8yOjEtcy8yfSxzPVtcIkxpbmVhclwiLFwiUXVhZFwiLFwiQ3ViaWNcIixcIlF1YXJ0XCIsXCJRdWludCxTdHJvbmdcIl0scj1zLmxlbmd0aDstLXI+LTE7KW49c1tyXStcIixQb3dlclwiK3IsUChuZXcgeShudWxsLG51bGwsMSxyKSxuLFwiZWFzZU91dFwiLCEwKSxQKG5ldyB5KG51bGwsbnVsbCwyLHIpLG4sXCJlYXNlSW5cIisoMD09PXI/XCIsZWFzZU5vbmVcIjpcIlwiKSksUChuZXcgeShudWxsLG51bGwsMyxyKSxuLFwiZWFzZUluT3V0XCIpO3cubGluZWFyPWguZWFzaW5nLkxpbmVhci5lYXNlSW4sdy5zd2luZz1oLmVhc2luZy5RdWFkLmVhc2VJbk91dDt2YXIgYj12KFwiZXZlbnRzLkV2ZW50RGlzcGF0Y2hlclwiLGZ1bmN0aW9uKHQpe3RoaXMuX2xpc3RlbmVycz17fSx0aGlzLl9ldmVudFRhcmdldD10fHx0aGlzfSk7bj1iLnByb3RvdHlwZSxuLmFkZEV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24odCxlLGkscyxyKXtyPXJ8fDA7dmFyIG4sbCxoPXRoaXMuX2xpc3RlbmVyc1t0XSxfPTA7Zm9yKG51bGw9PWgmJih0aGlzLl9saXN0ZW5lcnNbdF09aD1bXSksbD1oLmxlbmd0aDstLWw+LTE7KW49aFtsXSxuLmM9PT1lJiZuLnM9PT1pP2guc3BsaWNlKGwsMSk6MD09PV8mJnI+bi5wciYmKF89bCsxKTtoLnNwbGljZShfLDAse2M6ZSxzOmksdXA6cyxwcjpyfSksdGhpcyE9PWF8fG98fGEud2FrZSgpfSxuLnJlbW92ZUV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24odCxlKXt2YXIgaSxzPXRoaXMuX2xpc3RlbmVyc1t0XTtpZihzKWZvcihpPXMubGVuZ3RoOy0taT4tMTspaWYoc1tpXS5jPT09ZSlyZXR1cm4gcy5zcGxpY2UoaSwxKSx2b2lkIDB9LG4uZGlzcGF0Y2hFdmVudD1mdW5jdGlvbih0KXt2YXIgZSxpLHMscj10aGlzLl9saXN0ZW5lcnNbdF07aWYocilmb3IoZT1yLmxlbmd0aCxpPXRoaXMuX2V2ZW50VGFyZ2V0Oy0tZT4tMTspcz1yW2VdLHMmJihzLnVwP3MuYy5jYWxsKHMuc3x8aSx7dHlwZTp0LHRhcmdldDppfSk6cy5jLmNhbGwocy5zfHxpKSl9O3ZhciBrPXQucmVxdWVzdEFuaW1hdGlvbkZyYW1lLEE9dC5jYW5jZWxBbmltYXRpb25GcmFtZSxTPURhdGUubm93fHxmdW5jdGlvbigpe3JldHVybihuZXcgRGF0ZSkuZ2V0VGltZSgpfSx4PVMoKTtmb3Iocz1bXCJtc1wiLFwibW96XCIsXCJ3ZWJraXRcIixcIm9cIl0scj1zLmxlbmd0aDstLXI+LTEmJiFrOylrPXRbc1tyXStcIlJlcXVlc3RBbmltYXRpb25GcmFtZVwiXSxBPXRbc1tyXStcIkNhbmNlbEFuaW1hdGlvbkZyYW1lXCJdfHx0W3Nbcl0rXCJDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl07dihcIlRpY2tlclwiLGZ1bmN0aW9uKHQsZSl7dmFyIGkscyxyLG4sbCxoPXRoaXMsdT1TKCksYz1lIT09ITEmJmssbT01MDAscD0zMyxkPVwidGlja1wiLHY9ZnVuY3Rpb24odCl7dmFyIGUsYSxvPVMoKS14O28+bSYmKHUrPW8tcCkseCs9byxoLnRpbWU9KHgtdSkvMWUzLGU9aC50aW1lLWwsKCFpfHxlPjB8fHQ9PT0hMCkmJihoLmZyYW1lKyssbCs9ZSsoZT49bj8uMDA0Om4tZSksYT0hMCksdCE9PSEwJiYocj1zKHYpKSxhJiZoLmRpc3BhdGNoRXZlbnQoZCl9O2IuY2FsbChoKSxoLnRpbWU9aC5mcmFtZT0wLGgudGljaz1mdW5jdGlvbigpe3YoITApfSxoLmxhZ1Ntb290aGluZz1mdW5jdGlvbih0LGUpe209dHx8MS9fLHA9TWF0aC5taW4oZSxtLDApfSxoLnNsZWVwPWZ1bmN0aW9uKCl7bnVsbCE9ciYmKGMmJkE/QShyKTpjbGVhclRpbWVvdXQocikscz1mLHI9bnVsbCxoPT09YSYmKG89ITEpKX0saC53YWtlPWZ1bmN0aW9uKCl7bnVsbCE9PXI/aC5zbGVlcCgpOmguZnJhbWU+MTAmJih4PVMoKS1tKzUpLHM9MD09PWk/ZjpjJiZrP2s6ZnVuY3Rpb24odCl7cmV0dXJuIHNldFRpbWVvdXQodCwwfDFlMyoobC1oLnRpbWUpKzEpfSxoPT09YSYmKG89ITApLHYoMil9LGguZnBzPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhpPXQsbj0xLyhpfHw2MCksbD10aGlzLnRpbWUrbixoLndha2UoKSx2b2lkIDApOml9LGgudXNlUkFGPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhoLnNsZWVwKCksYz10LGguZnBzKGkpLHZvaWQgMCk6Y30saC5mcHModCksc2V0VGltZW91dChmdW5jdGlvbigpe2MmJjU+aC5mcmFtZSYmaC51c2VSQUYoITEpfSwxNTAwKX0pLG49aC5UaWNrZXIucHJvdG90eXBlPW5ldyBoLmV2ZW50cy5FdmVudERpc3BhdGNoZXIsbi5jb25zdHJ1Y3Rvcj1oLlRpY2tlcjt2YXIgUj12KFwiY29yZS5BbmltYXRpb25cIixmdW5jdGlvbih0LGUpe2lmKHRoaXMudmFycz1lPWV8fHt9LHRoaXMuX2R1cmF0aW9uPXRoaXMuX3RvdGFsRHVyYXRpb249dHx8MCx0aGlzLl9kZWxheT1OdW1iZXIoZS5kZWxheSl8fDAsdGhpcy5fdGltZVNjYWxlPTEsdGhpcy5fYWN0aXZlPWUuaW1tZWRpYXRlUmVuZGVyPT09ITAsdGhpcy5kYXRhPWUuZGF0YSx0aGlzLl9yZXZlcnNlZD1lLnJldmVyc2VkPT09ITAsSCl7b3x8YS53YWtlKCk7dmFyIGk9dGhpcy52YXJzLnVzZUZyYW1lcz9LOkg7aS5hZGQodGhpcyxpLl90aW1lKSx0aGlzLnZhcnMucGF1c2VkJiZ0aGlzLnBhdXNlZCghMCl9fSk7YT1SLnRpY2tlcj1uZXcgaC5UaWNrZXIsbj1SLnByb3RvdHlwZSxuLl9kaXJ0eT1uLl9nYz1uLl9pbml0dGVkPW4uX3BhdXNlZD0hMSxuLl90b3RhbFRpbWU9bi5fdGltZT0wLG4uX3Jhd1ByZXZUaW1lPS0xLG4uX25leHQ9bi5fbGFzdD1uLl9vblVwZGF0ZT1uLl90aW1lbGluZT1uLnRpbWVsaW5lPW51bGwsbi5fcGF1c2VkPSExO3ZhciBDPWZ1bmN0aW9uKCl7byYmUygpLXg+MmUzJiZhLndha2UoKSxzZXRUaW1lb3V0KEMsMmUzKX07QygpLG4ucGxheT1mdW5jdGlvbih0LGUpe3JldHVybiBudWxsIT10JiZ0aGlzLnNlZWsodCxlKSx0aGlzLnJldmVyc2VkKCExKS5wYXVzZWQoITEpfSxuLnBhdXNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG51bGwhPXQmJnRoaXMuc2Vlayh0LGUpLHRoaXMucGF1c2VkKCEwKX0sbi5yZXN1bWU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbCE9dCYmdGhpcy5zZWVrKHQsZSksdGhpcy5wYXVzZWQoITEpfSxuLnNlZWs9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50b3RhbFRpbWUoTnVtYmVyKHQpLGUhPT0hMSl9LG4ucmVzdGFydD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnJldmVyc2VkKCExKS5wYXVzZWQoITEpLnRvdGFsVGltZSh0Py10aGlzLl9kZWxheTowLGUhPT0hMSwhMCl9LG4ucmV2ZXJzZT1mdW5jdGlvbih0LGUpe3JldHVybiBudWxsIT10JiZ0aGlzLnNlZWsodHx8dGhpcy50b3RhbER1cmF0aW9uKCksZSksdGhpcy5yZXZlcnNlZCghMCkucGF1c2VkKCExKX0sbi5yZW5kZXI9ZnVuY3Rpb24oKXt9LG4uaW52YWxpZGF0ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl90aW1lPXRoaXMuX3RvdGFsVGltZT0wLHRoaXMuX2luaXR0ZWQ9dGhpcy5fZ2M9ITEsdGhpcy5fcmF3UHJldlRpbWU9LTEsKHRoaXMuX2djfHwhdGhpcy50aW1lbGluZSkmJnRoaXMuX2VuYWJsZWQoITApLHRoaXN9LG4uaXNBY3RpdmU9ZnVuY3Rpb24oKXt2YXIgdCxlPXRoaXMuX3RpbWVsaW5lLGk9dGhpcy5fc3RhcnRUaW1lO3JldHVybiFlfHwhdGhpcy5fZ2MmJiF0aGlzLl9wYXVzZWQmJmUuaXNBY3RpdmUoKSYmKHQ9ZS5yYXdUaW1lKCkpPj1pJiZpK3RoaXMudG90YWxEdXJhdGlvbigpL3RoaXMuX3RpbWVTY2FsZT50fSxuLl9lbmFibGVkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG98fGEud2FrZSgpLHRoaXMuX2djPSF0LHRoaXMuX2FjdGl2ZT10aGlzLmlzQWN0aXZlKCksZSE9PSEwJiYodCYmIXRoaXMudGltZWxpbmU/dGhpcy5fdGltZWxpbmUuYWRkKHRoaXMsdGhpcy5fc3RhcnRUaW1lLXRoaXMuX2RlbGF5KTohdCYmdGhpcy50aW1lbGluZSYmdGhpcy5fdGltZWxpbmUuX3JlbW92ZSh0aGlzLCEwKSksITF9LG4uX2tpbGw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZW5hYmxlZCghMSwhMSl9LG4ua2lsbD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl9raWxsKHQsZSksdGhpc30sbi5fdW5jYWNoZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9dD90aGlzOnRoaXMudGltZWxpbmU7ZTspZS5fZGlydHk9ITAsZT1lLnRpbWVsaW5lO3JldHVybiB0aGlzfSxuLl9zd2FwU2VsZkluUGFyYW1zPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lmxlbmd0aCxpPXQuY29uY2F0KCk7LS1lPi0xOylcIntzZWxmfVwiPT09dFtlXSYmKGlbZV09dGhpcyk7cmV0dXJuIGl9LG4uX2NhbGxiYWNrPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMudmFycztlW3RdLmFwcGx5KGVbdCtcIlNjb3BlXCJdfHxlLmNhbGxiYWNrU2NvcGV8fHRoaXMsZVt0K1wiUGFyYW1zXCJdfHxUKX0sbi5ldmVudENhbGxiYWNrPWZ1bmN0aW9uKHQsZSxpLHMpe2lmKFwib25cIj09PSh0fHxcIlwiKS5zdWJzdHIoMCwyKSl7dmFyIHI9dGhpcy52YXJzO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiByW3RdO251bGw9PWU/ZGVsZXRlIHJbdF06KHJbdF09ZSxyW3QrXCJQYXJhbXNcIl09YyhpKSYmLTEhPT1pLmpvaW4oXCJcIikuaW5kZXhPZihcIntzZWxmfVwiKT90aGlzLl9zd2FwU2VsZkluUGFyYW1zKGkpOmksclt0K1wiU2NvcGVcIl09cyksXCJvblVwZGF0ZVwiPT09dCYmKHRoaXMuX29uVXBkYXRlPWUpfXJldHVybiB0aGlzfSxuLmRlbGF5PWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZyYmdGhpcy5zdGFydFRpbWUodGhpcy5fc3RhcnRUaW1lK3QtdGhpcy5fZGVsYXkpLHRoaXMuX2RlbGF5PXQsdGhpcyk6dGhpcy5fZGVsYXl9LG4uZHVyYXRpb249ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHRoaXMuX2R1cmF0aW9uPXRoaXMuX3RvdGFsRHVyYXRpb249dCx0aGlzLl91bmNhY2hlKCEwKSx0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZyYmdGhpcy5fdGltZT4wJiZ0aGlzLl90aW1lPHRoaXMuX2R1cmF0aW9uJiYwIT09dCYmdGhpcy50b3RhbFRpbWUodGhpcy5fdG90YWxUaW1lKih0L3RoaXMuX2R1cmF0aW9uKSwhMCksdGhpcyk6KHRoaXMuX2RpcnR5PSExLHRoaXMuX2R1cmF0aW9uKX0sbi50b3RhbER1cmF0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9kaXJ0eT0hMSxhcmd1bWVudHMubGVuZ3RoP3RoaXMuZHVyYXRpb24odCk6dGhpcy5fdG90YWxEdXJhdGlvbn0sbi50aW1lPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHRoaXMuX2RpcnR5JiZ0aGlzLnRvdGFsRHVyYXRpb24oKSx0aGlzLnRvdGFsVGltZSh0PnRoaXMuX2R1cmF0aW9uP3RoaXMuX2R1cmF0aW9uOnQsZSkpOnRoaXMuX3RpbWV9LG4udG90YWxUaW1lPWZ1bmN0aW9uKHQsZSxpKXtpZihvfHxhLndha2UoKSwhYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5fdG90YWxUaW1lO2lmKHRoaXMuX3RpbWVsaW5lKXtpZigwPnQmJiFpJiYodCs9dGhpcy50b3RhbER1cmF0aW9uKCkpLHRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKXt0aGlzLl9kaXJ0eSYmdGhpcy50b3RhbER1cmF0aW9uKCk7dmFyIHM9dGhpcy5fdG90YWxEdXJhdGlvbixyPXRoaXMuX3RpbWVsaW5lO2lmKHQ+cyYmIWkmJih0PXMpLHRoaXMuX3N0YXJ0VGltZT0odGhpcy5fcGF1c2VkP3RoaXMuX3BhdXNlVGltZTpyLl90aW1lKS0odGhpcy5fcmV2ZXJzZWQ/cy10OnQpL3RoaXMuX3RpbWVTY2FsZSxyLl9kaXJ0eXx8dGhpcy5fdW5jYWNoZSghMSksci5fdGltZWxpbmUpZm9yKDtyLl90aW1lbGluZTspci5fdGltZWxpbmUuX3RpbWUhPT0oci5fc3RhcnRUaW1lK3IuX3RvdGFsVGltZSkvci5fdGltZVNjYWxlJiZyLnRvdGFsVGltZShyLl90b3RhbFRpbWUsITApLHI9ci5fdGltZWxpbmV9dGhpcy5fZ2MmJnRoaXMuX2VuYWJsZWQoITAsITEpLCh0aGlzLl90b3RhbFRpbWUhPT10fHwwPT09dGhpcy5fZHVyYXRpb24pJiYoei5sZW5ndGgmJlYoKSx0aGlzLnJlbmRlcih0LGUsITEpLHoubGVuZ3RoJiZWKCkpfXJldHVybiB0aGlzfSxuLnByb2dyZXNzPW4udG90YWxQcm9ncmVzcz1mdW5jdGlvbih0LGUpe3ZhciBpPXRoaXMuZHVyYXRpb24oKTtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD90aGlzLnRvdGFsVGltZShpKnQsZSk6aT90aGlzLl90aW1lL2k6dGhpcy5yYXRpb30sbi5zdGFydFRpbWU9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHQhPT10aGlzLl9zdGFydFRpbWUmJih0aGlzLl9zdGFydFRpbWU9dCx0aGlzLnRpbWVsaW5lJiZ0aGlzLnRpbWVsaW5lLl9zb3J0Q2hpbGRyZW4mJnRoaXMudGltZWxpbmUuYWRkKHRoaXMsdC10aGlzLl9kZWxheSkpLHRoaXMpOnRoaXMuX3N0YXJ0VGltZX0sbi5lbmRUaW1lPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9zdGFydFRpbWUrKDAhPXQ/dGhpcy50b3RhbER1cmF0aW9uKCk6dGhpcy5kdXJhdGlvbigpKS90aGlzLl90aW1lU2NhbGV9LG4udGltZVNjYWxlPWZ1bmN0aW9uKHQpe2lmKCFhcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLl90aW1lU2NhbGU7aWYodD10fHxfLHRoaXMuX3RpbWVsaW5lJiZ0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZyl7dmFyIGU9dGhpcy5fcGF1c2VUaW1lLGk9ZXx8MD09PWU/ZTp0aGlzLl90aW1lbGluZS50b3RhbFRpbWUoKTt0aGlzLl9zdGFydFRpbWU9aS0oaS10aGlzLl9zdGFydFRpbWUpKnRoaXMuX3RpbWVTY2FsZS90fXJldHVybiB0aGlzLl90aW1lU2NhbGU9dCx0aGlzLl91bmNhY2hlKCExKX0sbi5yZXZlcnNlZD1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odCE9dGhpcy5fcmV2ZXJzZWQmJih0aGlzLl9yZXZlcnNlZD10LHRoaXMudG90YWxUaW1lKHRoaXMuX3RpbWVsaW5lJiYhdGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmc/dGhpcy50b3RhbER1cmF0aW9uKCktdGhpcy5fdG90YWxUaW1lOnRoaXMuX3RvdGFsVGltZSwhMCkpLHRoaXMpOnRoaXMuX3JldmVyc2VkfSxuLnBhdXNlZD1mdW5jdGlvbih0KXtpZighYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5fcGF1c2VkO3ZhciBlLGkscz10aGlzLl90aW1lbGluZTtyZXR1cm4gdCE9dGhpcy5fcGF1c2VkJiZzJiYob3x8dHx8YS53YWtlKCksZT1zLnJhd1RpbWUoKSxpPWUtdGhpcy5fcGF1c2VUaW1lLCF0JiZzLnNtb290aENoaWxkVGltaW5nJiYodGhpcy5fc3RhcnRUaW1lKz1pLHRoaXMuX3VuY2FjaGUoITEpKSx0aGlzLl9wYXVzZVRpbWU9dD9lOm51bGwsdGhpcy5fcGF1c2VkPXQsdGhpcy5fYWN0aXZlPXRoaXMuaXNBY3RpdmUoKSwhdCYmMCE9PWkmJnRoaXMuX2luaXR0ZWQmJnRoaXMuZHVyYXRpb24oKSYmKGU9cy5zbW9vdGhDaGlsZFRpbWluZz90aGlzLl90b3RhbFRpbWU6KGUtdGhpcy5fc3RhcnRUaW1lKS90aGlzLl90aW1lU2NhbGUsdGhpcy5yZW5kZXIoZSxlPT09dGhpcy5fdG90YWxUaW1lLCEwKSkpLHRoaXMuX2djJiYhdCYmdGhpcy5fZW5hYmxlZCghMCwhMSksdGhpc307dmFyIEQ9dihcImNvcmUuU2ltcGxlVGltZWxpbmVcIixmdW5jdGlvbih0KXtSLmNhbGwodGhpcywwLHQpLHRoaXMuYXV0b1JlbW92ZUNoaWxkcmVuPXRoaXMuc21vb3RoQ2hpbGRUaW1pbmc9ITB9KTtuPUQucHJvdG90eXBlPW5ldyBSLG4uY29uc3RydWN0b3I9RCxuLmtpbGwoKS5fZ2M9ITEsbi5fZmlyc3Q9bi5fbGFzdD1uLl9yZWNlbnQ9bnVsbCxuLl9zb3J0Q2hpbGRyZW49ITEsbi5hZGQ9bi5pbnNlcnQ9ZnVuY3Rpb24odCxlKXt2YXIgaSxzO2lmKHQuX3N0YXJ0VGltZT1OdW1iZXIoZXx8MCkrdC5fZGVsYXksdC5fcGF1c2VkJiZ0aGlzIT09dC5fdGltZWxpbmUmJih0Ll9wYXVzZVRpbWU9dC5fc3RhcnRUaW1lKyh0aGlzLnJhd1RpbWUoKS10Ll9zdGFydFRpbWUpL3QuX3RpbWVTY2FsZSksdC50aW1lbGluZSYmdC50aW1lbGluZS5fcmVtb3ZlKHQsITApLHQudGltZWxpbmU9dC5fdGltZWxpbmU9dGhpcyx0Ll9nYyYmdC5fZW5hYmxlZCghMCwhMCksaT10aGlzLl9sYXN0LHRoaXMuX3NvcnRDaGlsZHJlbilmb3Iocz10Ll9zdGFydFRpbWU7aSYmaS5fc3RhcnRUaW1lPnM7KWk9aS5fcHJldjtyZXR1cm4gaT8odC5fbmV4dD1pLl9uZXh0LGkuX25leHQ9dCk6KHQuX25leHQ9dGhpcy5fZmlyc3QsdGhpcy5fZmlyc3Q9dCksdC5fbmV4dD90Ll9uZXh0Ll9wcmV2PXQ6dGhpcy5fbGFzdD10LHQuX3ByZXY9aSx0aGlzLl9yZWNlbnQ9dCx0aGlzLl90aW1lbGluZSYmdGhpcy5fdW5jYWNoZSghMCksdGhpc30sbi5fcmVtb3ZlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQudGltZWxpbmU9PT10aGlzJiYoZXx8dC5fZW5hYmxlZCghMSwhMCksdC5fcHJldj90Ll9wcmV2Ll9uZXh0PXQuX25leHQ6dGhpcy5fZmlyc3Q9PT10JiYodGhpcy5fZmlyc3Q9dC5fbmV4dCksdC5fbmV4dD90Ll9uZXh0Ll9wcmV2PXQuX3ByZXY6dGhpcy5fbGFzdD09PXQmJih0aGlzLl9sYXN0PXQuX3ByZXYpLHQuX25leHQ9dC5fcHJldj10LnRpbWVsaW5lPW51bGwsdD09PXRoaXMuX3JlY2VudCYmKHRoaXMuX3JlY2VudD10aGlzLl9sYXN0KSx0aGlzLl90aW1lbGluZSYmdGhpcy5fdW5jYWNoZSghMCkpLHRoaXN9LG4ucmVuZGVyPWZ1bmN0aW9uKHQsZSxpKXt2YXIgcyxyPXRoaXMuX2ZpcnN0O2Zvcih0aGlzLl90b3RhbFRpbWU9dGhpcy5fdGltZT10aGlzLl9yYXdQcmV2VGltZT10O3I7KXM9ci5fbmV4dCwoci5fYWN0aXZlfHx0Pj1yLl9zdGFydFRpbWUmJiFyLl9wYXVzZWQpJiYoci5fcmV2ZXJzZWQ/ci5yZW5kZXIoKHIuX2RpcnR5P3IudG90YWxEdXJhdGlvbigpOnIuX3RvdGFsRHVyYXRpb24pLSh0LXIuX3N0YXJ0VGltZSkqci5fdGltZVNjYWxlLGUsaSk6ci5yZW5kZXIoKHQtci5fc3RhcnRUaW1lKSpyLl90aW1lU2NhbGUsZSxpKSkscj1zfSxuLnJhd1RpbWU9ZnVuY3Rpb24oKXtyZXR1cm4gb3x8YS53YWtlKCksdGhpcy5fdG90YWxUaW1lfTt2YXIgST12KFwiVHdlZW5MaXRlXCIsZnVuY3Rpb24oZSxpLHMpe2lmKFIuY2FsbCh0aGlzLGkscyksdGhpcy5yZW5kZXI9SS5wcm90b3R5cGUucmVuZGVyLG51bGw9PWUpdGhyb3dcIkNhbm5vdCB0d2VlbiBhIG51bGwgdGFyZ2V0LlwiO3RoaXMudGFyZ2V0PWU9XCJzdHJpbmdcIiE9dHlwZW9mIGU/ZTpJLnNlbGVjdG9yKGUpfHxlO3ZhciByLG4sYSxvPWUuanF1ZXJ5fHxlLmxlbmd0aCYmZSE9PXQmJmVbMF0mJihlWzBdPT09dHx8ZVswXS5ub2RlVHlwZSYmZVswXS5zdHlsZSYmIWUubm9kZVR5cGUpLGw9dGhpcy52YXJzLm92ZXJ3cml0ZTtpZih0aGlzLl9vdmVyd3JpdGU9bD1udWxsPT1sPyRbSS5kZWZhdWx0T3ZlcndyaXRlXTpcIm51bWJlclwiPT10eXBlb2YgbD9sPj4wOiRbbF0sKG98fGUgaW5zdGFuY2VvZiBBcnJheXx8ZS5wdXNoJiZjKGUpKSYmXCJudW1iZXJcIiE9dHlwZW9mIGVbMF0pZm9yKHRoaXMuX3RhcmdldHM9YT11KGUpLHRoaXMuX3Byb3BMb29rdXA9W10sdGhpcy5fc2libGluZ3M9W10scj0wO2EubGVuZ3RoPnI7cisrKW49YVtyXSxuP1wic3RyaW5nXCIhPXR5cGVvZiBuP24ubGVuZ3RoJiZuIT09dCYmblswXSYmKG5bMF09PT10fHxuWzBdLm5vZGVUeXBlJiZuWzBdLnN0eWxlJiYhbi5ub2RlVHlwZSk/KGEuc3BsaWNlKHItLSwxKSx0aGlzLl90YXJnZXRzPWE9YS5jb25jYXQodShuKSkpOih0aGlzLl9zaWJsaW5nc1tyXT1XKG4sdGhpcywhMSksMT09PWwmJnRoaXMuX3NpYmxpbmdzW3JdLmxlbmd0aD4xJiZZKG4sdGhpcyxudWxsLDEsdGhpcy5fc2libGluZ3Nbcl0pKToobj1hW3ItLV09SS5zZWxlY3RvcihuKSxcInN0cmluZ1wiPT10eXBlb2YgbiYmYS5zcGxpY2UocisxLDEpKTphLnNwbGljZShyLS0sMSk7ZWxzZSB0aGlzLl9wcm9wTG9va3VwPXt9LHRoaXMuX3NpYmxpbmdzPVcoZSx0aGlzLCExKSwxPT09bCYmdGhpcy5fc2libGluZ3MubGVuZ3RoPjEmJlkoZSx0aGlzLG51bGwsMSx0aGlzLl9zaWJsaW5ncyk7KHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXJ8fDA9PT1pJiYwPT09dGhpcy5fZGVsYXkmJnRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXIhPT0hMSkmJih0aGlzLl90aW1lPS1fLHRoaXMucmVuZGVyKC10aGlzLl9kZWxheSkpfSwhMCksRT1mdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5sZW5ndGgmJmUhPT10JiZlWzBdJiYoZVswXT09PXR8fGVbMF0ubm9kZVR5cGUmJmVbMF0uc3R5bGUmJiFlLm5vZGVUeXBlKX0sTz1mdW5jdGlvbih0LGUpe3ZhciBpLHM9e307Zm9yKGkgaW4gdClNW2ldfHxpIGluIGUmJlwidHJhbnNmb3JtXCIhPT1pJiZcInhcIiE9PWkmJlwieVwiIT09aSYmXCJ3aWR0aFwiIT09aSYmXCJoZWlnaHRcIiE9PWkmJlwiY2xhc3NOYW1lXCIhPT1pJiZcImJvcmRlclwiIT09aXx8ISghUVtpXXx8UVtpXSYmUVtpXS5fYXV0b0NTUyl8fChzW2ldPXRbaV0sZGVsZXRlIHRbaV0pO3QuY3NzPXN9O249SS5wcm90b3R5cGU9bmV3IFIsbi5jb25zdHJ1Y3Rvcj1JLG4ua2lsbCgpLl9nYz0hMSxuLnJhdGlvPTAsbi5fZmlyc3RQVD1uLl90YXJnZXRzPW4uX292ZXJ3cml0dGVuUHJvcHM9bi5fc3RhcnRBdD1udWxsLG4uX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQ9bi5fbGF6eT0hMSxJLnZlcnNpb249XCIxLjE4LjBcIixJLmRlZmF1bHRFYXNlPW4uX2Vhc2U9bmV3IHkobnVsbCxudWxsLDEsMSksSS5kZWZhdWx0T3ZlcndyaXRlPVwiYXV0b1wiLEkudGlja2VyPWEsSS5hdXRvU2xlZXA9MTIwLEkubGFnU21vb3RoaW5nPWZ1bmN0aW9uKHQsZSl7YS5sYWdTbW9vdGhpbmcodCxlKX0sSS5zZWxlY3Rvcj10LiR8fHQualF1ZXJ5fHxmdW5jdGlvbihlKXt2YXIgaT10LiR8fHQualF1ZXJ5O3JldHVybiBpPyhJLnNlbGVjdG9yPWksaShlKSk6XCJ1bmRlZmluZWRcIj09dHlwZW9mIGRvY3VtZW50P2U6ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbD9kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGUpOmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiI1wiPT09ZS5jaGFyQXQoMCk/ZS5zdWJzdHIoMSk6ZSl9O3ZhciB6PVtdLEY9e30sTD0vKD86KC18LT18XFwrPSk/XFxkKlxcLj9cXGQqKD86ZVtcXC0rXT9cXGQrKT8pWzAtOV0vZ2ksTj1mdW5jdGlvbih0KXtmb3IodmFyIGUsaT10aGlzLl9maXJzdFBULHM9MWUtNjtpOyllPWkuYmxvYj90P3RoaXMuam9pbihcIlwiKTp0aGlzLnN0YXJ0OmkuYyp0K2kucyxpLnI/ZT1NYXRoLnJvdW5kKGUpOnM+ZSYmZT4tcyYmKGU9MCksaS5mP2kuZnA/aS50W2kucF0oaS5mcCxlKTppLnRbaS5wXShlKTppLnRbaS5wXT1lLGk9aS5fbmV4dH0sVT1mdW5jdGlvbih0LGUsaSxzKXt2YXIgcixuLGEsbyxsLGgsXyx1PVt0LGVdLGY9MCxjPVwiXCIsbT0wO2Zvcih1LnN0YXJ0PXQsaSYmKGkodSksdD11WzBdLGU9dVsxXSksdS5sZW5ndGg9MCxyPXQubWF0Y2goTCl8fFtdLG49ZS5tYXRjaChMKXx8W10scyYmKHMuX25leHQ9bnVsbCxzLmJsb2I9MSx1Ll9maXJzdFBUPXMpLGw9bi5sZW5ndGgsbz0wO2w+bztvKyspXz1uW29dLGg9ZS5zdWJzdHIoZixlLmluZGV4T2YoXyxmKS1mKSxjKz1ofHwhbz9oOlwiLFwiLGYrPWgubGVuZ3RoLG0/bT0obSsxKSU1OlwicmdiYShcIj09PWguc3Vic3RyKC01KSYmKG09MSksXz09PXJbb118fG8+PXIubGVuZ3RoP2MrPV86KGMmJih1LnB1c2goYyksYz1cIlwiKSxhPXBhcnNlRmxvYXQocltvXSksdS5wdXNoKGEpLHUuX2ZpcnN0UFQ9e19uZXh0OnUuX2ZpcnN0UFQsdDp1LHA6dS5sZW5ndGgtMSxzOmEsYzooXCI9XCI9PT1fLmNoYXJBdCgxKT9wYXJzZUludChfLmNoYXJBdCgwKStcIjFcIiwxMCkqcGFyc2VGbG9hdChfLnN1YnN0cigyKSk6cGFyc2VGbG9hdChfKS1hKXx8MCxmOjAscjptJiY0Pm19KSxmKz1fLmxlbmd0aDtyZXR1cm4gYys9ZS5zdWJzdHIoZiksYyYmdS5wdXNoKGMpLHUuc2V0UmF0aW89Tix1fSxqPWZ1bmN0aW9uKHQsZSxpLHMscixuLGEsbyl7dmFyIGwsaCxfPVwiZ2V0XCI9PT1pP3RbZV06aSx1PXR5cGVvZiB0W2VdLGY9XCJzdHJpbmdcIj09dHlwZW9mIHMmJlwiPVwiPT09cy5jaGFyQXQoMSksYz17dDp0LHA6ZSxzOl8sZjpcImZ1bmN0aW9uXCI9PT11LHBnOjAsbjpyfHxlLHI6bixwcjowLGM6Zj9wYXJzZUludChzLmNoYXJBdCgwKStcIjFcIiwxMCkqcGFyc2VGbG9hdChzLnN1YnN0cigyKSk6cGFyc2VGbG9hdChzKS1ffHwwfTtyZXR1cm5cIm51bWJlclwiIT09dSYmKFwiZnVuY3Rpb25cIj09PXUmJlwiZ2V0XCI9PT1pJiYoaD1lLmluZGV4T2YoXCJzZXRcIil8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIHRbXCJnZXRcIitlLnN1YnN0cigzKV0/ZTpcImdldFwiK2Uuc3Vic3RyKDMpLGMucz1fPWE/dFtoXShhKTp0W2hdKCkpLFwic3RyaW5nXCI9PXR5cGVvZiBfJiYoYXx8aXNOYU4oXykpPyhjLmZwPWEsbD1VKF8scyxvfHxJLmRlZmF1bHRTdHJpbmdGaWx0ZXIsYyksYz17dDpsLHA6XCJzZXRSYXRpb1wiLHM6MCxjOjEsZjoyLHBnOjAsbjpyfHxlLHByOjB9KTpmfHwoYy5jPXBhcnNlRmxvYXQocyktcGFyc2VGbG9hdChfKXx8MCkpLGMuYz8oKGMuX25leHQ9dGhpcy5fZmlyc3RQVCkmJihjLl9uZXh0Ll9wcmV2PWMpLHRoaXMuX2ZpcnN0UFQ9YyxjKTp2b2lkIDB9LEc9SS5faW50ZXJuYWxzPXtpc0FycmF5OmMsaXNTZWxlY3RvcjpFLGxhenlUd2VlbnM6eixibG9iRGlmOlV9LFE9SS5fcGx1Z2lucz17fSxxPUcudHdlZW5Mb29rdXA9e30sQj0wLE09Ry5yZXNlcnZlZFByb3BzPXtlYXNlOjEsZGVsYXk6MSxvdmVyd3JpdGU6MSxvbkNvbXBsZXRlOjEsb25Db21wbGV0ZVBhcmFtczoxLG9uQ29tcGxldGVTY29wZToxLHVzZUZyYW1lczoxLHJ1bkJhY2t3YXJkczoxLHN0YXJ0QXQ6MSxvblVwZGF0ZToxLG9uVXBkYXRlUGFyYW1zOjEsb25VcGRhdGVTY29wZToxLG9uU3RhcnQ6MSxvblN0YXJ0UGFyYW1zOjEsb25TdGFydFNjb3BlOjEsb25SZXZlcnNlQ29tcGxldGU6MSxvblJldmVyc2VDb21wbGV0ZVBhcmFtczoxLG9uUmV2ZXJzZUNvbXBsZXRlU2NvcGU6MSxvblJlcGVhdDoxLG9uUmVwZWF0UGFyYW1zOjEsb25SZXBlYXRTY29wZToxLGVhc2VQYXJhbXM6MSx5b3lvOjEsaW1tZWRpYXRlUmVuZGVyOjEscmVwZWF0OjEscmVwZWF0RGVsYXk6MSxkYXRhOjEscGF1c2VkOjEscmV2ZXJzZWQ6MSxhdXRvQ1NTOjEsbGF6eToxLG9uT3ZlcndyaXRlOjEsY2FsbGJhY2tTY29wZToxLHN0cmluZ0ZpbHRlcjoxfSwkPXtub25lOjAsYWxsOjEsYXV0bzoyLGNvbmN1cnJlbnQ6MyxhbGxPblN0YXJ0OjQscHJlZXhpc3Rpbmc6NSxcInRydWVcIjoxLFwiZmFsc2VcIjowfSxLPVIuX3Jvb3RGcmFtZXNUaW1lbGluZT1uZXcgRCxIPVIuX3Jvb3RUaW1lbGluZT1uZXcgRCxKPTMwLFY9Ry5sYXp5UmVuZGVyPWZ1bmN0aW9uKCl7dmFyIHQsZT16Lmxlbmd0aDtmb3IoRj17fTstLWU+LTE7KXQ9eltlXSx0JiZ0Ll9sYXp5IT09ITEmJih0LnJlbmRlcih0Ll9sYXp5WzBdLHQuX2xhenlbMV0sITApLHQuX2xhenk9ITEpO3oubGVuZ3RoPTB9O0guX3N0YXJ0VGltZT1hLnRpbWUsSy5fc3RhcnRUaW1lPWEuZnJhbWUsSC5fYWN0aXZlPUsuX2FjdGl2ZT0hMCxzZXRUaW1lb3V0KFYsMSksUi5fdXBkYXRlUm9vdD1JLnJlbmRlcj1mdW5jdGlvbigpe3ZhciB0LGUsaTtpZih6Lmxlbmd0aCYmVigpLEgucmVuZGVyKChhLnRpbWUtSC5fc3RhcnRUaW1lKSpILl90aW1lU2NhbGUsITEsITEpLEsucmVuZGVyKChhLmZyYW1lLUsuX3N0YXJ0VGltZSkqSy5fdGltZVNjYWxlLCExLCExKSx6Lmxlbmd0aCYmVigpLGEuZnJhbWU+PUope0o9YS5mcmFtZSsocGFyc2VJbnQoSS5hdXRvU2xlZXAsMTApfHwxMjApO2ZvcihpIGluIHEpe2ZvcihlPXFbaV0udHdlZW5zLHQ9ZS5sZW5ndGg7LS10Pi0xOyllW3RdLl9nYyYmZS5zcGxpY2UodCwxKTswPT09ZS5sZW5ndGgmJmRlbGV0ZSBxW2ldfWlmKGk9SC5fZmlyc3QsKCFpfHxpLl9wYXVzZWQpJiZJLmF1dG9TbGVlcCYmIUsuX2ZpcnN0JiYxPT09YS5fbGlzdGVuZXJzLnRpY2subGVuZ3RoKXtmb3IoO2kmJmkuX3BhdXNlZDspaT1pLl9uZXh0O2l8fGEuc2xlZXAoKX19fSxhLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsUi5fdXBkYXRlUm9vdCk7dmFyIFc9ZnVuY3Rpb24odCxlLGkpe3ZhciBzLHIsbj10Ll9nc1R3ZWVuSUQ7aWYocVtufHwodC5fZ3NUd2VlbklEPW49XCJ0XCIrQisrKV18fChxW25dPXt0YXJnZXQ6dCx0d2VlbnM6W119KSxlJiYocz1xW25dLnR3ZWVucyxzW3I9cy5sZW5ndGhdPWUsaSkpZm9yKDstLXI+LTE7KXNbcl09PT1lJiZzLnNwbGljZShyLDEpO3JldHVybiBxW25dLnR3ZWVuc30sWD1mdW5jdGlvbih0LGUsaSxzKXt2YXIgcixuLGE9dC52YXJzLm9uT3ZlcndyaXRlO3JldHVybiBhJiYocj1hKHQsZSxpLHMpKSxhPUkub25PdmVyd3JpdGUsYSYmKG49YSh0LGUsaSxzKSksciE9PSExJiZuIT09ITF9LFk9ZnVuY3Rpb24odCxlLGkscyxyKXt2YXIgbixhLG8sbDtpZigxPT09c3x8cz49NCl7Zm9yKGw9ci5sZW5ndGgsbj0wO2w+bjtuKyspaWYoKG89cltuXSkhPT1lKW8uX2djfHxvLl9raWxsKG51bGwsdCxlKSYmKGE9ITApO2Vsc2UgaWYoNT09PXMpYnJlYWs7cmV0dXJuIGF9dmFyIGgsdT1lLl9zdGFydFRpbWUrXyxmPVtdLGM9MCxtPTA9PT1lLl9kdXJhdGlvbjtmb3Iobj1yLmxlbmd0aDstLW4+LTE7KShvPXJbbl0pPT09ZXx8by5fZ2N8fG8uX3BhdXNlZHx8KG8uX3RpbWVsaW5lIT09ZS5fdGltZWxpbmU/KGg9aHx8WihlLDAsbSksMD09PVoobyxoLG0pJiYoZltjKytdPW8pKTp1Pj1vLl9zdGFydFRpbWUmJm8uX3N0YXJ0VGltZStvLnRvdGFsRHVyYXRpb24oKS9vLl90aW1lU2NhbGU+dSYmKChtfHwhby5faW5pdHRlZCkmJjJlLTEwPj11LW8uX3N0YXJ0VGltZXx8KGZbYysrXT1vKSkpO2ZvcihuPWM7LS1uPi0xOylpZihvPWZbbl0sMj09PXMmJm8uX2tpbGwoaSx0LGUpJiYoYT0hMCksMiE9PXN8fCFvLl9maXJzdFBUJiZvLl9pbml0dGVkKXtpZigyIT09cyYmIVgobyxlKSljb250aW51ZTtvLl9lbmFibGVkKCExLCExKSYmKGE9ITApfXJldHVybiBhfSxaPWZ1bmN0aW9uKHQsZSxpKXtmb3IodmFyIHM9dC5fdGltZWxpbmUscj1zLl90aW1lU2NhbGUsbj10Ll9zdGFydFRpbWU7cy5fdGltZWxpbmU7KXtpZihuKz1zLl9zdGFydFRpbWUscio9cy5fdGltZVNjYWxlLHMuX3BhdXNlZClyZXR1cm4tMTAwO3M9cy5fdGltZWxpbmV9cmV0dXJuIG4vPXIsbj5lP24tZTppJiZuPT09ZXx8IXQuX2luaXR0ZWQmJjIqXz5uLWU/Xzoobis9dC50b3RhbER1cmF0aW9uKCkvdC5fdGltZVNjYWxlL3IpPmUrXz8wOm4tZS1ffTtuLl9pbml0PWZ1bmN0aW9uKCl7dmFyIHQsZSxpLHMscixuPXRoaXMudmFycyxhPXRoaXMuX292ZXJ3cml0dGVuUHJvcHMsbz10aGlzLl9kdXJhdGlvbixsPSEhbi5pbW1lZGlhdGVSZW5kZXIsaD1uLmVhc2U7aWYobi5zdGFydEF0KXt0aGlzLl9zdGFydEF0JiYodGhpcy5fc3RhcnRBdC5yZW5kZXIoLTEsITApLHRoaXMuX3N0YXJ0QXQua2lsbCgpKSxyPXt9O2ZvcihzIGluIG4uc3RhcnRBdClyW3NdPW4uc3RhcnRBdFtzXTtpZihyLm92ZXJ3cml0ZT0hMSxyLmltbWVkaWF0ZVJlbmRlcj0hMCxyLmxhenk9bCYmbi5sYXp5IT09ITEsci5zdGFydEF0PXIuZGVsYXk9bnVsbCx0aGlzLl9zdGFydEF0PUkudG8odGhpcy50YXJnZXQsMCxyKSxsKWlmKHRoaXMuX3RpbWU+MCl0aGlzLl9zdGFydEF0PW51bGw7ZWxzZSBpZigwIT09bylyZXR1cm59ZWxzZSBpZihuLnJ1bkJhY2t3YXJkcyYmMCE9PW8paWYodGhpcy5fc3RhcnRBdCl0aGlzLl9zdGFydEF0LnJlbmRlcigtMSwhMCksdGhpcy5fc3RhcnRBdC5raWxsKCksdGhpcy5fc3RhcnRBdD1udWxsO2Vsc2V7MCE9PXRoaXMuX3RpbWUmJihsPSExKSxpPXt9O2ZvcihzIGluIG4pTVtzXSYmXCJhdXRvQ1NTXCIhPT1zfHwoaVtzXT1uW3NdKTtpZihpLm92ZXJ3cml0ZT0wLGkuZGF0YT1cImlzRnJvbVN0YXJ0XCIsaS5sYXp5PWwmJm4ubGF6eSE9PSExLGkuaW1tZWRpYXRlUmVuZGVyPWwsdGhpcy5fc3RhcnRBdD1JLnRvKHRoaXMudGFyZ2V0LDAsaSksbCl7aWYoMD09PXRoaXMuX3RpbWUpcmV0dXJufWVsc2UgdGhpcy5fc3RhcnRBdC5faW5pdCgpLHRoaXMuX3N0YXJ0QXQuX2VuYWJsZWQoITEpLHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXImJih0aGlzLl9zdGFydEF0PW51bGwpfWlmKHRoaXMuX2Vhc2U9aD1oP2ggaW5zdGFuY2VvZiB5P2g6XCJmdW5jdGlvblwiPT10eXBlb2YgaD9uZXcgeShoLG4uZWFzZVBhcmFtcyk6d1toXXx8SS5kZWZhdWx0RWFzZTpJLmRlZmF1bHRFYXNlLG4uZWFzZVBhcmFtcyBpbnN0YW5jZW9mIEFycmF5JiZoLmNvbmZpZyYmKHRoaXMuX2Vhc2U9aC5jb25maWcuYXBwbHkoaCxuLmVhc2VQYXJhbXMpKSx0aGlzLl9lYXNlVHlwZT10aGlzLl9lYXNlLl90eXBlLHRoaXMuX2Vhc2VQb3dlcj10aGlzLl9lYXNlLl9wb3dlcix0aGlzLl9maXJzdFBUPW51bGwsdGhpcy5fdGFyZ2V0cylmb3IodD10aGlzLl90YXJnZXRzLmxlbmd0aDstLXQ+LTE7KXRoaXMuX2luaXRQcm9wcyh0aGlzLl90YXJnZXRzW3RdLHRoaXMuX3Byb3BMb29rdXBbdF09e30sdGhpcy5fc2libGluZ3NbdF0sYT9hW3RdOm51bGwpJiYoZT0hMCk7ZWxzZSBlPXRoaXMuX2luaXRQcm9wcyh0aGlzLnRhcmdldCx0aGlzLl9wcm9wTG9va3VwLHRoaXMuX3NpYmxpbmdzLGEpO2lmKGUmJkkuX29uUGx1Z2luRXZlbnQoXCJfb25Jbml0QWxsUHJvcHNcIix0aGlzKSxhJiYodGhpcy5fZmlyc3RQVHx8XCJmdW5jdGlvblwiIT10eXBlb2YgdGhpcy50YXJnZXQmJnRoaXMuX2VuYWJsZWQoITEsITEpKSxuLnJ1bkJhY2t3YXJkcylmb3IoaT10aGlzLl9maXJzdFBUO2k7KWkucys9aS5jLGkuYz0taS5jLGk9aS5fbmV4dDt0aGlzLl9vblVwZGF0ZT1uLm9uVXBkYXRlLHRoaXMuX2luaXR0ZWQ9ITB9LG4uX2luaXRQcm9wcz1mdW5jdGlvbihlLGkscyxyKXt2YXIgbixhLG8sbCxoLF87aWYobnVsbD09ZSlyZXR1cm4hMTtGW2UuX2dzVHdlZW5JRF0mJlYoKSx0aGlzLnZhcnMuY3NzfHxlLnN0eWxlJiZlIT09dCYmZS5ub2RlVHlwZSYmUS5jc3MmJnRoaXMudmFycy5hdXRvQ1NTIT09ITEmJk8odGhpcy52YXJzLGUpO2ZvcihuIGluIHRoaXMudmFycylpZihfPXRoaXMudmFyc1tuXSxNW25dKV8mJihfIGluc3RhbmNlb2YgQXJyYXl8fF8ucHVzaCYmYyhfKSkmJi0xIT09Xy5qb2luKFwiXCIpLmluZGV4T2YoXCJ7c2VsZn1cIikmJih0aGlzLnZhcnNbbl09Xz10aGlzLl9zd2FwU2VsZkluUGFyYW1zKF8sdGhpcykpO2Vsc2UgaWYoUVtuXSYmKGw9bmV3IFFbbl0pLl9vbkluaXRUd2VlbihlLHRoaXMudmFyc1tuXSx0aGlzKSl7Zm9yKHRoaXMuX2ZpcnN0UFQ9aD17X25leHQ6dGhpcy5fZmlyc3RQVCx0OmwscDpcInNldFJhdGlvXCIsczowLGM6MSxmOjEsbjpuLHBnOjEscHI6bC5fcHJpb3JpdHl9LGE9bC5fb3ZlcndyaXRlUHJvcHMubGVuZ3RoOy0tYT4tMTspaVtsLl9vdmVyd3JpdGVQcm9wc1thXV09dGhpcy5fZmlyc3RQVDsobC5fcHJpb3JpdHl8fGwuX29uSW5pdEFsbFByb3BzKSYmKG89ITApLChsLl9vbkRpc2FibGV8fGwuX29uRW5hYmxlKSYmKHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQ9ITApLGguX25leHQmJihoLl9uZXh0Ll9wcmV2PWgpfWVsc2UgaVtuXT1qLmNhbGwodGhpcyxlLG4sXCJnZXRcIixfLG4sMCxudWxsLHRoaXMudmFycy5zdHJpbmdGaWx0ZXIpO3JldHVybiByJiZ0aGlzLl9raWxsKHIsZSk/dGhpcy5faW5pdFByb3BzKGUsaSxzLHIpOnRoaXMuX292ZXJ3cml0ZT4xJiZ0aGlzLl9maXJzdFBUJiZzLmxlbmd0aD4xJiZZKGUsdGhpcyxpLHRoaXMuX292ZXJ3cml0ZSxzKT8odGhpcy5fa2lsbChpLGUpLHRoaXMuX2luaXRQcm9wcyhlLGkscyxyKSk6KHRoaXMuX2ZpcnN0UFQmJih0aGlzLnZhcnMubGF6eSE9PSExJiZ0aGlzLl9kdXJhdGlvbnx8dGhpcy52YXJzLmxhenkmJiF0aGlzLl9kdXJhdGlvbikmJihGW2UuX2dzVHdlZW5JRF09ITApLG8pfSxuLnJlbmRlcj1mdW5jdGlvbih0LGUsaSl7dmFyIHMscixuLGEsbz10aGlzLl90aW1lLGw9dGhpcy5fZHVyYXRpb24saD10aGlzLl9yYXdQcmV2VGltZTtpZih0Pj1sKXRoaXMuX3RvdGFsVGltZT10aGlzLl90aW1lPWwsdGhpcy5yYXRpbz10aGlzLl9lYXNlLl9jYWxjRW5kP3RoaXMuX2Vhc2UuZ2V0UmF0aW8oMSk6MSx0aGlzLl9yZXZlcnNlZHx8KHM9ITAscj1cIm9uQ29tcGxldGVcIixpPWl8fHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbiksMD09PWwmJih0aGlzLl9pbml0dGVkfHwhdGhpcy52YXJzLmxhenl8fGkpJiYodGhpcy5fc3RhcnRUaW1lPT09dGhpcy5fdGltZWxpbmUuX2R1cmF0aW9uJiYodD0wKSwoMD09PXR8fDA+aHx8aD09PV8mJlwiaXNQYXVzZVwiIT09dGhpcy5kYXRhKSYmaCE9PXQmJihpPSEwLGg+XyYmKHI9XCJvblJldmVyc2VDb21wbGV0ZVwiKSksdGhpcy5fcmF3UHJldlRpbWU9YT0hZXx8dHx8aD09PXQ/dDpfKTtlbHNlIGlmKDFlLTc+dCl0aGlzLl90b3RhbFRpbWU9dGhpcy5fdGltZT0wLHRoaXMucmF0aW89dGhpcy5fZWFzZS5fY2FsY0VuZD90aGlzLl9lYXNlLmdldFJhdGlvKDApOjAsKDAhPT1vfHwwPT09bCYmaD4wKSYmKHI9XCJvblJldmVyc2VDb21wbGV0ZVwiLHM9dGhpcy5fcmV2ZXJzZWQpLDA+dCYmKHRoaXMuX2FjdGl2ZT0hMSwwPT09bCYmKHRoaXMuX2luaXR0ZWR8fCF0aGlzLnZhcnMubGF6eXx8aSkmJihoPj0wJiYoaCE9PV98fFwiaXNQYXVzZVwiIT09dGhpcy5kYXRhKSYmKGk9ITApLHRoaXMuX3Jhd1ByZXZUaW1lPWE9IWV8fHR8fGg9PT10P3Q6XykpLHRoaXMuX2luaXR0ZWR8fChpPSEwKTtlbHNlIGlmKHRoaXMuX3RvdGFsVGltZT10aGlzLl90aW1lPXQsdGhpcy5fZWFzZVR5cGUpe3ZhciB1PXQvbCxmPXRoaXMuX2Vhc2VUeXBlLGM9dGhpcy5fZWFzZVBvd2VyOygxPT09Znx8Mz09PWYmJnU+PS41KSYmKHU9MS11KSwzPT09ZiYmKHUqPTIpLDE9PT1jP3UqPXU6Mj09PWM/dSo9dSp1OjM9PT1jP3UqPXUqdSp1OjQ9PT1jJiYodSo9dSp1KnUqdSksdGhpcy5yYXRpbz0xPT09Zj8xLXU6Mj09PWY/dTouNT50L2w/dS8yOjEtdS8yfWVsc2UgdGhpcy5yYXRpbz10aGlzLl9lYXNlLmdldFJhdGlvKHQvbCk7aWYodGhpcy5fdGltZSE9PW98fGkpe2lmKCF0aGlzLl9pbml0dGVkKXtpZih0aGlzLl9pbml0KCksIXRoaXMuX2luaXR0ZWR8fHRoaXMuX2djKXJldHVybjtpZighaSYmdGhpcy5fZmlyc3RQVCYmKHRoaXMudmFycy5sYXp5IT09ITEmJnRoaXMuX2R1cmF0aW9ufHx0aGlzLnZhcnMubGF6eSYmIXRoaXMuX2R1cmF0aW9uKSlyZXR1cm4gdGhpcy5fdGltZT10aGlzLl90b3RhbFRpbWU9byx0aGlzLl9yYXdQcmV2VGltZT1oLHoucHVzaCh0aGlzKSx0aGlzLl9sYXp5PVt0LGVdLHZvaWQgMDt0aGlzLl90aW1lJiYhcz90aGlzLnJhdGlvPXRoaXMuX2Vhc2UuZ2V0UmF0aW8odGhpcy5fdGltZS9sKTpzJiZ0aGlzLl9lYXNlLl9jYWxjRW5kJiYodGhpcy5yYXRpbz10aGlzLl9lYXNlLmdldFJhdGlvKDA9PT10aGlzLl90aW1lPzA6MSkpfWZvcih0aGlzLl9sYXp5IT09ITEmJih0aGlzLl9sYXp5PSExKSx0aGlzLl9hY3RpdmV8fCF0aGlzLl9wYXVzZWQmJnRoaXMuX3RpbWUhPT1vJiZ0Pj0wJiYodGhpcy5fYWN0aXZlPSEwKSwwPT09byYmKHRoaXMuX3N0YXJ0QXQmJih0Pj0wP3RoaXMuX3N0YXJ0QXQucmVuZGVyKHQsZSxpKTpyfHwocj1cIl9kdW1teUdTXCIpKSx0aGlzLnZhcnMub25TdGFydCYmKDAhPT10aGlzLl90aW1lfHwwPT09bCkmJihlfHx0aGlzLl9jYWxsYmFjayhcIm9uU3RhcnRcIikpKSxuPXRoaXMuX2ZpcnN0UFQ7bjspbi5mP24udFtuLnBdKG4uYyp0aGlzLnJhdGlvK24ucyk6bi50W24ucF09bi5jKnRoaXMucmF0aW8rbi5zLG49bi5fbmV4dDt0aGlzLl9vblVwZGF0ZSYmKDA+dCYmdGhpcy5fc3RhcnRBdCYmdCE9PS0xZS00JiZ0aGlzLl9zdGFydEF0LnJlbmRlcih0LGUsaSksZXx8KHRoaXMuX3RpbWUhPT1vfHxzKSYmdGhpcy5fY2FsbGJhY2soXCJvblVwZGF0ZVwiKSksciYmKCF0aGlzLl9nY3x8aSkmJigwPnQmJnRoaXMuX3N0YXJ0QXQmJiF0aGlzLl9vblVwZGF0ZSYmdCE9PS0xZS00JiZ0aGlzLl9zdGFydEF0LnJlbmRlcih0LGUsaSkscyYmKHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbiYmdGhpcy5fZW5hYmxlZCghMSwhMSksdGhpcy5fYWN0aXZlPSExKSwhZSYmdGhpcy52YXJzW3JdJiZ0aGlzLl9jYWxsYmFjayhyKSwwPT09bCYmdGhpcy5fcmF3UHJldlRpbWU9PT1fJiZhIT09XyYmKHRoaXMuX3Jhd1ByZXZUaW1lPTApKX19LG4uX2tpbGw9ZnVuY3Rpb24odCxlLGkpe2lmKFwiYWxsXCI9PT10JiYodD1udWxsKSxudWxsPT10JiYobnVsbD09ZXx8ZT09PXRoaXMudGFyZ2V0KSlyZXR1cm4gdGhpcy5fbGF6eT0hMSx0aGlzLl9lbmFibGVkKCExLCExKTtlPVwic3RyaW5nXCIhPXR5cGVvZiBlP2V8fHRoaXMuX3RhcmdldHN8fHRoaXMudGFyZ2V0Okkuc2VsZWN0b3IoZSl8fGU7dmFyIHMscixuLGEsbyxsLGgsXyx1LGY9aSYmdGhpcy5fdGltZSYmaS5fc3RhcnRUaW1lPT09dGhpcy5fc3RhcnRUaW1lJiZ0aGlzLl90aW1lbGluZT09PWkuX3RpbWVsaW5lO2lmKChjKGUpfHxFKGUpKSYmXCJudW1iZXJcIiE9dHlwZW9mIGVbMF0pZm9yKHM9ZS5sZW5ndGg7LS1zPi0xOyl0aGlzLl9raWxsKHQsZVtzXSxpKSYmKGw9ITApO2Vsc2V7aWYodGhpcy5fdGFyZ2V0cyl7Zm9yKHM9dGhpcy5fdGFyZ2V0cy5sZW5ndGg7LS1zPi0xOylpZihlPT09dGhpcy5fdGFyZ2V0c1tzXSl7bz10aGlzLl9wcm9wTG9va3VwW3NdfHx7fSx0aGlzLl9vdmVyd3JpdHRlblByb3BzPXRoaXMuX292ZXJ3cml0dGVuUHJvcHN8fFtdLHI9dGhpcy5fb3ZlcndyaXR0ZW5Qcm9wc1tzXT10P3RoaXMuX292ZXJ3cml0dGVuUHJvcHNbc118fHt9OlwiYWxsXCI7YnJlYWt9fWVsc2V7aWYoZSE9PXRoaXMudGFyZ2V0KXJldHVybiExO289dGhpcy5fcHJvcExvb2t1cCxyPXRoaXMuX292ZXJ3cml0dGVuUHJvcHM9dD90aGlzLl9vdmVyd3JpdHRlblByb3BzfHx7fTpcImFsbFwifWlmKG8pe2lmKGg9dHx8byxfPXQhPT1yJiZcImFsbFwiIT09ciYmdCE9PW8mJihcIm9iamVjdFwiIT10eXBlb2YgdHx8IXQuX3RlbXBLaWxsKSxpJiYoSS5vbk92ZXJ3cml0ZXx8dGhpcy52YXJzLm9uT3ZlcndyaXRlKSl7Zm9yKG4gaW4gaClvW25dJiYodXx8KHU9W10pLHUucHVzaChuKSk7aWYoKHV8fCF0KSYmIVgodGhpcyxpLGUsdSkpcmV0dXJuITF9Zm9yKG4gaW4gaCkoYT1vW25dKSYmKGYmJihhLmY/YS50W2EucF0oYS5zKTphLnRbYS5wXT1hLnMsbD0hMCksYS5wZyYmYS50Ll9raWxsKGgpJiYobD0hMCksYS5wZyYmMCE9PWEudC5fb3ZlcndyaXRlUHJvcHMubGVuZ3RofHwoYS5fcHJldj9hLl9wcmV2Ll9uZXh0PWEuX25leHQ6YT09PXRoaXMuX2ZpcnN0UFQmJih0aGlzLl9maXJzdFBUPWEuX25leHQpLGEuX25leHQmJihhLl9uZXh0Ll9wcmV2PWEuX3ByZXYpLGEuX25leHQ9YS5fcHJldj1udWxsKSxkZWxldGUgb1tuXSksXyYmKHJbbl09MSk7IXRoaXMuX2ZpcnN0UFQmJnRoaXMuX2luaXR0ZWQmJnRoaXMuX2VuYWJsZWQoITEsITEpfX1yZXR1cm4gbH0sbi5pbnZhbGlkYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQmJkkuX29uUGx1Z2luRXZlbnQoXCJfb25EaXNhYmxlXCIsdGhpcyksdGhpcy5fZmlyc3RQVD10aGlzLl9vdmVyd3JpdHRlblByb3BzPXRoaXMuX3N0YXJ0QXQ9dGhpcy5fb25VcGRhdGU9bnVsbCx0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkPXRoaXMuX2FjdGl2ZT10aGlzLl9sYXp5PSExLHRoaXMuX3Byb3BMb29rdXA9dGhpcy5fdGFyZ2V0cz97fTpbXSxSLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyksdGhpcy52YXJzLmltbWVkaWF0ZVJlbmRlciYmKHRoaXMuX3RpbWU9LV8sdGhpcy5yZW5kZXIoLXRoaXMuX2RlbGF5KSksdGhpc30sbi5fZW5hYmxlZD1mdW5jdGlvbih0LGUpe2lmKG98fGEud2FrZSgpLHQmJnRoaXMuX2djKXt2YXIgaSxzPXRoaXMuX3RhcmdldHM7aWYocylmb3IoaT1zLmxlbmd0aDstLWk+LTE7KXRoaXMuX3NpYmxpbmdzW2ldPVcoc1tpXSx0aGlzLCEwKTtlbHNlIHRoaXMuX3NpYmxpbmdzPVcodGhpcy50YXJnZXQsdGhpcywhMCl9cmV0dXJuIFIucHJvdG90eXBlLl9lbmFibGVkLmNhbGwodGhpcyx0LGUpLHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQmJnRoaXMuX2ZpcnN0UFQ/SS5fb25QbHVnaW5FdmVudCh0P1wiX29uRW5hYmxlXCI6XCJfb25EaXNhYmxlXCIsdGhpcyk6ITF9LEkudG89ZnVuY3Rpb24odCxlLGkpe3JldHVybiBuZXcgSSh0LGUsaSl9LEkuZnJvbT1mdW5jdGlvbih0LGUsaSl7cmV0dXJuIGkucnVuQmFja3dhcmRzPSEwLGkuaW1tZWRpYXRlUmVuZGVyPTAhPWkuaW1tZWRpYXRlUmVuZGVyLG5ldyBJKHQsZSxpKX0sSS5mcm9tVG89ZnVuY3Rpb24odCxlLGkscyl7cmV0dXJuIHMuc3RhcnRBdD1pLHMuaW1tZWRpYXRlUmVuZGVyPTAhPXMuaW1tZWRpYXRlUmVuZGVyJiYwIT1pLmltbWVkaWF0ZVJlbmRlcixuZXcgSSh0LGUscyl9LEkuZGVsYXllZENhbGw9ZnVuY3Rpb24odCxlLGkscyxyKXtyZXR1cm4gbmV3IEkoZSwwLHtkZWxheTp0LG9uQ29tcGxldGU6ZSxvbkNvbXBsZXRlUGFyYW1zOmksY2FsbGJhY2tTY29wZTpzLG9uUmV2ZXJzZUNvbXBsZXRlOmUsb25SZXZlcnNlQ29tcGxldGVQYXJhbXM6aSxpbW1lZGlhdGVSZW5kZXI6ITEsbGF6eTohMSx1c2VGcmFtZXM6cixvdmVyd3JpdGU6MH0pfSxJLnNldD1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgSSh0LDAsZSl9LEkuZ2V0VHdlZW5zT2Y9ZnVuY3Rpb24odCxlKXtpZihudWxsPT10KXJldHVybltdO3Q9XCJzdHJpbmdcIiE9dHlwZW9mIHQ/dDpJLnNlbGVjdG9yKHQpfHx0O3ZhciBpLHMscixuO2lmKChjKHQpfHxFKHQpKSYmXCJudW1iZXJcIiE9dHlwZW9mIHRbMF0pe2ZvcihpPXQubGVuZ3RoLHM9W107LS1pPi0xOylzPXMuY29uY2F0KEkuZ2V0VHdlZW5zT2YodFtpXSxlKSk7Zm9yKGk9cy5sZW5ndGg7LS1pPi0xOylmb3Iobj1zW2ldLHI9aTstLXI+LTE7KW49PT1zW3JdJiZzLnNwbGljZShpLDEpfWVsc2UgZm9yKHM9Vyh0KS5jb25jYXQoKSxpPXMubGVuZ3RoOy0taT4tMTspKHNbaV0uX2djfHxlJiYhc1tpXS5pc0FjdGl2ZSgpKSYmcy5zcGxpY2UoaSwxKTtyZXR1cm4gc30sSS5raWxsVHdlZW5zT2Y9SS5raWxsRGVsYXllZENhbGxzVG89ZnVuY3Rpb24odCxlLGkpe1wib2JqZWN0XCI9PXR5cGVvZiBlJiYoaT1lLGU9ITEpO2Zvcih2YXIgcz1JLmdldFR3ZWVuc09mKHQsZSkscj1zLmxlbmd0aDstLXI+LTE7KXNbcl0uX2tpbGwoaSx0KX07dmFyIHRlPXYoXCJwbHVnaW5zLlR3ZWVuUGx1Z2luXCIsZnVuY3Rpb24odCxlKXt0aGlzLl9vdmVyd3JpdGVQcm9wcz0odHx8XCJcIikuc3BsaXQoXCIsXCIpLHRoaXMuX3Byb3BOYW1lPXRoaXMuX292ZXJ3cml0ZVByb3BzWzBdLHRoaXMuX3ByaW9yaXR5PWV8fDAsdGhpcy5fc3VwZXI9dGUucHJvdG90eXBlfSwhMCk7aWYobj10ZS5wcm90b3R5cGUsdGUudmVyc2lvbj1cIjEuMTguMFwiLHRlLkFQST0yLG4uX2ZpcnN0UFQ9bnVsbCxuLl9hZGRUd2Vlbj1qLG4uc2V0UmF0aW89TixuLl9raWxsPWZ1bmN0aW9uKHQpe3ZhciBlLGk9dGhpcy5fb3ZlcndyaXRlUHJvcHMscz10aGlzLl9maXJzdFBUO2lmKG51bGwhPXRbdGhpcy5fcHJvcE5hbWVdKXRoaXMuX292ZXJ3cml0ZVByb3BzPVtdO2Vsc2UgZm9yKGU9aS5sZW5ndGg7LS1lPi0xOyludWxsIT10W2lbZV1dJiZpLnNwbGljZShlLDEpO2Zvcig7czspbnVsbCE9dFtzLm5dJiYocy5fbmV4dCYmKHMuX25leHQuX3ByZXY9cy5fcHJldikscy5fcHJldj8ocy5fcHJldi5fbmV4dD1zLl9uZXh0LHMuX3ByZXY9bnVsbCk6dGhpcy5fZmlyc3RQVD09PXMmJih0aGlzLl9maXJzdFBUPXMuX25leHQpKSxzPXMuX25leHQ7cmV0dXJuITF9LG4uX3JvdW5kUHJvcHM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIGk9dGhpcy5fZmlyc3RQVDtpOykodFt0aGlzLl9wcm9wTmFtZV18fG51bGwhPWkubiYmdFtpLm4uc3BsaXQodGhpcy5fcHJvcE5hbWUrXCJfXCIpLmpvaW4oXCJcIildKSYmKGkucj1lKSxpPWkuX25leHR9LEkuX29uUGx1Z2luRXZlbnQ9ZnVuY3Rpb24odCxlKXt2YXIgaSxzLHIsbixhLG89ZS5fZmlyc3RQVDtpZihcIl9vbkluaXRBbGxQcm9wc1wiPT09dCl7Zm9yKDtvOyl7Zm9yKGE9by5fbmV4dCxzPXI7cyYmcy5wcj5vLnByOylzPXMuX25leHQ7KG8uX3ByZXY9cz9zLl9wcmV2Om4pP28uX3ByZXYuX25leHQ9bzpyPW8sKG8uX25leHQ9cyk/cy5fcHJldj1vOm49byxvPWF9bz1lLl9maXJzdFBUPXJ9Zm9yKDtvOylvLnBnJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBvLnRbdF0mJm8udFt0XSgpJiYoaT0hMCksbz1vLl9uZXh0O3JldHVybiBpfSx0ZS5hY3RpdmF0ZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5sZW5ndGg7LS1lPi0xOyl0W2VdLkFQST09PXRlLkFQSSYmKFFbKG5ldyB0W2VdKS5fcHJvcE5hbWVdPXRbZV0pO3JldHVybiEwfSxkLnBsdWdpbj1mdW5jdGlvbih0KXtpZighKHQmJnQucHJvcE5hbWUmJnQuaW5pdCYmdC5BUEkpKXRocm93XCJpbGxlZ2FsIHBsdWdpbiBkZWZpbml0aW9uLlwiO3ZhciBlLGk9dC5wcm9wTmFtZSxzPXQucHJpb3JpdHl8fDAscj10Lm92ZXJ3cml0ZVByb3BzLG49e2luaXQ6XCJfb25Jbml0VHdlZW5cIixzZXQ6XCJzZXRSYXRpb1wiLGtpbGw6XCJfa2lsbFwiLHJvdW5kOlwiX3JvdW5kUHJvcHNcIixpbml0QWxsOlwiX29uSW5pdEFsbFByb3BzXCJ9LGE9dihcInBsdWdpbnMuXCIraS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStpLnN1YnN0cigxKStcIlBsdWdpblwiLGZ1bmN0aW9uKCl7dGUuY2FsbCh0aGlzLGkscyksdGhpcy5fb3ZlcndyaXRlUHJvcHM9cnx8W119LHQuZ2xvYmFsPT09ITApLG89YS5wcm90b3R5cGU9bmV3IHRlKGkpO28uY29uc3RydWN0b3I9YSxhLkFQST10LkFQSTtmb3IoZSBpbiBuKVwiZnVuY3Rpb25cIj09dHlwZW9mIHRbZV0mJihvW25bZV1dPXRbZV0pO3JldHVybiBhLnZlcnNpb249dC52ZXJzaW9uLHRlLmFjdGl2YXRlKFthXSksYX0scz10Ll9nc1F1ZXVlKXtmb3Iocj0wO3MubGVuZ3RoPnI7cisrKXNbcl0oKTtmb3IobiBpbiBtKW1bbl0uZnVuY3x8dC5jb25zb2xlLmxvZyhcIkdTQVAgZW5jb3VudGVyZWQgbWlzc2luZyBkZXBlbmRlbmN5OiBjb20uZ3JlZW5zb2NrLlwiK24pfW89ITF9fSkoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOnRoaXN8fHdpbmRvdyxcIlR3ZWVuTGl0ZVwiKTtcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ6dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW5OeVl5OXFZWFpoYzJOeWFYQjBMMnhwWW5NdlZIZGxaVzVOWVhndlZIZGxaVzVNYVhSbExtcHpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFaUxDSm1hV3hsSWpvaVoyVnVaWEpoZEdWa0xtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJaThxSVZ4dUlDb2dWa1ZTVTBsUFRqb2dNUzR4T0M0d1hHNGdLaUJFUVZSRk9pQXlNREUxTFRBNUxUQXpYRzRnS2lCVlVFUkJWRVZUSUVGT1JDQkVUME5USUVGVU9pQm9kSFJ3T2k4dlozSmxaVzV6YjJOckxtTnZiVnh1SUNwY2JpQXFJRUJzYVdObGJuTmxJRU52Y0hseWFXZG9kQ0FvWXlrZ01qQXdPQzB5TURFMUxDQkhjbVZsYmxOdlkyc3VJRUZzYkNCeWFXZG9kSE1nY21WelpYSjJaV1F1WEc0Z0tpQlVhR2x6SUhkdmNtc2dhWE1nYzNWaWFtVmpkQ0IwYnlCMGFHVWdkR1Z5YlhNZ1lYUWdhSFIwY0RvdkwyZHlaV1Z1YzI5amF5NWpiMjB2YzNSaGJtUmhjbVF0YkdsalpXNXpaU0J2Y2lCbWIzSmNiaUFxSUVOc2RXSWdSM0psWlc1VGIyTnJJRzFsYldKbGNuTXNJSFJvWlNCemIyWjBkMkZ5WlNCaFozSmxaVzFsYm5RZ2RHaGhkQ0IzWVhNZ2FYTnpkV1ZrSUhkcGRHZ2dlVzkxY2lCdFpXMWlaWEp6YUdsd0xseHVJQ29nWEc0Z0tpQkFZWFYwYUc5eU9pQktZV05ySUVSdmVXeGxMQ0JxWVdOclFHZHlaV1Z1YzI5amF5NWpiMjFjYmlBcUwxeHVLR1oxYm1OMGFXOXVLSFFzWlNsN1hDSjFjMlVnYzNSeWFXTjBYQ0k3ZG1GeUlHazlkQzVIY21WbGJsTnZZMnRIYkc5aVlXeHpQWFF1UjNKbFpXNVRiMk5yUjJ4dlltRnNjM3g4ZER0cFppZ2hhUzVVZDJWbGJreHBkR1VwZTNaaGNpQnpMSElzYml4aExHOHNiRDFtZFc1amRHbHZiaWgwS1h0MllYSWdaU3h6UFhRdWMzQnNhWFFvWENJdVhDSXBMSEk5YVR0bWIzSW9aVDB3TzNNdWJHVnVaM1JvUG1VN1pTc3JLWEpiYzF0bFhWMDljajF5VzNOYlpWMWRmSHg3ZlR0eVpYUjFjbTRnY24wc2FEMXNLRndpWTI5dExtZHlaV1Z1YzI5amExd2lLU3hmUFRGbExURXdMSFU5Wm5WdVkzUnBiMjRvZENsN2RtRnlJR1VzYVQxYlhTeHpQWFF1YkdWdVozUm9PMlp2Y2lobFBUQTdaU0U5UFhNN2FTNXdkWE5vS0hSYlpTc3JYU2twTzNKbGRIVnliaUJwZlN4bVBXWjFibU4wYVc5dUtDbDdmU3hqUFdaMWJtTjBhVzl1S0NsN2RtRnlJSFE5VDJKcVpXTjBMbkJ5YjNSdmRIbHdaUzUwYjFOMGNtbHVaeXhsUFhRdVkyRnNiQ2hiWFNrN2NtVjBkWEp1SUdaMWJtTjBhVzl1S0drcGUzSmxkSFZ5YmlCdWRXeHNJVDFwSmlZb2FTQnBibk4wWVc1alpXOW1JRUZ5Y21GNWZIeGNJbTlpYW1WamRGd2lQVDEwZVhCbGIyWWdhU1ltSVNGcExuQjFjMmdtSm5RdVkyRnNiQ2hwS1QwOVBXVXBmWDBvS1N4dFBYdDlMSEE5Wm5WdVkzUnBiMjRvY3l4eUxHNHNZU2w3ZEdocGN5NXpZejF0VzNOZFAyMWJjMTB1YzJNNlcxMHNiVnR6WFQxMGFHbHpMSFJvYVhNdVozTkRiR0Z6Y3oxdWRXeHNMSFJvYVhNdVpuVnVZejF1TzNaaGNpQnZQVnRkTzNSb2FYTXVZMmhsWTJzOVpuVnVZM1JwYjI0b2FDbDdabTl5S0haaGNpQmZMSFVzWml4akxHUXNkajF5TG14bGJtZDBhQ3huUFhZN0xTMTJQaTB4T3lrb1h6MXRXM0piZGwxZGZIeHVaWGNnY0NoeVczWmRMRnRkS1NrdVozTkRiR0Z6Y3o4b2IxdDJYVDFmTG1kelEyeGhjM01zWnkwdEtUcG9KaVpmTG5OakxuQjFjMmdvZEdocGN5azdhV1lvTUQwOVBXY21KbTRwWm05eUtIVTlLRndpWTI5dExtZHlaV1Z1YzI5amF5NWNJaXR6S1M1emNHeHBkQ2hjSWk1Y0lpa3NaajExTG5CdmNDZ3BMR005YkNoMUxtcHZhVzRvWENJdVhDSXBLVnRtWFQxMGFHbHpMbWR6UTJ4aGMzTTliaTVoY0hCc2VTaHVMRzhwTEdFbUppaHBXMlpkUFdNc1pEMWNJblZ1WkdWbWFXNWxaRndpSVQxMGVYQmxiMllnYlc5a2RXeGxKaVp0YjJSMWJHVXVaWGh3YjNKMGN5d2haQ1ltWENKbWRXNWpkR2x2Ymx3aVBUMTBlWEJsYjJZZ1pHVm1hVzVsSmlaa1pXWnBibVV1WVcxa1AyUmxabWx1WlNnb2RDNUhjbVZsYmxOdlkydEJUVVJRWVhSb1AzUXVSM0psWlc1VGIyTnJRVTFFVUdGMGFDdGNJaTljSWpwY0lsd2lLU3R6TG5Od2JHbDBLRndpTGx3aUtTNXdiM0FvS1N4YlhTeG1kVzVqZEdsdmJpZ3BlM0psZEhWeWJpQmpmU2s2Y3owOVBXVW1KbVFtSmlodGIyUjFiR1V1Wlhod2IzSjBjejFqS1Nrc2RqMHdPM1JvYVhNdWMyTXViR1Z1WjNSb1BuWTdkaXNyS1hSb2FYTXVjMk5iZGwwdVkyaGxZMnNvS1gwc2RHaHBjeTVqYUdWamF5Z2hNQ2w5TEdROWRDNWZaM05FWldacGJtVTlablZ1WTNScGIyNG9kQ3hsTEdrc2N5bDdjbVYwZFhKdUlHNWxkeUJ3S0hRc1pTeHBMSE1wZlN4MlBXZ3VYMk5zWVhOelBXWjFibU4wYVc5dUtIUXNaU3hwS1h0eVpYUjFjbTRnWlQxbGZIeG1kVzVqZEdsdmJpZ3BlMzBzWkNoMExGdGRMR1oxYm1OMGFXOXVLQ2w3Y21WMGRYSnVJR1Y5TEdrcExHVjlPMlF1WjJ4dlltRnNjejFwTzNaaGNpQm5QVnN3TERBc01Td3hYU3hVUFZ0ZExIazlkaWhjSW1WaGMybHVaeTVGWVhObFhDSXNablZ1WTNScGIyNG9kQ3hsTEdrc2N5bDdkR2hwY3k1ZlpuVnVZejEwTEhSb2FYTXVYM1I1Y0dVOWFYeDhNQ3gwYUdsekxsOXdiM2RsY2oxemZId3dMSFJvYVhNdVgzQmhjbUZ0Y3oxbFAyY3VZMjl1WTJGMEtHVXBPbWQ5TENFd0tTeDNQWGt1YldGd1BYdDlMRkE5ZVM1eVpXZHBjM1JsY2oxbWRXNWpkR2x2YmloMExHVXNhU3h6S1h0bWIzSW9kbUZ5SUhJc2JpeGhMRzhzYkQxbExuTndiR2wwS0Z3aUxGd2lLU3hmUFd3dWJHVnVaM1JvTEhVOUtHbDhmRndpWldGelpVbHVMR1ZoYzJWUGRYUXNaV0Z6WlVsdVQzVjBYQ0lwTG5Od2JHbDBLRndpTEZ3aUtUc3RMVjgrTFRFN0tXWnZjaWh1UFd4YlgxMHNjajF6UDNZb1hDSmxZWE5wYm1jdVhDSXJiaXh1ZFd4c0xDRXdLVHBvTG1WaGMybHVaMXR1WFh4OGUzMHNZVDExTG14bGJtZDBhRHN0TFdFK0xURTdLVzg5ZFZ0aFhTeDNXMjRyWENJdVhDSXJiMTA5ZDF0dksyNWRQWEpiYjEwOWRDNW5aWFJTWVhScGJ6OTBPblJiYjExOGZHNWxkeUIwZlR0bWIzSW9iajE1TG5CeWIzUnZkSGx3WlN4dUxsOWpZV3hqUlc1a1BTRXhMRzR1WjJWMFVtRjBhVzg5Wm5WdVkzUnBiMjRvZENsN2FXWW9kR2hwY3k1ZlpuVnVZeWx5WlhSMWNtNGdkR2hwY3k1ZmNHRnlZVzF6V3pCZFBYUXNkR2hwY3k1ZlpuVnVZeTVoY0hCc2VTaHVkV3hzTEhSb2FYTXVYM0JoY21GdGN5azdkbUZ5SUdVOWRHaHBjeTVmZEhsd1pTeHBQWFJvYVhNdVgzQnZkMlZ5TEhNOU1UMDlQV1UvTVMxME9qSTlQVDFsUDNRNkxqVStkRDh5S25RNk1pb29NUzEwS1R0eVpYUjFjbTRnTVQwOVBXay9jeW85Y3pveVBUMDlhVDl6S2oxektuTTZNejA5UFdrL2N5bzljeXB6S25NNk5EMDlQV2ttSmloektqMXpLbk1xY3lwektTd3hQVDA5WlQ4eExYTTZNajA5UFdVL2N6b3VOVDUwUDNNdk1qb3hMWE12TW4wc2N6MWJYQ0pNYVc1bFlYSmNJaXhjSWxGMVlXUmNJaXhjSWtOMVltbGpYQ0lzWENKUmRXRnlkRndpTEZ3aVVYVnBiblFzVTNSeWIyNW5YQ0pkTEhJOWN5NXNaVzVuZEdnN0xTMXlQaTB4T3lsdVBYTmJjbDByWENJc1VHOTNaWEpjSWl0eUxGQW9ibVYzSUhrb2JuVnNiQ3h1ZFd4c0xERXNjaWtzYml4Y0ltVmhjMlZQZFhSY0lpd2hNQ2tzVUNodVpYY2dlU2h1ZFd4c0xHNTFiR3dzTWl4eUtTeHVMRndpWldGelpVbHVYQ0lyS0RBOVBUMXlQMXdpTEdWaGMyVk9iMjVsWENJNlhDSmNJaWtwTEZBb2JtVjNJSGtvYm5Wc2JDeHVkV3hzTERNc2Npa3NiaXhjSW1WaGMyVkpiazkxZEZ3aUtUdDNMbXhwYm1WaGNqMW9MbVZoYzJsdVp5NU1hVzVsWVhJdVpXRnpaVWx1TEhjdWMzZHBibWM5YUM1bFlYTnBibWN1VVhWaFpDNWxZWE5sU1c1UGRYUTdkbUZ5SUdJOWRpaGNJbVYyWlc1MGN5NUZkbVZ1ZEVScGMzQmhkR05vWlhKY0lpeG1kVzVqZEdsdmJpaDBLWHQwYUdsekxsOXNhWE4wWlc1bGNuTTllMzBzZEdocGN5NWZaWFpsYm5SVVlYSm5aWFE5ZEh4OGRHaHBjMzBwTzI0OVlpNXdjbTkwYjNSNWNHVXNiaTVoWkdSRmRtVnVkRXhwYzNSbGJtVnlQV1oxYm1OMGFXOXVLSFFzWlN4cExITXNjaWw3Y2oxeWZId3dPM1poY2lCdUxHd3NhRDEwYUdsekxsOXNhWE4wWlc1bGNuTmJkRjBzWHowd08yWnZjaWh1ZFd4c1BUMW9KaVlvZEdocGN5NWZiR2x6ZEdWdVpYSnpXM1JkUFdnOVcxMHBMR3c5YUM1c1pXNW5kR2c3TFMxc1BpMHhPeWx1UFdoYmJGMHNiaTVqUFQwOVpTWW1iaTV6UFQwOWFUOW9Mbk53YkdsalpTaHNMREVwT2pBOVBUMWZKaVp5UG00dWNISW1KaWhmUFd3ck1TazdhQzV6Y0d4cFkyVW9YeXd3TEh0ak9tVXNjenBwTEhWd09uTXNjSEk2Y24wcExIUm9hWE1oUFQxaGZIeHZmSHhoTG5kaGEyVW9LWDBzYmk1eVpXMXZkbVZGZG1WdWRFeHBjM1JsYm1WeVBXWjFibU4wYVc5dUtIUXNaU2w3ZG1GeUlHa3NjejEwYUdsekxsOXNhWE4wWlc1bGNuTmJkRjA3YVdZb2N5bG1iM0lvYVQxekxteGxibWQwYURzdExXaytMVEU3S1dsbUtITmJhVjB1WXowOVBXVXBjbVYwZFhKdUlITXVjM0JzYVdObEtHa3NNU2tzZG05cFpDQXdmU3h1TG1ScGMzQmhkR05vUlhabGJuUTlablZ1WTNScGIyNG9kQ2w3ZG1GeUlHVXNhU3h6TEhJOWRHaHBjeTVmYkdsemRHVnVaWEp6VzNSZE8ybG1LSElwWm05eUtHVTljaTVzWlc1bmRHZ3NhVDEwYUdsekxsOWxkbVZ1ZEZSaGNtZGxkRHN0TFdVK0xURTdLWE05Y2x0bFhTeHpKaVlvY3k1MWNEOXpMbU11WTJGc2JDaHpMbk44Zkdrc2UzUjVjR1U2ZEN4MFlYSm5aWFE2YVgwcE9uTXVZeTVqWVd4c0tITXVjM3g4YVNrcGZUdDJZWElnYXoxMExuSmxjWFZsYzNSQmJtbHRZWFJwYjI1R2NtRnRaU3hCUFhRdVkyRnVZMlZzUVc1cGJXRjBhVzl1Um5KaGJXVXNVejFFWVhSbExtNXZkM3g4Wm5WdVkzUnBiMjRvS1h0eVpYUjFjbTRvYm1WM0lFUmhkR1VwTG1kbGRGUnBiV1VvS1gwc2VEMVRLQ2s3Wm05eUtITTlXMXdpYlhOY0lpeGNJbTF2ZWx3aUxGd2lkMlZpYTJsMFhDSXNYQ0p2WENKZExISTljeTVzWlc1bmRHZzdMUzF5UGkweEppWWhhenNwYXoxMFczTmJjbDByWENKU1pYRjFaWE4wUVc1cGJXRjBhVzl1Um5KaGJXVmNJbDBzUVQxMFczTmJjbDByWENKRFlXNWpaV3hCYm1sdFlYUnBiMjVHY21GdFpWd2lYWHg4ZEZ0elczSmRLMXdpUTJGdVkyVnNVbVZ4ZFdWemRFRnVhVzFoZEdsdmJrWnlZVzFsWENKZE8zWW9YQ0pVYVdOclpYSmNJaXhtZFc1amRHbHZiaWgwTEdVcGUzWmhjaUJwTEhNc2NpeHVMR3dzYUQxMGFHbHpMSFU5VXlncExHTTlaU0U5UFNFeEppWnJMRzA5TlRBd0xIQTlNek1zWkQxY0luUnBZMnRjSWl4MlBXWjFibU4wYVc5dUtIUXBlM1poY2lCbExHRXNiejFUS0NrdGVEdHZQbTBtSmloMUt6MXZMWEFwTEhnclBXOHNhQzUwYVcxbFBTaDRMWFVwTHpGbE15eGxQV2d1ZEdsdFpTMXNMQ2doYVh4OFpUNHdmSHgwUFQwOUlUQXBKaVlvYUM1bWNtRnRaU3NyTEd3clBXVXJLR1UrUFc0L0xqQXdORHB1TFdVcExHRTlJVEFwTEhRaFBUMGhNQ1ltS0hJOWN5aDJLU2tzWVNZbWFDNWthWE53WVhSamFFVjJaVzUwS0dRcGZUdGlMbU5oYkd3b2FDa3NhQzUwYVcxbFBXZ3VabkpoYldVOU1DeG9MblJwWTJzOVpuVnVZM1JwYjI0b0tYdDJLQ0V3S1gwc2FDNXNZV2RUYlc5dmRHaHBibWM5Wm5WdVkzUnBiMjRvZEN4bEtYdHRQWFI4ZkRFdlh5eHdQVTFoZEdndWJXbHVLR1VzYlN3d0tYMHNhQzV6YkdWbGNEMW1kVzVqZEdsdmJpZ3BlMjUxYkd3aFBYSW1KaWhqSmlaQlAwRW9jaWs2WTJ4bFlYSlVhVzFsYjNWMEtISXBMSE05Wml4eVBXNTFiR3dzYUQwOVBXRW1KaWh2UFNFeEtTbDlMR2d1ZDJGclpUMW1kVzVqZEdsdmJpZ3BlMjUxYkd3aFBUMXlQMmd1YzJ4bFpYQW9LVHBvTG1aeVlXMWxQakV3SmlZb2VEMVRLQ2t0YlNzMUtTeHpQVEE5UFQxcFAyWTZZeVltYXo5ck9tWjFibU4wYVc5dUtIUXBlM0psZEhWeWJpQnpaWFJVYVcxbGIzVjBLSFFzTUh3eFpUTXFLR3d0YUM1MGFXMWxLU3N4S1gwc2FEMDlQV0VtSmlodlBTRXdLU3gyS0RJcGZTeG9MbVp3Y3oxbWRXNWpkR2x2YmloMEtYdHlaWFIxY200Z1lYSm5kVzFsYm5SekxteGxibWQwYUQ4b2FUMTBMRzQ5TVM4b2FYeDhOakFwTEd3OWRHaHBjeTUwYVcxbEsyNHNhQzUzWVd0bEtDa3NkbTlwWkNBd0tUcHBmU3hvTG5WelpWSkJSajFtZFc1amRHbHZiaWgwS1h0eVpYUjFjbTRnWVhKbmRXMWxiblJ6TG14bGJtZDBhRDhvYUM1emJHVmxjQ2dwTEdNOWRDeG9MbVp3Y3locEtTeDJiMmxrSURBcE9tTjlMR2d1Wm5CektIUXBMSE5sZEZScGJXVnZkWFFvWm5WdVkzUnBiMjRvS1h0akppWTFQbWd1Wm5KaGJXVW1KbWd1ZFhObFVrRkdLQ0V4S1gwc01UVXdNQ2w5S1N4dVBXZ3VWR2xqYTJWeUxuQnliM1J2ZEhsd1pUMXVaWGNnYUM1bGRtVnVkSE11UlhabGJuUkVhWE53WVhSamFHVnlMRzR1WTI5dWMzUnlkV04wYjNJOWFDNVVhV05yWlhJN2RtRnlJRkk5ZGloY0ltTnZjbVV1UVc1cGJXRjBhVzl1WENJc1puVnVZM1JwYjI0b2RDeGxLWHRwWmloMGFHbHpMblpoY25NOVpUMWxmSHg3ZlN4MGFHbHpMbDlrZFhKaGRHbHZiajEwYUdsekxsOTBiM1JoYkVSMWNtRjBhVzl1UFhSOGZEQXNkR2hwY3k1ZlpHVnNZWGs5VG5WdFltVnlLR1V1WkdWc1lYa3BmSHd3TEhSb2FYTXVYM1JwYldWVFkyRnNaVDB4TEhSb2FYTXVYMkZqZEdsMlpUMWxMbWx0YldWa2FXRjBaVkpsYm1SbGNqMDlQU0V3TEhSb2FYTXVaR0YwWVQxbExtUmhkR0VzZEdocGN5NWZjbVYyWlhKelpXUTlaUzV5WlhabGNuTmxaRDA5UFNFd0xFZ3BlMjk4ZkdFdWQyRnJaU2dwTzNaaGNpQnBQWFJvYVhNdWRtRnljeTUxYzJWR2NtRnRaWE0vU3pwSU8ya3VZV1JrS0hSb2FYTXNhUzVmZEdsdFpTa3NkR2hwY3k1MllYSnpMbkJoZFhObFpDWW1kR2hwY3k1d1lYVnpaV1FvSVRBcGZYMHBPMkU5VWk1MGFXTnJaWEk5Ym1WM0lHZ3VWR2xqYTJWeUxHNDlVaTV3Y205MGIzUjVjR1VzYmk1ZlpHbHlkSGs5Ymk1ZloyTTliaTVmYVc1cGRIUmxaRDF1TGw5d1lYVnpaV1E5SVRFc2JpNWZkRzkwWVd4VWFXMWxQVzR1WDNScGJXVTlNQ3h1TGw5eVlYZFFjbVYyVkdsdFpUMHRNU3h1TGw5dVpYaDBQVzR1WDJ4aGMzUTliaTVmYjI1VmNHUmhkR1U5Ymk1ZmRHbHRaV3hwYm1VOWJpNTBhVzFsYkdsdVpUMXVkV3hzTEc0dVgzQmhkWE5sWkQwaE1UdDJZWElnUXoxbWRXNWpkR2x2YmlncGUyOG1KbE1vS1MxNFBqSmxNeVltWVM1M1lXdGxLQ2tzYzJWMFZHbHRaVzkxZENoRExESmxNeWw5TzBNb0tTeHVMbkJzWVhrOVpuVnVZM1JwYjI0b2RDeGxLWHR5WlhSMWNtNGdiblZzYkNFOWRDWW1kR2hwY3k1elpXVnJLSFFzWlNrc2RHaHBjeTV5WlhabGNuTmxaQ2doTVNrdWNHRjFjMlZrS0NFeEtYMHNiaTV3WVhWelpUMW1kVzVqZEdsdmJpaDBMR1VwZTNKbGRIVnliaUJ1ZFd4c0lUMTBKaVowYUdsekxuTmxaV3NvZEN4bEtTeDBhR2x6TG5CaGRYTmxaQ2doTUNsOUxHNHVjbVZ6ZFcxbFBXWjFibU4wYVc5dUtIUXNaU2w3Y21WMGRYSnVJRzUxYkd3aFBYUW1KblJvYVhNdWMyVmxheWgwTEdVcExIUm9hWE11Y0dGMWMyVmtLQ0V4S1gwc2JpNXpaV1ZyUFdaMWJtTjBhVzl1S0hRc1pTbDdjbVYwZFhKdUlIUm9hWE11ZEc5MFlXeFVhVzFsS0U1MWJXSmxjaWgwS1N4bElUMDlJVEVwZlN4dUxuSmxjM1JoY25ROVpuVnVZM1JwYjI0b2RDeGxLWHR5WlhSMWNtNGdkR2hwY3k1eVpYWmxjbk5sWkNnaE1Ta3VjR0YxYzJWa0tDRXhLUzUwYjNSaGJGUnBiV1VvZEQ4dGRHaHBjeTVmWkdWc1lYazZNQ3hsSVQwOUlURXNJVEFwZlN4dUxuSmxkbVZ5YzJVOVpuVnVZM1JwYjI0b2RDeGxLWHR5WlhSMWNtNGdiblZzYkNFOWRDWW1kR2hwY3k1elpXVnJLSFI4ZkhSb2FYTXVkRzkwWVd4RWRYSmhkR2x2YmlncExHVXBMSFJvYVhNdWNtVjJaWEp6WldRb0lUQXBMbkJoZFhObFpDZ2hNU2w5TEc0dWNtVnVaR1Z5UFdaMWJtTjBhVzl1S0NsN2ZTeHVMbWx1ZG1Gc2FXUmhkR1U5Wm5WdVkzUnBiMjRvS1h0eVpYUjFjbTRnZEdocGN5NWZkR2x0WlQxMGFHbHpMbDkwYjNSaGJGUnBiV1U5TUN4MGFHbHpMbDlwYm1sMGRHVmtQWFJvYVhNdVgyZGpQU0V4TEhSb2FYTXVYM0poZDFCeVpYWlVhVzFsUFMweExDaDBhR2x6TGw5blkzeDhJWFJvYVhNdWRHbHRaV3hwYm1VcEppWjBhR2x6TGw5bGJtRmliR1ZrS0NFd0tTeDBhR2x6ZlN4dUxtbHpRV04wYVhabFBXWjFibU4wYVc5dUtDbDdkbUZ5SUhRc1pUMTBhR2x6TGw5MGFXMWxiR2x1WlN4cFBYUm9hWE11WDNOMFlYSjBWR2x0WlR0eVpYUjFjbTRoWlh4OElYUm9hWE11WDJkakppWWhkR2hwY3k1ZmNHRjFjMlZrSmlabExtbHpRV04wYVhabEtDa21KaWgwUFdVdWNtRjNWR2x0WlNncEtUNDlhU1ltYVN0MGFHbHpMblJ2ZEdGc1JIVnlZWFJwYjI0b0tTOTBhR2x6TGw5MGFXMWxVMk5oYkdVK2RIMHNiaTVmWlc1aFlteGxaRDFtZFc1amRHbHZiaWgwTEdVcGUzSmxkSFZ5YmlCdmZIeGhMbmRoYTJVb0tTeDBhR2x6TGw5bll6MGhkQ3gwYUdsekxsOWhZM1JwZG1VOWRHaHBjeTVwYzBGamRHbDJaU2dwTEdVaFBUMGhNQ1ltS0hRbUppRjBhR2x6TG5ScGJXVnNhVzVsUDNSb2FYTXVYM1JwYldWc2FXNWxMbUZrWkNoMGFHbHpMSFJvYVhNdVgzTjBZWEowVkdsdFpTMTBhR2x6TGw5a1pXeGhlU2s2SVhRbUpuUm9hWE11ZEdsdFpXeHBibVVtSm5Sb2FYTXVYM1JwYldWc2FXNWxMbDl5WlcxdmRtVW9kR2hwY3l3aE1Da3BMQ0V4ZlN4dUxsOXJhV3hzUFdaMWJtTjBhVzl1S0NsN2NtVjBkWEp1SUhSb2FYTXVYMlZ1WVdKc1pXUW9JVEVzSVRFcGZTeHVMbXRwYkd3OVpuVnVZM1JwYjI0b2RDeGxLWHR5WlhSMWNtNGdkR2hwY3k1ZmEybHNiQ2gwTEdVcExIUm9hWE45TEc0dVgzVnVZMkZqYUdVOVpuVnVZM1JwYjI0b2RDbDdabTl5S0haaGNpQmxQWFEvZEdocGN6cDBhR2x6TG5ScGJXVnNhVzVsTzJVN0tXVXVYMlJwY25SNVBTRXdMR1U5WlM1MGFXMWxiR2x1WlR0eVpYUjFjbTRnZEdocGMzMHNiaTVmYzNkaGNGTmxiR1pKYmxCaGNtRnRjejFtZFc1amRHbHZiaWgwS1h0bWIzSW9kbUZ5SUdVOWRDNXNaVzVuZEdnc2FUMTBMbU52Ym1OaGRDZ3BPeTB0WlQ0dE1Uc3BYQ0o3YzJWc1puMWNJajA5UFhSYlpWMG1KaWhwVzJWZFBYUm9hWE1wTzNKbGRIVnliaUJwZlN4dUxsOWpZV3hzWW1GamF6MW1kVzVqZEdsdmJpaDBLWHQyWVhJZ1pUMTBhR2x6TG5aaGNuTTdaVnQwWFM1aGNIQnNlU2hsVzNRclhDSlRZMjl3WlZ3aVhYeDhaUzVqWVd4c1ltRmphMU5qYjNCbGZIeDBhR2x6TEdWYmRDdGNJbEJoY21GdGMxd2lYWHg4VkNsOUxHNHVaWFpsYm5SRFlXeHNZbUZqYXoxbWRXNWpkR2x2YmloMExHVXNhU3h6S1h0cFppaGNJbTl1WENJOVBUMG9kSHg4WENKY0lpa3VjM1ZpYzNSeUtEQXNNaWtwZTNaaGNpQnlQWFJvYVhNdWRtRnljenRwWmlneFBUMDlZWEpuZFcxbGJuUnpMbXhsYm1kMGFDbHlaWFIxY200Z2NsdDBYVHR1ZFd4c1BUMWxQMlJsYkdWMFpTQnlXM1JkT2loeVczUmRQV1VzY2x0MEsxd2lVR0Z5WVcxelhDSmRQV01vYVNrbUppMHhJVDA5YVM1cWIybHVLRndpWENJcExtbHVaR1Y0VDJZb1hDSjdjMlZzWm4xY0lpay9kR2hwY3k1ZmMzZGhjRk5sYkdaSmJsQmhjbUZ0Y3locEtUcHBMSEpiZEN0Y0lsTmpiM0JsWENKZFBYTXBMRndpYjI1VmNHUmhkR1ZjSWowOVBYUW1KaWgwYUdsekxsOXZibFZ3WkdGMFpUMWxLWDF5WlhSMWNtNGdkR2hwYzMwc2JpNWtaV3hoZVQxbWRXNWpkR2x2YmloMEtYdHlaWFIxY200Z1lYSm5kVzFsYm5SekxteGxibWQwYUQ4b2RHaHBjeTVmZEdsdFpXeHBibVV1YzIxdmIzUm9RMmhwYkdSVWFXMXBibWNtSm5Sb2FYTXVjM1JoY25SVWFXMWxLSFJvYVhNdVgzTjBZWEowVkdsdFpTdDBMWFJvYVhNdVgyUmxiR0Y1S1N4MGFHbHpMbDlrWld4aGVUMTBMSFJvYVhNcE9uUm9hWE11WDJSbGJHRjVmU3h1TG1SMWNtRjBhVzl1UFdaMWJtTjBhVzl1S0hRcGUzSmxkSFZ5YmlCaGNtZDFiV1Z1ZEhNdWJHVnVaM1JvUHloMGFHbHpMbDlrZFhKaGRHbHZiajEwYUdsekxsOTBiM1JoYkVSMWNtRjBhVzl1UFhRc2RHaHBjeTVmZFc1allXTm9aU2doTUNrc2RHaHBjeTVmZEdsdFpXeHBibVV1YzIxdmIzUm9RMmhwYkdSVWFXMXBibWNtSm5Sb2FYTXVYM1JwYldVK01DWW1kR2hwY3k1ZmRHbHRaVHgwYUdsekxsOWtkWEpoZEdsdmJpWW1NQ0U5UFhRbUpuUm9hWE11ZEc5MFlXeFVhVzFsS0hSb2FYTXVYM1J2ZEdGc1ZHbHRaU29vZEM5MGFHbHpMbDlrZFhKaGRHbHZiaWtzSVRBcExIUm9hWE1wT2loMGFHbHpMbDlrYVhKMGVUMGhNU3gwYUdsekxsOWtkWEpoZEdsdmJpbDlMRzR1ZEc5MFlXeEVkWEpoZEdsdmJqMW1kVzVqZEdsdmJpaDBLWHR5WlhSMWNtNGdkR2hwY3k1ZlpHbHlkSGs5SVRFc1lYSm5kVzFsYm5SekxteGxibWQwYUQ5MGFHbHpMbVIxY21GMGFXOXVLSFFwT25Sb2FYTXVYM1J2ZEdGc1JIVnlZWFJwYjI1OUxHNHVkR2x0WlQxbWRXNWpkR2x2YmloMExHVXBlM0psZEhWeWJpQmhjbWQxYldWdWRITXViR1Z1WjNSb1B5aDBhR2x6TGw5a2FYSjBlU1ltZEdocGN5NTBiM1JoYkVSMWNtRjBhVzl1S0Nrc2RHaHBjeTUwYjNSaGJGUnBiV1VvZEQ1MGFHbHpMbDlrZFhKaGRHbHZiajkwYUdsekxsOWtkWEpoZEdsdmJqcDBMR1VwS1RwMGFHbHpMbDkwYVcxbGZTeHVMblJ2ZEdGc1ZHbHRaVDFtZFc1amRHbHZiaWgwTEdVc2FTbDdhV1lvYjN4OFlTNTNZV3RsS0Nrc0lXRnlaM1Z0Wlc1MGN5NXNaVzVuZEdncGNtVjBkWEp1SUhSb2FYTXVYM1J2ZEdGc1ZHbHRaVHRwWmloMGFHbHpMbDkwYVcxbGJHbHVaU2w3YVdZb01ENTBKaVloYVNZbUtIUXJQWFJvYVhNdWRHOTBZV3hFZFhKaGRHbHZiaWdwS1N4MGFHbHpMbDkwYVcxbGJHbHVaUzV6Ylc5dmRHaERhR2xzWkZScGJXbHVaeWw3ZEdocGN5NWZaR2x5ZEhrbUpuUm9hWE11ZEc5MFlXeEVkWEpoZEdsdmJpZ3BPM1poY2lCelBYUm9hWE11WDNSdmRHRnNSSFZ5WVhScGIyNHNjajEwYUdsekxsOTBhVzFsYkdsdVpUdHBaaWgwUG5NbUppRnBKaVlvZEQxektTeDBhR2x6TGw5emRHRnlkRlJwYldVOUtIUm9hWE11WDNCaGRYTmxaRDkwYUdsekxsOXdZWFZ6WlZScGJXVTZjaTVmZEdsdFpTa3RLSFJvYVhNdVgzSmxkbVZ5YzJWa1AzTXRkRHAwS1M5MGFHbHpMbDkwYVcxbFUyTmhiR1VzY2k1ZlpHbHlkSGw4ZkhSb2FYTXVYM1Z1WTJGamFHVW9JVEVwTEhJdVgzUnBiV1ZzYVc1bEtXWnZjaWc3Y2k1ZmRHbHRaV3hwYm1VN0tYSXVYM1JwYldWc2FXNWxMbDkwYVcxbElUMDlLSEl1WDNOMFlYSjBWR2x0WlN0eUxsOTBiM1JoYkZScGJXVXBMM0l1WDNScGJXVlRZMkZzWlNZbWNpNTBiM1JoYkZScGJXVW9jaTVmZEc5MFlXeFVhVzFsTENFd0tTeHlQWEl1WDNScGJXVnNhVzVsZlhSb2FYTXVYMmRqSmlaMGFHbHpMbDlsYm1GaWJHVmtLQ0V3TENFeEtTd29kR2hwY3k1ZmRHOTBZV3hVYVcxbElUMDlkSHg4TUQwOVBYUm9hWE11WDJSMWNtRjBhVzl1S1NZbUtIb3ViR1Z1WjNSb0ppWldLQ2tzZEdocGN5NXlaVzVrWlhJb2RDeGxMQ0V4S1N4NkxteGxibWQwYUNZbVZpZ3BLWDF5WlhSMWNtNGdkR2hwYzMwc2JpNXdjbTluY21WemN6MXVMblJ2ZEdGc1VISnZaM0psYzNNOVpuVnVZM1JwYjI0b2RDeGxLWHQyWVhJZ2FUMTBhR2x6TG1SMWNtRjBhVzl1S0NrN2NtVjBkWEp1SUdGeVozVnRaVzUwY3k1c1pXNW5kR2cvZEdocGN5NTBiM1JoYkZScGJXVW9hU3AwTEdVcE9tay9kR2hwY3k1ZmRHbHRaUzlwT25Sb2FYTXVjbUYwYVc5OUxHNHVjM1JoY25SVWFXMWxQV1oxYm1OMGFXOXVLSFFwZTNKbGRIVnliaUJoY21kMWJXVnVkSE11YkdWdVozUm9QeWgwSVQwOWRHaHBjeTVmYzNSaGNuUlVhVzFsSmlZb2RHaHBjeTVmYzNSaGNuUlVhVzFsUFhRc2RHaHBjeTUwYVcxbGJHbHVaU1ltZEdocGN5NTBhVzFsYkdsdVpTNWZjMjl5ZEVOb2FXeGtjbVZ1SmlaMGFHbHpMblJwYldWc2FXNWxMbUZrWkNoMGFHbHpMSFF0ZEdocGN5NWZaR1ZzWVhrcEtTeDBhR2x6S1RwMGFHbHpMbDl6ZEdGeWRGUnBiV1Y5TEc0dVpXNWtWR2x0WlQxbWRXNWpkR2x2YmloMEtYdHlaWFIxY200Z2RHaHBjeTVmYzNSaGNuUlVhVzFsS3lnd0lUMTBQM1JvYVhNdWRHOTBZV3hFZFhKaGRHbHZiaWdwT25Sb2FYTXVaSFZ5WVhScGIyNG9LU2t2ZEdocGN5NWZkR2x0WlZOallXeGxmU3h1TG5ScGJXVlRZMkZzWlQxbWRXNWpkR2x2YmloMEtYdHBaaWdoWVhKbmRXMWxiblJ6TG14bGJtZDBhQ2x5WlhSMWNtNGdkR2hwY3k1ZmRHbHRaVk5qWVd4bE8ybG1LSFE5ZEh4OFh5eDBhR2x6TGw5MGFXMWxiR2x1WlNZbWRHaHBjeTVmZEdsdFpXeHBibVV1YzIxdmIzUm9RMmhwYkdSVWFXMXBibWNwZTNaaGNpQmxQWFJvYVhNdVgzQmhkWE5sVkdsdFpTeHBQV1Y4ZkRBOVBUMWxQMlU2ZEdocGN5NWZkR2x0Wld4cGJtVXVkRzkwWVd4VWFXMWxLQ2s3ZEdocGN5NWZjM1JoY25SVWFXMWxQV2t0S0drdGRHaHBjeTVmYzNSaGNuUlVhVzFsS1NwMGFHbHpMbDkwYVcxbFUyTmhiR1V2ZEgxeVpYUjFjbTRnZEdocGN5NWZkR2x0WlZOallXeGxQWFFzZEdocGN5NWZkVzVqWVdOb1pTZ2hNU2w5TEc0dWNtVjJaWEp6WldROVpuVnVZM1JwYjI0b2RDbDdjbVYwZFhKdUlHRnlaM1Z0Wlc1MGN5NXNaVzVuZEdnL0tIUWhQWFJvYVhNdVgzSmxkbVZ5YzJWa0ppWW9kR2hwY3k1ZmNtVjJaWEp6WldROWRDeDBhR2x6TG5SdmRHRnNWR2x0WlNoMGFHbHpMbDkwYVcxbGJHbHVaU1ltSVhSb2FYTXVYM1JwYldWc2FXNWxMbk50YjI5MGFFTm9hV3hrVkdsdGFXNW5QM1JvYVhNdWRHOTBZV3hFZFhKaGRHbHZiaWdwTFhSb2FYTXVYM1J2ZEdGc1ZHbHRaVHAwYUdsekxsOTBiM1JoYkZScGJXVXNJVEFwS1N4MGFHbHpLVHAwYUdsekxsOXlaWFpsY25ObFpIMHNiaTV3WVhWelpXUTlablZ1WTNScGIyNG9kQ2w3YVdZb0lXRnlaM1Z0Wlc1MGN5NXNaVzVuZEdncGNtVjBkWEp1SUhSb2FYTXVYM0JoZFhObFpEdDJZWElnWlN4cExITTlkR2hwY3k1ZmRHbHRaV3hwYm1VN2NtVjBkWEp1SUhRaFBYUm9hWE11WDNCaGRYTmxaQ1ltY3lZbUtHOThmSFI4ZkdFdWQyRnJaU2dwTEdVOWN5NXlZWGRVYVcxbEtDa3NhVDFsTFhSb2FYTXVYM0JoZFhObFZHbHRaU3doZENZbWN5NXpiVzl2ZEdoRGFHbHNaRlJwYldsdVp5WW1LSFJvYVhNdVgzTjBZWEowVkdsdFpTczlhU3gwYUdsekxsOTFibU5oWTJobEtDRXhLU2tzZEdocGN5NWZjR0YxYzJWVWFXMWxQWFEvWlRwdWRXeHNMSFJvYVhNdVgzQmhkWE5sWkQxMExIUm9hWE11WDJGamRHbDJaVDEwYUdsekxtbHpRV04wYVhabEtDa3NJWFFtSmpBaFBUMXBKaVowYUdsekxsOXBibWwwZEdWa0ppWjBhR2x6TG1SMWNtRjBhVzl1S0NrbUppaGxQWE11YzIxdmIzUm9RMmhwYkdSVWFXMXBibWMvZEdocGN5NWZkRzkwWVd4VWFXMWxPaWhsTFhSb2FYTXVYM04wWVhKMFZHbHRaU2t2ZEdocGN5NWZkR2x0WlZOallXeGxMSFJvYVhNdWNtVnVaR1Z5S0dVc1pUMDlQWFJvYVhNdVgzUnZkR0ZzVkdsdFpTd2hNQ2twS1N4MGFHbHpMbDluWXlZbUlYUW1KblJvYVhNdVgyVnVZV0pzWldRb0lUQXNJVEVwTEhSb2FYTjlPM1poY2lCRVBYWW9YQ0pqYjNKbExsTnBiWEJzWlZScGJXVnNhVzVsWENJc1puVnVZM1JwYjI0b2RDbDdVaTVqWVd4c0tIUm9hWE1zTUN4MEtTeDBhR2x6TG1GMWRHOVNaVzF2ZG1WRGFHbHNaSEpsYmoxMGFHbHpMbk50YjI5MGFFTm9hV3hrVkdsdGFXNW5QU0V3ZlNrN2JqMUVMbkJ5YjNSdmRIbHdaVDF1WlhjZ1VpeHVMbU52Ym5OMGNuVmpkRzl5UFVRc2JpNXJhV3hzS0NrdVgyZGpQU0V4TEc0dVgyWnBjbk4wUFc0dVgyeGhjM1E5Ymk1ZmNtVmpaVzUwUFc1MWJHd3NiaTVmYzI5eWRFTm9hV3hrY21WdVBTRXhMRzR1WVdSa1BXNHVhVzV6WlhKMFBXWjFibU4wYVc5dUtIUXNaU2w3ZG1GeUlHa3NjenRwWmloMExsOXpkR0Z5ZEZScGJXVTlUblZ0WW1WeUtHVjhmREFwSzNRdVgyUmxiR0Y1TEhRdVgzQmhkWE5sWkNZbWRHaHBjeUU5UFhRdVgzUnBiV1ZzYVc1bEppWW9kQzVmY0dGMWMyVlVhVzFsUFhRdVgzTjBZWEowVkdsdFpTc29kR2hwY3k1eVlYZFVhVzFsS0NrdGRDNWZjM1JoY25SVWFXMWxLUzkwTGw5MGFXMWxVMk5oYkdVcExIUXVkR2x0Wld4cGJtVW1KblF1ZEdsdFpXeHBibVV1WDNKbGJXOTJaU2gwTENFd0tTeDBMblJwYldWc2FXNWxQWFF1WDNScGJXVnNhVzVsUFhSb2FYTXNkQzVmWjJNbUpuUXVYMlZ1WVdKc1pXUW9JVEFzSVRBcExHazlkR2hwY3k1ZmJHRnpkQ3gwYUdsekxsOXpiM0owUTJocGJHUnlaVzRwWm05eUtITTlkQzVmYzNSaGNuUlVhVzFsTzJrbUpta3VYM04wWVhKMFZHbHRaVDV6T3lscFBXa3VYM0J5WlhZN2NtVjBkWEp1SUdrL0tIUXVYMjVsZUhROWFTNWZibVY0ZEN4cExsOXVaWGgwUFhRcE9paDBMbDl1WlhoMFBYUm9hWE11WDJacGNuTjBMSFJvYVhNdVgyWnBjbk4wUFhRcExIUXVYMjVsZUhRL2RDNWZibVY0ZEM1ZmNISmxkajEwT25Sb2FYTXVYMnhoYzNROWRDeDBMbDl3Y21WMlBXa3NkR2hwY3k1ZmNtVmpaVzUwUFhRc2RHaHBjeTVmZEdsdFpXeHBibVVtSm5Sb2FYTXVYM1Z1WTJGamFHVW9JVEFwTEhSb2FYTjlMRzR1WDNKbGJXOTJaVDFtZFc1amRHbHZiaWgwTEdVcGUzSmxkSFZ5YmlCMExuUnBiV1ZzYVc1bFBUMDlkR2hwY3lZbUtHVjhmSFF1WDJWdVlXSnNaV1FvSVRFc0lUQXBMSFF1WDNCeVpYWS9kQzVmY0hKbGRpNWZibVY0ZEQxMExsOXVaWGgwT25Sb2FYTXVYMlpwY25OMFBUMDlkQ1ltS0hSb2FYTXVYMlpwY25OMFBYUXVYMjVsZUhRcExIUXVYMjVsZUhRL2RDNWZibVY0ZEM1ZmNISmxkajEwTGw5d2NtVjJPblJvYVhNdVgyeGhjM1E5UFQxMEppWW9kR2hwY3k1ZmJHRnpkRDEwTGw5d2NtVjJLU3gwTGw5dVpYaDBQWFF1WDNCeVpYWTlkQzUwYVcxbGJHbHVaVDF1ZFd4c0xIUTlQVDEwYUdsekxsOXlaV05sYm5RbUppaDBhR2x6TGw5eVpXTmxiblE5ZEdocGN5NWZiR0Z6ZENrc2RHaHBjeTVmZEdsdFpXeHBibVVtSm5Sb2FYTXVYM1Z1WTJGamFHVW9JVEFwS1N4MGFHbHpmU3h1TG5KbGJtUmxjajFtZFc1amRHbHZiaWgwTEdVc2FTbDdkbUZ5SUhNc2NqMTBhR2x6TGw5bWFYSnpkRHRtYjNJb2RHaHBjeTVmZEc5MFlXeFVhVzFsUFhSb2FYTXVYM1JwYldVOWRHaHBjeTVmY21GM1VISmxkbFJwYldVOWREdHlPeWx6UFhJdVgyNWxlSFFzS0hJdVgyRmpkR2wyWlh4OGRENDljaTVmYzNSaGNuUlVhVzFsSmlZaGNpNWZjR0YxYzJWa0tTWW1LSEl1WDNKbGRtVnljMlZrUDNJdWNtVnVaR1Z5S0NoeUxsOWthWEowZVQ5eUxuUnZkR0ZzUkhWeVlYUnBiMjRvS1RweUxsOTBiM1JoYkVSMWNtRjBhVzl1S1Mwb2RDMXlMbDl6ZEdGeWRGUnBiV1VwS25JdVgzUnBiV1ZUWTJGc1pTeGxMR2twT25JdWNtVnVaR1Z5S0NoMExYSXVYM04wWVhKMFZHbHRaU2txY2k1ZmRHbHRaVk5qWVd4bExHVXNhU2twTEhJOWMzMHNiaTV5WVhkVWFXMWxQV1oxYm1OMGFXOXVLQ2w3Y21WMGRYSnVJRzk4ZkdFdWQyRnJaU2dwTEhSb2FYTXVYM1J2ZEdGc1ZHbHRaWDA3ZG1GeUlFazlkaWhjSWxSM1pXVnVUR2wwWlZ3aUxHWjFibU4wYVc5dUtHVXNhU3h6S1h0cFppaFNMbU5oYkd3b2RHaHBjeXhwTEhNcExIUm9hWE11Y21WdVpHVnlQVWt1Y0hKdmRHOTBlWEJsTG5KbGJtUmxjaXh1ZFd4c1BUMWxLWFJvY205M1hDSkRZVzV1YjNRZ2RIZGxaVzRnWVNCdWRXeHNJSFJoY21kbGRDNWNJanQwYUdsekxuUmhjbWRsZEQxbFBWd2ljM1J5YVc1blhDSWhQWFI1Y0dWdlppQmxQMlU2U1M1elpXeGxZM1J2Y2lobEtYeDhaVHQyWVhJZ2NpeHVMR0VzYnoxbExtcHhkV1Z5ZVh4OFpTNXNaVzVuZEdnbUptVWhQVDEwSmlabFd6QmRKaVlvWlZzd1hUMDlQWFI4ZkdWYk1GMHVibTlrWlZSNWNHVW1KbVZiTUYwdWMzUjViR1VtSmlGbExtNXZaR1ZVZVhCbEtTeHNQWFJvYVhNdWRtRnljeTV2ZG1WeWQzSnBkR1U3YVdZb2RHaHBjeTVmYjNabGNuZHlhWFJsUFd3OWJuVnNiRDA5YkQ4a1cwa3VaR1ZtWVhWc2RFOTJaWEozY21sMFpWMDZYQ0p1ZFcxaVpYSmNJajA5ZEhsd1pXOW1JR3cvYkQ0K01Eb2tXMnhkTENodmZIeGxJR2x1YzNSaGJtTmxiMllnUVhKeVlYbDhmR1V1Y0hWemFDWW1ZeWhsS1NrbUpsd2liblZ0WW1WeVhDSWhQWFI1Y0dWdlppQmxXekJkS1dadmNpaDBhR2x6TGw5MFlYSm5aWFJ6UFdFOWRTaGxLU3gwYUdsekxsOXdjbTl3VEc5dmEzVndQVnRkTEhSb2FYTXVYM05wWW14cGJtZHpQVnRkTEhJOU1EdGhMbXhsYm1kMGFENXlPM0lyS3lsdVBXRmJjbDBzYmo5Y0luTjBjbWx1WjF3aUlUMTBlWEJsYjJZZ2JqOXVMbXhsYm1kMGFDWW1iaUU5UFhRbUptNWJNRjBtSmlodVd6QmRQVDA5ZEh4OGJsc3dYUzV1YjJSbFZIbHdaU1ltYmxzd1hTNXpkSGxzWlNZbUlXNHVibTlrWlZSNWNHVXBQeWhoTG5Od2JHbGpaU2h5TFMwc01Ta3NkR2hwY3k1ZmRHRnlaMlYwY3oxaFBXRXVZMjl1WTJGMEtIVW9iaWtwS1Rvb2RHaHBjeTVmYzJsaWJHbHVaM05iY2wwOVZ5aHVMSFJvYVhNc0lURXBMREU5UFQxc0ppWjBhR2x6TGw5emFXSnNhVzVuYzF0eVhTNXNaVzVuZEdnK01TWW1XU2h1TEhSb2FYTXNiblZzYkN3eExIUm9hWE11WDNOcFlteHBibWR6VzNKZEtTazZLRzQ5WVZ0eUxTMWRQVWt1YzJWc1pXTjBiM0lvYmlrc1hDSnpkSEpwYm1kY0lqMDlkSGx3Wlc5bUlHNG1KbUV1YzNCc2FXTmxLSElyTVN3eEtTazZZUzV6Y0d4cFkyVW9jaTB0TERFcE8yVnNjMlVnZEdocGN5NWZjSEp2Y0V4dmIydDFjRDE3ZlN4MGFHbHpMbDl6YVdKc2FXNW5jejFYS0dVc2RHaHBjeXdoTVNrc01UMDlQV3dtSm5Sb2FYTXVYM05wWW14cGJtZHpMbXhsYm1kMGFENHhKaVpaS0dVc2RHaHBjeXh1ZFd4c0xERXNkR2hwY3k1ZmMybGliR2x1WjNNcE95aDBhR2x6TG5aaGNuTXVhVzF0WldScFlYUmxVbVZ1WkdWeWZId3dQVDA5YVNZbU1EMDlQWFJvYVhNdVgyUmxiR0Y1SmlaMGFHbHpMblpoY25NdWFXMXRaV1JwWVhSbFVtVnVaR1Z5SVQwOUlURXBKaVlvZEdocGN5NWZkR2x0WlQwdFh5eDBhR2x6TG5KbGJtUmxjaWd0ZEdocGN5NWZaR1ZzWVhrcEtYMHNJVEFwTEVVOVpuVnVZM1JwYjI0b1pTbDdjbVYwZFhKdUlHVW1KbVV1YkdWdVozUm9KaVpsSVQwOWRDWW1aVnN3WFNZbUtHVmJNRjA5UFQxMGZIeGxXekJkTG01dlpHVlVlWEJsSmlabFd6QmRMbk4wZVd4bEppWWhaUzV1YjJSbFZIbHdaU2w5TEU4OVpuVnVZM1JwYjI0b2RDeGxLWHQyWVhJZ2FTeHpQWHQ5TzJadmNpaHBJR2x1SUhRcFRWdHBYWHg4YVNCcGJpQmxKaVpjSW5SeVlXNXpabTl5YlZ3aUlUMDlhU1ltWENKNFhDSWhQVDFwSmlaY0lubGNJaUU5UFdrbUpsd2lkMmxrZEdoY0lpRTlQV2ttSmx3aWFHVnBaMmgwWENJaFBUMXBKaVpjSW1Oc1lYTnpUbUZ0WlZ3aUlUMDlhU1ltWENKaWIzSmtaWEpjSWlFOVBXbDhmQ0VvSVZGYmFWMThmRkZiYVYwbUpsRmJhVjB1WDJGMWRHOURVMU1wZkh3b2MxdHBYVDEwVzJsZExHUmxiR1YwWlNCMFcybGRLVHQwTG1OemN6MXpmVHR1UFVrdWNISnZkRzkwZVhCbFBXNWxkeUJTTEc0dVkyOXVjM1J5ZFdOMGIzSTlTU3h1TG10cGJHd29LUzVmWjJNOUlURXNiaTV5WVhScGJ6MHdMRzR1WDJacGNuTjBVRlE5Ymk1ZmRHRnlaMlYwY3oxdUxsOXZkbVZ5ZDNKcGRIUmxibEJ5YjNCelBXNHVYM04wWVhKMFFYUTliblZzYkN4dUxsOXViM1JwWm5sUWJIVm5hVzV6VDJaRmJtRmliR1ZrUFc0dVgyeGhlbms5SVRFc1NTNTJaWEp6YVc5dVBWd2lNUzR4T0M0d1hDSXNTUzVrWldaaGRXeDBSV0Z6WlQxdUxsOWxZWE5sUFc1bGR5QjVLRzUxYkd3c2JuVnNiQ3d4TERFcExFa3VaR1ZtWVhWc2RFOTJaWEozY21sMFpUMWNJbUYxZEc5Y0lpeEpMblJwWTJ0bGNqMWhMRWt1WVhWMGIxTnNaV1Z3UFRFeU1DeEpMbXhoWjFOdGIyOTBhR2x1WnoxbWRXNWpkR2x2YmloMExHVXBlMkV1YkdGblUyMXZiM1JvYVc1bktIUXNaU2w5TEVrdWMyVnNaV04wYjNJOWRDNGtmSHgwTG1wUmRXVnllWHg4Wm5WdVkzUnBiMjRvWlNsN2RtRnlJR2s5ZEM0a2ZIeDBMbXBSZFdWeWVUdHlaWFIxY200Z2FUOG9TUzV6Wld4bFkzUnZjajFwTEdrb1pTa3BPbHdpZFc1a1pXWnBibVZrWENJOVBYUjVjR1Z2WmlCa2IyTjFiV1Z1ZEQ5bE9tUnZZM1Z0Wlc1MExuRjFaWEo1VTJWc1pXTjBiM0pCYkd3L1pHOWpkVzFsYm5RdWNYVmxjbmxUWld4bFkzUnZja0ZzYkNobEtUcGtiMk4xYldWdWRDNW5aWFJGYkdWdFpXNTBRbmxKWkNoY0lpTmNJajA5UFdVdVkyaGhja0YwS0RBcFAyVXVjM1ZpYzNSeUtERXBPbVVwZlR0MllYSWdlajFiWFN4R1BYdDlMRXc5THlnL09pZ3RmQzA5ZkZ4Y0t6MHBQMXhjWkNwY1hDNC9YRnhrS2lnL09tVmJYRnd0SzEwL1hGeGtLeWsvS1Zzd0xUbGRMMmRwTEU0OVpuVnVZM1JwYjI0b2RDbDdabTl5S0haaGNpQmxMR2s5ZEdocGN5NWZabWx5YzNSUVZDeHpQVEZsTFRZN2FUc3BaVDFwTG1Kc2IySS9kRDkwYUdsekxtcHZhVzRvWENKY0lpazZkR2hwY3k1emRHRnlkRHBwTG1NcWRDdHBMbk1zYVM1eVAyVTlUV0YwYUM1eWIzVnVaQ2hsS1RwelBtVW1KbVUrTFhNbUppaGxQVEFwTEdrdVpqOXBMbVp3UDJrdWRGdHBMbkJkS0drdVpuQXNaU2s2YVM1MFcya3VjRjBvWlNrNmFTNTBXMmt1Y0YwOVpTeHBQV2t1WDI1bGVIUjlMRlU5Wm5WdVkzUnBiMjRvZEN4bExHa3NjeWw3ZG1GeUlISXNiaXhoTEc4c2JDeG9MRjhzZFQxYmRDeGxYU3htUFRBc1l6MWNJbHdpTEcwOU1EdG1iM0lvZFM1emRHRnlkRDEwTEdrbUppaHBLSFVwTEhROWRWc3dYU3hsUFhWYk1WMHBMSFV1YkdWdVozUm9QVEFzY2oxMExtMWhkR05vS0V3cGZIeGJYU3h1UFdVdWJXRjBZMmdvVENsOGZGdGRMSE1tSmloekxsOXVaWGgwUFc1MWJHd3NjeTVpYkc5aVBURXNkUzVmWm1seWMzUlFWRDF6S1N4c1BXNHViR1Z1WjNSb0xHODlNRHRzUG04N2J5c3JLVjg5Ymx0dlhTeG9QV1V1YzNWaWMzUnlLR1lzWlM1cGJtUmxlRTltS0Y4c1ppa3RaaWtzWXlzOWFIeDhJVzgvYURwY0lpeGNJaXhtS3oxb0xteGxibWQwYUN4dFAyMDlLRzByTVNrbE5UcGNJbkpuWW1Fb1hDSTlQVDFvTG5OMVluTjBjaWd0TlNrbUppaHRQVEVwTEY4OVBUMXlXMjlkZkh4dlBqMXlMbXhsYm1kMGFEOWpLejFmT2loakppWW9kUzV3ZFhOb0tHTXBMR005WENKY0lpa3NZVDF3WVhKelpVWnNiMkYwS0hKYmIxMHBMSFV1Y0hWemFDaGhLU3gxTGw5bWFYSnpkRkJVUFh0ZmJtVjRkRHAxTGw5bWFYSnpkRkJVTEhRNmRTeHdPblV1YkdWdVozUm9MVEVzY3pwaExHTTZLRndpUFZ3aVBUMDlYeTVqYUdGeVFYUW9NU2svY0dGeWMyVkpiblFvWHk1amFHRnlRWFFvTUNrclhDSXhYQ0lzTVRBcEtuQmhjbk5sUm14dllYUW9YeTV6ZFdKemRISW9NaWtwT25CaGNuTmxSbXh2WVhRb1h5a3RZU2w4ZkRBc1pqb3dMSEk2YlNZbU5ENXRmU2tzWmlzOVh5NXNaVzVuZEdnN2NtVjBkWEp1SUdNclBXVXVjM1ZpYzNSeUtHWXBMR01tSm5VdWNIVnphQ2hqS1N4MUxuTmxkRkpoZEdsdlBVNHNkWDBzYWoxbWRXNWpkR2x2YmloMExHVXNhU3h6TEhJc2JpeGhMRzhwZTNaaGNpQnNMR2dzWHoxY0ltZGxkRndpUFQwOWFUOTBXMlZkT21rc2RUMTBlWEJsYjJZZ2RGdGxYU3htUFZ3aWMzUnlhVzVuWENJOVBYUjVjR1Z2WmlCekppWmNJajFjSWowOVBYTXVZMmhoY2tGMEtERXBMR005ZTNRNmRDeHdPbVVzY3pwZkxHWTZYQ0ptZFc1amRHbHZibHdpUFQwOWRTeHdaem93TEc0NmNueDhaU3h5T200c2NISTZNQ3hqT21ZL2NHRnljMlZKYm5Rb2N5NWphR0Z5UVhRb01Da3JYQ0l4WENJc01UQXBLbkJoY25ObFJteHZZWFFvY3k1emRXSnpkSElvTWlrcE9uQmhjbk5sUm14dllYUW9jeWt0WDN4OE1IMDdjbVYwZFhKdVhDSnVkVzFpWlhKY0lpRTlQWFVtSmloY0ltWjFibU4wYVc5dVhDSTlQVDExSmlaY0ltZGxkRndpUFQwOWFTWW1LR2c5WlM1cGJtUmxlRTltS0Z3aWMyVjBYQ0lwZkh4Y0ltWjFibU4wYVc5dVhDSWhQWFI1Y0dWdlppQjBXMXdpWjJWMFhDSXJaUzV6ZFdKemRISW9NeWxkUDJVNlhDSm5aWFJjSWl0bExuTjFZbk4wY2lnektTeGpMbk05WHoxaFAzUmJhRjBvWVNrNmRGdG9YU2dwS1N4Y0luTjBjbWx1WjF3aVBUMTBlWEJsYjJZZ1h5WW1LR0Y4ZkdselRtRk9LRjhwS1Q4b1l5NW1jRDFoTEd3OVZTaGZMSE1zYjN4OFNTNWtaV1poZFd4MFUzUnlhVzVuUm1sc2RHVnlMR01wTEdNOWUzUTZiQ3h3T2x3aWMyVjBVbUYwYVc5Y0lpeHpPakFzWXpveExHWTZNaXh3Wnpvd0xHNDZjbng4WlN4d2Nqb3dmU2s2Wm54OEtHTXVZejF3WVhKelpVWnNiMkYwS0hNcExYQmhjbk5sUm14dllYUW9YeWw4ZkRBcEtTeGpMbU0vS0NoakxsOXVaWGgwUFhSb2FYTXVYMlpwY25OMFVGUXBKaVlvWXk1ZmJtVjRkQzVmY0hKbGRqMWpLU3gwYUdsekxsOW1hWEp6ZEZCVVBXTXNZeWs2ZG05cFpDQXdmU3hIUFVrdVgybHVkR1Z5Ym1Gc2N6MTdhWE5CY25KaGVUcGpMR2x6VTJWc1pXTjBiM0k2UlN4c1lYcDVWSGRsWlc1ek9ub3NZbXh2WWtScFpqcFZmU3hSUFVrdVgzQnNkV2RwYm5NOWUzMHNjVDFITG5SM1pXVnVURzl2YTNWd1BYdDlMRUk5TUN4TlBVY3VjbVZ6WlhKMlpXUlFjbTl3Y3oxN1pXRnpaVG94TEdSbGJHRjVPakVzYjNabGNuZHlhWFJsT2pFc2IyNURiMjF3YkdWMFpUb3hMRzl1UTI5dGNHeGxkR1ZRWVhKaGJYTTZNU3h2YmtOdmJYQnNaWFJsVTJOdmNHVTZNU3gxYzJWR2NtRnRaWE02TVN4eWRXNUNZV05yZDJGeVpITTZNU3h6ZEdGeWRFRjBPakVzYjI1VmNHUmhkR1U2TVN4dmJsVndaR0YwWlZCaGNtRnRjem94TEc5dVZYQmtZWFJsVTJOdmNHVTZNU3h2YmxOMFlYSjBPakVzYjI1VGRHRnlkRkJoY21GdGN6b3hMRzl1VTNSaGNuUlRZMjl3WlRveExHOXVVbVYyWlhKelpVTnZiWEJzWlhSbE9qRXNiMjVTWlhabGNuTmxRMjl0Y0d4bGRHVlFZWEpoYlhNNk1TeHZibEpsZG1WeWMyVkRiMjF3YkdWMFpWTmpiM0JsT2pFc2IyNVNaWEJsWVhRNk1TeHZibEpsY0dWaGRGQmhjbUZ0Y3pveExHOXVVbVZ3WldGMFUyTnZjR1U2TVN4bFlYTmxVR0Z5WVcxek9qRXNlVzk1YnpveExHbHRiV1ZrYVdGMFpWSmxibVJsY2pveExISmxjR1ZoZERveExISmxjR1ZoZEVSbGJHRjVPakVzWkdGMFlUb3hMSEJoZFhObFpEb3hMSEpsZG1WeWMyVmtPakVzWVhWMGIwTlRVem94TEd4aGVuazZNU3h2Yms5MlpYSjNjbWwwWlRveExHTmhiR3hpWVdOclUyTnZjR1U2TVN4emRISnBibWRHYVd4MFpYSTZNWDBzSkQxN2JtOXVaVG93TEdGc2JEb3hMR0YxZEc4Nk1peGpiMjVqZFhKeVpXNTBPak1zWVd4c1QyNVRkR0Z5ZERvMExIQnlaV1Y0YVhOMGFXNW5PalVzWENKMGNuVmxYQ0k2TVN4Y0ltWmhiSE5sWENJNk1IMHNTejFTTGw5eWIyOTBSbkpoYldWelZHbHRaV3hwYm1VOWJtVjNJRVFzU0QxU0xsOXliMjkwVkdsdFpXeHBibVU5Ym1WM0lFUXNTajB6TUN4V1BVY3ViR0Y2ZVZKbGJtUmxjajFtZFc1amRHbHZiaWdwZTNaaGNpQjBMR1U5ZWk1c1pXNW5kR2c3Wm05eUtFWTllMzA3TFMxbFBpMHhPeWwwUFhwYlpWMHNkQ1ltZEM1ZmJHRjZlU0U5UFNFeEppWW9kQzV5Wlc1a1pYSW9kQzVmYkdGNmVWc3dYU3gwTGw5c1lYcDVXekZkTENFd0tTeDBMbDlzWVhwNVBTRXhLVHQ2TG14bGJtZDBhRDB3ZlR0SUxsOXpkR0Z5ZEZScGJXVTlZUzUwYVcxbExFc3VYM04wWVhKMFZHbHRaVDFoTG1aeVlXMWxMRWd1WDJGamRHbDJaVDFMTGw5aFkzUnBkbVU5SVRBc2MyVjBWR2x0Wlc5MWRDaFdMREVwTEZJdVgzVndaR0YwWlZKdmIzUTlTUzV5Wlc1a1pYSTlablZ1WTNScGIyNG9LWHQyWVhJZ2RDeGxMR2s3YVdZb2VpNXNaVzVuZEdnbUpsWW9LU3hJTG5KbGJtUmxjaWdvWVM1MGFXMWxMVWd1WDNOMFlYSjBWR2x0WlNrcVNDNWZkR2x0WlZOallXeGxMQ0V4TENFeEtTeExMbkpsYm1SbGNpZ29ZUzVtY21GdFpTMUxMbDl6ZEdGeWRGUnBiV1VwS2tzdVgzUnBiV1ZUWTJGc1pTd2hNU3doTVNrc2VpNXNaVzVuZEdnbUpsWW9LU3hoTG1aeVlXMWxQajFLS1h0S1BXRXVabkpoYldVcktIQmhjbk5sU1c1MEtFa3VZWFYwYjFOc1pXVndMREV3S1h4OE1USXdLVHRtYjNJb2FTQnBiaUJ4S1h0bWIzSW9aVDF4VzJsZExuUjNaV1Z1Y3l4MFBXVXViR1Z1WjNSb095MHRkRDR0TVRzcFpWdDBYUzVmWjJNbUptVXVjM0JzYVdObEtIUXNNU2s3TUQwOVBXVXViR1Z1WjNSb0ppWmtaV3hsZEdVZ2NWdHBYWDFwWmlocFBVZ3VYMlpwY25OMExDZ2hhWHg4YVM1ZmNHRjFjMlZrS1NZbVNTNWhkWFJ2VTJ4bFpYQW1KaUZMTGw5bWFYSnpkQ1ltTVQwOVBXRXVYMnhwYzNSbGJtVnljeTUwYVdOckxteGxibWQwYUNsN1ptOXlLRHRwSmlacExsOXdZWFZ6WldRN0tXazlhUzVmYm1WNGREdHBmSHhoTG5Oc1pXVndLQ2w5Zlgwc1lTNWhaR1JGZG1WdWRFeHBjM1JsYm1WeUtGd2lkR2xqYTF3aUxGSXVYM1Z3WkdGMFpWSnZiM1FwTzNaaGNpQlhQV1oxYm1OMGFXOXVLSFFzWlN4cEtYdDJZWElnY3l4eUxHNDlkQzVmWjNOVWQyVmxia2xFTzJsbUtIRmJibng4S0hRdVgyZHpWSGRsWlc1SlJEMXVQVndpZEZ3aUswSXJLeWxkZkh3b2NWdHVYVDE3ZEdGeVoyVjBPblFzZEhkbFpXNXpPbHRkZlNrc1pTWW1LSE05Y1Z0dVhTNTBkMlZsYm5Nc2MxdHlQWE11YkdWdVozUm9YVDFsTEdrcEtXWnZjaWc3TFMxeVBpMHhPeWx6VzNKZFBUMDlaU1ltY3k1emNHeHBZMlVvY2l3eEtUdHlaWFIxY200Z2NWdHVYUzUwZDJWbGJuTjlMRmc5Wm5WdVkzUnBiMjRvZEN4bExHa3NjeWw3ZG1GeUlISXNiaXhoUFhRdWRtRnljeTV2Yms5MlpYSjNjbWwwWlR0eVpYUjFjbTRnWVNZbUtISTlZU2gwTEdVc2FTeHpLU2tzWVQxSkxtOXVUM1psY25keWFYUmxMR0VtSmlodVBXRW9kQ3hsTEdrc2N5a3BMSEloUFQwaE1TWW1iaUU5UFNFeGZTeFpQV1oxYm1OMGFXOXVLSFFzWlN4cExITXNjaWw3ZG1GeUlHNHNZU3h2TEd3N2FXWW9NVDA5UFhOOGZITStQVFFwZTJadmNpaHNQWEl1YkdWdVozUm9MRzQ5TUR0c1BtNDdiaXNyS1dsbUtDaHZQWEpiYmwwcElUMDlaU2x2TGw5blkzeDhieTVmYTJsc2JDaHVkV3hzTEhRc1pTa21KaWhoUFNFd0tUdGxiSE5sSUdsbUtEVTlQVDF6S1dKeVpXRnJPM0psZEhWeWJpQmhmWFpoY2lCb0xIVTlaUzVmYzNSaGNuUlVhVzFsSzE4c1pqMWJYU3hqUFRBc2JUMHdQVDA5WlM1ZlpIVnlZWFJwYjI0N1ptOXlLRzQ5Y2k1c1pXNW5kR2c3TFMxdVBpMHhPeWtvYnoxeVcyNWRLVDA5UFdWOGZHOHVYMmRqZkh4dkxsOXdZWFZ6WldSOGZDaHZMbDkwYVcxbGJHbHVaU0U5UFdVdVgzUnBiV1ZzYVc1bFB5aG9QV2g4ZkZvb1pTd3dMRzBwTERBOVBUMWFLRzhzYUN4dEtTWW1LR1piWXlzclhUMXZLU2s2ZFQ0OWJ5NWZjM1JoY25SVWFXMWxKaVp2TGw5emRHRnlkRlJwYldVcmJ5NTBiM1JoYkVSMWNtRjBhVzl1S0NrdmJ5NWZkR2x0WlZOallXeGxQblVtSmlnb2JYeDhJVzh1WDJsdWFYUjBaV1FwSmlZeVpTMHhNRDQ5ZFMxdkxsOXpkR0Z5ZEZScGJXVjhmQ2htVzJNcksxMDlieWtwS1R0bWIzSW9iajFqT3kwdGJqNHRNVHNwYVdZb2J6MW1XMjVkTERJOVBUMXpKaVp2TGw5cmFXeHNLR2tzZEN4bEtTWW1LR0U5SVRBcExESWhQVDF6Zkh3aGJ5NWZabWx5YzNSUVZDWW1ieTVmYVc1cGRIUmxaQ2w3YVdZb01pRTlQWE1tSmlGWUtHOHNaU2twWTI5dWRHbHVkV1U3Ynk1ZlpXNWhZbXhsWkNnaE1Td2hNU2ttSmloaFBTRXdLWDF5WlhSMWNtNGdZWDBzV2oxbWRXNWpkR2x2YmloMExHVXNhU2w3Wm05eUtIWmhjaUJ6UFhRdVgzUnBiV1ZzYVc1bExISTljeTVmZEdsdFpWTmpZV3hsTEc0OWRDNWZjM1JoY25SVWFXMWxPM011WDNScGJXVnNhVzVsT3lsN2FXWW9iaXM5Y3k1ZmMzUmhjblJVYVcxbExISXFQWE11WDNScGJXVlRZMkZzWlN4ekxsOXdZWFZ6WldRcGNtVjBkWEp1TFRFd01EdHpQWE11WDNScGJXVnNhVzVsZlhKbGRIVnliaUJ1THoxeUxHNCtaVDl1TFdVNmFTWW1iajA5UFdWOGZDRjBMbDlwYm1sMGRHVmtKaVl5S2w4K2JpMWxQMTg2S0c0clBYUXVkRzkwWVd4RWRYSmhkR2x2YmlncEwzUXVYM1JwYldWVFkyRnNaUzl5S1Q1bEsxOC9NRHB1TFdVdFgzMDdiaTVmYVc1cGREMW1kVzVqZEdsdmJpZ3BlM1poY2lCMExHVXNhU3h6TEhJc2JqMTBhR2x6TG5aaGNuTXNZVDEwYUdsekxsOXZkbVZ5ZDNKcGRIUmxibEJ5YjNCekxHODlkR2hwY3k1ZlpIVnlZWFJwYjI0c2JEMGhJVzR1YVcxdFpXUnBZWFJsVW1WdVpHVnlMR2c5Ymk1bFlYTmxPMmxtS0c0dWMzUmhjblJCZENsN2RHaHBjeTVmYzNSaGNuUkJkQ1ltS0hSb2FYTXVYM04wWVhKMFFYUXVjbVZ1WkdWeUtDMHhMQ0V3S1N4MGFHbHpMbDl6ZEdGeWRFRjBMbXRwYkd3b0tTa3NjajE3ZlR0bWIzSW9jeUJwYmlCdUxuTjBZWEowUVhRcGNsdHpYVDF1TG5OMFlYSjBRWFJiYzEwN2FXWW9jaTV2ZG1WeWQzSnBkR1U5SVRFc2NpNXBiVzFsWkdsaGRHVlNaVzVrWlhJOUlUQXNjaTVzWVhwNVBXd21KbTR1YkdGNmVTRTlQU0V4TEhJdWMzUmhjblJCZEQxeUxtUmxiR0Y1UFc1MWJHd3NkR2hwY3k1ZmMzUmhjblJCZEQxSkxuUnZLSFJvYVhNdWRHRnlaMlYwTERBc2Npa3NiQ2xwWmloMGFHbHpMbDkwYVcxbFBqQXBkR2hwY3k1ZmMzUmhjblJCZEQxdWRXeHNPMlZzYzJVZ2FXWW9NQ0U5UFc4cGNtVjBkWEp1ZldWc2MyVWdhV1lvYmk1eWRXNUNZV05yZDJGeVpITW1KakFoUFQxdktXbG1LSFJvYVhNdVgzTjBZWEowUVhRcGRHaHBjeTVmYzNSaGNuUkJkQzV5Wlc1a1pYSW9MVEVzSVRBcExIUm9hWE11WDNOMFlYSjBRWFF1YTJsc2JDZ3BMSFJvYVhNdVgzTjBZWEowUVhROWJuVnNiRHRsYkhObGV6QWhQVDEwYUdsekxsOTBhVzFsSmlZb2JEMGhNU2tzYVQxN2ZUdG1iM0lvY3lCcGJpQnVLVTFiYzEwbUpsd2lZWFYwYjBOVFUxd2lJVDA5YzN4OEtHbGJjMTA5Ymx0elhTazdhV1lvYVM1dmRtVnlkM0pwZEdVOU1DeHBMbVJoZEdFOVhDSnBjMFp5YjIxVGRHRnlkRndpTEdrdWJHRjZlVDFzSmladUxteGhlbmtoUFQwaE1TeHBMbWx0YldWa2FXRjBaVkpsYm1SbGNqMXNMSFJvYVhNdVgzTjBZWEowUVhROVNTNTBieWgwYUdsekxuUmhjbWRsZEN3d0xHa3BMR3dwZTJsbUtEQTlQVDEwYUdsekxsOTBhVzFsS1hKbGRIVnlibjFsYkhObElIUm9hWE11WDNOMFlYSjBRWFF1WDJsdWFYUW9LU3gwYUdsekxsOXpkR0Z5ZEVGMExsOWxibUZpYkdWa0tDRXhLU3gwYUdsekxuWmhjbk11YVcxdFpXUnBZWFJsVW1WdVpHVnlKaVlvZEdocGN5NWZjM1JoY25SQmREMXVkV3hzS1gxcFppaDBhR2x6TGw5bFlYTmxQV2c5YUQ5b0lHbHVjM1JoYm1ObGIyWWdlVDlvT2x3aVpuVnVZM1JwYjI1Y0lqMDlkSGx3Wlc5bUlHZy9ibVYzSUhrb2FDeHVMbVZoYzJWUVlYSmhiWE1wT25kYmFGMThmRWt1WkdWbVlYVnNkRVZoYzJVNlNTNWtaV1poZFd4MFJXRnpaU3h1TG1WaGMyVlFZWEpoYlhNZ2FXNXpkR0Z1WTJWdlppQkJjbkpoZVNZbWFDNWpiMjVtYVdjbUppaDBhR2x6TGw5bFlYTmxQV2d1WTI5dVptbG5MbUZ3Y0d4NUtHZ3NiaTVsWVhObFVHRnlZVzF6S1Nrc2RHaHBjeTVmWldGelpWUjVjR1U5ZEdocGN5NWZaV0Z6WlM1ZmRIbHdaU3gwYUdsekxsOWxZWE5sVUc5M1pYSTlkR2hwY3k1ZlpXRnpaUzVmY0c5M1pYSXNkR2hwY3k1ZlptbHljM1JRVkQxdWRXeHNMSFJvYVhNdVgzUmhjbWRsZEhNcFptOXlLSFE5ZEdocGN5NWZkR0Z5WjJWMGN5NXNaVzVuZEdnN0xTMTBQaTB4T3lsMGFHbHpMbDlwYm1sMFVISnZjSE1vZEdocGN5NWZkR0Z5WjJWMGMxdDBYU3gwYUdsekxsOXdjbTl3VEc5dmEzVndXM1JkUFh0OUxIUm9hWE11WDNOcFlteHBibWR6VzNSZExHRS9ZVnQwWFRwdWRXeHNLU1ltS0dVOUlUQXBPMlZzYzJVZ1pUMTBhR2x6TGw5cGJtbDBVSEp2Y0hNb2RHaHBjeTUwWVhKblpYUXNkR2hwY3k1ZmNISnZjRXh2YjJ0MWNDeDBhR2x6TGw5emFXSnNhVzVuY3l4aEtUdHBaaWhsSmlaSkxsOXZibEJzZFdkcGJrVjJaVzUwS0Z3aVgyOXVTVzVwZEVGc2JGQnliM0J6WENJc2RHaHBjeWtzWVNZbUtIUm9hWE11WDJacGNuTjBVRlI4ZkZ3aVpuVnVZM1JwYjI1Y0lpRTlkSGx3Wlc5bUlIUm9hWE11ZEdGeVoyVjBKaVowYUdsekxsOWxibUZpYkdWa0tDRXhMQ0V4S1Nrc2JpNXlkVzVDWVdOcmQyRnlaSE1wWm05eUtHazlkR2hwY3k1ZlptbHljM1JRVkR0cE95bHBMbk1yUFdrdVl5eHBMbU05TFdrdVl5eHBQV2t1WDI1bGVIUTdkR2hwY3k1ZmIyNVZjR1JoZEdVOWJpNXZibFZ3WkdGMFpTeDBhR2x6TGw5cGJtbDBkR1ZrUFNFd2ZTeHVMbDlwYm1sMFVISnZjSE05Wm5WdVkzUnBiMjRvWlN4cExITXNjaWw3ZG1GeUlHNHNZU3h2TEd3c2FDeGZPMmxtS0c1MWJHdzlQV1VwY21WMGRYSnVJVEU3Umx0bExsOW5jMVIzWldWdVNVUmRKaVpXS0Nrc2RHaHBjeTUyWVhKekxtTnpjM3g4WlM1emRIbHNaU1ltWlNFOVBYUW1KbVV1Ym05a1pWUjVjR1VtSmxFdVkzTnpKaVowYUdsekxuWmhjbk11WVhWMGIwTlRVeUU5UFNFeEppWlBLSFJvYVhNdWRtRnljeXhsS1R0bWIzSW9iaUJwYmlCMGFHbHpMblpoY25NcGFXWW9YejEwYUdsekxuWmhjbk5iYmwwc1RWdHVYU2xmSmlZb1h5QnBibk4wWVc1alpXOW1JRUZ5Y21GNWZIeGZMbkIxYzJnbUptTW9YeWtwSmlZdE1TRTlQVjh1YW05cGJpaGNJbHdpS1M1cGJtUmxlRTltS0Z3aWUzTmxiR1o5WENJcEppWW9kR2hwY3k1MllYSnpXMjVkUFY4OWRHaHBjeTVmYzNkaGNGTmxiR1pKYmxCaGNtRnRjeWhmTEhSb2FYTXBLVHRsYkhObElHbG1LRkZiYmwwbUppaHNQVzVsZHlCUlcyNWRLUzVmYjI1SmJtbDBWSGRsWlc0b1pTeDBhR2x6TG5aaGNuTmJibDBzZEdocGN5a3BlMlp2Y2loMGFHbHpMbDltYVhKemRGQlVQV2c5ZTE5dVpYaDBPblJvYVhNdVgyWnBjbk4wVUZRc2REcHNMSEE2WENKelpYUlNZWFJwYjF3aUxITTZNQ3hqT2pFc1pqb3hMRzQ2Yml4d1p6b3hMSEJ5T213dVgzQnlhVzl5YVhSNWZTeGhQV3d1WDI5MlpYSjNjbWwwWlZCeWIzQnpMbXhsYm1kMGFEc3RMV0UrTFRFN0tXbGJiQzVmYjNabGNuZHlhWFJsVUhKdmNITmJZVjFkUFhSb2FYTXVYMlpwY25OMFVGUTdLR3d1WDNCeWFXOXlhWFI1Zkh4c0xsOXZia2x1YVhSQmJHeFFjbTl3Y3lrbUppaHZQU0V3S1N3b2JDNWZiMjVFYVhOaFlteGxmSHhzTGw5dmJrVnVZV0pzWlNrbUppaDBhR2x6TGw5dWIzUnBabmxRYkhWbmFXNXpUMlpGYm1GaWJHVmtQU0V3S1N4b0xsOXVaWGgwSmlZb2FDNWZibVY0ZEM1ZmNISmxkajFvS1gxbGJITmxJR2xiYmwwOWFpNWpZV3hzS0hSb2FYTXNaU3h1TEZ3aVoyVjBYQ0lzWHl4dUxEQXNiblZzYkN4MGFHbHpMblpoY25NdWMzUnlhVzVuUm1sc2RHVnlLVHR5WlhSMWNtNGdjaVltZEdocGN5NWZhMmxzYkNoeUxHVXBQM1JvYVhNdVgybHVhWFJRY205d2N5aGxMR2tzY3l4eUtUcDBhR2x6TGw5dmRtVnlkM0pwZEdVK01TWW1kR2hwY3k1ZlptbHljM1JRVkNZbWN5NXNaVzVuZEdnK01TWW1XU2hsTEhSb2FYTXNhU3gwYUdsekxsOXZkbVZ5ZDNKcGRHVXNjeWsvS0hSb2FYTXVYMnRwYkd3b2FTeGxLU3gwYUdsekxsOXBibWwwVUhKdmNITW9aU3hwTEhNc2Npa3BPaWgwYUdsekxsOW1hWEp6ZEZCVUppWW9kR2hwY3k1MllYSnpMbXhoZW5raFBUMGhNU1ltZEdocGN5NWZaSFZ5WVhScGIyNThmSFJvYVhNdWRtRnljeTVzWVhwNUppWWhkR2hwY3k1ZlpIVnlZWFJwYjI0cEppWW9SbHRsTGw5bmMxUjNaV1Z1U1VSZFBTRXdLU3h2S1gwc2JpNXlaVzVrWlhJOVpuVnVZM1JwYjI0b2RDeGxMR2twZTNaaGNpQnpMSElzYml4aExHODlkR2hwY3k1ZmRHbHRaU3hzUFhSb2FYTXVYMlIxY21GMGFXOXVMR2c5ZEdocGN5NWZjbUYzVUhKbGRsUnBiV1U3YVdZb2RENDliQ2wwYUdsekxsOTBiM1JoYkZScGJXVTlkR2hwY3k1ZmRHbHRaVDFzTEhSb2FYTXVjbUYwYVc4OWRHaHBjeTVmWldGelpTNWZZMkZzWTBWdVpEOTBhR2x6TGw5bFlYTmxMbWRsZEZKaGRHbHZLREVwT2pFc2RHaHBjeTVmY21WMlpYSnpaV1I4ZkNoelBTRXdMSEk5WENKdmJrTnZiWEJzWlhSbFhDSXNhVDFwZkh4MGFHbHpMbDkwYVcxbGJHbHVaUzVoZFhSdlVtVnRiM1psUTJocGJHUnlaVzRwTERBOVBUMXNKaVlvZEdocGN5NWZhVzVwZEhSbFpIeDhJWFJvYVhNdWRtRnljeTVzWVhwNWZIeHBLU1ltS0hSb2FYTXVYM04wWVhKMFZHbHRaVDA5UFhSb2FYTXVYM1JwYldWc2FXNWxMbDlrZFhKaGRHbHZiaVltS0hROU1Da3NLREE5UFQxMGZId3dQbWg4ZkdnOVBUMWZKaVpjSW1selVHRjFjMlZjSWlFOVBYUm9hWE11WkdGMFlTa21KbWdoUFQxMEppWW9hVDBoTUN4b1BsOG1KaWh5UFZ3aWIyNVNaWFpsY25ObFEyOXRjR3hsZEdWY0lpa3BMSFJvYVhNdVgzSmhkMUJ5WlhaVWFXMWxQV0U5SVdWOGZIUjhmR2c5UFQxMFAzUTZYeWs3Wld4elpTQnBaaWd4WlMwM1BuUXBkR2hwY3k1ZmRHOTBZV3hVYVcxbFBYUm9hWE11WDNScGJXVTlNQ3gwYUdsekxuSmhkR2x2UFhSb2FYTXVYMlZoYzJVdVgyTmhiR05GYm1RL2RHaHBjeTVmWldGelpTNW5aWFJTWVhScGJ5Z3dLVG93TENnd0lUMDliM3g4TUQwOVBXd21KbWcrTUNrbUppaHlQVndpYjI1U1pYWmxjbk5sUTI5dGNHeGxkR1ZjSWl4elBYUm9hWE11WDNKbGRtVnljMlZrS1N3d1BuUW1KaWgwYUdsekxsOWhZM1JwZG1VOUlURXNNRDA5UFd3bUppaDBhR2x6TGw5cGJtbDBkR1ZrZkh3aGRHaHBjeTUyWVhKekxteGhlbmw4ZkdrcEppWW9hRDQ5TUNZbUtHZ2hQVDFmZkh4Y0ltbHpVR0YxYzJWY0lpRTlQWFJvYVhNdVpHRjBZU2ttSmlocFBTRXdLU3gwYUdsekxsOXlZWGRRY21WMlZHbHRaVDFoUFNGbGZIeDBmSHhvUFQwOWREOTBPbDhwS1N4MGFHbHpMbDlwYm1sMGRHVmtmSHdvYVQwaE1DazdaV3h6WlNCcFppaDBhR2x6TGw5MGIzUmhiRlJwYldVOWRHaHBjeTVmZEdsdFpUMTBMSFJvYVhNdVgyVmhjMlZVZVhCbEtYdDJZWElnZFQxMEwyd3NaajEwYUdsekxsOWxZWE5sVkhsd1pTeGpQWFJvYVhNdVgyVmhjMlZRYjNkbGNqc29NVDA5UFdaOGZETTlQVDFtSmlaMVBqMHVOU2ttSmloMVBURXRkU2tzTXowOVBXWW1KaWgxS2oweUtTd3hQVDA5WXo5MUtqMTFPakk5UFQxalAzVXFQWFVxZFRvelBUMDlZejkxS2oxMUtuVXFkVG8wUFQwOVl5WW1LSFVxUFhVcWRTcDFLblVwTEhSb2FYTXVjbUYwYVc4OU1UMDlQV1kvTVMxMU9qSTlQVDFtUDNVNkxqVStkQzlzUDNVdk1qb3hMWFV2TW4xbGJITmxJSFJvYVhNdWNtRjBhVzg5ZEdocGN5NWZaV0Z6WlM1blpYUlNZWFJwYnloMEwyd3BPMmxtS0hSb2FYTXVYM1JwYldVaFBUMXZmSHhwS1h0cFppZ2hkR2hwY3k1ZmFXNXBkSFJsWkNsN2FXWW9kR2hwY3k1ZmFXNXBkQ2dwTENGMGFHbHpMbDlwYm1sMGRHVmtmSHgwYUdsekxsOW5ZeWx5WlhSMWNtNDdhV1lvSVdrbUpuUm9hWE11WDJacGNuTjBVRlFtSmloMGFHbHpMblpoY25NdWJHRjZlU0U5UFNFeEppWjBhR2x6TGw5a2RYSmhkR2x2Ym54OGRHaHBjeTUyWVhKekxteGhlbmttSmlGMGFHbHpMbDlrZFhKaGRHbHZiaWtwY21WMGRYSnVJSFJvYVhNdVgzUnBiV1U5ZEdocGN5NWZkRzkwWVd4VWFXMWxQVzhzZEdocGN5NWZjbUYzVUhKbGRsUnBiV1U5YUN4NkxuQjFjMmdvZEdocGN5a3NkR2hwY3k1ZmJHRjZlVDFiZEN4bFhTeDJiMmxrSURBN2RHaHBjeTVmZEdsdFpTWW1JWE0vZEdocGN5NXlZWFJwYnoxMGFHbHpMbDlsWVhObExtZGxkRkpoZEdsdktIUm9hWE11WDNScGJXVXZiQ2s2Y3lZbWRHaHBjeTVmWldGelpTNWZZMkZzWTBWdVpDWW1LSFJvYVhNdWNtRjBhVzg5ZEdocGN5NWZaV0Z6WlM1blpYUlNZWFJwYnlnd1BUMDlkR2hwY3k1ZmRHbHRaVDh3T2pFcEtYMW1iM0lvZEdocGN5NWZiR0Y2ZVNFOVBTRXhKaVlvZEdocGN5NWZiR0Y2ZVQwaE1Ta3NkR2hwY3k1ZllXTjBhWFpsZkh3aGRHaHBjeTVmY0dGMWMyVmtKaVowYUdsekxsOTBhVzFsSVQwOWJ5WW1kRDQ5TUNZbUtIUm9hWE11WDJGamRHbDJaVDBoTUNrc01EMDlQVzhtSmloMGFHbHpMbDl6ZEdGeWRFRjBKaVlvZEQ0OU1EOTBhR2x6TGw5emRHRnlkRUYwTG5KbGJtUmxjaWgwTEdVc2FTazZjbng4S0hJOVhDSmZaSFZ0YlhsSFUxd2lLU2tzZEdocGN5NTJZWEp6TG05dVUzUmhjblFtSmlnd0lUMDlkR2hwY3k1ZmRHbHRaWHg4TUQwOVBXd3BKaVlvWlh4OGRHaHBjeTVmWTJGc2JHSmhZMnNvWENKdmJsTjBZWEowWENJcEtTa3NiajEwYUdsekxsOW1hWEp6ZEZCVU8yNDdLVzR1Wmo5dUxuUmJiaTV3WFNodUxtTXFkR2hwY3k1eVlYUnBieXR1TG5NcE9tNHVkRnR1TG5CZFBXNHVZeXAwYUdsekxuSmhkR2x2SzI0dWN5eHVQVzR1WDI1bGVIUTdkR2hwY3k1ZmIyNVZjR1JoZEdVbUppZ3dQblFtSm5Sb2FYTXVYM04wWVhKMFFYUW1KblFoUFQwdE1XVXROQ1ltZEdocGN5NWZjM1JoY25SQmRDNXlaVzVrWlhJb2RDeGxMR2twTEdWOGZDaDBhR2x6TGw5MGFXMWxJVDA5YjN4OGN5a21KblJvYVhNdVgyTmhiR3hpWVdOcktGd2liMjVWY0dSaGRHVmNJaWtwTEhJbUppZ2hkR2hwY3k1ZloyTjhmR2twSmlZb01ENTBKaVowYUdsekxsOXpkR0Z5ZEVGMEppWWhkR2hwY3k1ZmIyNVZjR1JoZEdVbUpuUWhQVDB0TVdVdE5DWW1kR2hwY3k1ZmMzUmhjblJCZEM1eVpXNWtaWElvZEN4bExHa3BMSE1tSmloMGFHbHpMbDkwYVcxbGJHbHVaUzVoZFhSdlVtVnRiM1psUTJocGJHUnlaVzRtSm5Sb2FYTXVYMlZ1WVdKc1pXUW9JVEVzSVRFcExIUm9hWE11WDJGamRHbDJaVDBoTVNrc0lXVW1KblJvYVhNdWRtRnljMXR5WFNZbWRHaHBjeTVmWTJGc2JHSmhZMnNvY2lrc01EMDlQV3dtSm5Sb2FYTXVYM0poZDFCeVpYWlVhVzFsUFQwOVh5WW1ZU0U5UFY4bUppaDBhR2x6TGw5eVlYZFFjbVYyVkdsdFpUMHdLU2w5ZlN4dUxsOXJhV3hzUFdaMWJtTjBhVzl1S0hRc1pTeHBLWHRwWmloY0ltRnNiRndpUFQwOWRDWW1LSFE5Ym5Wc2JDa3NiblZzYkQwOWRDWW1LRzUxYkd3OVBXVjhmR1U5UFQxMGFHbHpMblJoY21kbGRDa3BjbVYwZFhKdUlIUm9hWE11WDJ4aGVuazlJVEVzZEdocGN5NWZaVzVoWW14bFpDZ2hNU3doTVNrN1pUMWNJbk4wY21sdVoxd2lJVDEwZVhCbGIyWWdaVDlsZkh4MGFHbHpMbDkwWVhKblpYUnpmSHgwYUdsekxuUmhjbWRsZERwSkxuTmxiR1ZqZEc5eUtHVXBmSHhsTzNaaGNpQnpMSElzYml4aExHOHNiQ3hvTEY4c2RTeG1QV2ttSm5Sb2FYTXVYM1JwYldVbUpta3VYM04wWVhKMFZHbHRaVDA5UFhSb2FYTXVYM04wWVhKMFZHbHRaU1ltZEdocGN5NWZkR2x0Wld4cGJtVTlQVDFwTGw5MGFXMWxiR2x1WlR0cFppZ29ZeWhsS1h4OFJTaGxLU2ttSmx3aWJuVnRZbVZ5WENJaFBYUjVjR1Z2WmlCbFd6QmRLV1p2Y2loelBXVXViR1Z1WjNSb095MHRjejR0TVRzcGRHaHBjeTVmYTJsc2JDaDBMR1ZiYzEwc2FTa21KaWhzUFNFd0tUdGxiSE5sZTJsbUtIUm9hWE11WDNSaGNtZGxkSE1wZTJadmNpaHpQWFJvYVhNdVgzUmhjbWRsZEhNdWJHVnVaM1JvT3kwdGN6NHRNVHNwYVdZb1pUMDlQWFJvYVhNdVgzUmhjbWRsZEhOYmMxMHBlMjg5ZEdocGN5NWZjSEp2Y0V4dmIydDFjRnR6WFh4OGUzMHNkR2hwY3k1ZmIzWmxjbmR5YVhSMFpXNVFjbTl3Y3oxMGFHbHpMbDl2ZG1WeWQzSnBkSFJsYmxCeWIzQnpmSHhiWFN4eVBYUm9hWE11WDI5MlpYSjNjbWwwZEdWdVVISnZjSE5iYzEwOWREOTBhR2x6TGw5dmRtVnlkM0pwZEhSbGJsQnliM0J6VzNOZGZIeDdmVHBjSW1Gc2JGd2lPMkp5WldGcmZYMWxiSE5sZTJsbUtHVWhQVDEwYUdsekxuUmhjbWRsZENseVpYUjFjbTRoTVR0dlBYUm9hWE11WDNCeWIzQk1iMjlyZFhBc2NqMTBhR2x6TGw5dmRtVnlkM0pwZEhSbGJsQnliM0J6UFhRL2RHaHBjeTVmYjNabGNuZHlhWFIwWlc1UWNtOXdjM3g4ZTMwNlhDSmhiR3hjSW4xcFppaHZLWHRwWmlob1BYUjhmRzhzWHoxMElUMDljaVltWENKaGJHeGNJaUU5UFhJbUpuUWhQVDF2SmlZb1hDSnZZbXBsWTNSY0lpRTlkSGx3Wlc5bUlIUjhmQ0YwTGw5MFpXMXdTMmxzYkNrc2FTWW1LRWt1YjI1UGRtVnlkM0pwZEdWOGZIUm9hWE11ZG1GeWN5NXZiazkyWlhKM2NtbDBaU2twZTJadmNpaHVJR2x1SUdncGIxdHVYU1ltS0hWOGZDaDFQVnRkS1N4MUxuQjFjMmdvYmlrcE8ybG1LQ2gxZkh3aGRDa21KaUZZS0hSb2FYTXNhU3hsTEhVcEtYSmxkSFZ5YmlFeGZXWnZjaWh1SUdsdUlHZ3BLR0U5YjF0dVhTa21KaWhtSmlZb1lTNW1QMkV1ZEZ0aExuQmRLR0V1Y3lrNllTNTBXMkV1Y0YwOVlTNXpMR3c5SVRBcExHRXVjR2NtSm1FdWRDNWZhMmxzYkNob0tTWW1LR3c5SVRBcExHRXVjR2NtSmpBaFBUMWhMblF1WDI5MlpYSjNjbWwwWlZCeWIzQnpMbXhsYm1kMGFIeDhLR0V1WDNCeVpYWS9ZUzVmY0hKbGRpNWZibVY0ZEQxaExsOXVaWGgwT21FOVBUMTBhR2x6TGw5bWFYSnpkRkJVSmlZb2RHaHBjeTVmWm1seWMzUlFWRDFoTGw5dVpYaDBLU3hoTGw5dVpYaDBKaVlvWVM1ZmJtVjRkQzVmY0hKbGRqMWhMbDl3Y21WMktTeGhMbDl1WlhoMFBXRXVYM0J5WlhZOWJuVnNiQ2tzWkdWc1pYUmxJRzliYmwwcExGOG1KaWh5VzI1ZFBURXBPeUYwYUdsekxsOW1hWEp6ZEZCVUppWjBhR2x6TGw5cGJtbDBkR1ZrSmlaMGFHbHpMbDlsYm1GaWJHVmtLQ0V4TENFeEtYMTljbVYwZFhKdUlHeDlMRzR1YVc1MllXeHBaR0YwWlQxbWRXNWpkR2x2YmlncGUzSmxkSFZ5YmlCMGFHbHpMbDl1YjNScFpubFFiSFZuYVc1elQyWkZibUZpYkdWa0ppWkpMbDl2YmxCc2RXZHBia1YyWlc1MEtGd2lYMjl1UkdsellXSnNaVndpTEhSb2FYTXBMSFJvYVhNdVgyWnBjbk4wVUZROWRHaHBjeTVmYjNabGNuZHlhWFIwWlc1UWNtOXdjejEwYUdsekxsOXpkR0Z5ZEVGMFBYUm9hWE11WDI5dVZYQmtZWFJsUFc1MWJHd3NkR2hwY3k1ZmJtOTBhV1o1VUd4MVoybHVjMDltUlc1aFlteGxaRDEwYUdsekxsOWhZM1JwZG1VOWRHaHBjeTVmYkdGNmVUMGhNU3gwYUdsekxsOXdjbTl3VEc5dmEzVndQWFJvYVhNdVgzUmhjbWRsZEhNL2UzMDZXMTBzVWk1d2NtOTBiM1I1Y0dVdWFXNTJZV3hwWkdGMFpTNWpZV3hzS0hSb2FYTXBMSFJvYVhNdWRtRnljeTVwYlcxbFpHbGhkR1ZTWlc1a1pYSW1KaWgwYUdsekxsOTBhVzFsUFMxZkxIUm9hWE11Y21WdVpHVnlLQzEwYUdsekxsOWtaV3hoZVNrcExIUm9hWE45TEc0dVgyVnVZV0pzWldROVpuVnVZM1JwYjI0b2RDeGxLWHRwWmlodmZIeGhMbmRoYTJVb0tTeDBKaVowYUdsekxsOW5ZeWw3ZG1GeUlHa3NjejEwYUdsekxsOTBZWEpuWlhSek8ybG1LSE1wWm05eUtHazljeTVzWlc1bmRHZzdMUzFwUGkweE95bDBhR2x6TGw5emFXSnNhVzVuYzF0cFhUMVhLSE5iYVYwc2RHaHBjeXdoTUNrN1pXeHpaU0IwYUdsekxsOXphV0pzYVc1bmN6MVhLSFJvYVhNdWRHRnlaMlYwTEhSb2FYTXNJVEFwZlhKbGRIVnliaUJTTG5CeWIzUnZkSGx3WlM1ZlpXNWhZbXhsWkM1allXeHNLSFJvYVhNc2RDeGxLU3gwYUdsekxsOXViM1JwWm5sUWJIVm5hVzV6VDJaRmJtRmliR1ZrSmlaMGFHbHpMbDltYVhKemRGQlVQMGt1WDI5dVVHeDFaMmx1UlhabGJuUW9kRDljSWw5dmJrVnVZV0pzWlZ3aU9sd2lYMjl1UkdsellXSnNaVndpTEhSb2FYTXBPaUV4ZlN4SkxuUnZQV1oxYm1OMGFXOXVLSFFzWlN4cEtYdHlaWFIxY200Z2JtVjNJRWtvZEN4bExHa3BmU3hKTG1aeWIyMDlablZ1WTNScGIyNG9kQ3hsTEdrcGUzSmxkSFZ5YmlCcExuSjFia0poWTJ0M1lYSmtjejBoTUN4cExtbHRiV1ZrYVdGMFpWSmxibVJsY2owd0lUMXBMbWx0YldWa2FXRjBaVkpsYm1SbGNpeHVaWGNnU1NoMExHVXNhU2w5TEVrdVpuSnZiVlJ2UFdaMWJtTjBhVzl1S0hRc1pTeHBMSE1wZTNKbGRIVnliaUJ6TG5OMFlYSjBRWFE5YVN4ekxtbHRiV1ZrYVdGMFpWSmxibVJsY2owd0lUMXpMbWx0YldWa2FXRjBaVkpsYm1SbGNpWW1NQ0U5YVM1cGJXMWxaR2xoZEdWU1pXNWtaWElzYm1WM0lFa29kQ3hsTEhNcGZTeEpMbVJsYkdGNVpXUkRZV3hzUFdaMWJtTjBhVzl1S0hRc1pTeHBMSE1zY2lsN2NtVjBkWEp1SUc1bGR5QkpLR1VzTUN4N1pHVnNZWGs2ZEN4dmJrTnZiWEJzWlhSbE9tVXNiMjVEYjIxd2JHVjBaVkJoY21GdGN6cHBMR05oYkd4aVlXTnJVMk52Y0dVNmN5eHZibEpsZG1WeWMyVkRiMjF3YkdWMFpUcGxMRzl1VW1WMlpYSnpaVU52YlhCc1pYUmxVR0Z5WVcxek9ta3NhVzF0WldScFlYUmxVbVZ1WkdWeU9pRXhMR3hoZW5rNklURXNkWE5sUm5KaGJXVnpPbklzYjNabGNuZHlhWFJsT2pCOUtYMHNTUzV6WlhROVpuVnVZM1JwYjI0b2RDeGxLWHR5WlhSMWNtNGdibVYzSUVrb2RDd3dMR1VwZlN4SkxtZGxkRlIzWldWdWMwOW1QV1oxYm1OMGFXOXVLSFFzWlNsN2FXWW9iblZzYkQwOWRDbHlaWFIxY201YlhUdDBQVndpYzNSeWFXNW5YQ0loUFhSNWNHVnZaaUIwUDNRNlNTNXpaV3hsWTNSdmNpaDBLWHg4ZER0MllYSWdhU3h6TEhJc2JqdHBaaWdvWXloMEtYeDhSU2gwS1NrbUpsd2liblZ0WW1WeVhDSWhQWFI1Y0dWdlppQjBXekJkS1h0bWIzSW9hVDEwTG14bGJtZDBhQ3h6UFZ0ZE95MHRhVDR0TVRzcGN6MXpMbU52Ym1OaGRDaEpMbWRsZEZSM1pXVnVjMDltS0hSYmFWMHNaU2twTzJadmNpaHBQWE11YkdWdVozUm9PeTB0YVQ0dE1Uc3BabTl5S0c0OWMxdHBYU3h5UFdrN0xTMXlQaTB4T3lsdVBUMDljMXR5WFNZbWN5NXpjR3hwWTJVb2FTd3hLWDFsYkhObElHWnZjaWh6UFZjb2RDa3VZMjl1WTJGMEtDa3NhVDF6TG14bGJtZDBhRHN0TFdrK0xURTdLU2h6VzJsZExsOW5ZM3g4WlNZbUlYTmJhVjB1YVhOQlkzUnBkbVVvS1NrbUpuTXVjM0JzYVdObEtHa3NNU2s3Y21WMGRYSnVJSE45TEVrdWEybHNiRlIzWldWdWMwOW1QVWt1YTJsc2JFUmxiR0Y1WldSRFlXeHNjMVJ2UFdaMWJtTjBhVzl1S0hRc1pTeHBLWHRjSW05aWFtVmpkRndpUFQxMGVYQmxiMllnWlNZbUtHazlaU3hsUFNFeEtUdG1iM0lvZG1GeUlITTlTUzVuWlhSVWQyVmxibk5QWmloMExHVXBMSEk5Y3k1c1pXNW5kR2c3TFMxeVBpMHhPeWx6VzNKZExsOXJhV3hzS0drc2RDbDlPM1poY2lCMFpUMTJLRndpY0d4MVoybHVjeTVVZDJWbGJsQnNkV2RwYmx3aUxHWjFibU4wYVc5dUtIUXNaU2w3ZEdocGN5NWZiM1psY25keWFYUmxVSEp2Y0hNOUtIUjhmRndpWENJcExuTndiR2wwS0Z3aUxGd2lLU3gwYUdsekxsOXdjbTl3VG1GdFpUMTBhR2x6TGw5dmRtVnlkM0pwZEdWUWNtOXdjMXN3WFN4MGFHbHpMbDl3Y21sdmNtbDBlVDFsZkh3d0xIUm9hWE11WDNOMWNHVnlQWFJsTG5CeWIzUnZkSGx3Wlgwc0lUQXBPMmxtS0c0OWRHVXVjSEp2ZEc5MGVYQmxMSFJsTG5abGNuTnBiMjQ5WENJeExqRTRMakJjSWl4MFpTNUJVRWs5TWl4dUxsOW1hWEp6ZEZCVVBXNTFiR3dzYmk1ZllXUmtWSGRsWlc0OWFpeHVMbk5sZEZKaGRHbHZQVTRzYmk1ZmEybHNiRDFtZFc1amRHbHZiaWgwS1h0MllYSWdaU3hwUFhSb2FYTXVYMjkyWlhKM2NtbDBaVkJ5YjNCekxITTlkR2hwY3k1ZlptbHljM1JRVkR0cFppaHVkV3hzSVQxMFczUm9hWE11WDNCeWIzQk9ZVzFsWFNsMGFHbHpMbDl2ZG1WeWQzSnBkR1ZRY205d2N6MWJYVHRsYkhObElHWnZjaWhsUFdrdWJHVnVaM1JvT3kwdFpUNHRNVHNwYm5Wc2JDRTlkRnRwVzJWZFhTWW1hUzV6Y0d4cFkyVW9aU3d4S1R0bWIzSW9PM003S1c1MWJHd2hQWFJiY3k1dVhTWW1LSE11WDI1bGVIUW1KaWh6TGw5dVpYaDBMbDl3Y21WMlBYTXVYM0J5WlhZcExITXVYM0J5WlhZL0tITXVYM0J5WlhZdVgyNWxlSFE5Y3k1ZmJtVjRkQ3h6TGw5d2NtVjJQVzUxYkd3cE9uUm9hWE11WDJacGNuTjBVRlE5UFQxekppWW9kR2hwY3k1ZlptbHljM1JRVkQxekxsOXVaWGgwS1Nrc2N6MXpMbDl1WlhoME8zSmxkSFZ5YmlFeGZTeHVMbDl5YjNWdVpGQnliM0J6UFdaMWJtTjBhVzl1S0hRc1pTbDdabTl5S0haaGNpQnBQWFJvYVhNdVgyWnBjbk4wVUZRN2FUc3BLSFJiZEdocGN5NWZjSEp2Y0U1aGJXVmRmSHh1ZFd4c0lUMXBMbTRtSm5SYmFTNXVMbk53YkdsMEtIUm9hWE11WDNCeWIzQk9ZVzFsSzF3aVgxd2lLUzVxYjJsdUtGd2lYQ0lwWFNrbUppaHBMbkk5WlNrc2FUMXBMbDl1WlhoMGZTeEpMbDl2YmxCc2RXZHBia1YyWlc1MFBXWjFibU4wYVc5dUtIUXNaU2w3ZG1GeUlHa3NjeXh5TEc0c1lTeHZQV1V1WDJacGNuTjBVRlE3YVdZb1hDSmZiMjVKYm1sMFFXeHNVSEp2Y0hOY0lqMDlQWFFwZTJadmNpZzdienNwZTJadmNpaGhQVzh1WDI1bGVIUXNjejF5TzNNbUpuTXVjSEkrYnk1d2Nqc3BjejF6TGw5dVpYaDBPeWh2TGw5d2NtVjJQWE0vY3k1ZmNISmxkanB1S1Q5dkxsOXdjbVYyTGw5dVpYaDBQVzg2Y2oxdkxDaHZMbDl1WlhoMFBYTXBQM011WDNCeVpYWTlienB1UFc4c2J6MWhmVzg5WlM1ZlptbHljM1JRVkQxeWZXWnZjaWc3YnpzcGJ5NXdaeVltWENKbWRXNWpkR2x2Ymx3aVBUMTBlWEJsYjJZZ2J5NTBXM1JkSmladkxuUmJkRjBvS1NZbUtHazlJVEFwTEc4OWJ5NWZibVY0ZER0eVpYUjFjbTRnYVgwc2RHVXVZV04wYVhaaGRHVTlablZ1WTNScGIyNG9kQ2w3Wm05eUtIWmhjaUJsUFhRdWJHVnVaM1JvT3kwdFpUNHRNVHNwZEZ0bFhTNUJVRWs5UFQxMFpTNUJVRWttSmloUld5aHVaWGNnZEZ0bFhTa3VYM0J5YjNCT1lXMWxYVDEwVzJWZEtUdHlaWFIxY200aE1IMHNaQzV3YkhWbmFXNDlablZ1WTNScGIyNG9kQ2w3YVdZb0lTaDBKaVowTG5CeWIzQk9ZVzFsSmlaMExtbHVhWFFtSm5RdVFWQkpLU2wwYUhKdmQxd2lhV3hzWldkaGJDQndiSFZuYVc0Z1pHVm1hVzVwZEdsdmJpNWNJanQyWVhJZ1pTeHBQWFF1Y0hKdmNFNWhiV1VzY3oxMExuQnlhVzl5YVhSNWZId3dMSEk5ZEM1dmRtVnlkM0pwZEdWUWNtOXdjeXh1UFh0cGJtbDBPbHdpWDI5dVNXNXBkRlIzWldWdVhDSXNjMlYwT2x3aWMyVjBVbUYwYVc5Y0lpeHJhV3hzT2x3aVgydHBiR3hjSWl4eWIzVnVaRHBjSWw5eWIzVnVaRkJ5YjNCelhDSXNhVzVwZEVGc2JEcGNJbDl2YmtsdWFYUkJiR3hRY205d2Mxd2lmU3hoUFhZb1hDSndiSFZuYVc1ekxsd2lLMmt1WTJoaGNrRjBLREFwTG5SdlZYQndaWEpEWVhObEtDa3JhUzV6ZFdKemRISW9NU2tyWENKUWJIVm5hVzVjSWl4bWRXNWpkR2x2YmlncGUzUmxMbU5oYkd3b2RHaHBjeXhwTEhNcExIUm9hWE11WDI5MlpYSjNjbWwwWlZCeWIzQnpQWEo4ZkZ0ZGZTeDBMbWRzYjJKaGJEMDlQU0V3S1N4dlBXRXVjSEp2ZEc5MGVYQmxQVzVsZHlCMFpTaHBLVHR2TG1OdmJuTjBjblZqZEc5eVBXRXNZUzVCVUVrOWRDNUJVRWs3Wm05eUtHVWdhVzRnYmlsY0ltWjFibU4wYVc5dVhDSTlQWFI1Y0dWdlppQjBXMlZkSmlZb2IxdHVXMlZkWFQxMFcyVmRLVHR5WlhSMWNtNGdZUzUyWlhKemFXOXVQWFF1ZG1WeWMybHZiaXgwWlM1aFkzUnBkbUYwWlNoYllWMHBMR0Y5TEhNOWRDNWZaM05SZFdWMVpTbDdabTl5S0hJOU1EdHpMbXhsYm1kMGFENXlPM0lyS3lselczSmRLQ2s3Wm05eUtHNGdhVzRnYlNsdFcyNWRMbVoxYm1OOGZIUXVZMjl1YzI5c1pTNXNiMmNvWENKSFUwRlFJR1Z1WTI5MWJuUmxjbVZrSUcxcGMzTnBibWNnWkdWd1pXNWtaVzVqZVRvZ1kyOXRMbWR5WldWdWMyOWpheTVjSWl0dUtYMXZQU0V4ZlgwcEtGd2lkVzVrWldacGJtVmtYQ0loUFhSNWNHVnZaaUJ0YjJSMWJHVW1KbTF2WkhWc1pTNWxlSEJ2Y25SekppWmNJblZ1WkdWbWFXNWxaRndpSVQxMGVYQmxiMllnWjJ4dlltRnNQMmRzYjJKaGJEcDBhR2x6Zkh4M2FXNWtiM2NzWENKVWQyVmxia3hwZEdWY0lpazdJbDE5IiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyohXG4gKiBWRVJTSU9OOiAxLjE4LjBcbiAqIERBVEU6IDIwMTUtMDktMDVcbiAqIFVQREFURVMgQU5EIERPQ1MgQVQ6IGh0dHA6Ly9ncmVlbnNvY2suY29tXG4gKiBcbiAqIEluY2x1ZGVzIGFsbCBvZiB0aGUgZm9sbG93aW5nOiBUd2VlbkxpdGUsIFR3ZWVuTWF4LCBUaW1lbGluZUxpdGUsIFRpbWVsaW5lTWF4LCBFYXNlUGFjaywgQ1NTUGx1Z2luLCBSb3VuZFByb3BzUGx1Z2luLCBCZXppZXJQbHVnaW4sIEF0dHJQbHVnaW4sIERpcmVjdGlvbmFsUm90YXRpb25QbHVnaW5cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDgtMjAxNSwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyB3b3JrIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHA6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgc29mdHdhcmUgYWdyZWVtZW50IHRoYXQgd2FzIGlzc3VlZCB3aXRoIHlvdXIgbWVtYmVyc2hpcC5cbiAqIFxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4gKiovXG52YXIgX2dzU2NvcGU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOnRoaXN8fHdpbmRvdzsoX2dzU2NvcGUuX2dzUXVldWV8fChfZ3NTY29wZS5fZ3NRdWV1ZT1bXSkpLnB1c2goZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtfZ3NTY29wZS5fZ3NEZWZpbmUoXCJUd2Vlbk1heFwiLFtcImNvcmUuQW5pbWF0aW9uXCIsXCJjb3JlLlNpbXBsZVRpbWVsaW5lXCIsXCJUd2VlbkxpdGVcIl0sZnVuY3Rpb24odCxlLGkpe3ZhciBzPWZ1bmN0aW9uKHQpe3ZhciBlLGk9W10scz10Lmxlbmd0aDtmb3IoZT0wO2UhPT1zO2kucHVzaCh0W2UrK10pKTtyZXR1cm4gaX0scj1mdW5jdGlvbih0LGUsaSl7dmFyIHMscixuPXQuY3ljbGU7Zm9yKHMgaW4gbilyPW5bc10sdFtzXT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByP3IuY2FsbChlW2ldLGkpOnJbaSVyLmxlbmd0aF07ZGVsZXRlIHQuY3ljbGV9LG49ZnVuY3Rpb24odCxlLHMpe2kuY2FsbCh0aGlzLHQsZSxzKSx0aGlzLl9jeWNsZT0wLHRoaXMuX3lveW89dGhpcy52YXJzLnlveW89PT0hMCx0aGlzLl9yZXBlYXQ9dGhpcy52YXJzLnJlcGVhdHx8MCx0aGlzLl9yZXBlYXREZWxheT10aGlzLnZhcnMucmVwZWF0RGVsYXl8fDAsdGhpcy5fZGlydHk9ITAsdGhpcy5yZW5kZXI9bi5wcm90b3R5cGUucmVuZGVyfSxhPTFlLTEwLG89aS5faW50ZXJuYWxzLGw9by5pc1NlbGVjdG9yLGg9by5pc0FycmF5LF89bi5wcm90b3R5cGU9aS50byh7fSwuMSx7fSksdT1bXTtuLnZlcnNpb249XCIxLjE4LjBcIixfLmNvbnN0cnVjdG9yPW4sXy5raWxsKCkuX2djPSExLG4ua2lsbFR3ZWVuc09mPW4ua2lsbERlbGF5ZWRDYWxsc1RvPWkua2lsbFR3ZWVuc09mLG4uZ2V0VHdlZW5zT2Y9aS5nZXRUd2VlbnNPZixuLmxhZ1Ntb290aGluZz1pLmxhZ1Ntb290aGluZyxuLnRpY2tlcj1pLnRpY2tlcixuLnJlbmRlcj1pLnJlbmRlcixfLmludmFsaWRhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5feW95bz10aGlzLnZhcnMueW95bz09PSEwLHRoaXMuX3JlcGVhdD10aGlzLnZhcnMucmVwZWF0fHwwLHRoaXMuX3JlcGVhdERlbGF5PXRoaXMudmFycy5yZXBlYXREZWxheXx8MCx0aGlzLl91bmNhY2hlKCEwKSxpLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyl9LF8udXBkYXRlVG89ZnVuY3Rpb24odCxlKXt2YXIgcyxyPXRoaXMucmF0aW8sbj10aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyfHx0LmltbWVkaWF0ZVJlbmRlcjtlJiZ0aGlzLl9zdGFydFRpbWU8dGhpcy5fdGltZWxpbmUuX3RpbWUmJih0aGlzLl9zdGFydFRpbWU9dGhpcy5fdGltZWxpbmUuX3RpbWUsdGhpcy5fdW5jYWNoZSghMSksdGhpcy5fZ2M/dGhpcy5fZW5hYmxlZCghMCwhMSk6dGhpcy5fdGltZWxpbmUuaW5zZXJ0KHRoaXMsdGhpcy5fc3RhcnRUaW1lLXRoaXMuX2RlbGF5KSk7Zm9yKHMgaW4gdCl0aGlzLnZhcnNbc109dFtzXTtpZih0aGlzLl9pbml0dGVkfHxuKWlmKGUpdGhpcy5faW5pdHRlZD0hMSxuJiZ0aGlzLnJlbmRlcigwLCEwLCEwKTtlbHNlIGlmKHRoaXMuX2djJiZ0aGlzLl9lbmFibGVkKCEwLCExKSx0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkJiZ0aGlzLl9maXJzdFBUJiZpLl9vblBsdWdpbkV2ZW50KFwiX29uRGlzYWJsZVwiLHRoaXMpLHRoaXMuX3RpbWUvdGhpcy5fZHVyYXRpb24+Ljk5OCl7dmFyIGE9dGhpcy5fdGltZTt0aGlzLnJlbmRlcigwLCEwLCExKSx0aGlzLl9pbml0dGVkPSExLHRoaXMucmVuZGVyKGEsITAsITEpfWVsc2UgaWYodGhpcy5fdGltZT4wfHxuKXt0aGlzLl9pbml0dGVkPSExLHRoaXMuX2luaXQoKTtmb3IodmFyIG8sbD0xLygxLXIpLGg9dGhpcy5fZmlyc3RQVDtoOylvPWgucytoLmMsaC5jKj1sLGgucz1vLWguYyxoPWguX25leHR9cmV0dXJuIHRoaXN9LF8ucmVuZGVyPWZ1bmN0aW9uKHQsZSxpKXt0aGlzLl9pbml0dGVkfHwwPT09dGhpcy5fZHVyYXRpb24mJnRoaXMudmFycy5yZXBlYXQmJnRoaXMuaW52YWxpZGF0ZSgpO3ZhciBzLHIsbixsLGgsXyx1LGMsZj10aGlzLl9kaXJ0eT90aGlzLnRvdGFsRHVyYXRpb24oKTp0aGlzLl90b3RhbER1cmF0aW9uLHA9dGhpcy5fdGltZSxtPXRoaXMuX3RvdGFsVGltZSxkPXRoaXMuX2N5Y2xlLGc9dGhpcy5fZHVyYXRpb24sdj10aGlzLl9yYXdQcmV2VGltZTtpZih0Pj1mPyh0aGlzLl90b3RhbFRpbWU9Zix0aGlzLl9jeWNsZT10aGlzLl9yZXBlYXQsdGhpcy5feW95byYmMCE9PSgxJnRoaXMuX2N5Y2xlKT8odGhpcy5fdGltZT0wLHRoaXMucmF0aW89dGhpcy5fZWFzZS5fY2FsY0VuZD90aGlzLl9lYXNlLmdldFJhdGlvKDApOjApOih0aGlzLl90aW1lPWcsdGhpcy5yYXRpbz10aGlzLl9lYXNlLl9jYWxjRW5kP3RoaXMuX2Vhc2UuZ2V0UmF0aW8oMSk6MSksdGhpcy5fcmV2ZXJzZWR8fChzPSEwLHI9XCJvbkNvbXBsZXRlXCIsaT1pfHx0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pLDA9PT1nJiYodGhpcy5faW5pdHRlZHx8IXRoaXMudmFycy5sYXp5fHxpKSYmKHRoaXMuX3N0YXJ0VGltZT09PXRoaXMuX3RpbWVsaW5lLl9kdXJhdGlvbiYmKHQ9MCksKDA9PT10fHwwPnZ8fHY9PT1hKSYmdiE9PXQmJihpPSEwLHY+YSYmKHI9XCJvblJldmVyc2VDb21wbGV0ZVwiKSksdGhpcy5fcmF3UHJldlRpbWU9Yz0hZXx8dHx8dj09PXQ/dDphKSk6MWUtNz50Pyh0aGlzLl90b3RhbFRpbWU9dGhpcy5fdGltZT10aGlzLl9jeWNsZT0wLHRoaXMucmF0aW89dGhpcy5fZWFzZS5fY2FsY0VuZD90aGlzLl9lYXNlLmdldFJhdGlvKDApOjAsKDAhPT1tfHwwPT09ZyYmdj4wKSYmKHI9XCJvblJldmVyc2VDb21wbGV0ZVwiLHM9dGhpcy5fcmV2ZXJzZWQpLDA+dCYmKHRoaXMuX2FjdGl2ZT0hMSwwPT09ZyYmKHRoaXMuX2luaXR0ZWR8fCF0aGlzLnZhcnMubGF6eXx8aSkmJih2Pj0wJiYoaT0hMCksdGhpcy5fcmF3UHJldlRpbWU9Yz0hZXx8dHx8dj09PXQ/dDphKSksdGhpcy5faW5pdHRlZHx8KGk9ITApKToodGhpcy5fdG90YWxUaW1lPXRoaXMuX3RpbWU9dCwwIT09dGhpcy5fcmVwZWF0JiYobD1nK3RoaXMuX3JlcGVhdERlbGF5LHRoaXMuX2N5Y2xlPXRoaXMuX3RvdGFsVGltZS9sPj4wLDAhPT10aGlzLl9jeWNsZSYmdGhpcy5fY3ljbGU9PT10aGlzLl90b3RhbFRpbWUvbCYmdGhpcy5fY3ljbGUtLSx0aGlzLl90aW1lPXRoaXMuX3RvdGFsVGltZS10aGlzLl9jeWNsZSpsLHRoaXMuX3lveW8mJjAhPT0oMSZ0aGlzLl9jeWNsZSkmJih0aGlzLl90aW1lPWctdGhpcy5fdGltZSksdGhpcy5fdGltZT5nP3RoaXMuX3RpbWU9ZzowPnRoaXMuX3RpbWUmJih0aGlzLl90aW1lPTApKSx0aGlzLl9lYXNlVHlwZT8oaD10aGlzLl90aW1lL2csXz10aGlzLl9lYXNlVHlwZSx1PXRoaXMuX2Vhc2VQb3dlciwoMT09PV98fDM9PT1fJiZoPj0uNSkmJihoPTEtaCksMz09PV8mJihoKj0yKSwxPT09dT9oKj1oOjI9PT11P2gqPWgqaDozPT09dT9oKj1oKmgqaDo0PT09dSYmKGgqPWgqaCpoKmgpLHRoaXMucmF0aW89MT09PV8/MS1oOjI9PT1fP2g6LjU+dGhpcy5fdGltZS9nP2gvMjoxLWgvMik6dGhpcy5yYXRpbz10aGlzLl9lYXNlLmdldFJhdGlvKHRoaXMuX3RpbWUvZykpLHA9PT10aGlzLl90aW1lJiYhaSYmZD09PXRoaXMuX2N5Y2xlKXJldHVybiBtIT09dGhpcy5fdG90YWxUaW1lJiZ0aGlzLl9vblVwZGF0ZSYmKGV8fHRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIikpLHZvaWQgMDtpZighdGhpcy5faW5pdHRlZCl7aWYodGhpcy5faW5pdCgpLCF0aGlzLl9pbml0dGVkfHx0aGlzLl9nYylyZXR1cm47aWYoIWkmJnRoaXMuX2ZpcnN0UFQmJih0aGlzLnZhcnMubGF6eSE9PSExJiZ0aGlzLl9kdXJhdGlvbnx8dGhpcy52YXJzLmxhenkmJiF0aGlzLl9kdXJhdGlvbikpcmV0dXJuIHRoaXMuX3RpbWU9cCx0aGlzLl90b3RhbFRpbWU9bSx0aGlzLl9yYXdQcmV2VGltZT12LHRoaXMuX2N5Y2xlPWQsby5sYXp5VHdlZW5zLnB1c2godGhpcyksdGhpcy5fbGF6eT1bdCxlXSx2b2lkIDA7dGhpcy5fdGltZSYmIXM/dGhpcy5yYXRpbz10aGlzLl9lYXNlLmdldFJhdGlvKHRoaXMuX3RpbWUvZyk6cyYmdGhpcy5fZWFzZS5fY2FsY0VuZCYmKHRoaXMucmF0aW89dGhpcy5fZWFzZS5nZXRSYXRpbygwPT09dGhpcy5fdGltZT8wOjEpKX1mb3IodGhpcy5fbGF6eSE9PSExJiYodGhpcy5fbGF6eT0hMSksdGhpcy5fYWN0aXZlfHwhdGhpcy5fcGF1c2VkJiZ0aGlzLl90aW1lIT09cCYmdD49MCYmKHRoaXMuX2FjdGl2ZT0hMCksMD09PW0mJigyPT09dGhpcy5faW5pdHRlZCYmdD4wJiZ0aGlzLl9pbml0KCksdGhpcy5fc3RhcnRBdCYmKHQ+PTA/dGhpcy5fc3RhcnRBdC5yZW5kZXIodCxlLGkpOnJ8fChyPVwiX2R1bW15R1NcIikpLHRoaXMudmFycy5vblN0YXJ0JiYoMCE9PXRoaXMuX3RvdGFsVGltZXx8MD09PWcpJiYoZXx8dGhpcy5fY2FsbGJhY2soXCJvblN0YXJ0XCIpKSksbj10aGlzLl9maXJzdFBUO247KW4uZj9uLnRbbi5wXShuLmMqdGhpcy5yYXRpbytuLnMpOm4udFtuLnBdPW4uYyp0aGlzLnJhdGlvK24ucyxuPW4uX25leHQ7dGhpcy5fb25VcGRhdGUmJigwPnQmJnRoaXMuX3N0YXJ0QXQmJnRoaXMuX3N0YXJ0VGltZSYmdGhpcy5fc3RhcnRBdC5yZW5kZXIodCxlLGkpLGV8fCh0aGlzLl90b3RhbFRpbWUhPT1tfHxzKSYmdGhpcy5fY2FsbGJhY2soXCJvblVwZGF0ZVwiKSksdGhpcy5fY3ljbGUhPT1kJiYoZXx8dGhpcy5fZ2N8fHRoaXMudmFycy5vblJlcGVhdCYmdGhpcy5fY2FsbGJhY2soXCJvblJlcGVhdFwiKSksciYmKCF0aGlzLl9nY3x8aSkmJigwPnQmJnRoaXMuX3N0YXJ0QXQmJiF0aGlzLl9vblVwZGF0ZSYmdGhpcy5fc3RhcnRUaW1lJiZ0aGlzLl9zdGFydEF0LnJlbmRlcih0LGUsaSkscyYmKHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbiYmdGhpcy5fZW5hYmxlZCghMSwhMSksdGhpcy5fYWN0aXZlPSExKSwhZSYmdGhpcy52YXJzW3JdJiZ0aGlzLl9jYWxsYmFjayhyKSwwPT09ZyYmdGhpcy5fcmF3UHJldlRpbWU9PT1hJiZjIT09YSYmKHRoaXMuX3Jhd1ByZXZUaW1lPTApKX0sbi50bz1mdW5jdGlvbih0LGUsaSl7cmV0dXJuIG5ldyBuKHQsZSxpKX0sbi5mcm9tPWZ1bmN0aW9uKHQsZSxpKXtyZXR1cm4gaS5ydW5CYWNrd2FyZHM9ITAsaS5pbW1lZGlhdGVSZW5kZXI9MCE9aS5pbW1lZGlhdGVSZW5kZXIsbmV3IG4odCxlLGkpfSxuLmZyb21Ubz1mdW5jdGlvbih0LGUsaSxzKXtyZXR1cm4gcy5zdGFydEF0PWkscy5pbW1lZGlhdGVSZW5kZXI9MCE9cy5pbW1lZGlhdGVSZW5kZXImJjAhPWkuaW1tZWRpYXRlUmVuZGVyLG5ldyBuKHQsZSxzKX0sbi5zdGFnZ2VyVG89bi5hbGxUbz1mdW5jdGlvbih0LGUsYSxvLF8sYyxmKXtvPW98fDA7dmFyIHAsbSxkLGcsdj1hLmRlbGF5fHwwLHk9W10sVD1mdW5jdGlvbigpe2Eub25Db21wbGV0ZSYmYS5vbkNvbXBsZXRlLmFwcGx5KGEub25Db21wbGV0ZVNjb3BlfHx0aGlzLGFyZ3VtZW50cyksXy5hcHBseShmfHxhLmNhbGxiYWNrU2NvcGV8fHRoaXMsY3x8dSl9LHg9YS5jeWNsZSx3PWEuc3RhcnRBdCYmYS5zdGFydEF0LmN5Y2xlO2ZvcihoKHQpfHwoXCJzdHJpbmdcIj09dHlwZW9mIHQmJih0PWkuc2VsZWN0b3IodCl8fHQpLGwodCkmJih0PXModCkpKSx0PXR8fFtdLDA+byYmKHQ9cyh0KSx0LnJldmVyc2UoKSxvKj0tMSkscD10Lmxlbmd0aC0xLGQ9MDtwPj1kO2QrKyl7bT17fTtmb3IoZyBpbiBhKW1bZ109YVtnXTtpZih4JiZyKG0sdCxkKSx3KXt3PW0uc3RhcnRBdD17fTtmb3IoZyBpbiBhLnN0YXJ0QXQpd1tnXT1hLnN0YXJ0QXRbZ107cihtLnN0YXJ0QXQsdCxkKX1tLmRlbGF5PXYsZD09PXAmJl8mJihtLm9uQ29tcGxldGU9VCkseVtkXT1uZXcgbih0W2RdLGUsbSksdis9b31yZXR1cm4geX0sbi5zdGFnZ2VyRnJvbT1uLmFsbEZyb209ZnVuY3Rpb24odCxlLGkscyxyLGEsbyl7cmV0dXJuIGkucnVuQmFja3dhcmRzPSEwLGkuaW1tZWRpYXRlUmVuZGVyPTAhPWkuaW1tZWRpYXRlUmVuZGVyLG4uc3RhZ2dlclRvKHQsZSxpLHMscixhLG8pfSxuLnN0YWdnZXJGcm9tVG89bi5hbGxGcm9tVG89ZnVuY3Rpb24odCxlLGkscyxyLGEsbyxsKXtyZXR1cm4gcy5zdGFydEF0PWkscy5pbW1lZGlhdGVSZW5kZXI9MCE9cy5pbW1lZGlhdGVSZW5kZXImJjAhPWkuaW1tZWRpYXRlUmVuZGVyLG4uc3RhZ2dlclRvKHQsZSxzLHIsYSxvLGwpfSxuLmRlbGF5ZWRDYWxsPWZ1bmN0aW9uKHQsZSxpLHMscil7cmV0dXJuIG5ldyBuKGUsMCx7ZGVsYXk6dCxvbkNvbXBsZXRlOmUsb25Db21wbGV0ZVBhcmFtczppLGNhbGxiYWNrU2NvcGU6cyxvblJldmVyc2VDb21wbGV0ZTplLG9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zOmksaW1tZWRpYXRlUmVuZGVyOiExLHVzZUZyYW1lczpyLG92ZXJ3cml0ZTowfSl9LG4uc2V0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyBuKHQsMCxlKX0sbi5pc1R3ZWVuaW5nPWZ1bmN0aW9uKHQpe3JldHVybiBpLmdldFR3ZWVuc09mKHQsITApLmxlbmd0aD4wfTt2YXIgYz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgcz1bXSxyPTAsbj10Ll9maXJzdDtuOyluIGluc3RhbmNlb2YgaT9zW3IrK109bjooZSYmKHNbcisrXT1uKSxzPXMuY29uY2F0KGMobixlKSkscj1zLmxlbmd0aCksbj1uLl9uZXh0O3JldHVybiBzfSxmPW4uZ2V0QWxsVHdlZW5zPWZ1bmN0aW9uKGUpe3JldHVybiBjKHQuX3Jvb3RUaW1lbGluZSxlKS5jb25jYXQoYyh0Ll9yb290RnJhbWVzVGltZWxpbmUsZSkpfTtuLmtpbGxBbGw9ZnVuY3Rpb24odCxpLHMscil7bnVsbD09aSYmKGk9ITApLG51bGw9PXMmJihzPSEwKTt2YXIgbixhLG8sbD1mKDAhPXIpLGg9bC5sZW5ndGgsXz1pJiZzJiZyO2ZvcihvPTA7aD5vO28rKylhPWxbb10sKF98fGEgaW5zdGFuY2VvZiBlfHwobj1hLnRhcmdldD09PWEudmFycy5vbkNvbXBsZXRlKSYmc3x8aSYmIW4pJiYodD9hLnRvdGFsVGltZShhLl9yZXZlcnNlZD8wOmEudG90YWxEdXJhdGlvbigpKTphLl9lbmFibGVkKCExLCExKSl9LG4ua2lsbENoaWxkVHdlZW5zT2Y9ZnVuY3Rpb24odCxlKXtpZihudWxsIT10KXt2YXIgcixhLF8sdSxjLGY9by50d2Vlbkxvb2t1cDtpZihcInN0cmluZ1wiPT10eXBlb2YgdCYmKHQ9aS5zZWxlY3Rvcih0KXx8dCksbCh0KSYmKHQ9cyh0KSksaCh0KSlmb3IodT10Lmxlbmd0aDstLXU+LTE7KW4ua2lsbENoaWxkVHdlZW5zT2YodFt1XSxlKTtlbHNle3I9W107Zm9yKF8gaW4gZilmb3IoYT1mW19dLnRhcmdldC5wYXJlbnROb2RlO2E7KWE9PT10JiYocj1yLmNvbmNhdChmW19dLnR3ZWVucykpLGE9YS5wYXJlbnROb2RlO2ZvcihjPXIubGVuZ3RoLHU9MDtjPnU7dSsrKWUmJnJbdV0udG90YWxUaW1lKHJbdV0udG90YWxEdXJhdGlvbigpKSxyW3VdLl9lbmFibGVkKCExLCExKX19fTt2YXIgcD1mdW5jdGlvbih0LGkscyxyKXtpPWkhPT0hMSxzPXMhPT0hMSxyPXIhPT0hMTtmb3IodmFyIG4sYSxvPWYociksbD1pJiZzJiZyLGg9by5sZW5ndGg7LS1oPi0xOylhPW9baF0sKGx8fGEgaW5zdGFuY2VvZiBlfHwobj1hLnRhcmdldD09PWEudmFycy5vbkNvbXBsZXRlKSYmc3x8aSYmIW4pJiZhLnBhdXNlZCh0KX07cmV0dXJuIG4ucGF1c2VBbGw9ZnVuY3Rpb24odCxlLGkpe3AoITAsdCxlLGkpfSxuLnJlc3VtZUFsbD1mdW5jdGlvbih0LGUsaSl7cCghMSx0LGUsaSl9LG4uZ2xvYmFsVGltZVNjYWxlPWZ1bmN0aW9uKGUpe3ZhciBzPXQuX3Jvb3RUaW1lbGluZSxyPWkudGlja2VyLnRpbWU7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGU9ZXx8YSxzLl9zdGFydFRpbWU9ci0oci1zLl9zdGFydFRpbWUpKnMuX3RpbWVTY2FsZS9lLHM9dC5fcm9vdEZyYW1lc1RpbWVsaW5lLHI9aS50aWNrZXIuZnJhbWUscy5fc3RhcnRUaW1lPXItKHItcy5fc3RhcnRUaW1lKSpzLl90aW1lU2NhbGUvZSxzLl90aW1lU2NhbGU9dC5fcm9vdFRpbWVsaW5lLl90aW1lU2NhbGU9ZSxlKTpzLl90aW1lU2NhbGV9LF8ucHJvZ3Jlc3M9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/dGhpcy50b3RhbFRpbWUodGhpcy5kdXJhdGlvbigpKih0aGlzLl95b3lvJiYwIT09KDEmdGhpcy5fY3ljbGUpPzEtdDp0KSt0aGlzLl9jeWNsZSoodGhpcy5fZHVyYXRpb24rdGhpcy5fcmVwZWF0RGVsYXkpLCExKTp0aGlzLl90aW1lL3RoaXMuZHVyYXRpb24oKX0sXy50b3RhbFByb2dyZXNzPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoP3RoaXMudG90YWxUaW1lKHRoaXMudG90YWxEdXJhdGlvbigpKnQsITEpOnRoaXMuX3RvdGFsVGltZS90aGlzLnRvdGFsRHVyYXRpb24oKX0sXy50aW1lPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHRoaXMuX2RpcnR5JiZ0aGlzLnRvdGFsRHVyYXRpb24oKSx0PnRoaXMuX2R1cmF0aW9uJiYodD10aGlzLl9kdXJhdGlvbiksdGhpcy5feW95byYmMCE9PSgxJnRoaXMuX2N5Y2xlKT90PXRoaXMuX2R1cmF0aW9uLXQrdGhpcy5fY3ljbGUqKHRoaXMuX2R1cmF0aW9uK3RoaXMuX3JlcGVhdERlbGF5KTowIT09dGhpcy5fcmVwZWF0JiYodCs9dGhpcy5fY3ljbGUqKHRoaXMuX2R1cmF0aW9uK3RoaXMuX3JlcGVhdERlbGF5KSksdGhpcy50b3RhbFRpbWUodCxlKSk6dGhpcy5fdGltZX0sXy5kdXJhdGlvbj1mdW5jdGlvbihlKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD90LnByb3RvdHlwZS5kdXJhdGlvbi5jYWxsKHRoaXMsZSk6dGhpcy5fZHVyYXRpb259LF8udG90YWxEdXJhdGlvbj1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8tMT09PXRoaXMuX3JlcGVhdD90aGlzOnRoaXMuZHVyYXRpb24oKHQtdGhpcy5fcmVwZWF0KnRoaXMuX3JlcGVhdERlbGF5KS8odGhpcy5fcmVwZWF0KzEpKToodGhpcy5fZGlydHkmJih0aGlzLl90b3RhbER1cmF0aW9uPS0xPT09dGhpcy5fcmVwZWF0Pzk5OTk5OTk5OTk5OTp0aGlzLl9kdXJhdGlvbioodGhpcy5fcmVwZWF0KzEpK3RoaXMuX3JlcGVhdERlbGF5KnRoaXMuX3JlcGVhdCx0aGlzLl9kaXJ0eT0hMSksdGhpcy5fdG90YWxEdXJhdGlvbil9LF8ucmVwZWF0PWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh0aGlzLl9yZXBlYXQ9dCx0aGlzLl91bmNhY2hlKCEwKSk6dGhpcy5fcmVwZWF0fSxfLnJlcGVhdERlbGF5PWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh0aGlzLl9yZXBlYXREZWxheT10LHRoaXMuX3VuY2FjaGUoITApKTp0aGlzLl9yZXBlYXREZWxheX0sXy55b3lvPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh0aGlzLl95b3lvPXQsdGhpcyk6dGhpcy5feW95b30sbn0sITApLF9nc1Njb3BlLl9nc0RlZmluZShcIlRpbWVsaW5lTGl0ZVwiLFtcImNvcmUuQW5pbWF0aW9uXCIsXCJjb3JlLlNpbXBsZVRpbWVsaW5lXCIsXCJUd2VlbkxpdGVcIl0sZnVuY3Rpb24odCxlLGkpe3ZhciBzPWZ1bmN0aW9uKHQpe2UuY2FsbCh0aGlzLHQpLHRoaXMuX2xhYmVscz17fSx0aGlzLmF1dG9SZW1vdmVDaGlsZHJlbj10aGlzLnZhcnMuYXV0b1JlbW92ZUNoaWxkcmVuPT09ITAsdGhpcy5zbW9vdGhDaGlsZFRpbWluZz10aGlzLnZhcnMuc21vb3RoQ2hpbGRUaW1pbmc9PT0hMCx0aGlzLl9zb3J0Q2hpbGRyZW49ITAsdGhpcy5fb25VcGRhdGU9dGhpcy52YXJzLm9uVXBkYXRlO3ZhciBpLHMscj10aGlzLnZhcnM7Zm9yKHMgaW4gcilpPXJbc10sbChpKSYmLTEhPT1pLmpvaW4oXCJcIikuaW5kZXhPZihcIntzZWxmfVwiKSYmKHJbc109dGhpcy5fc3dhcFNlbGZJblBhcmFtcyhpKSk7bChyLnR3ZWVucykmJnRoaXMuYWRkKHIudHdlZW5zLDAsci5hbGlnbixyLnN0YWdnZXIpfSxyPTFlLTEwLG49aS5faW50ZXJuYWxzLGE9cy5faW50ZXJuYWxzPXt9LG89bi5pc1NlbGVjdG9yLGw9bi5pc0FycmF5LGg9bi5sYXp5VHdlZW5zLF89bi5sYXp5UmVuZGVyLHU9X2dzU2NvcGUuX2dzRGVmaW5lLmdsb2JhbHMsYz1mdW5jdGlvbih0KXt2YXIgZSxpPXt9O2ZvcihlIGluIHQpaVtlXT10W2VdO3JldHVybiBpfSxmPWZ1bmN0aW9uKHQsZSxpKXt2YXIgcyxyLG49dC5jeWNsZTtmb3IocyBpbiBuKXI9bltzXSx0W3NdPVwiZnVuY3Rpb25cIj09dHlwZW9mIHI/ci5jYWxsKGVbaV0saSk6cltpJXIubGVuZ3RoXTtkZWxldGUgdC5jeWNsZX0scD1hLnBhdXNlQ2FsbGJhY2s9ZnVuY3Rpb24oKXt9LG09ZnVuY3Rpb24odCl7dmFyIGUsaT1bXSxzPXQubGVuZ3RoO2ZvcihlPTA7ZSE9PXM7aS5wdXNoKHRbZSsrXSkpO3JldHVybiBpfSxkPXMucHJvdG90eXBlPW5ldyBlO3JldHVybiBzLnZlcnNpb249XCIxLjE4LjBcIixkLmNvbnN0cnVjdG9yPXMsZC5raWxsKCkuX2djPWQuX2ZvcmNpbmdQbGF5aGVhZD1kLl9oYXNQYXVzZT0hMSxkLnRvPWZ1bmN0aW9uKHQsZSxzLHIpe3ZhciBuPXMucmVwZWF0JiZ1LlR3ZWVuTWF4fHxpO3JldHVybiBlP3RoaXMuYWRkKG5ldyBuKHQsZSxzKSxyKTp0aGlzLnNldCh0LHMscil9LGQuZnJvbT1mdW5jdGlvbih0LGUscyxyKXtyZXR1cm4gdGhpcy5hZGQoKHMucmVwZWF0JiZ1LlR3ZWVuTWF4fHxpKS5mcm9tKHQsZSxzKSxyKX0sZC5mcm9tVG89ZnVuY3Rpb24odCxlLHMscixuKXt2YXIgYT1yLnJlcGVhdCYmdS5Ud2Vlbk1heHx8aTtyZXR1cm4gZT90aGlzLmFkZChhLmZyb21Ubyh0LGUscyxyKSxuKTp0aGlzLnNldCh0LHIsbil9LGQuc3RhZ2dlclRvPWZ1bmN0aW9uKHQsZSxyLG4sYSxsLGgsXyl7dmFyIHUscCxkPW5ldyBzKHtvbkNvbXBsZXRlOmwsb25Db21wbGV0ZVBhcmFtczpoLGNhbGxiYWNrU2NvcGU6XyxzbW9vdGhDaGlsZFRpbWluZzp0aGlzLnNtb290aENoaWxkVGltaW5nfSksZz1yLmN5Y2xlO2ZvcihcInN0cmluZ1wiPT10eXBlb2YgdCYmKHQ9aS5zZWxlY3Rvcih0KXx8dCksdD10fHxbXSxvKHQpJiYodD1tKHQpKSxuPW58fDAsMD5uJiYodD1tKHQpLHQucmV2ZXJzZSgpLG4qPS0xKSxwPTA7dC5sZW5ndGg+cDtwKyspdT1jKHIpLHUuc3RhcnRBdCYmKHUuc3RhcnRBdD1jKHUuc3RhcnRBdCksdS5zdGFydEF0LmN5Y2xlJiZmKHUuc3RhcnRBdCx0LHApKSxnJiZmKHUsdCxwKSxkLnRvKHRbcF0sZSx1LHAqbik7cmV0dXJuIHRoaXMuYWRkKGQsYSl9LGQuc3RhZ2dlckZyb209ZnVuY3Rpb24odCxlLGkscyxyLG4sYSxvKXtyZXR1cm4gaS5pbW1lZGlhdGVSZW5kZXI9MCE9aS5pbW1lZGlhdGVSZW5kZXIsaS5ydW5CYWNrd2FyZHM9ITAsdGhpcy5zdGFnZ2VyVG8odCxlLGkscyxyLG4sYSxvKX0sZC5zdGFnZ2VyRnJvbVRvPWZ1bmN0aW9uKHQsZSxpLHMscixuLGEsbyxsKXtyZXR1cm4gcy5zdGFydEF0PWkscy5pbW1lZGlhdGVSZW5kZXI9MCE9cy5pbW1lZGlhdGVSZW5kZXImJjAhPWkuaW1tZWRpYXRlUmVuZGVyLHRoaXMuc3RhZ2dlclRvKHQsZSxzLHIsbixhLG8sbCl9LGQuY2FsbD1mdW5jdGlvbih0LGUscyxyKXtyZXR1cm4gdGhpcy5hZGQoaS5kZWxheWVkQ2FsbCgwLHQsZSxzKSxyKX0sZC5zZXQ9ZnVuY3Rpb24odCxlLHMpe3JldHVybiBzPXRoaXMuX3BhcnNlVGltZU9yTGFiZWwocywwLCEwKSxudWxsPT1lLmltbWVkaWF0ZVJlbmRlciYmKGUuaW1tZWRpYXRlUmVuZGVyPXM9PT10aGlzLl90aW1lJiYhdGhpcy5fcGF1c2VkKSx0aGlzLmFkZChuZXcgaSh0LDAsZSkscyl9LHMuZXhwb3J0Um9vdD1mdW5jdGlvbih0LGUpe3Q9dHx8e30sbnVsbD09dC5zbW9vdGhDaGlsZFRpbWluZyYmKHQuc21vb3RoQ2hpbGRUaW1pbmc9ITApO3ZhciByLG4sYT1uZXcgcyh0KSxvPWEuX3RpbWVsaW5lO2ZvcihudWxsPT1lJiYoZT0hMCksby5fcmVtb3ZlKGEsITApLGEuX3N0YXJ0VGltZT0wLGEuX3Jhd1ByZXZUaW1lPWEuX3RpbWU9YS5fdG90YWxUaW1lPW8uX3RpbWUscj1vLl9maXJzdDtyOyluPXIuX25leHQsZSYmciBpbnN0YW5jZW9mIGkmJnIudGFyZ2V0PT09ci52YXJzLm9uQ29tcGxldGV8fGEuYWRkKHIsci5fc3RhcnRUaW1lLXIuX2RlbGF5KSxyPW47cmV0dXJuIG8uYWRkKGEsMCksYX0sZC5hZGQ9ZnVuY3Rpb24ocixuLGEsbyl7dmFyIGgsXyx1LGMsZixwO2lmKFwibnVtYmVyXCIhPXR5cGVvZiBuJiYobj10aGlzLl9wYXJzZVRpbWVPckxhYmVsKG4sMCwhMCxyKSksIShyIGluc3RhbmNlb2YgdCkpe2lmKHIgaW5zdGFuY2VvZiBBcnJheXx8ciYmci5wdXNoJiZsKHIpKXtmb3IoYT1hfHxcIm5vcm1hbFwiLG89b3x8MCxoPW4sXz1yLmxlbmd0aCx1PTA7Xz51O3UrKylsKGM9clt1XSkmJihjPW5ldyBzKHt0d2VlbnM6Y30pKSx0aGlzLmFkZChjLGgpLFwic3RyaW5nXCIhPXR5cGVvZiBjJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBjJiYoXCJzZXF1ZW5jZVwiPT09YT9oPWMuX3N0YXJ0VGltZStjLnRvdGFsRHVyYXRpb24oKS9jLl90aW1lU2NhbGU6XCJzdGFydFwiPT09YSYmKGMuX3N0YXJ0VGltZS09Yy5kZWxheSgpKSksaCs9bztyZXR1cm4gdGhpcy5fdW5jYWNoZSghMCl9aWYoXCJzdHJpbmdcIj09dHlwZW9mIHIpcmV0dXJuIHRoaXMuYWRkTGFiZWwocixuKTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiByKXRocm93XCJDYW5ub3QgYWRkIFwiK3IrXCIgaW50byB0aGUgdGltZWxpbmU7IGl0IGlzIG5vdCBhIHR3ZWVuLCB0aW1lbGluZSwgZnVuY3Rpb24sIG9yIHN0cmluZy5cIjtyPWkuZGVsYXllZENhbGwoMCxyKX1pZihlLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLHIsbiksKHRoaXMuX2djfHx0aGlzLl90aW1lPT09dGhpcy5fZHVyYXRpb24pJiYhdGhpcy5fcGF1c2VkJiZ0aGlzLl9kdXJhdGlvbjx0aGlzLmR1cmF0aW9uKCkpZm9yKGY9dGhpcyxwPWYucmF3VGltZSgpPnIuX3N0YXJ0VGltZTtmLl90aW1lbGluZTspcCYmZi5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmc/Zi50b3RhbFRpbWUoZi5fdG90YWxUaW1lLCEwKTpmLl9nYyYmZi5fZW5hYmxlZCghMCwhMSksZj1mLl90aW1lbGluZTtyZXR1cm4gdGhpc30sZC5yZW1vdmU9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIHQpe3RoaXMuX3JlbW92ZShlLCExKTt2YXIgaT1lLl90aW1lbGluZT1lLnZhcnMudXNlRnJhbWVzP3QuX3Jvb3RGcmFtZXNUaW1lbGluZTp0Ll9yb290VGltZWxpbmU7cmV0dXJuIGUuX3N0YXJ0VGltZT0oZS5fcGF1c2VkP2UuX3BhdXNlVGltZTppLl90aW1lKS0oZS5fcmV2ZXJzZWQ/ZS50b3RhbER1cmF0aW9uKCktZS5fdG90YWxUaW1lOmUuX3RvdGFsVGltZSkvZS5fdGltZVNjYWxlLHRoaXN9aWYoZSBpbnN0YW5jZW9mIEFycmF5fHxlJiZlLnB1c2gmJmwoZSkpe2Zvcih2YXIgcz1lLmxlbmd0aDstLXM+LTE7KXRoaXMucmVtb3ZlKGVbc10pO3JldHVybiB0aGlzfXJldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlP3RoaXMucmVtb3ZlTGFiZWwoZSk6dGhpcy5raWxsKG51bGwsZSl9LGQuX3JlbW92ZT1mdW5jdGlvbih0LGkpe2UucHJvdG90eXBlLl9yZW1vdmUuY2FsbCh0aGlzLHQsaSk7dmFyIHM9dGhpcy5fbGFzdDtyZXR1cm4gcz90aGlzLl90aW1lPnMuX3N0YXJ0VGltZStzLl90b3RhbER1cmF0aW9uL3MuX3RpbWVTY2FsZSYmKHRoaXMuX3RpbWU9dGhpcy5kdXJhdGlvbigpLHRoaXMuX3RvdGFsVGltZT10aGlzLl90b3RhbER1cmF0aW9uKTp0aGlzLl90aW1lPXRoaXMuX3RvdGFsVGltZT10aGlzLl9kdXJhdGlvbj10aGlzLl90b3RhbER1cmF0aW9uPTAsdGhpc30sZC5hcHBlbmQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hZGQodCx0aGlzLl9wYXJzZVRpbWVPckxhYmVsKG51bGwsZSwhMCx0KSl9LGQuaW5zZXJ0PWQuaW5zZXJ0TXVsdGlwbGU9ZnVuY3Rpb24odCxlLGkscyl7cmV0dXJuIHRoaXMuYWRkKHQsZXx8MCxpLHMpfSxkLmFwcGVuZE11bHRpcGxlPWZ1bmN0aW9uKHQsZSxpLHMpe3JldHVybiB0aGlzLmFkZCh0LHRoaXMuX3BhcnNlVGltZU9yTGFiZWwobnVsbCxlLCEwLHQpLGkscyl9LGQuYWRkTGFiZWw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fbGFiZWxzW3RdPXRoaXMuX3BhcnNlVGltZU9yTGFiZWwoZSksdGhpc30sZC5hZGRQYXVzZT1mdW5jdGlvbih0LGUscyxyKXt2YXIgbj1pLmRlbGF5ZWRDYWxsKDAscCxzLHJ8fHRoaXMpO3JldHVybiBuLnZhcnMub25Db21wbGV0ZT1uLnZhcnMub25SZXZlcnNlQ29tcGxldGU9ZSxuLmRhdGE9XCJpc1BhdXNlXCIsdGhpcy5faGFzUGF1c2U9ITAsdGhpcy5hZGQobix0KX0sZC5yZW1vdmVMYWJlbD1mdW5jdGlvbih0KXtyZXR1cm4gZGVsZXRlIHRoaXMuX2xhYmVsc1t0XSx0aGlzfSxkLmdldExhYmVsVGltZT1mdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9dGhpcy5fbGFiZWxzW3RdP3RoaXMuX2xhYmVsc1t0XTotMX0sZC5fcGFyc2VUaW1lT3JMYWJlbD1mdW5jdGlvbihlLGkscyxyKXt2YXIgbjtpZihyIGluc3RhbmNlb2YgdCYmci50aW1lbGluZT09PXRoaXMpdGhpcy5yZW1vdmUocik7ZWxzZSBpZihyJiYociBpbnN0YW5jZW9mIEFycmF5fHxyLnB1c2gmJmwocikpKWZvcihuPXIubGVuZ3RoOy0tbj4tMTspcltuXWluc3RhbmNlb2YgdCYmcltuXS50aW1lbGluZT09PXRoaXMmJnRoaXMucmVtb3ZlKHJbbl0pO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBpKXJldHVybiB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKGkscyYmXCJudW1iZXJcIj09dHlwZW9mIGUmJm51bGw9PXRoaXMuX2xhYmVsc1tpXT9lLXRoaXMuZHVyYXRpb24oKTowLHMpO2lmKGk9aXx8MCxcInN0cmluZ1wiIT10eXBlb2YgZXx8IWlzTmFOKGUpJiZudWxsPT10aGlzLl9sYWJlbHNbZV0pbnVsbD09ZSYmKGU9dGhpcy5kdXJhdGlvbigpKTtlbHNle2lmKG49ZS5pbmRleE9mKFwiPVwiKSwtMT09PW4pcmV0dXJuIG51bGw9PXRoaXMuX2xhYmVsc1tlXT9zP3RoaXMuX2xhYmVsc1tlXT10aGlzLmR1cmF0aW9uKCkraTppOnRoaXMuX2xhYmVsc1tlXStpO2k9cGFyc2VJbnQoZS5jaGFyQXQobi0xKStcIjFcIiwxMCkqTnVtYmVyKGUuc3Vic3RyKG4rMSkpLGU9bj4xP3RoaXMuX3BhcnNlVGltZU9yTGFiZWwoZS5zdWJzdHIoMCxuLTEpLDAscyk6dGhpcy5kdXJhdGlvbigpfXJldHVybiBOdW1iZXIoZSkraX0sZC5zZWVrPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudG90YWxUaW1lKFwibnVtYmVyXCI9PXR5cGVvZiB0P3Q6dGhpcy5fcGFyc2VUaW1lT3JMYWJlbCh0KSxlIT09ITEpfSxkLnN0b3A9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXVzZWQoITApfSxkLmdvdG9BbmRQbGF5PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMucGxheSh0LGUpfSxkLmdvdG9BbmRTdG9wPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMucGF1c2UodCxlKX0sZC5yZW5kZXI9ZnVuY3Rpb24odCxlLGkpe3RoaXMuX2djJiZ0aGlzLl9lbmFibGVkKCEwLCExKTt2YXIgcyxuLGEsbyxsLHUsYz10aGlzLl9kaXJ0eT90aGlzLnRvdGFsRHVyYXRpb24oKTp0aGlzLl90b3RhbER1cmF0aW9uLGY9dGhpcy5fdGltZSxwPXRoaXMuX3N0YXJ0VGltZSxtPXRoaXMuX3RpbWVTY2FsZSxkPXRoaXMuX3BhdXNlZDtpZih0Pj1jKXRoaXMuX3RvdGFsVGltZT10aGlzLl90aW1lPWMsdGhpcy5fcmV2ZXJzZWR8fHRoaXMuX2hhc1BhdXNlZENoaWxkKCl8fChuPSEwLG89XCJvbkNvbXBsZXRlXCIsbD0hIXRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbiwwPT09dGhpcy5fZHVyYXRpb24mJigwPT09dHx8MD50aGlzLl9yYXdQcmV2VGltZXx8dGhpcy5fcmF3UHJldlRpbWU9PT1yKSYmdGhpcy5fcmF3UHJldlRpbWUhPT10JiZ0aGlzLl9maXJzdCYmKGw9ITAsdGhpcy5fcmF3UHJldlRpbWU+ciYmKG89XCJvblJldmVyc2VDb21wbGV0ZVwiKSkpLHRoaXMuX3Jhd1ByZXZUaW1lPXRoaXMuX2R1cmF0aW9ufHwhZXx8dHx8dGhpcy5fcmF3UHJldlRpbWU9PT10P3Q6cix0PWMrMWUtNDtlbHNlIGlmKDFlLTc+dClpZih0aGlzLl90b3RhbFRpbWU9dGhpcy5fdGltZT0wLCgwIT09Znx8MD09PXRoaXMuX2R1cmF0aW9uJiZ0aGlzLl9yYXdQcmV2VGltZSE9PXImJih0aGlzLl9yYXdQcmV2VGltZT4wfHwwPnQmJnRoaXMuX3Jhd1ByZXZUaW1lPj0wKSkmJihvPVwib25SZXZlcnNlQ29tcGxldGVcIixuPXRoaXMuX3JldmVyc2VkKSwwPnQpdGhpcy5fYWN0aXZlPSExLHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbiYmdGhpcy5fcmV2ZXJzZWQ/KGw9bj0hMCxvPVwib25SZXZlcnNlQ29tcGxldGVcIik6dGhpcy5fcmF3UHJldlRpbWU+PTAmJnRoaXMuX2ZpcnN0JiYobD0hMCksdGhpcy5fcmF3UHJldlRpbWU9dDtlbHNle2lmKHRoaXMuX3Jhd1ByZXZUaW1lPXRoaXMuX2R1cmF0aW9ufHwhZXx8dHx8dGhpcy5fcmF3UHJldlRpbWU9PT10P3Q6ciwwPT09dCYmbilmb3Iocz10aGlzLl9maXJzdDtzJiYwPT09cy5fc3RhcnRUaW1lOylzLl9kdXJhdGlvbnx8KG49ITEpLHM9cy5fbmV4dDt0PTAsdGhpcy5faW5pdHRlZHx8KGw9ITApfWVsc2V7aWYodGhpcy5faGFzUGF1c2UmJiF0aGlzLl9mb3JjaW5nUGxheWhlYWQmJiFlKXtpZih0Pj1mKWZvcihzPXRoaXMuX2ZpcnN0O3MmJnQ+PXMuX3N0YXJ0VGltZSYmIXU7KXMuX2R1cmF0aW9ufHxcImlzUGF1c2VcIiE9PXMuZGF0YXx8cy5yYXRpb3x8MD09PXMuX3N0YXJ0VGltZSYmMD09PXRoaXMuX3Jhd1ByZXZUaW1lfHwodT1zKSxzPXMuX25leHQ7ZWxzZSBmb3Iocz10aGlzLl9sYXN0O3MmJnMuX3N0YXJ0VGltZT49dCYmIXU7KXMuX2R1cmF0aW9ufHxcImlzUGF1c2VcIj09PXMuZGF0YSYmcy5fcmF3UHJldlRpbWU+MCYmKHU9cykscz1zLl9wcmV2O3UmJih0aGlzLl90aW1lPXQ9dS5fc3RhcnRUaW1lLHRoaXMuX3RvdGFsVGltZT10K3RoaXMuX2N5Y2xlKih0aGlzLl90b3RhbER1cmF0aW9uK3RoaXMuX3JlcGVhdERlbGF5KSl9dGhpcy5fdG90YWxUaW1lPXRoaXMuX3RpbWU9dGhpcy5fcmF3UHJldlRpbWU9dH1pZih0aGlzLl90aW1lIT09ZiYmdGhpcy5fZmlyc3R8fGl8fGx8fHUpe2lmKHRoaXMuX2luaXR0ZWR8fCh0aGlzLl9pbml0dGVkPSEwKSx0aGlzLl9hY3RpdmV8fCF0aGlzLl9wYXVzZWQmJnRoaXMuX3RpbWUhPT1mJiZ0PjAmJih0aGlzLl9hY3RpdmU9ITApLDA9PT1mJiZ0aGlzLnZhcnMub25TdGFydCYmMCE9PXRoaXMuX3RpbWUmJihlfHx0aGlzLl9jYWxsYmFjayhcIm9uU3RhcnRcIikpLHRoaXMuX3RpbWU+PWYpZm9yKHM9dGhpcy5fZmlyc3Q7cyYmKGE9cy5fbmV4dCwhdGhpcy5fcGF1c2VkfHxkKTspKHMuX2FjdGl2ZXx8cy5fc3RhcnRUaW1lPD10aGlzLl90aW1lJiYhcy5fcGF1c2VkJiYhcy5fZ2MpJiYodT09PXMmJnRoaXMucGF1c2UoKSxzLl9yZXZlcnNlZD9zLnJlbmRlcigocy5fZGlydHk/cy50b3RhbER1cmF0aW9uKCk6cy5fdG90YWxEdXJhdGlvbiktKHQtcy5fc3RhcnRUaW1lKSpzLl90aW1lU2NhbGUsZSxpKTpzLnJlbmRlcigodC1zLl9zdGFydFRpbWUpKnMuX3RpbWVTY2FsZSxlLGkpKSxzPWE7ZWxzZSBmb3Iocz10aGlzLl9sYXN0O3MmJihhPXMuX3ByZXYsIXRoaXMuX3BhdXNlZHx8ZCk7KXtpZihzLl9hY3RpdmV8fGY+PXMuX3N0YXJ0VGltZSYmIXMuX3BhdXNlZCYmIXMuX2djKXtpZih1PT09cyl7Zm9yKHU9cy5fcHJldjt1JiZ1LmVuZFRpbWUoKT50aGlzLl90aW1lOyl1LnJlbmRlcih1Ll9yZXZlcnNlZD91LnRvdGFsRHVyYXRpb24oKS0odC11Ll9zdGFydFRpbWUpKnUuX3RpbWVTY2FsZToodC11Ll9zdGFydFRpbWUpKnUuX3RpbWVTY2FsZSxlLGkpLHU9dS5fcHJldjt1PW51bGwsdGhpcy5wYXVzZSgpfXMuX3JldmVyc2VkP3MucmVuZGVyKChzLl9kaXJ0eT9zLnRvdGFsRHVyYXRpb24oKTpzLl90b3RhbER1cmF0aW9uKS0odC1zLl9zdGFydFRpbWUpKnMuX3RpbWVTY2FsZSxlLGkpOnMucmVuZGVyKCh0LXMuX3N0YXJ0VGltZSkqcy5fdGltZVNjYWxlLGUsaSl9cz1hfXRoaXMuX29uVXBkYXRlJiYoZXx8KGgubGVuZ3RoJiZfKCksdGhpcy5fY2FsbGJhY2soXCJvblVwZGF0ZVwiKSkpLG8mJih0aGlzLl9nY3x8KHA9PT10aGlzLl9zdGFydFRpbWV8fG0hPT10aGlzLl90aW1lU2NhbGUpJiYoMD09PXRoaXMuX3RpbWV8fGM+PXRoaXMudG90YWxEdXJhdGlvbigpKSYmKG4mJihoLmxlbmd0aCYmXygpLHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbiYmdGhpcy5fZW5hYmxlZCghMSwhMSksdGhpcy5fYWN0aXZlPSExKSwhZSYmdGhpcy52YXJzW29dJiZ0aGlzLl9jYWxsYmFjayhvKSkpfX0sZC5faGFzUGF1c2VkQ2hpbGQ9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5fZmlyc3Q7dDspe2lmKHQuX3BhdXNlZHx8dCBpbnN0YW5jZW9mIHMmJnQuX2hhc1BhdXNlZENoaWxkKCkpcmV0dXJuITA7dD10Ll9uZXh0fXJldHVybiExfSxkLmdldENoaWxkcmVuPWZ1bmN0aW9uKHQsZSxzLHIpe3I9cnx8LTk5OTk5OTk5OTk7Zm9yKHZhciBuPVtdLGE9dGhpcy5fZmlyc3Qsbz0wO2E7KXI+YS5fc3RhcnRUaW1lfHwoYSBpbnN0YW5jZW9mIGk/ZSE9PSExJiYobltvKytdPWEpOihzIT09ITEmJihuW28rK109YSksdCE9PSExJiYobj1uLmNvbmNhdChhLmdldENoaWxkcmVuKCEwLGUscykpLG89bi5sZW5ndGgpKSksYT1hLl9uZXh0O3JldHVybiBufSxkLmdldFR3ZWVuc09mPWZ1bmN0aW9uKHQsZSl7dmFyIHMscixuPXRoaXMuX2djLGE9W10sbz0wO2ZvcihuJiZ0aGlzLl9lbmFibGVkKCEwLCEwKSxzPWkuZ2V0VHdlZW5zT2YodCkscj1zLmxlbmd0aDstLXI+LTE7KShzW3JdLnRpbWVsaW5lPT09dGhpc3x8ZSYmdGhpcy5fY29udGFpbnMoc1tyXSkpJiYoYVtvKytdPXNbcl0pO3JldHVybiBuJiZ0aGlzLl9lbmFibGVkKCExLCEwKSxhfSxkLnJlY2VudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZWNlbnR9LGQuX2NvbnRhaW5zPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LnRpbWVsaW5lO2U7KXtpZihlPT09dGhpcylyZXR1cm4hMDtlPWUudGltZWxpbmV9cmV0dXJuITF9LGQuc2hpZnRDaGlsZHJlbj1mdW5jdGlvbih0LGUsaSl7aT1pfHwwO2Zvcih2YXIgcyxyPXRoaXMuX2ZpcnN0LG49dGhpcy5fbGFiZWxzO3I7KXIuX3N0YXJ0VGltZT49aSYmKHIuX3N0YXJ0VGltZSs9dCkscj1yLl9uZXh0O2lmKGUpZm9yKHMgaW4gbiluW3NdPj1pJiYobltzXSs9dCk7cmV0dXJuIHRoaXMuX3VuY2FjaGUoITApfSxkLl9raWxsPWZ1bmN0aW9uKHQsZSl7aWYoIXQmJiFlKXJldHVybiB0aGlzLl9lbmFibGVkKCExLCExKTtmb3IodmFyIGk9ZT90aGlzLmdldFR3ZWVuc09mKGUpOnRoaXMuZ2V0Q2hpbGRyZW4oITAsITAsITEpLHM9aS5sZW5ndGgscj0hMTstLXM+LTE7KWlbc10uX2tpbGwodCxlKSYmKHI9ITApO3JldHVybiByfSxkLmNsZWFyPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0Q2hpbGRyZW4oITEsITAsITApLGk9ZS5sZW5ndGg7Zm9yKHRoaXMuX3RpbWU9dGhpcy5fdG90YWxUaW1lPTA7LS1pPi0xOyllW2ldLl9lbmFibGVkKCExLCExKTtyZXR1cm4gdCE9PSExJiYodGhpcy5fbGFiZWxzPXt9KSx0aGlzLl91bmNhY2hlKCEwKX0sZC5pbnZhbGlkYXRlPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXMuX2ZpcnN0O2U7KWUuaW52YWxpZGF0ZSgpLGU9ZS5fbmV4dDtyZXR1cm4gdC5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMpfSxkLl9lbmFibGVkPWZ1bmN0aW9uKHQsaSl7aWYodD09PXRoaXMuX2djKWZvcih2YXIgcz10aGlzLl9maXJzdDtzOylzLl9lbmFibGVkKHQsITApLHM9cy5fbmV4dDtyZXR1cm4gZS5wcm90b3R5cGUuX2VuYWJsZWQuY2FsbCh0aGlzLHQsaSl9LGQudG90YWxUaW1lPWZ1bmN0aW9uKCl7dGhpcy5fZm9yY2luZ1BsYXloZWFkPSEwO3ZhciBlPXQucHJvdG90eXBlLnRvdGFsVGltZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIHRoaXMuX2ZvcmNpbmdQbGF5aGVhZD0hMSxlfSxkLmR1cmF0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPygwIT09dGhpcy5kdXJhdGlvbigpJiYwIT09dCYmdGhpcy50aW1lU2NhbGUodGhpcy5fZHVyYXRpb24vdCksdGhpcyk6KHRoaXMuX2RpcnR5JiZ0aGlzLnRvdGFsRHVyYXRpb24oKSx0aGlzLl9kdXJhdGlvbil9LGQudG90YWxEdXJhdGlvbj1mdW5jdGlvbih0KXtpZighYXJndW1lbnRzLmxlbmd0aCl7aWYodGhpcy5fZGlydHkpe2Zvcih2YXIgZSxpLHM9MCxyPXRoaXMuX2xhc3Qsbj05OTk5OTk5OTk5OTk7cjspZT1yLl9wcmV2LHIuX2RpcnR5JiZyLnRvdGFsRHVyYXRpb24oKSxyLl9zdGFydFRpbWU+biYmdGhpcy5fc29ydENoaWxkcmVuJiYhci5fcGF1c2VkP3RoaXMuYWRkKHIsci5fc3RhcnRUaW1lLXIuX2RlbGF5KTpuPXIuX3N0YXJ0VGltZSwwPnIuX3N0YXJ0VGltZSYmIXIuX3BhdXNlZCYmKHMtPXIuX3N0YXJ0VGltZSx0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZyYmKHRoaXMuX3N0YXJ0VGltZSs9ci5fc3RhcnRUaW1lL3RoaXMuX3RpbWVTY2FsZSksdGhpcy5zaGlmdENoaWxkcmVuKC1yLl9zdGFydFRpbWUsITEsLTk5OTk5OTk5OTkpLG49MCksaT1yLl9zdGFydFRpbWUrci5fdG90YWxEdXJhdGlvbi9yLl90aW1lU2NhbGUsaT5zJiYocz1pKSxyPWU7dGhpcy5fZHVyYXRpb249dGhpcy5fdG90YWxEdXJhdGlvbj1zLHRoaXMuX2RpcnR5PSExfXJldHVybiB0aGlzLl90b3RhbER1cmF0aW9ufXJldHVybiAwIT09dGhpcy50b3RhbER1cmF0aW9uKCkmJjAhPT10JiZ0aGlzLnRpbWVTY2FsZSh0aGlzLl90b3RhbER1cmF0aW9uL3QpLHRoaXN9LGQucGF1c2VkPWZ1bmN0aW9uKGUpe2lmKCFlKWZvcih2YXIgaT10aGlzLl9maXJzdCxzPXRoaXMuX3RpbWU7aTspaS5fc3RhcnRUaW1lPT09cyYmXCJpc1BhdXNlXCI9PT1pLmRhdGEmJihpLl9yYXdQcmV2VGltZT0wKSxpPWkuX25leHQ7cmV0dXJuIHQucHJvdG90eXBlLnBhdXNlZC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGQudXNlc0ZyYW1lcz1mdW5jdGlvbigpe2Zvcih2YXIgZT10aGlzLl90aW1lbGluZTtlLl90aW1lbGluZTspZT1lLl90aW1lbGluZTtyZXR1cm4gZT09PXQuX3Jvb3RGcmFtZXNUaW1lbGluZX0sZC5yYXdUaW1lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BhdXNlZD90aGlzLl90b3RhbFRpbWU6KHRoaXMuX3RpbWVsaW5lLnJhd1RpbWUoKS10aGlzLl9zdGFydFRpbWUpKnRoaXMuX3RpbWVTY2FsZX0sc30sITApLF9nc1Njb3BlLl9nc0RlZmluZShcIlRpbWVsaW5lTWF4XCIsW1wiVGltZWxpbmVMaXRlXCIsXCJUd2VlbkxpdGVcIixcImVhc2luZy5FYXNlXCJdLGZ1bmN0aW9uKHQsZSxpKXt2YXIgcz1mdW5jdGlvbihlKXt0LmNhbGwodGhpcyxlKSx0aGlzLl9yZXBlYXQ9dGhpcy52YXJzLnJlcGVhdHx8MCx0aGlzLl9yZXBlYXREZWxheT10aGlzLnZhcnMucmVwZWF0RGVsYXl8fDAsdGhpcy5fY3ljbGU9MCx0aGlzLl95b3lvPXRoaXMudmFycy55b3lvPT09ITAsdGhpcy5fZGlydHk9ITB9LHI9MWUtMTAsbj1lLl9pbnRlcm5hbHMsYT1uLmxhenlUd2VlbnMsbz1uLmxhenlSZW5kZXIsbD1uZXcgaShudWxsLG51bGwsMSwwKSxoPXMucHJvdG90eXBlPW5ldyB0O3JldHVybiBoLmNvbnN0cnVjdG9yPXMsaC5raWxsKCkuX2djPSExLHMudmVyc2lvbj1cIjEuMTguMFwiLGguaW52YWxpZGF0ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl95b3lvPXRoaXMudmFycy55b3lvPT09ITAsdGhpcy5fcmVwZWF0PXRoaXMudmFycy5yZXBlYXR8fDAsdGhpcy5fcmVwZWF0RGVsYXk9dGhpcy52YXJzLnJlcGVhdERlbGF5fHwwLHRoaXMuX3VuY2FjaGUoITApLHQucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKX0saC5hZGRDYWxsYmFjaz1mdW5jdGlvbih0LGkscyxyKXtyZXR1cm4gdGhpcy5hZGQoZS5kZWxheWVkQ2FsbCgwLHQscyxyKSxpKX0saC5yZW1vdmVDYWxsYmFjaz1mdW5jdGlvbih0LGUpe2lmKHQpaWYobnVsbD09ZSl0aGlzLl9raWxsKG51bGwsdCk7ZWxzZSBmb3IodmFyIGk9dGhpcy5nZXRUd2VlbnNPZih0LCExKSxzPWkubGVuZ3RoLHI9dGhpcy5fcGFyc2VUaW1lT3JMYWJlbChlKTstLXM+LTE7KWlbc10uX3N0YXJ0VGltZT09PXImJmlbc10uX2VuYWJsZWQoITEsITEpO3JldHVybiB0aGlzfSxoLnJlbW92ZVBhdXNlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlbW92ZUNhbGxiYWNrKHQuX2ludGVybmFscy5wYXVzZUNhbGxiYWNrLGUpfSxoLnR3ZWVuVG89ZnVuY3Rpb24odCxpKXtpPWl8fHt9O3ZhciBzLHIsbixhPXtlYXNlOmwsdXNlRnJhbWVzOnRoaXMudXNlc0ZyYW1lcygpLGltbWVkaWF0ZVJlbmRlcjohMX07Zm9yKHIgaW4gaSlhW3JdPWlbcl07cmV0dXJuIGEudGltZT10aGlzLl9wYXJzZVRpbWVPckxhYmVsKHQpLHM9TWF0aC5hYnMoTnVtYmVyKGEudGltZSktdGhpcy5fdGltZSkvdGhpcy5fdGltZVNjYWxlfHwuMDAxLG49bmV3IGUodGhpcyxzLGEpLGEub25TdGFydD1mdW5jdGlvbigpe24udGFyZ2V0LnBhdXNlZCghMCksbi52YXJzLnRpbWUhPT1uLnRhcmdldC50aW1lKCkmJnM9PT1uLmR1cmF0aW9uKCkmJm4uZHVyYXRpb24oTWF0aC5hYnMobi52YXJzLnRpbWUtbi50YXJnZXQudGltZSgpKS9uLnRhcmdldC5fdGltZVNjYWxlKSxpLm9uU3RhcnQmJm4uX2NhbGxiYWNrKFwib25TdGFydFwiKX0sbn0saC50d2VlbkZyb21Ubz1mdW5jdGlvbih0LGUsaSl7aT1pfHx7fSx0PXRoaXMuX3BhcnNlVGltZU9yTGFiZWwodCksaS5zdGFydEF0PXtvbkNvbXBsZXRlOnRoaXMuc2VlayxvbkNvbXBsZXRlUGFyYW1zOlt0XSxjYWxsYmFja1Njb3BlOnRoaXN9LGkuaW1tZWRpYXRlUmVuZGVyPWkuaW1tZWRpYXRlUmVuZGVyIT09ITE7dmFyIHM9dGhpcy50d2VlblRvKGUsaSk7cmV0dXJuIHMuZHVyYXRpb24oTWF0aC5hYnMocy52YXJzLnRpbWUtdCkvdGhpcy5fdGltZVNjYWxlfHwuMDAxKX0saC5yZW5kZXI9ZnVuY3Rpb24odCxlLGkpe3RoaXMuX2djJiZ0aGlzLl9lbmFibGVkKCEwLCExKTt2YXIgcyxuLGwsaCxfLHUsYyxmPXRoaXMuX2RpcnR5P3RoaXMudG90YWxEdXJhdGlvbigpOnRoaXMuX3RvdGFsRHVyYXRpb24scD10aGlzLl9kdXJhdGlvbixtPXRoaXMuX3RpbWUsZD10aGlzLl90b3RhbFRpbWUsZz10aGlzLl9zdGFydFRpbWUsdj10aGlzLl90aW1lU2NhbGUseT10aGlzLl9yYXdQcmV2VGltZSxUPXRoaXMuX3BhdXNlZCx4PXRoaXMuX2N5Y2xlO2lmKHQ+PWYpdGhpcy5fbG9ja2VkfHwodGhpcy5fdG90YWxUaW1lPWYsdGhpcy5fY3ljbGU9dGhpcy5fcmVwZWF0KSx0aGlzLl9yZXZlcnNlZHx8dGhpcy5faGFzUGF1c2VkQ2hpbGQoKXx8KG49ITAsaD1cIm9uQ29tcGxldGVcIixfPSEhdGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuLDA9PT10aGlzLl9kdXJhdGlvbiYmKDA9PT10fHwwPnl8fHk9PT1yKSYmeSE9PXQmJnRoaXMuX2ZpcnN0JiYoXz0hMCx5PnImJihoPVwib25SZXZlcnNlQ29tcGxldGVcIikpKSx0aGlzLl9yYXdQcmV2VGltZT10aGlzLl9kdXJhdGlvbnx8IWV8fHR8fHRoaXMuX3Jhd1ByZXZUaW1lPT09dD90OnIsdGhpcy5feW95byYmMCE9PSgxJnRoaXMuX2N5Y2xlKT90aGlzLl90aW1lPXQ9MDoodGhpcy5fdGltZT1wLHQ9cCsxZS00KTtlbHNlIGlmKDFlLTc+dClpZih0aGlzLl9sb2NrZWR8fCh0aGlzLl90b3RhbFRpbWU9dGhpcy5fY3ljbGU9MCksdGhpcy5fdGltZT0wLCgwIT09bXx8MD09PXAmJnkhPT1yJiYoeT4wfHwwPnQmJnk+PTApJiYhdGhpcy5fbG9ja2VkKSYmKGg9XCJvblJldmVyc2VDb21wbGV0ZVwiLG49dGhpcy5fcmV2ZXJzZWQpLDA+dCl0aGlzLl9hY3RpdmU9ITEsdGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuJiZ0aGlzLl9yZXZlcnNlZD8oXz1uPSEwLGg9XCJvblJldmVyc2VDb21wbGV0ZVwiKTp5Pj0wJiZ0aGlzLl9maXJzdCYmKF89ITApLHRoaXMuX3Jhd1ByZXZUaW1lPXQ7ZWxzZXtpZih0aGlzLl9yYXdQcmV2VGltZT1wfHwhZXx8dHx8dGhpcy5fcmF3UHJldlRpbWU9PT10P3Q6ciwwPT09dCYmbilmb3Iocz10aGlzLl9maXJzdDtzJiYwPT09cy5fc3RhcnRUaW1lOylzLl9kdXJhdGlvbnx8KG49ITEpLHM9cy5fbmV4dDt0PTAsdGhpcy5faW5pdHRlZHx8KF89ITApfWVsc2UgaWYoMD09PXAmJjA+eSYmKF89ITApLHRoaXMuX3RpbWU9dGhpcy5fcmF3UHJldlRpbWU9dCx0aGlzLl9sb2NrZWR8fCh0aGlzLl90b3RhbFRpbWU9dCwwIT09dGhpcy5fcmVwZWF0JiYodT1wK3RoaXMuX3JlcGVhdERlbGF5LHRoaXMuX2N5Y2xlPXRoaXMuX3RvdGFsVGltZS91Pj4wLDAhPT10aGlzLl9jeWNsZSYmdGhpcy5fY3ljbGU9PT10aGlzLl90b3RhbFRpbWUvdSYmdGhpcy5fY3ljbGUtLSx0aGlzLl90aW1lPXRoaXMuX3RvdGFsVGltZS10aGlzLl9jeWNsZSp1LHRoaXMuX3lveW8mJjAhPT0oMSZ0aGlzLl9jeWNsZSkmJih0aGlzLl90aW1lPXAtdGhpcy5fdGltZSksdGhpcy5fdGltZT5wPyh0aGlzLl90aW1lPXAsdD1wKzFlLTQpOjA+dGhpcy5fdGltZT90aGlzLl90aW1lPXQ9MDp0PXRoaXMuX3RpbWUpKSx0aGlzLl9oYXNQYXVzZSYmIXRoaXMuX2ZvcmNpbmdQbGF5aGVhZCYmIWUpe2lmKHQ9dGhpcy5fdGltZSx0Pj1tKWZvcihzPXRoaXMuX2ZpcnN0O3MmJnQ+PXMuX3N0YXJ0VGltZSYmIWM7KXMuX2R1cmF0aW9ufHxcImlzUGF1c2VcIiE9PXMuZGF0YXx8cy5yYXRpb3x8MD09PXMuX3N0YXJ0VGltZSYmMD09PXRoaXMuX3Jhd1ByZXZUaW1lfHwoYz1zKSxzPXMuX25leHQ7ZWxzZSBmb3Iocz10aGlzLl9sYXN0O3MmJnMuX3N0YXJ0VGltZT49dCYmIWM7KXMuX2R1cmF0aW9ufHxcImlzUGF1c2VcIj09PXMuZGF0YSYmcy5fcmF3UHJldlRpbWU+MCYmKGM9cykscz1zLl9wcmV2O2MmJih0aGlzLl90aW1lPXQ9Yy5fc3RhcnRUaW1lLHRoaXMuX3RvdGFsVGltZT10K3RoaXMuX2N5Y2xlKih0aGlzLl90b3RhbER1cmF0aW9uK3RoaXMuX3JlcGVhdERlbGF5KSl9aWYodGhpcy5fY3ljbGUhPT14JiYhdGhpcy5fbG9ja2VkKXt2YXIgdz10aGlzLl95b3lvJiYwIT09KDEmeCksYj13PT09KHRoaXMuX3lveW8mJjAhPT0oMSZ0aGlzLl9jeWNsZSkpLFA9dGhpcy5fdG90YWxUaW1lLGs9dGhpcy5fY3ljbGUsUz10aGlzLl9yYXdQcmV2VGltZSxSPXRoaXMuX3RpbWU7aWYodGhpcy5fdG90YWxUaW1lPXgqcCx4PnRoaXMuX2N5Y2xlP3c9IXc6dGhpcy5fdG90YWxUaW1lKz1wLHRoaXMuX3RpbWU9bSx0aGlzLl9yYXdQcmV2VGltZT0wPT09cD95LTFlLTQ6eSx0aGlzLl9jeWNsZT14LHRoaXMuX2xvY2tlZD0hMCxtPXc/MDpwLHRoaXMucmVuZGVyKG0sZSwwPT09cCksZXx8dGhpcy5fZ2N8fHRoaXMudmFycy5vblJlcGVhdCYmdGhpcy5fY2FsbGJhY2soXCJvblJlcGVhdFwiKSxiJiYobT13P3ArMWUtNDotMWUtNCx0aGlzLnJlbmRlcihtLCEwLCExKSksdGhpcy5fbG9ja2VkPSExLHRoaXMuX3BhdXNlZCYmIVQpcmV0dXJuO3RoaXMuX3RpbWU9Uix0aGlzLl90b3RhbFRpbWU9UCx0aGlzLl9jeWNsZT1rLHRoaXMuX3Jhd1ByZXZUaW1lPVN9aWYoISh0aGlzLl90aW1lIT09bSYmdGhpcy5fZmlyc3R8fGl8fF98fGMpKXJldHVybiBkIT09dGhpcy5fdG90YWxUaW1lJiZ0aGlzLl9vblVwZGF0ZSYmKGV8fHRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIikpLHZvaWQgMDtpZih0aGlzLl9pbml0dGVkfHwodGhpcy5faW5pdHRlZD0hMCksdGhpcy5fYWN0aXZlfHwhdGhpcy5fcGF1c2VkJiZ0aGlzLl90b3RhbFRpbWUhPT1kJiZ0PjAmJih0aGlzLl9hY3RpdmU9ITApLDA9PT1kJiZ0aGlzLnZhcnMub25TdGFydCYmMCE9PXRoaXMuX3RvdGFsVGltZSYmKGV8fHRoaXMuX2NhbGxiYWNrKFwib25TdGFydFwiKSksdGhpcy5fdGltZT49bSlmb3Iocz10aGlzLl9maXJzdDtzJiYobD1zLl9uZXh0LCF0aGlzLl9wYXVzZWR8fFQpOykocy5fYWN0aXZlfHxzLl9zdGFydFRpbWU8PXRoaXMuX3RpbWUmJiFzLl9wYXVzZWQmJiFzLl9nYykmJihjPT09cyYmdGhpcy5wYXVzZSgpLHMuX3JldmVyc2VkP3MucmVuZGVyKChzLl9kaXJ0eT9zLnRvdGFsRHVyYXRpb24oKTpzLl90b3RhbER1cmF0aW9uKS0odC1zLl9zdGFydFRpbWUpKnMuX3RpbWVTY2FsZSxlLGkpOnMucmVuZGVyKCh0LXMuX3N0YXJ0VGltZSkqcy5fdGltZVNjYWxlLGUsaSkpLHM9bDtlbHNlIGZvcihzPXRoaXMuX2xhc3Q7cyYmKGw9cy5fcHJldiwhdGhpcy5fcGF1c2VkfHxUKTspe2lmKHMuX2FjdGl2ZXx8bT49cy5fc3RhcnRUaW1lJiYhcy5fcGF1c2VkJiYhcy5fZ2Mpe2lmKGM9PT1zKXtmb3IoYz1zLl9wcmV2O2MmJmMuZW5kVGltZSgpPnRoaXMuX3RpbWU7KWMucmVuZGVyKGMuX3JldmVyc2VkP2MudG90YWxEdXJhdGlvbigpLSh0LWMuX3N0YXJ0VGltZSkqYy5fdGltZVNjYWxlOih0LWMuX3N0YXJ0VGltZSkqYy5fdGltZVNjYWxlLGUsaSksYz1jLl9wcmV2O2M9bnVsbCx0aGlzLnBhdXNlKCl9cy5fcmV2ZXJzZWQ/cy5yZW5kZXIoKHMuX2RpcnR5P3MudG90YWxEdXJhdGlvbigpOnMuX3RvdGFsRHVyYXRpb24pLSh0LXMuX3N0YXJ0VGltZSkqcy5fdGltZVNjYWxlLGUsaSk6cy5yZW5kZXIoKHQtcy5fc3RhcnRUaW1lKSpzLl90aW1lU2NhbGUsZSxpKX1zPWx9dGhpcy5fb25VcGRhdGUmJihlfHwoYS5sZW5ndGgmJm8oKSx0aGlzLl9jYWxsYmFjayhcIm9uVXBkYXRlXCIpKSksaCYmKHRoaXMuX2xvY2tlZHx8dGhpcy5fZ2N8fChnPT09dGhpcy5fc3RhcnRUaW1lfHx2IT09dGhpcy5fdGltZVNjYWxlKSYmKDA9PT10aGlzLl90aW1lfHxmPj10aGlzLnRvdGFsRHVyYXRpb24oKSkmJihuJiYoYS5sZW5ndGgmJm8oKSx0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4mJnRoaXMuX2VuYWJsZWQoITEsITEpLHRoaXMuX2FjdGl2ZT0hMSksIWUmJnRoaXMudmFyc1toXSYmdGhpcy5fY2FsbGJhY2soaCkpKX0saC5nZXRBY3RpdmU9ZnVuY3Rpb24odCxlLGkpe251bGw9PXQmJih0PSEwKSxudWxsPT1lJiYoZT0hMCksbnVsbD09aSYmKGk9ITEpO3ZhciBzLHIsbj1bXSxhPXRoaXMuZ2V0Q2hpbGRyZW4odCxlLGkpLG89MCxsPWEubGVuZ3RoO2ZvcihzPTA7bD5zO3MrKylyPWFbc10sci5pc0FjdGl2ZSgpJiYobltvKytdPXIpO3JldHVybiBufSxoLmdldExhYmVsQWZ0ZXI9ZnVuY3Rpb24odCl7dHx8MCE9PXQmJih0PXRoaXMuX3RpbWUpO3ZhciBlLGk9dGhpcy5nZXRMYWJlbHNBcnJheSgpLHM9aS5sZW5ndGg7Zm9yKGU9MDtzPmU7ZSsrKWlmKGlbZV0udGltZT50KXJldHVybiBpW2VdLm5hbWU7cmV0dXJuIG51bGx9LGguZ2V0TGFiZWxCZWZvcmU9ZnVuY3Rpb24odCl7bnVsbD09dCYmKHQ9dGhpcy5fdGltZSk7Zm9yKHZhciBlPXRoaXMuZ2V0TGFiZWxzQXJyYXkoKSxpPWUubGVuZ3RoOy0taT4tMTspaWYodD5lW2ldLnRpbWUpcmV0dXJuIGVbaV0ubmFtZTtyZXR1cm4gbnVsbH0saC5nZXRMYWJlbHNBcnJheT1mdW5jdGlvbigpe3ZhciB0LGU9W10saT0wO2Zvcih0IGluIHRoaXMuX2xhYmVscyllW2krK109e3RpbWU6dGhpcy5fbGFiZWxzW3RdLG5hbWU6dH07cmV0dXJuIGUuc29ydChmdW5jdGlvbih0LGUpe3JldHVybiB0LnRpbWUtZS50aW1lfSksZX0saC5wcm9ncmVzcz1mdW5jdGlvbih0LGUpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoP3RoaXMudG90YWxUaW1lKHRoaXMuZHVyYXRpb24oKSoodGhpcy5feW95byYmMCE9PSgxJnRoaXMuX2N5Y2xlKT8xLXQ6dCkrdGhpcy5fY3ljbGUqKHRoaXMuX2R1cmF0aW9uK3RoaXMuX3JlcGVhdERlbGF5KSxlKTp0aGlzLl90aW1lL3RoaXMuZHVyYXRpb24oKX0saC50b3RhbFByb2dyZXNzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/dGhpcy50b3RhbFRpbWUodGhpcy50b3RhbER1cmF0aW9uKCkqdCxlKTp0aGlzLl90b3RhbFRpbWUvdGhpcy50b3RhbER1cmF0aW9uKCl9LGgudG90YWxEdXJhdGlvbj1mdW5jdGlvbihlKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8tMT09PXRoaXMuX3JlcGVhdD90aGlzOnRoaXMuZHVyYXRpb24oKGUtdGhpcy5fcmVwZWF0KnRoaXMuX3JlcGVhdERlbGF5KS8odGhpcy5fcmVwZWF0KzEpKToodGhpcy5fZGlydHkmJih0LnByb3RvdHlwZS50b3RhbER1cmF0aW9uLmNhbGwodGhpcyksdGhpcy5fdG90YWxEdXJhdGlvbj0tMT09PXRoaXMuX3JlcGVhdD85OTk5OTk5OTk5OTk6dGhpcy5fZHVyYXRpb24qKHRoaXMuX3JlcGVhdCsxKSt0aGlzLl9yZXBlYXREZWxheSp0aGlzLl9yZXBlYXQpLHRoaXMuX3RvdGFsRHVyYXRpb24pfSxoLnRpbWU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odGhpcy5fZGlydHkmJnRoaXMudG90YWxEdXJhdGlvbigpLHQ+dGhpcy5fZHVyYXRpb24mJih0PXRoaXMuX2R1cmF0aW9uKSx0aGlzLl95b3lvJiYwIT09KDEmdGhpcy5fY3ljbGUpP3Q9dGhpcy5fZHVyYXRpb24tdCt0aGlzLl9jeWNsZSoodGhpcy5fZHVyYXRpb24rdGhpcy5fcmVwZWF0RGVsYXkpOjAhPT10aGlzLl9yZXBlYXQmJih0Kz10aGlzLl9jeWNsZSoodGhpcy5fZHVyYXRpb24rdGhpcy5fcmVwZWF0RGVsYXkpKSx0aGlzLnRvdGFsVGltZSh0LGUpKTp0aGlzLl90aW1lfSxoLnJlcGVhdD1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odGhpcy5fcmVwZWF0PXQsdGhpcy5fdW5jYWNoZSghMCkpOnRoaXMuX3JlcGVhdH0saC5yZXBlYXREZWxheT1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odGhpcy5fcmVwZWF0RGVsYXk9dCx0aGlzLl91bmNhY2hlKCEwKSk6dGhpcy5fcmVwZWF0RGVsYXl9LGgueW95bz1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odGhpcy5feW95bz10LHRoaXMpOnRoaXMuX3lveW99LGguY3VycmVudExhYmVsPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoP3RoaXMuc2Vlayh0LCEwKTp0aGlzLmdldExhYmVsQmVmb3JlKHRoaXMuX3RpbWUrMWUtOCl9LHN9LCEwKSxmdW5jdGlvbigpe3ZhciB0PTE4MC9NYXRoLlBJLGU9W10saT1bXSxzPVtdLHI9e30sbj1fZ3NTY29wZS5fZ3NEZWZpbmUuZ2xvYmFscyxhPWZ1bmN0aW9uKHQsZSxpLHMpe3RoaXMuYT10LHRoaXMuYj1lLHRoaXMuYz1pLHRoaXMuZD1zLHRoaXMuZGE9cy10LHRoaXMuY2E9aS10LHRoaXMuYmE9ZS10fSxvPVwiLHgseSx6LGxlZnQsdG9wLHJpZ2h0LGJvdHRvbSxtYXJnaW5Ub3AsbWFyZ2luTGVmdCxtYXJnaW5SaWdodCxtYXJnaW5Cb3R0b20scGFkZGluZ0xlZnQscGFkZGluZ1RvcCxwYWRkaW5nUmlnaHQscGFkZGluZ0JvdHRvbSxiYWNrZ3JvdW5kUG9zaXRpb24sYmFja2dyb3VuZFBvc2l0aW9uX3ksXCIsbD1mdW5jdGlvbih0LGUsaSxzKXt2YXIgcj17YTp0fSxuPXt9LGE9e30sbz17YzpzfSxsPSh0K2UpLzIsaD0oZStpKS8yLF89KGkrcykvMix1PShsK2gpLzIsYz0oaCtfKS8yLGY9KGMtdSkvODtyZXR1cm4gci5iPWwrKHQtbCkvNCxuLmI9dStmLHIuYz1uLmE9KHIuYituLmIpLzIsbi5jPWEuYT0odStjKS8yLGEuYj1jLWYsby5iPV8rKHMtXykvNCxhLmM9by5hPShhLmIrby5iKS8yLFtyLG4sYSxvXX0saD1mdW5jdGlvbih0LHIsbixhLG8pe3ZhciBoLF8sdSxjLGYscCxtLGQsZyx2LHksVCx4LHc9dC5sZW5ndGgtMSxiPTAsUD10WzBdLmE7Zm9yKGg9MDt3Pmg7aCsrKWY9dFtiXSxfPWYuYSx1PWYuZCxjPXRbYisxXS5kLG8/KHk9ZVtoXSxUPWlbaF0seD0uMjUqKFQreSkqci8oYT8uNTpzW2hdfHwuNSkscD11LSh1LV8pKihhPy41KnI6MCE9PXk/eC95OjApLG09dSsoYy11KSooYT8uNSpyOjAhPT1UP3gvVDowKSxkPXUtKHArKChtLXApKigzKnkvKHkrVCkrLjUpLzR8fDApKSk6KHA9dS0uNSoodS1fKSpyLG09dSsuNSooYy11KSpyLGQ9dS0ocCttKS8yKSxwKz1kLG0rPWQsZi5jPWc9cCxmLmI9MCE9PWg/UDpQPWYuYSsuNiooZi5jLWYuYSksZi5kYT11LV8sZi5jYT1nLV8sZi5iYT1QLV8sbj8odj1sKF8sUCxnLHUpLHQuc3BsaWNlKGIsMSx2WzBdLHZbMV0sdlsyXSx2WzNdKSxiKz00KTpiKyssUD1tO2Y9dFtiXSxmLmI9UCxmLmM9UCsuNCooZi5kLVApLGYuZGE9Zi5kLWYuYSxmLmNhPWYuYy1mLmEsZi5iYT1QLWYuYSxuJiYodj1sKGYuYSxQLGYuYyxmLmQpLHQuc3BsaWNlKGIsMSx2WzBdLHZbMV0sdlsyXSx2WzNdKSl9LF89ZnVuY3Rpb24odCxzLHIsbil7dmFyIG8sbCxoLF8sdSxjLGY9W107aWYobilmb3IodD1bbl0uY29uY2F0KHQpLGw9dC5sZW5ndGg7LS1sPi0xOylcInN0cmluZ1wiPT10eXBlb2YoYz10W2xdW3NdKSYmXCI9XCI9PT1jLmNoYXJBdCgxKSYmKHRbbF1bc109bltzXStOdW1iZXIoYy5jaGFyQXQoMCkrYy5zdWJzdHIoMikpKTtpZihvPXQubGVuZ3RoLTIsMD5vKXJldHVybiBmWzBdPW5ldyBhKHRbMF1bc10sMCwwLHRbLTE+bz8wOjFdW3NdKSxmO2ZvcihsPTA7bz5sO2wrKyloPXRbbF1bc10sXz10W2wrMV1bc10sZltsXT1uZXcgYShoLDAsMCxfKSxyJiYodT10W2wrMl1bc10sZVtsXT0oZVtsXXx8MCkrKF8taCkqKF8taCksaVtsXT0oaVtsXXx8MCkrKHUtXykqKHUtXykpO3JldHVybiBmW2xdPW5ldyBhKHRbbF1bc10sMCwwLHRbbCsxXVtzXSksZn0sdT1mdW5jdGlvbih0LG4sYSxsLHUsYyl7dmFyIGYscCxtLGQsZyx2LHksVCx4PXt9LHc9W10sYj1jfHx0WzBdO3U9XCJzdHJpbmdcIj09dHlwZW9mIHU/XCIsXCIrdStcIixcIjpvLG51bGw9PW4mJihuPTEpO2ZvcihwIGluIHRbMF0pdy5wdXNoKHApO2lmKHQubGVuZ3RoPjEpe2ZvcihUPXRbdC5sZW5ndGgtMV0seT0hMCxmPXcubGVuZ3RoOy0tZj4tMTspaWYocD13W2ZdLE1hdGguYWJzKGJbcF0tVFtwXSk+LjA1KXt5PSExO2JyZWFrfXkmJih0PXQuY29uY2F0KCksYyYmdC51bnNoaWZ0KGMpLHQucHVzaCh0WzFdKSxjPXRbdC5sZW5ndGgtM10pfWZvcihlLmxlbmd0aD1pLmxlbmd0aD1zLmxlbmd0aD0wLGY9dy5sZW5ndGg7LS1mPi0xOylwPXdbZl0scltwXT0tMSE9PXUuaW5kZXhPZihcIixcIitwK1wiLFwiKSx4W3BdPV8odCxwLHJbcF0sYyk7Zm9yKGY9ZS5sZW5ndGg7LS1mPi0xOyllW2ZdPU1hdGguc3FydChlW2ZdKSxpW2ZdPU1hdGguc3FydChpW2ZdKTtpZighbCl7Zm9yKGY9dy5sZW5ndGg7LS1mPi0xOylpZihyW3BdKWZvcihtPXhbd1tmXV0sdj1tLmxlbmd0aC0xLGQ9MDt2PmQ7ZCsrKWc9bVtkKzFdLmRhL2lbZF0rbVtkXS5kYS9lW2RdLHNbZF09KHNbZF18fDApK2cqZztmb3IoZj1zLmxlbmd0aDstLWY+LTE7KXNbZl09TWF0aC5zcXJ0KHNbZl0pfWZvcihmPXcubGVuZ3RoLGQ9YT80OjE7LS1mPi0xOylwPXdbZl0sbT14W3BdLGgobSxuLGEsbCxyW3BdKSx5JiYobS5zcGxpY2UoMCxkKSxtLnNwbGljZShtLmxlbmd0aC1kLGQpKTtyZXR1cm4geH0sYz1mdW5jdGlvbih0LGUsaSl7ZT1lfHxcInNvZnRcIjt2YXIgcyxyLG4sbyxsLGgsXyx1LGMsZixwLG09e30sZD1cImN1YmljXCI9PT1lPzM6MixnPVwic29mdFwiPT09ZSx2PVtdO2lmKGcmJmkmJih0PVtpXS5jb25jYXQodCkpLG51bGw9PXR8fGQrMT50Lmxlbmd0aCl0aHJvd1wiaW52YWxpZCBCZXppZXIgZGF0YVwiO2ZvcihjIGluIHRbMF0pdi5wdXNoKGMpO2ZvcihoPXYubGVuZ3RoOy0taD4tMTspe2ZvcihjPXZbaF0sbVtjXT1sPVtdLGY9MCx1PXQubGVuZ3RoLF89MDt1Pl87XysrKXM9bnVsbD09aT90W19dW2NdOlwic3RyaW5nXCI9PXR5cGVvZihwPXRbX11bY10pJiZcIj1cIj09PXAuY2hhckF0KDEpP2lbY10rTnVtYmVyKHAuY2hhckF0KDApK3Auc3Vic3RyKDIpKTpOdW1iZXIocCksZyYmXz4xJiZ1LTE+XyYmKGxbZisrXT0ocytsW2YtMl0pLzIpLGxbZisrXT1zO2Zvcih1PWYtZCsxLGY9MCxfPTA7dT5fO18rPWQpcz1sW19dLHI9bFtfKzFdLG49bFtfKzJdLG89Mj09PWQ/MDpsW18rM10sbFtmKytdPXA9Mz09PWQ/bmV3IGEocyxyLG4sbyk6bmV3IGEocywoMipyK3MpLzMsKDIqcituKS8zLG4pO2wubGVuZ3RoPWZ9cmV0dXJuIG19LGY9ZnVuY3Rpb24odCxlLGkpe2Zvcih2YXIgcyxyLG4sYSxvLGwsaCxfLHUsYyxmLHA9MS9pLG09dC5sZW5ndGg7LS1tPi0xOylmb3IoYz10W21dLG49Yy5hLGE9Yy5kLW4sbz1jLmMtbixsPWMuYi1uLHM9cj0wLF89MTtpPj1fO18rKyloPXAqXyx1PTEtaCxzPXItKHI9KGgqaCphKzMqdSooaCpvK3UqbCkpKmgpLGY9bSppK18tMSxlW2ZdPShlW2ZdfHwwKStzKnN9LHA9ZnVuY3Rpb24odCxlKXtlPWU+PjB8fDY7dmFyIGkscyxyLG4sYT1bXSxvPVtdLGw9MCxoPTAsXz1lLTEsdT1bXSxjPVtdO2ZvcihpIGluIHQpZih0W2ldLGEsZSk7Zm9yKHI9YS5sZW5ndGgscz0wO3I+cztzKyspbCs9TWF0aC5zcXJ0KGFbc10pLG49cyVlLGNbbl09bCxuPT09XyYmKGgrPWwsbj1zL2U+PjAsdVtuXT1jLG9bbl09aCxsPTAsYz1bXSk7cmV0dXJue2xlbmd0aDpoLGxlbmd0aHM6byxzZWdtZW50czp1fX0sbT1fZ3NTY29wZS5fZ3NEZWZpbmUucGx1Z2luKHtwcm9wTmFtZTpcImJlemllclwiLHByaW9yaXR5Oi0xLHZlcnNpb246XCIxLjMuNFwiLEFQSToyLGdsb2JhbDohMCxpbml0OmZ1bmN0aW9uKHQsZSxpKXt0aGlzLl90YXJnZXQ9dCxlIGluc3RhbmNlb2YgQXJyYXkmJihlPXt2YWx1ZXM6ZX0pLHRoaXMuX2Z1bmM9e30sdGhpcy5fcm91bmQ9e30sdGhpcy5fcHJvcHM9W10sdGhpcy5fdGltZVJlcz1udWxsPT1lLnRpbWVSZXNvbHV0aW9uPzY6cGFyc2VJbnQoZS50aW1lUmVzb2x1dGlvbiwxMCk7dmFyIHMscixuLGEsbyxsPWUudmFsdWVzfHxbXSxoPXt9LF89bFswXSxmPWUuYXV0b1JvdGF0ZXx8aS52YXJzLm9yaWVudFRvQmV6aWVyO3RoaXMuX2F1dG9Sb3RhdGU9Zj9mIGluc3RhbmNlb2YgQXJyYXk/ZjpbW1wieFwiLFwieVwiLFwicm90YXRpb25cIixmPT09ITA/MDpOdW1iZXIoZil8fDBdXTpudWxsO1xuZm9yKHMgaW4gXyl0aGlzLl9wcm9wcy5wdXNoKHMpO2ZvcihuPXRoaXMuX3Byb3BzLmxlbmd0aDstLW4+LTE7KXM9dGhpcy5fcHJvcHNbbl0sdGhpcy5fb3ZlcndyaXRlUHJvcHMucHVzaChzKSxyPXRoaXMuX2Z1bmNbc109XCJmdW5jdGlvblwiPT10eXBlb2YgdFtzXSxoW3NdPXI/dFtzLmluZGV4T2YoXCJzZXRcIil8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIHRbXCJnZXRcIitzLnN1YnN0cigzKV0/czpcImdldFwiK3Muc3Vic3RyKDMpXSgpOnBhcnNlRmxvYXQodFtzXSksb3x8aFtzXSE9PWxbMF1bc10mJihvPWgpO2lmKHRoaXMuX2JlemllcnM9XCJjdWJpY1wiIT09ZS50eXBlJiZcInF1YWRyYXRpY1wiIT09ZS50eXBlJiZcInNvZnRcIiE9PWUudHlwZT91KGwsaXNOYU4oZS5jdXJ2aW5lc3MpPzE6ZS5jdXJ2aW5lc3MsITEsXCJ0aHJ1QmFzaWNcIj09PWUudHlwZSxlLmNvcnJlbGF0ZSxvKTpjKGwsZS50eXBlLGgpLHRoaXMuX3NlZ0NvdW50PXRoaXMuX2JlemllcnNbc10ubGVuZ3RoLHRoaXMuX3RpbWVSZXMpe3ZhciBtPXAodGhpcy5fYmV6aWVycyx0aGlzLl90aW1lUmVzKTt0aGlzLl9sZW5ndGg9bS5sZW5ndGgsdGhpcy5fbGVuZ3Rocz1tLmxlbmd0aHMsdGhpcy5fc2VnbWVudHM9bS5zZWdtZW50cyx0aGlzLl9sMT10aGlzLl9saT10aGlzLl9zMT10aGlzLl9zaT0wLHRoaXMuX2wyPXRoaXMuX2xlbmd0aHNbMF0sdGhpcy5fY3VyU2VnPXRoaXMuX3NlZ21lbnRzWzBdLHRoaXMuX3MyPXRoaXMuX2N1clNlZ1swXSx0aGlzLl9wcmVjPTEvdGhpcy5fY3VyU2VnLmxlbmd0aH1pZihmPXRoaXMuX2F1dG9Sb3RhdGUpZm9yKHRoaXMuX2luaXRpYWxSb3RhdGlvbnM9W10sZlswXWluc3RhbmNlb2YgQXJyYXl8fCh0aGlzLl9hdXRvUm90YXRlPWY9W2ZdKSxuPWYubGVuZ3RoOy0tbj4tMTspe2ZvcihhPTA7Mz5hO2ErKylzPWZbbl1bYV0sdGhpcy5fZnVuY1tzXT1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0W3NdP3Rbcy5pbmRleE9mKFwic2V0XCIpfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiB0W1wiZ2V0XCIrcy5zdWJzdHIoMyldP3M6XCJnZXRcIitzLnN1YnN0cigzKV06ITE7cz1mW25dWzJdLHRoaXMuX2luaXRpYWxSb3RhdGlvbnNbbl09dGhpcy5fZnVuY1tzXT90aGlzLl9mdW5jW3NdLmNhbGwodGhpcy5fdGFyZ2V0KTp0aGlzLl90YXJnZXRbc119cmV0dXJuIHRoaXMuX3N0YXJ0UmF0aW89aS52YXJzLnJ1bkJhY2t3YXJkcz8xOjAsITB9LHNldDpmdW5jdGlvbihlKXt2YXIgaSxzLHIsbixhLG8sbCxoLF8sdSxjPXRoaXMuX3NlZ0NvdW50LGY9dGhpcy5fZnVuYyxwPXRoaXMuX3RhcmdldCxtPWUhPT10aGlzLl9zdGFydFJhdGlvO2lmKHRoaXMuX3RpbWVSZXMpe2lmKF89dGhpcy5fbGVuZ3Rocyx1PXRoaXMuX2N1clNlZyxlKj10aGlzLl9sZW5ndGgscj10aGlzLl9saSxlPnRoaXMuX2wyJiZjLTE+cil7Zm9yKGg9Yy0xO2g+ciYmZT49KHRoaXMuX2wyPV9bKytyXSk7KTt0aGlzLl9sMT1fW3ItMV0sdGhpcy5fbGk9cix0aGlzLl9jdXJTZWc9dT10aGlzLl9zZWdtZW50c1tyXSx0aGlzLl9zMj11W3RoaXMuX3MxPXRoaXMuX3NpPTBdfWVsc2UgaWYodGhpcy5fbDE+ZSYmcj4wKXtmb3IoO3I+MCYmKHRoaXMuX2wxPV9bLS1yXSk+PWU7KTswPT09ciYmdGhpcy5fbDE+ZT90aGlzLl9sMT0wOnIrKyx0aGlzLl9sMj1fW3JdLHRoaXMuX2xpPXIsdGhpcy5fY3VyU2VnPXU9dGhpcy5fc2VnbWVudHNbcl0sdGhpcy5fczE9dVsodGhpcy5fc2k9dS5sZW5ndGgtMSktMV18fDAsdGhpcy5fczI9dVt0aGlzLl9zaV19aWYoaT1yLGUtPXRoaXMuX2wxLHI9dGhpcy5fc2ksZT50aGlzLl9zMiYmdS5sZW5ndGgtMT5yKXtmb3IoaD11Lmxlbmd0aC0xO2g+ciYmZT49KHRoaXMuX3MyPXVbKytyXSk7KTt0aGlzLl9zMT11W3ItMV0sdGhpcy5fc2k9cn1lbHNlIGlmKHRoaXMuX3MxPmUmJnI+MCl7Zm9yKDtyPjAmJih0aGlzLl9zMT11Wy0tcl0pPj1lOyk7MD09PXImJnRoaXMuX3MxPmU/dGhpcy5fczE9MDpyKyssdGhpcy5fczI9dVtyXSx0aGlzLl9zaT1yfW89KHIrKGUtdGhpcy5fczEpLyh0aGlzLl9zMi10aGlzLl9zMSkpKnRoaXMuX3ByZWN9ZWxzZSBpPTA+ZT8wOmU+PTE/Yy0xOmMqZT4+MCxvPShlLWkqKDEvYykpKmM7Zm9yKHM9MS1vLHI9dGhpcy5fcHJvcHMubGVuZ3RoOy0tcj4tMTspbj10aGlzLl9wcm9wc1tyXSxhPXRoaXMuX2JlemllcnNbbl1baV0sbD0obypvKmEuZGErMypzKihvKmEuY2ErcyphLmJhKSkqbythLmEsdGhpcy5fcm91bmRbbl0mJihsPU1hdGgucm91bmQobCkpLGZbbl0/cFtuXShsKTpwW25dPWw7aWYodGhpcy5fYXV0b1JvdGF0ZSl7dmFyIGQsZyx2LHksVCx4LHcsYj10aGlzLl9hdXRvUm90YXRlO2ZvcihyPWIubGVuZ3RoOy0tcj4tMTspbj1iW3JdWzJdLHg9YltyXVszXXx8MCx3PWJbcl1bNF09PT0hMD8xOnQsYT10aGlzLl9iZXppZXJzW2Jbcl1bMF1dLGQ9dGhpcy5fYmV6aWVyc1tiW3JdWzFdXSxhJiZkJiYoYT1hW2ldLGQ9ZFtpXSxnPWEuYSsoYS5iLWEuYSkqbyx5PWEuYisoYS5jLWEuYikqbyxnKz0oeS1nKSpvLHkrPShhLmMrKGEuZC1hLmMpKm8teSkqbyx2PWQuYSsoZC5iLWQuYSkqbyxUPWQuYisoZC5jLWQuYikqbyx2Kz0oVC12KSpvLFQrPShkLmMrKGQuZC1kLmMpKm8tVCkqbyxsPW0/TWF0aC5hdGFuMihULXYseS1nKSp3K3g6dGhpcy5faW5pdGlhbFJvdGF0aW9uc1tyXSxmW25dP3Bbbl0obCk6cFtuXT1sKX19fSksZD1tLnByb3RvdHlwZTttLmJlemllclRocm91Z2g9dSxtLmN1YmljVG9RdWFkcmF0aWM9bCxtLl9hdXRvQ1NTPSEwLG0ucXVhZHJhdGljVG9DdWJpYz1mdW5jdGlvbih0LGUsaSl7cmV0dXJuIG5ldyBhKHQsKDIqZSt0KS8zLCgyKmUraSkvMyxpKX0sbS5fY3NzUmVnaXN0ZXI9ZnVuY3Rpb24oKXt2YXIgdD1uLkNTU1BsdWdpbjtpZih0KXt2YXIgZT10Ll9pbnRlcm5hbHMsaT1lLl9wYXJzZVRvUHJveHkscz1lLl9zZXRQbHVnaW5SYXRpbyxyPWUuQ1NTUHJvcFR3ZWVuO2UuX3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYmV6aWVyXCIse3BhcnNlcjpmdW5jdGlvbih0LGUsbixhLG8sbCl7ZSBpbnN0YW5jZW9mIEFycmF5JiYoZT17dmFsdWVzOmV9KSxsPW5ldyBtO3ZhciBoLF8sdSxjPWUudmFsdWVzLGY9Yy5sZW5ndGgtMSxwPVtdLGQ9e307aWYoMD5mKXJldHVybiBvO2ZvcihoPTA7Zj49aDtoKyspdT1pKHQsY1toXSxhLG8sbCxmIT09aCkscFtoXT11LmVuZDtmb3IoXyBpbiBlKWRbX109ZVtfXTtyZXR1cm4gZC52YWx1ZXM9cCxvPW5ldyByKHQsXCJiZXppZXJcIiwwLDAsdS5wdCwyKSxvLmRhdGE9dSxvLnBsdWdpbj1sLG8uc2V0UmF0aW89cywwPT09ZC5hdXRvUm90YXRlJiYoZC5hdXRvUm90YXRlPSEwKSwhZC5hdXRvUm90YXRlfHxkLmF1dG9Sb3RhdGUgaW5zdGFuY2VvZiBBcnJheXx8KGg9ZC5hdXRvUm90YXRlPT09ITA/MDpOdW1iZXIoZC5hdXRvUm90YXRlKSxkLmF1dG9Sb3RhdGU9bnVsbCE9dS5lbmQubGVmdD9bW1wibGVmdFwiLFwidG9wXCIsXCJyb3RhdGlvblwiLGgsITFdXTpudWxsIT11LmVuZC54P1tbXCJ4XCIsXCJ5XCIsXCJyb3RhdGlvblwiLGgsITFdXTohMSksZC5hdXRvUm90YXRlJiYoYS5fdHJhbnNmb3JtfHxhLl9lbmFibGVUcmFuc2Zvcm1zKCExKSx1LmF1dG9Sb3RhdGU9YS5fdGFyZ2V0Ll9nc1RyYW5zZm9ybSksbC5fb25Jbml0VHdlZW4odS5wcm94eSxkLGEuX3R3ZWVuKSxvfX0pfX0sZC5fcm91bmRQcm9wcz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgaT10aGlzLl9vdmVyd3JpdGVQcm9wcyxzPWkubGVuZ3RoOy0tcz4tMTspKHRbaVtzXV18fHQuYmV6aWVyfHx0LmJlemllclRocm91Z2gpJiYodGhpcy5fcm91bmRbaVtzXV09ZSl9LGQuX2tpbGw9ZnVuY3Rpb24odCl7dmFyIGUsaSxzPXRoaXMuX3Byb3BzO2ZvcihlIGluIHRoaXMuX2JlemllcnMpaWYoZSBpbiB0KWZvcihkZWxldGUgdGhpcy5fYmV6aWVyc1tlXSxkZWxldGUgdGhpcy5fZnVuY1tlXSxpPXMubGVuZ3RoOy0taT4tMTspc1tpXT09PWUmJnMuc3BsaWNlKGksMSk7cmV0dXJuIHRoaXMuX3N1cGVyLl9raWxsLmNhbGwodGhpcyx0KX19KCksX2dzU2NvcGUuX2dzRGVmaW5lKFwicGx1Z2lucy5DU1NQbHVnaW5cIixbXCJwbHVnaW5zLlR3ZWVuUGx1Z2luXCIsXCJUd2VlbkxpdGVcIl0sZnVuY3Rpb24odCxlKXt2YXIgaSxzLHIsbixhPWZ1bmN0aW9uKCl7dC5jYWxsKHRoaXMsXCJjc3NcIiksdGhpcy5fb3ZlcndyaXRlUHJvcHMubGVuZ3RoPTAsdGhpcy5zZXRSYXRpbz1hLnByb3RvdHlwZS5zZXRSYXRpb30sbz1fZ3NTY29wZS5fZ3NEZWZpbmUuZ2xvYmFscyxsPXt9LGg9YS5wcm90b3R5cGU9bmV3IHQoXCJjc3NcIik7aC5jb25zdHJ1Y3Rvcj1hLGEudmVyc2lvbj1cIjEuMTguMFwiLGEuQVBJPTIsYS5kZWZhdWx0VHJhbnNmb3JtUGVyc3BlY3RpdmU9MCxhLmRlZmF1bHRTa2V3VHlwZT1cImNvbXBlbnNhdGVkXCIsYS5kZWZhdWx0U21vb3RoT3JpZ2luPSEwLGg9XCJweFwiLGEuc3VmZml4TWFwPXt0b3A6aCxyaWdodDpoLGJvdHRvbTpoLGxlZnQ6aCx3aWR0aDpoLGhlaWdodDpoLGZvbnRTaXplOmgscGFkZGluZzpoLG1hcmdpbjpoLHBlcnNwZWN0aXZlOmgsbGluZUhlaWdodDpcIlwifTt2YXIgXyx1LGMsZixwLG0sZD0vKD86XFxkfFxcLVxcZHxcXC5cXGR8XFwtXFwuXFxkKSsvZyxnPS8oPzpcXGR8XFwtXFxkfFxcLlxcZHxcXC1cXC5cXGR8XFwrPVxcZHxcXC09XFxkfFxcKz0uXFxkfFxcLT1cXC5cXGQpKy9nLHY9Lyg/OlxcKz18XFwtPXxcXC18XFxiKVtcXGRcXC1cXC5dK1thLXpBLVowLTldKig/OiV8XFxiKS9naSx5PS8oPyFbKy1dP1xcZCpcXC4/XFxkK3xbKy1dfGVbKy1dXFxkKylbXjAtOV0vZyxUPS8oPzpcXGR8XFwtfFxcK3w9fCN8XFwuKSovZyx4PS9vcGFjaXR5ICo9ICooW14pXSopL2ksdz0vb3BhY2l0eTooW147XSopL2ksYj0vYWxwaGFcXChvcGFjaXR5ICo9Lis/XFwpL2ksUD0vXihyZ2J8aHNsKS8saz0vKFtBLVpdKS9nLFM9Ly0oW2Etel0pL2dpLFI9LyheKD86dXJsXFwoXFxcInx1cmxcXCgpKXwoPzooXFxcIlxcKSkkfFxcKSQpL2dpLE89ZnVuY3Rpb24odCxlKXtyZXR1cm4gZS50b1VwcGVyQ2FzZSgpfSxBPS8oPzpMZWZ0fFJpZ2h0fFdpZHRoKS9pLEM9LyhNMTF8TTEyfE0yMXxNMjIpPVtcXGRcXC1cXC5lXSsvZ2ksRD0vcHJvZ2lkXFw6RFhJbWFnZVRyYW5zZm9ybVxcLk1pY3Jvc29mdFxcLk1hdHJpeFxcKC4rP1xcKS9pLE09LywoPz1bXlxcKV0qKD86XFwofCQpKS9naSx6PU1hdGguUEkvMTgwLEY9MTgwL01hdGguUEksST17fSxFPWRvY3VtZW50LE49ZnVuY3Rpb24odCl7cmV0dXJuIEUuY3JlYXRlRWxlbWVudE5TP0UuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLHQpOkUuY3JlYXRlRWxlbWVudCh0KX0sTD1OKFwiZGl2XCIpLFg9TihcImltZ1wiKSxCPWEuX2ludGVybmFscz17X3NwZWNpYWxQcm9wczpsfSxqPW5hdmlnYXRvci51c2VyQWdlbnQsWT1mdW5jdGlvbigpe3ZhciB0PWouaW5kZXhPZihcIkFuZHJvaWRcIiksZT1OKFwiYVwiKTtyZXR1cm4gYz0tMSE9PWouaW5kZXhPZihcIlNhZmFyaVwiKSYmLTE9PT1qLmluZGV4T2YoXCJDaHJvbWVcIikmJigtMT09PXR8fE51bWJlcihqLnN1YnN0cih0KzgsMSkpPjMpLHA9YyYmNj5OdW1iZXIoai5zdWJzdHIoai5pbmRleE9mKFwiVmVyc2lvbi9cIikrOCwxKSksZj0tMSE9PWouaW5kZXhPZihcIkZpcmVmb3hcIiksKC9NU0lFIChbMC05XXsxLH1bXFwuMC05XXswLH0pLy5leGVjKGopfHwvVHJpZGVudFxcLy4qcnY6KFswLTldezEsfVtcXC4wLTldezAsfSkvLmV4ZWMoaikpJiYobT1wYXJzZUZsb2F0KFJlZ0V4cC4kMSkpLGU/KGUuc3R5bGUuY3NzVGV4dD1cInRvcDoxcHg7b3BhY2l0eTouNTU7XCIsL14wLjU1Ly50ZXN0KGUuc3R5bGUub3BhY2l0eSkpOiExfSgpLFU9ZnVuY3Rpb24odCl7cmV0dXJuIHgudGVzdChcInN0cmluZ1wiPT10eXBlb2YgdD90Oih0LmN1cnJlbnRTdHlsZT90LmN1cnJlbnRTdHlsZS5maWx0ZXI6dC5zdHlsZS5maWx0ZXIpfHxcIlwiKT9wYXJzZUZsb2F0KFJlZ0V4cC4kMSkvMTAwOjF9LHE9ZnVuY3Rpb24odCl7d2luZG93LmNvbnNvbGUmJmNvbnNvbGUubG9nKHQpfSxWPVwiXCIsRz1cIlwiLFc9ZnVuY3Rpb24odCxlKXtlPWV8fEw7dmFyIGkscyxyPWUuc3R5bGU7aWYodm9pZCAwIT09clt0XSlyZXR1cm4gdDtmb3IodD10LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Quc3Vic3RyKDEpLGk9W1wiT1wiLFwiTW96XCIsXCJtc1wiLFwiTXNcIixcIldlYmtpdFwiXSxzPTU7LS1zPi0xJiZ2b2lkIDA9PT1yW2lbc10rdF07KTtyZXR1cm4gcz49MD8oRz0zPT09cz9cIm1zXCI6aVtzXSxWPVwiLVwiK0cudG9Mb3dlckNhc2UoKStcIi1cIixHK3QpOm51bGx9LFo9RS5kZWZhdWx0Vmlldz9FLmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGU6ZnVuY3Rpb24oKXt9LFE9YS5nZXRTdHlsZT1mdW5jdGlvbih0LGUsaSxzLHIpe3ZhciBuO3JldHVybiBZfHxcIm9wYWNpdHlcIiE9PWU/KCFzJiZ0LnN0eWxlW2VdP249dC5zdHlsZVtlXTooaT1pfHxaKHQpKT9uPWlbZV18fGkuZ2V0UHJvcGVydHlWYWx1ZShlKXx8aS5nZXRQcm9wZXJ0eVZhbHVlKGUucmVwbGFjZShrLFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpOnQuY3VycmVudFN0eWxlJiYobj10LmN1cnJlbnRTdHlsZVtlXSksbnVsbD09cnx8biYmXCJub25lXCIhPT1uJiZcImF1dG9cIiE9PW4mJlwiYXV0byBhdXRvXCIhPT1uP246cik6VSh0KX0sJD1CLmNvbnZlcnRUb1BpeGVscz1mdW5jdGlvbih0LGkscyxyLG4pe2lmKFwicHhcIj09PXJ8fCFyKXJldHVybiBzO2lmKFwiYXV0b1wiPT09cnx8IXMpcmV0dXJuIDA7dmFyIG8sbCxoLF89QS50ZXN0KGkpLHU9dCxjPUwuc3R5bGUsZj0wPnM7aWYoZiYmKHM9LXMpLFwiJVwiPT09ciYmLTEhPT1pLmluZGV4T2YoXCJib3JkZXJcIikpbz1zLzEwMCooXz90LmNsaWVudFdpZHRoOnQuY2xpZW50SGVpZ2h0KTtlbHNle2lmKGMuY3NzVGV4dD1cImJvcmRlcjowIHNvbGlkIHJlZDtwb3NpdGlvbjpcIitRKHQsXCJwb3NpdGlvblwiKStcIjtsaW5lLWhlaWdodDowO1wiLFwiJVwiIT09ciYmdS5hcHBlbmRDaGlsZCYmXCJ2XCIhPT1yLmNoYXJBdCgwKSYmXCJyZW1cIiE9PXIpY1tfP1wiYm9yZGVyTGVmdFdpZHRoXCI6XCJib3JkZXJUb3BXaWR0aFwiXT1zK3I7ZWxzZXtpZih1PXQucGFyZW50Tm9kZXx8RS5ib2R5LGw9dS5fZ3NDYWNoZSxoPWUudGlja2VyLmZyYW1lLGwmJl8mJmwudGltZT09PWgpcmV0dXJuIGwud2lkdGgqcy8xMDA7Y1tfP1wid2lkdGhcIjpcImhlaWdodFwiXT1zK3J9dS5hcHBlbmRDaGlsZChMKSxvPXBhcnNlRmxvYXQoTFtfP1wib2Zmc2V0V2lkdGhcIjpcIm9mZnNldEhlaWdodFwiXSksdS5yZW1vdmVDaGlsZChMKSxfJiZcIiVcIj09PXImJmEuY2FjaGVXaWR0aHMhPT0hMSYmKGw9dS5fZ3NDYWNoZT11Ll9nc0NhY2hlfHx7fSxsLnRpbWU9aCxsLndpZHRoPTEwMCooby9zKSksMCE9PW98fG58fChvPSQodCxpLHMsciwhMCkpfXJldHVybiBmPy1vOm99LEg9Qi5jYWxjdWxhdGVPZmZzZXQ9ZnVuY3Rpb24odCxlLGkpe2lmKFwiYWJzb2x1dGVcIiE9PVEodCxcInBvc2l0aW9uXCIsaSkpcmV0dXJuIDA7dmFyIHM9XCJsZWZ0XCI9PT1lP1wiTGVmdFwiOlwiVG9wXCIscj1RKHQsXCJtYXJnaW5cIitzLGkpO3JldHVybiB0W1wib2Zmc2V0XCIrc10tKCQodCxlLHBhcnNlRmxvYXQociksci5yZXBsYWNlKFQsXCJcIikpfHwwKX0sSz1mdW5jdGlvbih0LGUpe3ZhciBpLHMscixuPXt9O2lmKGU9ZXx8Wih0LG51bGwpKWlmKGk9ZS5sZW5ndGgpZm9yKDstLWk+LTE7KXI9ZVtpXSwoLTE9PT1yLmluZGV4T2YoXCItdHJhbnNmb3JtXCIpfHxrZT09PXIpJiYobltyLnJlcGxhY2UoUyxPKV09ZS5nZXRQcm9wZXJ0eVZhbHVlKHIpKTtlbHNlIGZvcihpIGluIGUpKC0xPT09aS5pbmRleE9mKFwiVHJhbnNmb3JtXCIpfHxQZT09PWkpJiYobltpXT1lW2ldKTtlbHNlIGlmKGU9dC5jdXJyZW50U3R5bGV8fHQuc3R5bGUpZm9yKGkgaW4gZSlcInN0cmluZ1wiPT10eXBlb2YgaSYmdm9pZCAwPT09bltpXSYmKG5baS5yZXBsYWNlKFMsTyldPWVbaV0pO3JldHVybiBZfHwobi5vcGFjaXR5PVUodCkpLHM9TmUodCxlLCExKSxuLnJvdGF0aW9uPXMucm90YXRpb24sbi5za2V3WD1zLnNrZXdYLG4uc2NhbGVYPXMuc2NhbGVYLG4uc2NhbGVZPXMuc2NhbGVZLG4ueD1zLngsbi55PXMueSxSZSYmKG4uej1zLnosbi5yb3RhdGlvblg9cy5yb3RhdGlvblgsbi5yb3RhdGlvblk9cy5yb3RhdGlvblksbi5zY2FsZVo9cy5zY2FsZVopLG4uZmlsdGVycyYmZGVsZXRlIG4uZmlsdGVycyxufSxKPWZ1bmN0aW9uKHQsZSxpLHMscil7dmFyIG4sYSxvLGw9e30saD10LnN0eWxlO2ZvcihhIGluIGkpXCJjc3NUZXh0XCIhPT1hJiZcImxlbmd0aFwiIT09YSYmaXNOYU4oYSkmJihlW2FdIT09KG49aVthXSl8fHImJnJbYV0pJiYtMT09PWEuaW5kZXhPZihcIk9yaWdpblwiKSYmKFwibnVtYmVyXCI9PXR5cGVvZiBufHxcInN0cmluZ1wiPT10eXBlb2YgbikmJihsW2FdPVwiYXV0b1wiIT09bnx8XCJsZWZ0XCIhPT1hJiZcInRvcFwiIT09YT9cIlwiIT09biYmXCJhdXRvXCIhPT1uJiZcIm5vbmVcIiE9PW58fFwic3RyaW5nXCIhPXR5cGVvZiBlW2FdfHxcIlwiPT09ZVthXS5yZXBsYWNlKHksXCJcIik/bjowOkgodCxhKSx2b2lkIDAhPT1oW2FdJiYobz1uZXcgcGUoaCxhLGhbYV0sbykpKTtpZihzKWZvcihhIGluIHMpXCJjbGFzc05hbWVcIiE9PWEmJihsW2FdPXNbYV0pO3JldHVybntkaWZzOmwsZmlyc3RNUFQ6b319LHRlPXt3aWR0aDpbXCJMZWZ0XCIsXCJSaWdodFwiXSxoZWlnaHQ6W1wiVG9wXCIsXCJCb3R0b21cIl19LGVlPVtcIm1hcmdpbkxlZnRcIixcIm1hcmdpblJpZ2h0XCIsXCJtYXJnaW5Ub3BcIixcIm1hcmdpbkJvdHRvbVwiXSxpZT1mdW5jdGlvbih0LGUsaSl7dmFyIHM9cGFyc2VGbG9hdChcIndpZHRoXCI9PT1lP3Qub2Zmc2V0V2lkdGg6dC5vZmZzZXRIZWlnaHQpLHI9dGVbZV0sbj1yLmxlbmd0aDtmb3IoaT1pfHxaKHQsbnVsbCk7LS1uPi0xOylzLT1wYXJzZUZsb2F0KFEodCxcInBhZGRpbmdcIityW25dLGksITApKXx8MCxzLT1wYXJzZUZsb2F0KFEodCxcImJvcmRlclwiK3Jbbl0rXCJXaWR0aFwiLGksITApKXx8MDtyZXR1cm4gc30sc2U9ZnVuY3Rpb24odCxlKXtpZihcImNvbnRhaW5cIj09PXR8fFwiYXV0b1wiPT09dHx8XCJhdXRvIGF1dG9cIj09PXQpcmV0dXJuIHQrXCIgXCI7KG51bGw9PXR8fFwiXCI9PT10KSYmKHQ9XCIwIDBcIik7dmFyIGk9dC5zcGxpdChcIiBcIikscz0tMSE9PXQuaW5kZXhPZihcImxlZnRcIik/XCIwJVwiOi0xIT09dC5pbmRleE9mKFwicmlnaHRcIik/XCIxMDAlXCI6aVswXSxyPS0xIT09dC5pbmRleE9mKFwidG9wXCIpP1wiMCVcIjotMSE9PXQuaW5kZXhPZihcImJvdHRvbVwiKT9cIjEwMCVcIjppWzFdO3JldHVybiBudWxsPT1yP3I9XCJjZW50ZXJcIj09PXM/XCI1MCVcIjpcIjBcIjpcImNlbnRlclwiPT09ciYmKHI9XCI1MCVcIiksKFwiY2VudGVyXCI9PT1zfHxpc05hTihwYXJzZUZsb2F0KHMpKSYmLTE9PT0ocytcIlwiKS5pbmRleE9mKFwiPVwiKSkmJihzPVwiNTAlXCIpLHQ9cytcIiBcIityKyhpLmxlbmd0aD4yP1wiIFwiK2lbMl06XCJcIiksZSYmKGUub3hwPS0xIT09cy5pbmRleE9mKFwiJVwiKSxlLm95cD0tMSE9PXIuaW5kZXhPZihcIiVcIiksZS5veHI9XCI9XCI9PT1zLmNoYXJBdCgxKSxlLm95cj1cIj1cIj09PXIuY2hhckF0KDEpLGUub3g9cGFyc2VGbG9hdChzLnJlcGxhY2UoeSxcIlwiKSksZS5veT1wYXJzZUZsb2F0KHIucmVwbGFjZSh5LFwiXCIpKSxlLnY9dCksZXx8dH0scmU9ZnVuY3Rpb24odCxlKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdCYmXCI9XCI9PT10LmNoYXJBdCgxKT9wYXJzZUludCh0LmNoYXJBdCgwKStcIjFcIiwxMCkqcGFyc2VGbG9hdCh0LnN1YnN0cigyKSk6cGFyc2VGbG9hdCh0KS1wYXJzZUZsb2F0KGUpfSxuZT1mdW5jdGlvbih0LGUpe3JldHVybiBudWxsPT10P2U6XCJzdHJpbmdcIj09dHlwZW9mIHQmJlwiPVwiPT09dC5jaGFyQXQoMSk/cGFyc2VJbnQodC5jaGFyQXQoMCkrXCIxXCIsMTApKnBhcnNlRmxvYXQodC5zdWJzdHIoMikpK2U6cGFyc2VGbG9hdCh0KX0sYWU9ZnVuY3Rpb24odCxlLGkscyl7dmFyIHIsbixhLG8sbCxoPTFlLTY7cmV0dXJuIG51bGw9PXQ/bz1lOlwibnVtYmVyXCI9PXR5cGVvZiB0P289dDoocj0zNjAsbj10LnNwbGl0KFwiX1wiKSxsPVwiPVwiPT09dC5jaGFyQXQoMSksYT0obD9wYXJzZUludCh0LmNoYXJBdCgwKStcIjFcIiwxMCkqcGFyc2VGbG9hdChuWzBdLnN1YnN0cigyKSk6cGFyc2VGbG9hdChuWzBdKSkqKC0xPT09dC5pbmRleE9mKFwicmFkXCIpPzE6RiktKGw/MDplKSxuLmxlbmd0aCYmKHMmJihzW2ldPWUrYSksLTEhPT10LmluZGV4T2YoXCJzaG9ydFwiKSYmKGElPXIsYSE9PWElKHIvMikmJihhPTA+YT9hK3I6YS1yKSksLTEhPT10LmluZGV4T2YoXCJfY3dcIikmJjA+YT9hPShhKzk5OTk5OTk5OTkqciklci0oMHxhL3IpKnI6LTEhPT10LmluZGV4T2YoXCJjY3dcIikmJmE+MCYmKGE9KGEtOTk5OTk5OTk5OSpyKSVyLSgwfGEvcikqcikpLG89ZSthKSxoPm8mJm8+LWgmJihvPTApLG99LG9lPXthcXVhOlswLDI1NSwyNTVdLGxpbWU6WzAsMjU1LDBdLHNpbHZlcjpbMTkyLDE5MiwxOTJdLGJsYWNrOlswLDAsMF0sbWFyb29uOlsxMjgsMCwwXSx0ZWFsOlswLDEyOCwxMjhdLGJsdWU6WzAsMCwyNTVdLG5hdnk6WzAsMCwxMjhdLHdoaXRlOlsyNTUsMjU1LDI1NV0sZnVjaHNpYTpbMjU1LDAsMjU1XSxvbGl2ZTpbMTI4LDEyOCwwXSx5ZWxsb3c6WzI1NSwyNTUsMF0sb3JhbmdlOlsyNTUsMTY1LDBdLGdyYXk6WzEyOCwxMjgsMTI4XSxwdXJwbGU6WzEyOCwwLDEyOF0sZ3JlZW46WzAsMTI4LDBdLHJlZDpbMjU1LDAsMF0scGluazpbMjU1LDE5MiwyMDNdLGN5YW46WzAsMjU1LDI1NV0sdHJhbnNwYXJlbnQ6WzI1NSwyNTUsMjU1LDBdfSxsZT1mdW5jdGlvbih0LGUsaSl7cmV0dXJuIHQ9MD50P3QrMTp0PjE/dC0xOnQsMHwyNTUqKDE+Nip0P2UrNiooaS1lKSp0Oi41PnQ/aToyPjMqdD9lKzYqKGktZSkqKDIvMy10KTplKSsuNX0saGU9YS5wYXJzZUNvbG9yPWZ1bmN0aW9uKHQsZSl7dmFyIGkscyxyLG4sYSxvLGwsaCxfLHUsYztpZih0KWlmKFwibnVtYmVyXCI9PXR5cGVvZiB0KWk9W3Q+PjE2LDI1NSZ0Pj44LDI1NSZ0XTtlbHNle2lmKFwiLFwiPT09dC5jaGFyQXQodC5sZW5ndGgtMSkmJih0PXQuc3Vic3RyKDAsdC5sZW5ndGgtMSkpLG9lW3RdKWk9b2VbdF07ZWxzZSBpZihcIiNcIj09PXQuY2hhckF0KDApKTQ9PT10Lmxlbmd0aCYmKHM9dC5jaGFyQXQoMSkscj10LmNoYXJBdCgyKSxuPXQuY2hhckF0KDMpLHQ9XCIjXCIrcytzK3IrcituK24pLHQ9cGFyc2VJbnQodC5zdWJzdHIoMSksMTYpLGk9W3Q+PjE2LDI1NSZ0Pj44LDI1NSZ0XTtlbHNlIGlmKFwiaHNsXCI9PT10LnN1YnN0cigwLDMpKWlmKGk9Yz10Lm1hdGNoKGQpLGUpe2lmKC0xIT09dC5pbmRleE9mKFwiPVwiKSlyZXR1cm4gdC5tYXRjaChnKX1lbHNlIGE9TnVtYmVyKGlbMF0pJTM2MC8zNjAsbz1OdW1iZXIoaVsxXSkvMTAwLGw9TnVtYmVyKGlbMl0pLzEwMCxyPS41Pj1sP2wqKG8rMSk6bCtvLWwqbyxzPTIqbC1yLGkubGVuZ3RoPjMmJihpWzNdPU51bWJlcih0WzNdKSksaVswXT1sZShhKzEvMyxzLHIpLGlbMV09bGUoYSxzLHIpLGlbMl09bGUoYS0xLzMscyxyKTtlbHNlIGk9dC5tYXRjaChkKXx8b2UudHJhbnNwYXJlbnQ7aVswXT1OdW1iZXIoaVswXSksaVsxXT1OdW1iZXIoaVsxXSksaVsyXT1OdW1iZXIoaVsyXSksaS5sZW5ndGg+MyYmKGlbM109TnVtYmVyKGlbM10pKX1lbHNlIGk9b2UuYmxhY2s7cmV0dXJuIGUmJiFjJiYocz1pWzBdLzI1NSxyPWlbMV0vMjU1LG49aVsyXS8yNTUsaD1NYXRoLm1heChzLHIsbiksXz1NYXRoLm1pbihzLHIsbiksbD0oaCtfKS8yLGg9PT1fP2E9bz0wOih1PWgtXyxvPWw+LjU/dS8oMi1oLV8pOnUvKGgrXyksYT1oPT09cz8oci1uKS91KyhuPnI/NjowKTpoPT09cj8obi1zKS91KzI6KHMtcikvdSs0LGEqPTYwKSxpWzBdPTB8YSsuNSxpWzFdPTB8MTAwKm8rLjUsaVsyXT0wfDEwMCpsKy41KSxpfSxfZT1mdW5jdGlvbih0LGUpe3ZhciBpLHMscixuPXQubWF0Y2godWUpfHxbXSxhPTAsbz1uLmxlbmd0aD9cIlwiOnQ7Zm9yKGk9MDtuLmxlbmd0aD5pO2krKylzPW5baV0scj10LnN1YnN0cihhLHQuaW5kZXhPZihzLGEpLWEpLGErPXIubGVuZ3RoK3MubGVuZ3RoLHM9aGUocyxlKSwzPT09cy5sZW5ndGgmJnMucHVzaCgxKSxvKz1yKyhlP1wiaHNsYShcIitzWzBdK1wiLFwiK3NbMV0rXCIlLFwiK3NbMl0rXCIlLFwiK3NbM106XCJyZ2JhKFwiK3Muam9pbihcIixcIikpK1wiKVwiO3JldHVybiBvfSx1ZT1cIig/OlxcXFxiKD86KD86cmdifHJnYmF8aHNsfGhzbGEpXFxcXCguKz9cXFxcKSl8XFxcXEIjLis/XFxcXGJcIjtmb3IoaCBpbiBvZSl1ZSs9XCJ8XCIraCtcIlxcXFxiXCI7dWU9UmVnRXhwKHVlK1wiKVwiLFwiZ2lcIiksYS5jb2xvclN0cmluZ0ZpbHRlcj1mdW5jdGlvbih0KXt2YXIgZSxpPXRbMF0rdFsxXTt1ZS5sYXN0SW5kZXg9MCx1ZS50ZXN0KGkpJiYoZT0tMSE9PWkuaW5kZXhPZihcImhzbChcIil8fC0xIT09aS5pbmRleE9mKFwiaHNsYShcIiksdFswXT1fZSh0WzBdLGUpLHRbMV09X2UodFsxXSxlKSl9LGUuZGVmYXVsdFN0cmluZ0ZpbHRlcnx8KGUuZGVmYXVsdFN0cmluZ0ZpbHRlcj1hLmNvbG9yU3RyaW5nRmlsdGVyKTt2YXIgY2U9ZnVuY3Rpb24odCxlLGkscyl7aWYobnVsbD09dClyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIHR9O3ZhciByLG49ZT8odC5tYXRjaCh1ZSl8fFtcIlwiXSlbMF06XCJcIixhPXQuc3BsaXQobikuam9pbihcIlwiKS5tYXRjaCh2KXx8W10sbz10LnN1YnN0cigwLHQuaW5kZXhPZihhWzBdKSksbD1cIilcIj09PXQuY2hhckF0KHQubGVuZ3RoLTEpP1wiKVwiOlwiXCIsaD0tMSE9PXQuaW5kZXhPZihcIiBcIik/XCIgXCI6XCIsXCIsXz1hLmxlbmd0aCx1PV8+MD9hWzBdLnJlcGxhY2UoZCxcIlwiKTpcIlwiO3JldHVybiBfP3I9ZT9mdW5jdGlvbih0KXt2YXIgZSxjLGYscDtpZihcIm51bWJlclwiPT10eXBlb2YgdCl0Kz11O2Vsc2UgaWYocyYmTS50ZXN0KHQpKXtmb3IocD10LnJlcGxhY2UoTSxcInxcIikuc3BsaXQoXCJ8XCIpLGY9MDtwLmxlbmd0aD5mO2YrKylwW2ZdPXIocFtmXSk7cmV0dXJuIHAuam9pbihcIixcIil9aWYoZT0odC5tYXRjaCh1ZSl8fFtuXSlbMF0sYz10LnNwbGl0KGUpLmpvaW4oXCJcIikubWF0Y2godil8fFtdLGY9Yy5sZW5ndGgsXz5mLS0pZm9yKDtfPisrZjspY1tmXT1pP2NbMHwoZi0xKS8yXTphW2ZdO3JldHVybiBvK2Muam9pbihoKStoK2UrbCsoLTEhPT10LmluZGV4T2YoXCJpbnNldFwiKT9cIiBpbnNldFwiOlwiXCIpfTpmdW5jdGlvbih0KXt2YXIgZSxuLGM7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpdCs9dTtlbHNlIGlmKHMmJk0udGVzdCh0KSl7Zm9yKG49dC5yZXBsYWNlKE0sXCJ8XCIpLnNwbGl0KFwifFwiKSxjPTA7bi5sZW5ndGg+YztjKyspbltjXT1yKG5bY10pO3JldHVybiBuLmpvaW4oXCIsXCIpfWlmKGU9dC5tYXRjaCh2KXx8W10sYz1lLmxlbmd0aCxfPmMtLSlmb3IoO18+KytjOyllW2NdPWk/ZVswfChjLTEpLzJdOmFbY107cmV0dXJuIG8rZS5qb2luKGgpK2x9OmZ1bmN0aW9uKHQpe3JldHVybiB0fX0sZmU9ZnVuY3Rpb24odCl7cmV0dXJuIHQ9dC5zcGxpdChcIixcIiksZnVuY3Rpb24oZSxpLHMscixuLGEsbyl7dmFyIGwsaD0oaStcIlwiKS5zcGxpdChcIiBcIik7Zm9yKG89e30sbD0wOzQ+bDtsKyspb1t0W2xdXT1oW2xdPWhbbF18fGhbKGwtMSkvMj4+MF07cmV0dXJuIHIucGFyc2UoZSxvLG4sYSl9fSxwZT0oQi5fc2V0UGx1Z2luUmF0aW89ZnVuY3Rpb24odCl7dGhpcy5wbHVnaW4uc2V0UmF0aW8odCk7Zm9yKHZhciBlLGkscyxyLG49dGhpcy5kYXRhLGE9bi5wcm94eSxvPW4uZmlyc3RNUFQsbD0xZS02O287KWU9YVtvLnZdLG8ucj9lPU1hdGgucm91bmQoZSk6bD5lJiZlPi1sJiYoZT0wKSxvLnRbby5wXT1lLG89by5fbmV4dDtpZihuLmF1dG9Sb3RhdGUmJihuLmF1dG9Sb3RhdGUucm90YXRpb249YS5yb3RhdGlvbiksMT09PXQpZm9yKG89bi5maXJzdE1QVDtvOyl7aWYoaT1vLnQsaS50eXBlKXtpZigxPT09aS50eXBlKXtmb3Iocj1pLnhzMCtpLnMraS54czEscz0xO2kubD5zO3MrKylyKz1pW1wieG5cIitzXStpW1wieHNcIisocysxKV07aS5lPXJ9fWVsc2UgaS5lPWkucytpLnhzMDtvPW8uX25leHR9fSxmdW5jdGlvbih0LGUsaSxzLHIpe3RoaXMudD10LHRoaXMucD1lLHRoaXMudj1pLHRoaXMucj1yLHMmJihzLl9wcmV2PXRoaXMsdGhpcy5fbmV4dD1zKX0pLG1lPShCLl9wYXJzZVRvUHJveHk9ZnVuY3Rpb24odCxlLGkscyxyLG4pe3ZhciBhLG8sbCxoLF8sdT1zLGM9e30sZj17fSxwPWkuX3RyYW5zZm9ybSxtPUk7Zm9yKGkuX3RyYW5zZm9ybT1udWxsLEk9ZSxzPV89aS5wYXJzZSh0LGUscyxyKSxJPW0sbiYmKGkuX3RyYW5zZm9ybT1wLHUmJih1Ll9wcmV2PW51bGwsdS5fcHJldiYmKHUuX3ByZXYuX25leHQ9bnVsbCkpKTtzJiZzIT09dTspe2lmKDE+PXMudHlwZSYmKG89cy5wLGZbb109cy5zK3MuYyxjW29dPXMucyxufHwoaD1uZXcgcGUocyxcInNcIixvLGgscy5yKSxzLmM9MCksMT09PXMudHlwZSkpZm9yKGE9cy5sOy0tYT4wOylsPVwieG5cIithLG89cy5wK1wiX1wiK2wsZltvXT1zLmRhdGFbbF0sY1tvXT1zW2xdLG58fChoPW5ldyBwZShzLGwsbyxoLHMucnhwW2xdKSk7cz1zLl9uZXh0fXJldHVybntwcm94eTpjLGVuZDpmLGZpcnN0TVBUOmgscHQ6X319LEIuQ1NTUHJvcFR3ZWVuPWZ1bmN0aW9uKHQsZSxzLHIsYSxvLGwsaCxfLHUsYyl7dGhpcy50PXQsdGhpcy5wPWUsdGhpcy5zPXMsdGhpcy5jPXIsdGhpcy5uPWx8fGUsdCBpbnN0YW5jZW9mIG1lfHxuLnB1c2godGhpcy5uKSx0aGlzLnI9aCx0aGlzLnR5cGU9b3x8MCxfJiYodGhpcy5wcj1fLGk9ITApLHRoaXMuYj12b2lkIDA9PT11P3M6dSx0aGlzLmU9dm9pZCAwPT09Yz9zK3I6YyxhJiYodGhpcy5fbmV4dD1hLGEuX3ByZXY9dGhpcyl9KSxkZT1mdW5jdGlvbih0LGUsaSxzLHIsbil7dmFyIGE9bmV3IG1lKHQsZSxpLHMtaSxyLC0xLG4pO3JldHVybiBhLmI9aSxhLmU9YS54czA9cyxhfSxnZT1hLnBhcnNlQ29tcGxleD1mdW5jdGlvbih0LGUsaSxzLHIsbixhLG8sbCxoKXtpPWl8fG58fFwiXCIsYT1uZXcgbWUodCxlLDAsMCxhLGg/MjoxLG51bGwsITEsbyxpLHMpLHMrPVwiXCI7dmFyIHUsYyxmLHAsbSx2LHksVCx4LHcsYixQLGssUz1pLnNwbGl0KFwiLCBcIikuam9pbihcIixcIikuc3BsaXQoXCIgXCIpLFI9cy5zcGxpdChcIiwgXCIpLmpvaW4oXCIsXCIpLnNwbGl0KFwiIFwiKSxPPVMubGVuZ3RoLEE9XyE9PSExO2ZvcigoLTEhPT1zLmluZGV4T2YoXCIsXCIpfHwtMSE9PWkuaW5kZXhPZihcIixcIikpJiYoUz1TLmpvaW4oXCIgXCIpLnJlcGxhY2UoTSxcIiwgXCIpLnNwbGl0KFwiIFwiKSxSPVIuam9pbihcIiBcIikucmVwbGFjZShNLFwiLCBcIikuc3BsaXQoXCIgXCIpLE89Uy5sZW5ndGgpLE8hPT1SLmxlbmd0aCYmKFM9KG58fFwiXCIpLnNwbGl0KFwiIFwiKSxPPVMubGVuZ3RoKSxhLnBsdWdpbj1sLGEuc2V0UmF0aW89aCx1ZS5sYXN0SW5kZXg9MCx1PTA7Tz51O3UrKylpZihwPVNbdV0sbT1SW3VdLFQ9cGFyc2VGbG9hdChwKSxUfHwwPT09VClhLmFwcGVuZFh0cmEoXCJcIixULHJlKG0sVCksbS5yZXBsYWNlKGcsXCJcIiksQSYmLTEhPT1tLmluZGV4T2YoXCJweFwiKSwhMCk7ZWxzZSBpZihyJiZ1ZS50ZXN0KHApKVA9XCIsXCI9PT1tLmNoYXJBdChtLmxlbmd0aC0xKT9cIiksXCI6XCIpXCIsaz0tMSE9PW0uaW5kZXhPZihcImhzbFwiKSYmWSxwPWhlKHAsayksbT1oZShtLGspLHg9cC5sZW5ndGgrbS5sZW5ndGg+Nix4JiYhWSYmMD09PW1bM10/KGFbXCJ4c1wiK2EubF0rPWEubD9cIiB0cmFuc3BhcmVudFwiOlwidHJhbnNwYXJlbnRcIixhLmU9YS5lLnNwbGl0KFJbdV0pLmpvaW4oXCJ0cmFuc3BhcmVudFwiKSk6KFl8fCh4PSExKSxrP2EuYXBwZW5kWHRyYSh4P1wiaHNsYShcIjpcImhzbChcIixwWzBdLHJlKG1bMF0scFswXSksXCIsXCIsITEsITApLmFwcGVuZFh0cmEoXCJcIixwWzFdLHJlKG1bMV0scFsxXSksXCIlLFwiLCExKS5hcHBlbmRYdHJhKFwiXCIscFsyXSxyZShtWzJdLHBbMl0pLHg/XCIlLFwiOlwiJVwiK1AsITEpOmEuYXBwZW5kWHRyYSh4P1wicmdiYShcIjpcInJnYihcIixwWzBdLG1bMF0tcFswXSxcIixcIiwhMCwhMCkuYXBwZW5kWHRyYShcIlwiLHBbMV0sbVsxXS1wWzFdLFwiLFwiLCEwKS5hcHBlbmRYdHJhKFwiXCIscFsyXSxtWzJdLXBbMl0seD9cIixcIjpQLCEwKSx4JiYocD00PnAubGVuZ3RoPzE6cFszXSxhLmFwcGVuZFh0cmEoXCJcIixwLCg0Pm0ubGVuZ3RoPzE6bVszXSktcCxQLCExKSkpLHVlLmxhc3RJbmRleD0wO2Vsc2UgaWYodj1wLm1hdGNoKGQpKXtpZih5PW0ubWF0Y2goZyksIXl8fHkubGVuZ3RoIT09di5sZW5ndGgpcmV0dXJuIGE7Zm9yKGY9MCxjPTA7di5sZW5ndGg+YztjKyspYj12W2NdLHc9cC5pbmRleE9mKGIsZiksYS5hcHBlbmRYdHJhKHAuc3Vic3RyKGYsdy1mKSxOdW1iZXIoYikscmUoeVtjXSxiKSxcIlwiLEEmJlwicHhcIj09PXAuc3Vic3RyKHcrYi5sZW5ndGgsMiksMD09PWMpLGY9dytiLmxlbmd0aDthW1wieHNcIithLmxdKz1wLnN1YnN0cihmKX1lbHNlIGFbXCJ4c1wiK2EubF0rPWEubD9cIiBcIitwOnA7aWYoLTEhPT1zLmluZGV4T2YoXCI9XCIpJiZhLmRhdGEpe2ZvcihQPWEueHMwK2EuZGF0YS5zLHU9MTthLmw+dTt1KyspUCs9YVtcInhzXCIrdV0rYS5kYXRhW1wieG5cIit1XTthLmU9UCthW1wieHNcIit1XX1yZXR1cm4gYS5sfHwoYS50eXBlPS0xLGEueHMwPWEuZSksYS54Zmlyc3R8fGF9LHZlPTk7Zm9yKGg9bWUucHJvdG90eXBlLGgubD1oLnByPTA7LS12ZT4wOyloW1wieG5cIit2ZV09MCxoW1wieHNcIit2ZV09XCJcIjtoLnhzMD1cIlwiLGguX25leHQ9aC5fcHJldj1oLnhmaXJzdD1oLmRhdGE9aC5wbHVnaW49aC5zZXRSYXRpbz1oLnJ4cD1udWxsLGguYXBwZW5kWHRyYT1mdW5jdGlvbih0LGUsaSxzLHIsbil7dmFyIGE9dGhpcyxvPWEubDtyZXR1cm4gYVtcInhzXCIrb10rPW4mJm8/XCIgXCIrdDp0fHxcIlwiLGl8fDA9PT1vfHxhLnBsdWdpbj8oYS5sKyssYS50eXBlPWEuc2V0UmF0aW8/MjoxLGFbXCJ4c1wiK2EubF09c3x8XCJcIixvPjA/KGEuZGF0YVtcInhuXCIrb109ZStpLGEucnhwW1wieG5cIitvXT1yLGFbXCJ4blwiK29dPWUsYS5wbHVnaW58fChhLnhmaXJzdD1uZXcgbWUoYSxcInhuXCIrbyxlLGksYS54Zmlyc3R8fGEsMCxhLm4scixhLnByKSxhLnhmaXJzdC54czA9MCksYSk6KGEuZGF0YT17czplK2l9LGEucnhwPXt9LGEucz1lLGEuYz1pLGEucj1yLGEpKTooYVtcInhzXCIrb10rPWUrKHN8fFwiXCIpLGEpfTt2YXIgeWU9ZnVuY3Rpb24odCxlKXtlPWV8fHt9LHRoaXMucD1lLnByZWZpeD9XKHQpfHx0OnQsbFt0XT1sW3RoaXMucF09dGhpcyx0aGlzLmZvcm1hdD1lLmZvcm1hdHRlcnx8Y2UoZS5kZWZhdWx0VmFsdWUsZS5jb2xvcixlLmNvbGxhcHNpYmxlLGUubXVsdGkpLGUucGFyc2VyJiYodGhpcy5wYXJzZT1lLnBhcnNlciksdGhpcy5jbHJzPWUuY29sb3IsdGhpcy5tdWx0aT1lLm11bHRpLHRoaXMua2V5d29yZD1lLmtleXdvcmQsdGhpcy5kZmx0PWUuZGVmYXVsdFZhbHVlLHRoaXMucHI9ZS5wcmlvcml0eXx8MH0sVGU9Qi5fcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3A9ZnVuY3Rpb24odCxlLGkpe1wib2JqZWN0XCIhPXR5cGVvZiBlJiYoZT17cGFyc2VyOml9KTt2YXIgcyxyLG49dC5zcGxpdChcIixcIiksYT1lLmRlZmF1bHRWYWx1ZTtmb3IoaT1pfHxbYV0scz0wO24ubGVuZ3RoPnM7cysrKWUucHJlZml4PTA9PT1zJiZlLnByZWZpeCxlLmRlZmF1bHRWYWx1ZT1pW3NdfHxhLHI9bmV3IHllKG5bc10sZSl9LHhlPWZ1bmN0aW9uKHQpe2lmKCFsW3RdKXt2YXIgZT10LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Quc3Vic3RyKDEpK1wiUGx1Z2luXCI7VGUodCx7cGFyc2VyOmZ1bmN0aW9uKHQsaSxzLHIsbixhLGgpe3ZhciBfPW8uY29tLmdyZWVuc29jay5wbHVnaW5zW2VdO3JldHVybiBfPyhfLl9jc3NSZWdpc3RlcigpLGxbc10ucGFyc2UodCxpLHMscixuLGEsaCkpOihxKFwiRXJyb3I6IFwiK2UrXCIganMgZmlsZSBub3QgbG9hZGVkLlwiKSxuKX19KX19O2g9eWUucHJvdG90eXBlLGgucGFyc2VDb21wbGV4PWZ1bmN0aW9uKHQsZSxpLHMscixuKXt2YXIgYSxvLGwsaCxfLHUsYz10aGlzLmtleXdvcmQ7aWYodGhpcy5tdWx0aSYmKE0udGVzdChpKXx8TS50ZXN0KGUpPyhvPWUucmVwbGFjZShNLFwifFwiKS5zcGxpdChcInxcIiksbD1pLnJlcGxhY2UoTSxcInxcIikuc3BsaXQoXCJ8XCIpKTpjJiYobz1bZV0sbD1baV0pKSxsKXtmb3IoaD1sLmxlbmd0aD5vLmxlbmd0aD9sLmxlbmd0aDpvLmxlbmd0aCxhPTA7aD5hO2ErKyllPW9bYV09b1thXXx8dGhpcy5kZmx0LGk9bFthXT1sW2FdfHx0aGlzLmRmbHQsYyYmKF89ZS5pbmRleE9mKGMpLHU9aS5pbmRleE9mKGMpLF8hPT11JiYoLTE9PT11P29bYV09b1thXS5zcGxpdChjKS5qb2luKFwiXCIpOi0xPT09XyYmKG9bYV0rPVwiIFwiK2MpKSk7ZT1vLmpvaW4oXCIsIFwiKSxpPWwuam9pbihcIiwgXCIpfXJldHVybiBnZSh0LHRoaXMucCxlLGksdGhpcy5jbHJzLHRoaXMuZGZsdCxzLHRoaXMucHIscixuKX0saC5wYXJzZT1mdW5jdGlvbih0LGUsaSxzLG4sYSl7cmV0dXJuIHRoaXMucGFyc2VDb21wbGV4KHQuc3R5bGUsdGhpcy5mb3JtYXQoUSh0LHRoaXMucCxyLCExLHRoaXMuZGZsdCkpLHRoaXMuZm9ybWF0KGUpLG4sYSl9LGEucmVnaXN0ZXJTcGVjaWFsUHJvcD1mdW5jdGlvbih0LGUsaSl7VGUodCx7cGFyc2VyOmZ1bmN0aW9uKHQscyxyLG4sYSxvKXt2YXIgbD1uZXcgbWUodCxyLDAsMCxhLDIsciwhMSxpKTtyZXR1cm4gbC5wbHVnaW49byxsLnNldFJhdGlvPWUodCxzLG4uX3R3ZWVuLHIpLGx9LHByaW9yaXR5Oml9KX0sYS51c2VTVkdUcmFuc2Zvcm1BdHRyPWN8fGY7dmFyIHdlLGJlPVwic2NhbGVYLHNjYWxlWSxzY2FsZVoseCx5LHosc2tld1gsc2tld1kscm90YXRpb24scm90YXRpb25YLHJvdGF0aW9uWSxwZXJzcGVjdGl2ZSx4UGVyY2VudCx5UGVyY2VudFwiLnNwbGl0KFwiLFwiKSxQZT1XKFwidHJhbnNmb3JtXCIpLGtlPVYrXCJ0cmFuc2Zvcm1cIixTZT1XKFwidHJhbnNmb3JtT3JpZ2luXCIpLFJlPW51bGwhPT1XKFwicGVyc3BlY3RpdmVcIiksT2U9Qi5UcmFuc2Zvcm09ZnVuY3Rpb24oKXt0aGlzLnBlcnNwZWN0aXZlPXBhcnNlRmxvYXQoYS5kZWZhdWx0VHJhbnNmb3JtUGVyc3BlY3RpdmUpfHwwLHRoaXMuZm9yY2UzRD1hLmRlZmF1bHRGb3JjZTNEIT09ITEmJlJlP2EuZGVmYXVsdEZvcmNlM0R8fFwiYXV0b1wiOiExfSxBZT13aW5kb3cuU1ZHRWxlbWVudCxDZT1mdW5jdGlvbih0LGUsaSl7dmFyIHMscj1FLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsdCksbj0vKFthLXpdKShbQS1aXSkvZztmb3IocyBpbiBpKXIuc2V0QXR0cmlidXRlTlMobnVsbCxzLnJlcGxhY2UobixcIiQxLSQyXCIpLnRvTG93ZXJDYXNlKCksaVtzXSk7cmV0dXJuIGUuYXBwZW5kQ2hpbGQocikscn0sRGU9RS5kb2N1bWVudEVsZW1lbnQsTWU9ZnVuY3Rpb24oKXt2YXIgdCxlLGkscz1tfHwvQW5kcm9pZC9pLnRlc3QoaikmJiF3aW5kb3cuY2hyb21lO3JldHVybiBFLmNyZWF0ZUVsZW1lbnROUyYmIXMmJih0PUNlKFwic3ZnXCIsRGUpLGU9Q2UoXCJyZWN0XCIsdCx7d2lkdGg6MTAwLGhlaWdodDo1MCx4OjEwMH0pLGk9ZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCxlLnN0eWxlW1NlXT1cIjUwJSA1MCVcIixlLnN0eWxlW1BlXT1cInNjYWxlWCgwLjUpXCIscz1pPT09ZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCYmIShmJiZSZSksRGUucmVtb3ZlQ2hpbGQodCkpLHN9KCksemU9ZnVuY3Rpb24odCxlLGkscyxyKXt2YXIgbixvLGwsaCxfLHUsYyxmLHAsbSxkLGcsdix5LFQ9dC5fZ3NUcmFuc2Zvcm0seD1FZSh0LCEwKTtUJiYodj1ULnhPcmlnaW4seT1ULnlPcmlnaW4pLCghc3x8Mj4obj1zLnNwbGl0KFwiIFwiKSkubGVuZ3RoKSYmKGM9dC5nZXRCQm94KCksZT1zZShlKS5zcGxpdChcIiBcIiksbj1bKC0xIT09ZVswXS5pbmRleE9mKFwiJVwiKT9wYXJzZUZsb2F0KGVbMF0pLzEwMCpjLndpZHRoOnBhcnNlRmxvYXQoZVswXSkpK2MueCwoLTEhPT1lWzFdLmluZGV4T2YoXCIlXCIpP3BhcnNlRmxvYXQoZVsxXSkvMTAwKmMuaGVpZ2h0OnBhcnNlRmxvYXQoZVsxXSkpK2MueV0pLGkueE9yaWdpbj1oPXBhcnNlRmxvYXQoblswXSksaS55T3JpZ2luPV89cGFyc2VGbG9hdChuWzFdKSxzJiZ4IT09SWUmJih1PXhbMF0sYz14WzFdLGY9eFsyXSxwPXhbM10sbT14WzRdLGQ9eFs1XSxnPXUqcC1jKmYsbz1oKihwL2cpK18qKC1mL2cpKyhmKmQtcCptKS9nLGw9aCooLWMvZykrXyoodS9nKS0odSpkLWMqbSkvZyxoPWkueE9yaWdpbj1uWzBdPW8sXz1pLnlPcmlnaW49blsxXT1sKSxUJiYocnx8ciE9PSExJiZhLmRlZmF1bHRTbW9vdGhPcmlnaW4hPT0hMT8obz1oLXYsbD1fLXksVC54T2Zmc2V0Kz1vKnhbMF0rbCp4WzJdLW8sVC55T2Zmc2V0Kz1vKnhbMV0rbCp4WzNdLWwpOlQueE9mZnNldD1ULnlPZmZzZXQ9MCksdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXN2Zy1vcmlnaW5cIixuLmpvaW4oXCIgXCIpKX0sRmU9ZnVuY3Rpb24odCl7cmV0dXJuISEoQWUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQuZ2V0QkJveCYmdC5nZXRDVE0mJighdC5wYXJlbnROb2RlfHx0LnBhcmVudE5vZGUuZ2V0QkJveCYmdC5wYXJlbnROb2RlLmdldENUTSkpfSxJZT1bMSwwLDAsMSwwLDBdLEVlPWZ1bmN0aW9uKHQsZSl7dmFyIGkscyxyLG4sYSxvPXQuX2dzVHJhbnNmb3JtfHxuZXcgT2UsbD0xZTU7aWYoUGU/cz1RKHQsa2UsbnVsbCwhMCk6dC5jdXJyZW50U3R5bGUmJihzPXQuY3VycmVudFN0eWxlLmZpbHRlci5tYXRjaChDKSxzPXMmJjQ9PT1zLmxlbmd0aD9bc1swXS5zdWJzdHIoNCksTnVtYmVyKHNbMl0uc3Vic3RyKDQpKSxOdW1iZXIoc1sxXS5zdWJzdHIoNCkpLHNbM10uc3Vic3RyKDQpLG8ueHx8MCxvLnl8fDBdLmpvaW4oXCIsXCIpOlwiXCIpLGk9IXN8fFwibm9uZVwiPT09c3x8XCJtYXRyaXgoMSwgMCwgMCwgMSwgMCwgMClcIj09PXMsKG8uc3ZnfHx0LmdldEJCb3gmJkZlKHQpKSYmKGkmJi0xIT09KHQuc3R5bGVbUGVdK1wiXCIpLmluZGV4T2YoXCJtYXRyaXhcIikmJihzPXQuc3R5bGVbUGVdLGk9MCkscj10LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKSxpJiZyJiYoLTEhPT1yLmluZGV4T2YoXCJtYXRyaXhcIik/KHM9cixpPTApOi0xIT09ci5pbmRleE9mKFwidHJhbnNsYXRlXCIpJiYocz1cIm1hdHJpeCgxLDAsMCwxLFwiK3IubWF0Y2goLyg/OlxcLXxcXGIpW1xcZFxcLVxcLmVdK1xcYi9naSkuam9pbihcIixcIikrXCIpXCIsaT0wKSkpLGkpcmV0dXJuIEllO2ZvcihyPShzfHxcIlwiKS5tYXRjaCgvKD86XFwtfFxcYilbXFxkXFwtXFwuZV0rXFxiL2dpKXx8W10sdmU9ci5sZW5ndGg7LS12ZT4tMTspbj1OdW1iZXIoclt2ZV0pLHJbdmVdPShhPW4tKG58PTApKT8oMHxhKmwrKDA+YT8tLjU6LjUpKS9sK246bjtyZXR1cm4gZSYmci5sZW5ndGg+Nj9bclswXSxyWzFdLHJbNF0scls1XSxyWzEyXSxyWzEzXV06cn0sTmU9Qi5nZXRUcmFuc2Zvcm09ZnVuY3Rpb24odCxpLHMsbil7aWYodC5fZ3NUcmFuc2Zvcm0mJnMmJiFuKXJldHVybiB0Ll9nc1RyYW5zZm9ybTt2YXIgbyxsLGgsXyx1LGMsZj1zP3QuX2dzVHJhbnNmb3JtfHxuZXcgT2U6bmV3IE9lLHA9MD5mLnNjYWxlWCxtPTJlLTUsZD0xZTUsZz1SZT9wYXJzZUZsb2F0KFEodCxTZSxpLCExLFwiMCAwIDBcIikuc3BsaXQoXCIgXCIpWzJdKXx8Zi56T3JpZ2lufHwwOjAsdj1wYXJzZUZsb2F0KGEuZGVmYXVsdFRyYW5zZm9ybVBlcnNwZWN0aXZlKXx8MDtpZihmLnN2Zz0hKCF0LmdldEJCb3h8fCFGZSh0KSksZi5zdmcmJih6ZSh0LFEodCxTZSxyLCExLFwiNTAlIDUwJVwiKStcIlwiLGYsdC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXN2Zy1vcmlnaW5cIikpLHdlPWEudXNlU1ZHVHJhbnNmb3JtQXR0cnx8TWUpLG89RWUodCksbyE9PUllKXtpZigxNj09PW8ubGVuZ3RoKXt2YXIgeSxULHgsdyxiLFA9b1swXSxrPW9bMV0sUz1vWzJdLFI9b1szXSxPPW9bNF0sQT1vWzVdLEM9b1s2XSxEPW9bN10sTT1vWzhdLHo9b1s5XSxJPW9bMTBdLEU9b1sxMl0sTj1vWzEzXSxMPW9bMTRdLFg9b1sxMV0sQj1NYXRoLmF0YW4yKEMsSSk7Zi56T3JpZ2luJiYoTD0tZi56T3JpZ2luLEU9TSpMLW9bMTJdLE49eipMLW9bMTNdLEw9SSpMK2Yuek9yaWdpbi1vWzE0XSksZi5yb3RhdGlvblg9QipGLEImJih3PU1hdGguY29zKC1CKSxiPU1hdGguc2luKC1CKSx5PU8qdytNKmIsVD1BKncreipiLHg9Qyp3K0kqYixNPU8qLWIrTSp3LHo9QSotYit6KncsST1DKi1iK0kqdyxYPUQqLWIrWCp3LE89eSxBPVQsQz14KSxCPU1hdGguYXRhbjIoTSxJKSxmLnJvdGF0aW9uWT1CKkYsQiYmKHc9TWF0aC5jb3MoLUIpLGI9TWF0aC5zaW4oLUIpLHk9UCp3LU0qYixUPWsqdy16KmIseD1TKnctSSpiLHo9aypiK3oqdyxJPVMqYitJKncsWD1SKmIrWCp3LFA9eSxrPVQsUz14KSxCPU1hdGguYXRhbjIoayxQKSxmLnJvdGF0aW9uPUIqRixCJiYodz1NYXRoLmNvcygtQiksYj1NYXRoLnNpbigtQiksUD1QKncrTypiLFQ9ayp3K0EqYixBPWsqLWIrQSp3LEM9UyotYitDKncsaz1UKSxmLnJvdGF0aW9uWCYmTWF0aC5hYnMoZi5yb3RhdGlvblgpK01hdGguYWJzKGYucm90YXRpb24pPjM1OS45JiYoZi5yb3RhdGlvblg9Zi5yb3RhdGlvbj0wLGYucm90YXRpb25ZKz0xODApLGYuc2NhbGVYPSgwfE1hdGguc3FydChQKlArayprKSpkKy41KS9kLGYuc2NhbGVZPSgwfE1hdGguc3FydChBKkEreip6KSpkKy41KS9kLGYuc2NhbGVaPSgwfE1hdGguc3FydChDKkMrSSpJKSpkKy41KS9kLGYuc2tld1g9MCxmLnBlcnNwZWN0aXZlPVg/MS8oMD5YPy1YOlgpOjAsZi54PUUsZi55PU4sZi56PUwsZi5zdmcmJihmLngtPWYueE9yaWdpbi0oZi54T3JpZ2luKlAtZi55T3JpZ2luKk8pLGYueS09Zi55T3JpZ2luLShmLnlPcmlnaW4qay1mLnhPcmlnaW4qQSkpfWVsc2UgaWYoIShSZSYmIW4mJm8ubGVuZ3RoJiZmLng9PT1vWzRdJiZmLnk9PT1vWzVdJiYoZi5yb3RhdGlvblh8fGYucm90YXRpb25ZKXx8dm9pZCAwIT09Zi54JiZcIm5vbmVcIj09PVEodCxcImRpc3BsYXlcIixpKSkpe3ZhciBqPW8ubGVuZ3RoPj02LFk9aj9vWzBdOjEsVT1vWzFdfHwwLHE9b1syXXx8MCxWPWo/b1szXToxO2YueD1vWzRdfHwwLGYueT1vWzVdfHwwLGg9TWF0aC5zcXJ0KFkqWStVKlUpLF89TWF0aC5zcXJ0KFYqVitxKnEpLHU9WXx8VT9NYXRoLmF0YW4yKFUsWSkqRjpmLnJvdGF0aW9ufHwwLGM9cXx8Vj9NYXRoLmF0YW4yKHEsVikqRit1OmYuc2tld1h8fDAsTWF0aC5hYnMoYyk+OTAmJjI3MD5NYXRoLmFicyhjKSYmKHA/KGgqPS0xLGMrPTA+PXU/MTgwOi0xODAsdSs9MD49dT8xODA6LTE4MCk6KF8qPS0xLGMrPTA+PWM/MTgwOi0xODApKSxmLnNjYWxlWD1oLGYuc2NhbGVZPV8sZi5yb3RhdGlvbj11LGYuc2tld1g9YyxSZSYmKGYucm90YXRpb25YPWYucm90YXRpb25ZPWYuej0wLGYucGVyc3BlY3RpdmU9dixmLnNjYWxlWj0xKSxmLnN2ZyYmKGYueC09Zi54T3JpZ2luLShmLnhPcmlnaW4qWStmLnlPcmlnaW4qcSksZi55LT1mLnlPcmlnaW4tKGYueE9yaWdpbipVK2YueU9yaWdpbipWKSl9Zi56T3JpZ2luPWc7Zm9yKGwgaW4gZiltPmZbbF0mJmZbbF0+LW0mJihmW2xdPTApfXJldHVybiBzJiYodC5fZ3NUcmFuc2Zvcm09ZixmLnN2ZyYmKHdlJiZ0LnN0eWxlW1BlXT9lLmRlbGF5ZWRDYWxsKC4wMDEsZnVuY3Rpb24oKXtqZSh0LnN0eWxlLFBlKX0pOiF3ZSYmdC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIikmJmUuZGVsYXllZENhbGwoLjAwMSxmdW5jdGlvbigpe3QucmVtb3ZlQXR0cmlidXRlKFwidHJhbnNmb3JtXCIpfSkpKSxmfSxMZT1mdW5jdGlvbih0KXt2YXIgZSxpLHM9dGhpcy5kYXRhLHI9LXMucm90YXRpb24qeixuPXIrcy5za2V3WCp6LGE9MWU1LG89KDB8TWF0aC5jb3Mocikqcy5zY2FsZVgqYSkvYSxsPSgwfE1hdGguc2luKHIpKnMuc2NhbGVYKmEpL2EsaD0oMHxNYXRoLnNpbihuKSotcy5zY2FsZVkqYSkvYSxfPSgwfE1hdGguY29zKG4pKnMuc2NhbGVZKmEpL2EsdT10aGlzLnQuc3R5bGUsYz10aGlzLnQuY3VycmVudFN0eWxlO2lmKGMpe2k9bCxsPS1oLGg9LWksZT1jLmZpbHRlcix1LmZpbHRlcj1cIlwiO3ZhciBmLHAsZD10aGlzLnQub2Zmc2V0V2lkdGgsZz10aGlzLnQub2Zmc2V0SGVpZ2h0LHY9XCJhYnNvbHV0ZVwiIT09Yy5wb3NpdGlvbix5PVwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChNMTE9XCIrbytcIiwgTTEyPVwiK2wrXCIsIE0yMT1cIitoK1wiLCBNMjI9XCIrXyx3PXMueCtkKnMueFBlcmNlbnQvMTAwLGI9cy55K2cqcy55UGVyY2VudC8xMDA7aWYobnVsbCE9cy5veCYmKGY9KHMub3hwPy4wMSpkKnMub3g6cy5veCktZC8yLHA9KHMub3lwPy4wMSpnKnMub3k6cy5veSktZy8yLHcrPWYtKGYqbytwKmwpLGIrPXAtKGYqaCtwKl8pKSx2PyhmPWQvMixwPWcvMix5Kz1cIiwgRHg9XCIrKGYtKGYqbytwKmwpK3cpK1wiLCBEeT1cIisocC0oZipoK3AqXykrYikrXCIpXCIpOnkrPVwiLCBzaXppbmdNZXRob2Q9J2F1dG8gZXhwYW5kJylcIix1LmZpbHRlcj0tMSE9PWUuaW5kZXhPZihcIkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChcIik/ZS5yZXBsYWNlKEQseSk6eStcIiBcIitlLCgwPT09dHx8MT09PXQpJiYxPT09byYmMD09PWwmJjA9PT1oJiYxPT09XyYmKHYmJi0xPT09eS5pbmRleE9mKFwiRHg9MCwgRHk9MFwiKXx8eC50ZXN0KGUpJiYxMDAhPT1wYXJzZUZsb2F0KFJlZ0V4cC4kMSl8fC0xPT09ZS5pbmRleE9mKFwiZ3JhZGllbnQoXCImJmUuaW5kZXhPZihcIkFscGhhXCIpKSYmdS5yZW1vdmVBdHRyaWJ1dGUoXCJmaWx0ZXJcIikpLCF2KXt2YXIgUCxrLFMsUj04Pm0/MTotMTtmb3IoZj1zLmllT2Zmc2V0WHx8MCxwPXMuaWVPZmZzZXRZfHwwLHMuaWVPZmZzZXRYPU1hdGgucm91bmQoKGQtKCgwPm8/LW86bykqZCsoMD5sPy1sOmwpKmcpKS8yK3cpLHMuaWVPZmZzZXRZPU1hdGgucm91bmQoKGctKCgwPl8/LV86XykqZysoMD5oPy1oOmgpKmQpKS8yK2IpLHZlPTA7ND52ZTt2ZSsrKWs9ZWVbdmVdLFA9Y1trXSxpPS0xIT09UC5pbmRleE9mKFwicHhcIik/cGFyc2VGbG9hdChQKTokKHRoaXMudCxrLHBhcnNlRmxvYXQoUCksUC5yZXBsYWNlKFQsXCJcIikpfHwwLFM9aSE9PXNba10/Mj52ZT8tcy5pZU9mZnNldFg6LXMuaWVPZmZzZXRZOjI+dmU/Zi1zLmllT2Zmc2V0WDpwLXMuaWVPZmZzZXRZLHVba109KHNba109TWF0aC5yb3VuZChpLVMqKDA9PT12ZXx8Mj09PXZlPzE6UikpKStcInB4XCJ9fX0sWGU9Qi5zZXQzRFRyYW5zZm9ybVJhdGlvPUIuc2V0VHJhbnNmb3JtUmF0aW89ZnVuY3Rpb24odCl7dmFyIGUsaSxzLHIsbixhLG8sbCxoLF8sdSxjLHAsbSxkLGcsdix5LFQseCx3LGIsUCxrPXRoaXMuZGF0YSxTPXRoaXMudC5zdHlsZSxSPWsucm90YXRpb24sTz1rLnJvdGF0aW9uWCxBPWsucm90YXRpb25ZLEM9ay5zY2FsZVgsRD1rLnNjYWxlWSxNPWsuc2NhbGVaLEY9ay54LEk9ay55LEU9ay56LE49ay5zdmcsTD1rLnBlcnNwZWN0aXZlLFg9ay5mb3JjZTNEO2lmKCEoKCgxIT09dCYmMCE9PXR8fFwiYXV0b1wiIT09WHx8dGhpcy50d2Vlbi5fdG90YWxUaW1lIT09dGhpcy50d2Vlbi5fdG90YWxEdXJhdGlvbiYmdGhpcy50d2Vlbi5fdG90YWxUaW1lKSYmWHx8RXx8THx8QXx8TykmJighd2V8fCFOKSYmUmUpKXJldHVybiBSfHxrLnNrZXdYfHxOPyhSKj16LGI9ay5za2V3WCp6LFA9MWU1LGU9TWF0aC5jb3MoUikqQyxyPU1hdGguc2luKFIpKkMsaT1NYXRoLnNpbihSLWIpKi1ELG49TWF0aC5jb3MoUi1iKSpELGImJlwic2ltcGxlXCI9PT1rLnNrZXdUeXBlJiYodj1NYXRoLnRhbihiKSx2PU1hdGguc3FydCgxK3YqdiksaSo9dixuKj12LGsuc2tld1kmJihlKj12LHIqPXYpKSxOJiYoRis9ay54T3JpZ2luLShrLnhPcmlnaW4qZStrLnlPcmlnaW4qaSkray54T2Zmc2V0LEkrPWsueU9yaWdpbi0oay54T3JpZ2luKnIray55T3JpZ2luKm4pK2sueU9mZnNldCx3ZSYmKGsueFBlcmNlbnR8fGsueVBlcmNlbnQpJiYobT10aGlzLnQuZ2V0QkJveCgpLEYrPS4wMSprLnhQZXJjZW50Km0ud2lkdGgsSSs9LjAxKmsueVBlcmNlbnQqbS5oZWlnaHQpLG09MWUtNixtPkYmJkY+LW0mJihGPTApLG0+SSYmST4tbSYmKEk9MCkpLFQ9KDB8ZSpQKS9QK1wiLFwiKygwfHIqUCkvUCtcIixcIisoMHxpKlApL1ArXCIsXCIrKDB8bipQKS9QK1wiLFwiK0YrXCIsXCIrSStcIilcIixOJiZ3ZT90aGlzLnQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsXCJtYXRyaXgoXCIrVCk6U1tQZV09KGsueFBlcmNlbnR8fGsueVBlcmNlbnQ/XCJ0cmFuc2xhdGUoXCIray54UGVyY2VudCtcIiUsXCIray55UGVyY2VudCtcIiUpIG1hdHJpeChcIjpcIm1hdHJpeChcIikrVCk6U1tQZV09KGsueFBlcmNlbnR8fGsueVBlcmNlbnQ/XCJ0cmFuc2xhdGUoXCIray54UGVyY2VudCtcIiUsXCIray55UGVyY2VudCtcIiUpIG1hdHJpeChcIjpcIm1hdHJpeChcIikrQytcIiwwLDAsXCIrRCtcIixcIitGK1wiLFwiK0krXCIpXCIsdm9pZCAwO2lmKGYmJihtPTFlLTQsbT5DJiZDPi1tJiYoQz1NPTJlLTUpLG0+RCYmRD4tbSYmKEQ9TT0yZS01KSwhTHx8ay56fHxrLnJvdGF0aW9uWHx8ay5yb3RhdGlvbll8fChMPTApKSxSfHxrLnNrZXdYKVIqPXosZD1lPU1hdGguY29zKFIpLGc9cj1NYXRoLnNpbihSKSxrLnNrZXdYJiYoUi09ay5za2V3WCp6LGQ9TWF0aC5jb3MoUiksZz1NYXRoLnNpbihSKSxcInNpbXBsZVwiPT09ay5za2V3VHlwZSYmKHY9TWF0aC50YW4oay5za2V3WCp6KSx2PU1hdGguc3FydCgxK3YqdiksZCo9dixnKj12LGsuc2tld1kmJihlKj12LHIqPXYpKSksaT0tZyxuPWQ7ZWxzZXtpZighKEF8fE98fDEhPT1NfHxMfHxOKSlyZXR1cm4gU1tQZV09KGsueFBlcmNlbnR8fGsueVBlcmNlbnQ/XCJ0cmFuc2xhdGUoXCIray54UGVyY2VudCtcIiUsXCIray55UGVyY2VudCtcIiUpIHRyYW5zbGF0ZTNkKFwiOlwidHJhbnNsYXRlM2QoXCIpK0YrXCJweCxcIitJK1wicHgsXCIrRStcInB4KVwiKygxIT09Q3x8MSE9PUQ/XCIgc2NhbGUoXCIrQytcIixcIitEK1wiKVwiOlwiXCIpLHZvaWQgMDtlPW49MSxpPXI9MH1oPTEscz1hPW89bD1fPXU9MCxjPUw/LTEvTDowLHA9ay56T3JpZ2luLG09MWUtNix4PVwiLFwiLHc9XCIwXCIsUj1BKnosUiYmKGQ9TWF0aC5jb3MoUiksZz1NYXRoLnNpbihSKSxvPS1nLF89YyotZyxzPWUqZyxhPXIqZyxoPWQsYyo9ZCxlKj1kLHIqPWQpLFI9Typ6LFImJihkPU1hdGguY29zKFIpLGc9TWF0aC5zaW4oUiksdj1pKmQrcypnLHk9bipkK2EqZyxsPWgqZyx1PWMqZyxzPWkqLWcrcypkLGE9biotZythKmQsaCo9ZCxjKj1kLGk9dixuPXkpLDEhPT1NJiYocyo9TSxhKj1NLGgqPU0sYyo9TSksMSE9PUQmJihpKj1ELG4qPUQsbCo9RCx1Kj1EKSwxIT09QyYmKGUqPUMscio9QyxvKj1DLF8qPUMpLChwfHxOKSYmKHAmJihGKz1zKi1wLEkrPWEqLXAsRSs9aCotcCtwKSxOJiYoRis9ay54T3JpZ2luLShrLnhPcmlnaW4qZStrLnlPcmlnaW4qaSkray54T2Zmc2V0LEkrPWsueU9yaWdpbi0oay54T3JpZ2luKnIray55T3JpZ2luKm4pK2sueU9mZnNldCksbT5GJiZGPi1tJiYoRj13KSxtPkkmJkk+LW0mJihJPXcpLG0+RSYmRT4tbSYmKEU9MCkpLFQ9ay54UGVyY2VudHx8ay55UGVyY2VudD9cInRyYW5zbGF0ZShcIitrLnhQZXJjZW50K1wiJSxcIitrLnlQZXJjZW50K1wiJSkgbWF0cml4M2QoXCI6XCJtYXRyaXgzZChcIixUKz0obT5lJiZlPi1tP3c6ZSkreCsobT5yJiZyPi1tP3c6cikreCsobT5vJiZvPi1tP3c6byksVCs9eCsobT5fJiZfPi1tP3c6XykreCsobT5pJiZpPi1tP3c6aSkreCsobT5uJiZuPi1tP3c6biksT3x8QT8oVCs9eCsobT5sJiZsPi1tP3c6bCkreCsobT51JiZ1Pi1tP3c6dSkreCsobT5zJiZzPi1tP3c6cyksVCs9eCsobT5hJiZhPi1tP3c6YSkreCsobT5oJiZoPi1tP3c6aCkreCsobT5jJiZjPi1tP3c6YykreCk6VCs9XCIsMCwwLDAsMCwxLDAsXCIsVCs9Rit4K0kreCtFK3grKEw/MSstRS9MOjEpK1wiKVwiLFNbUGVdPVR9O2g9T2UucHJvdG90eXBlLGgueD1oLnk9aC56PWguc2tld1g9aC5za2V3WT1oLnJvdGF0aW9uPWgucm90YXRpb25YPWgucm90YXRpb25ZPWguek9yaWdpbj1oLnhQZXJjZW50PWgueVBlcmNlbnQ9aC54T2Zmc2V0PWgueU9mZnNldD0wLGguc2NhbGVYPWguc2NhbGVZPWguc2NhbGVaPTEsVGUoXCJ0cmFuc2Zvcm0sc2NhbGUsc2NhbGVYLHNjYWxlWSxzY2FsZVoseCx5LHoscm90YXRpb24scm90YXRpb25YLHJvdGF0aW9uWSxyb3RhdGlvblosc2tld1gsc2tld1ksc2hvcnRSb3RhdGlvbixzaG9ydFJvdGF0aW9uWCxzaG9ydFJvdGF0aW9uWSxzaG9ydFJvdGF0aW9uWix0cmFuc2Zvcm1PcmlnaW4sc3ZnT3JpZ2luLHRyYW5zZm9ybVBlcnNwZWN0aXZlLGRpcmVjdGlvbmFsUm90YXRpb24scGFyc2VUcmFuc2Zvcm0sZm9yY2UzRCxza2V3VHlwZSx4UGVyY2VudCx5UGVyY2VudCxzbW9vdGhPcmlnaW5cIix7cGFyc2VyOmZ1bmN0aW9uKHQsZSxpLHMsbixvLGwpe2lmKHMuX2xhc3RQYXJzZWRUcmFuc2Zvcm09PT1sKXJldHVybiBuO3MuX2xhc3RQYXJzZWRUcmFuc2Zvcm09bDt2YXIgaCxfLHUsYyxmLHAsbSxkLGcsdix5PXQuX2dzVHJhbnNmb3JtLFQ9dC5zdHlsZSx4PTFlLTYsdz1iZS5sZW5ndGgsYj1sLFA9e30saz1cInRyYW5zZm9ybU9yaWdpblwiO2lmKGwuZGlzcGxheT8oYz1RKHQsXCJkaXNwbGF5XCIpLFQuZGlzcGxheT1cImJsb2NrXCIsaD1OZSh0LHIsITAsbC5wYXJzZVRyYW5zZm9ybSksVC5kaXNwbGF5PWMpOmg9TmUodCxyLCEwLGwucGFyc2VUcmFuc2Zvcm0pLHMuX3RyYW5zZm9ybT1oLFwic3RyaW5nXCI9PXR5cGVvZiBiLnRyYW5zZm9ybSYmUGUpYz1MLnN0eWxlLGNbUGVdPWIudHJhbnNmb3JtLGMuZGlzcGxheT1cImJsb2NrXCIsYy5wb3NpdGlvbj1cImFic29sdXRlXCIsRS5ib2R5LmFwcGVuZENoaWxkKEwpLF89TmUoTCxudWxsLCExKSxFLmJvZHkucmVtb3ZlQ2hpbGQoTCksXy5wZXJzcGVjdGl2ZXx8KF8ucGVyc3BlY3RpdmU9aC5wZXJzcGVjdGl2ZSksbnVsbCE9Yi54UGVyY2VudCYmKF8ueFBlcmNlbnQ9bmUoYi54UGVyY2VudCxoLnhQZXJjZW50KSksbnVsbCE9Yi55UGVyY2VudCYmKF8ueVBlcmNlbnQ9bmUoYi55UGVyY2VudCxoLnlQZXJjZW50KSk7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgYil7aWYoXz17c2NhbGVYOm5lKG51bGwhPWIuc2NhbGVYP2Iuc2NhbGVYOmIuc2NhbGUsaC5zY2FsZVgpLHNjYWxlWTpuZShudWxsIT1iLnNjYWxlWT9iLnNjYWxlWTpiLnNjYWxlLGguc2NhbGVZKSxzY2FsZVo6bmUoYi5zY2FsZVosaC5zY2FsZVopLHg6bmUoYi54LGgueCkseTpuZShiLnksaC55KSx6Om5lKGIueixoLnopLHhQZXJjZW50Om5lKGIueFBlcmNlbnQsaC54UGVyY2VudCkseVBlcmNlbnQ6bmUoYi55UGVyY2VudCxoLnlQZXJjZW50KSxwZXJzcGVjdGl2ZTpuZShiLnRyYW5zZm9ybVBlcnNwZWN0aXZlLGgucGVyc3BlY3RpdmUpfSxkPWIuZGlyZWN0aW9uYWxSb3RhdGlvbixudWxsIT1kKWlmKFwib2JqZWN0XCI9PXR5cGVvZiBkKWZvcihjIGluIGQpYltjXT1kW2NdO2Vsc2UgYi5yb3RhdGlvbj1kO1wic3RyaW5nXCI9PXR5cGVvZiBiLngmJi0xIT09Yi54LmluZGV4T2YoXCIlXCIpJiYoXy54PTAsXy54UGVyY2VudD1uZShiLngsaC54UGVyY2VudCkpLFwic3RyaW5nXCI9PXR5cGVvZiBiLnkmJi0xIT09Yi55LmluZGV4T2YoXCIlXCIpJiYoXy55PTAsXy55UGVyY2VudD1uZShiLnksaC55UGVyY2VudCkpLF8ucm90YXRpb249YWUoXCJyb3RhdGlvblwiaW4gYj9iLnJvdGF0aW9uOlwic2hvcnRSb3RhdGlvblwiaW4gYj9iLnNob3J0Um90YXRpb24rXCJfc2hvcnRcIjpcInJvdGF0aW9uWlwiaW4gYj9iLnJvdGF0aW9uWjpoLnJvdGF0aW9uLGgucm90YXRpb24sXCJyb3RhdGlvblwiLFApLFJlJiYoXy5yb3RhdGlvblg9YWUoXCJyb3RhdGlvblhcImluIGI/Yi5yb3RhdGlvblg6XCJzaG9ydFJvdGF0aW9uWFwiaW4gYj9iLnNob3J0Um90YXRpb25YK1wiX3Nob3J0XCI6aC5yb3RhdGlvblh8fDAsaC5yb3RhdGlvblgsXCJyb3RhdGlvblhcIixQKSxfLnJvdGF0aW9uWT1hZShcInJvdGF0aW9uWVwiaW4gYj9iLnJvdGF0aW9uWTpcInNob3J0Um90YXRpb25ZXCJpbiBiP2Iuc2hvcnRSb3RhdGlvblkrXCJfc2hvcnRcIjpoLnJvdGF0aW9uWXx8MCxoLnJvdGF0aW9uWSxcInJvdGF0aW9uWVwiLFApKSxfLnNrZXdYPW51bGw9PWIuc2tld1g/aC5za2V3WDphZShiLnNrZXdYLGguc2tld1gpLF8uc2tld1k9bnVsbD09Yi5za2V3WT9oLnNrZXdZOmFlKGIuc2tld1ksaC5za2V3WSksKHU9Xy5za2V3WS1oLnNrZXdZKSYmKF8uc2tld1grPXUsXy5yb3RhdGlvbis9dSl9Zm9yKFJlJiZudWxsIT1iLmZvcmNlM0QmJihoLmZvcmNlM0Q9Yi5mb3JjZTNELG09ITApLGguc2tld1R5cGU9Yi5za2V3VHlwZXx8aC5za2V3VHlwZXx8YS5kZWZhdWx0U2tld1R5cGUscD1oLmZvcmNlM0R8fGguenx8aC5yb3RhdGlvblh8fGgucm90YXRpb25ZfHxfLnp8fF8ucm90YXRpb25YfHxfLnJvdGF0aW9uWXx8Xy5wZXJzcGVjdGl2ZSxwfHxudWxsPT1iLnNjYWxlfHwoXy5zY2FsZVo9MSk7LS13Pi0xOylpPWJlW3ddLGY9X1tpXS1oW2ldLChmPnh8fC14PmZ8fG51bGwhPWJbaV18fG51bGwhPUlbaV0pJiYobT0hMCxuPW5ldyBtZShoLGksaFtpXSxmLG4pLGkgaW4gUCYmKG4uZT1QW2ldKSxuLnhzMD0wLG4ucGx1Z2luPW8scy5fb3ZlcndyaXRlUHJvcHMucHVzaChuLm4pKTtyZXR1cm4gZj1iLnRyYW5zZm9ybU9yaWdpbixoLnN2ZyYmKGZ8fGIuc3ZnT3JpZ2luKSYmKGc9aC54T2Zmc2V0LHY9aC55T2Zmc2V0LHplKHQsc2UoZiksXyxiLnN2Z09yaWdpbixiLnNtb290aE9yaWdpbiksbj1kZShoLFwieE9yaWdpblwiLCh5P2g6XykueE9yaWdpbixfLnhPcmlnaW4sbixrKSxuPWRlKGgsXCJ5T3JpZ2luXCIsKHk/aDpfKS55T3JpZ2luLF8ueU9yaWdpbixuLGspLChnIT09aC54T2Zmc2V0fHx2IT09aC55T2Zmc2V0KSYmKG49ZGUoaCxcInhPZmZzZXRcIix5P2c6aC54T2Zmc2V0LGgueE9mZnNldCxuLGspLG49ZGUoaCxcInlPZmZzZXRcIix5P3Y6aC55T2Zmc2V0LGgueU9mZnNldCxuLGspKSxmPXdlP251bGw6XCIwcHggMHB4XCIpLChmfHxSZSYmcCYmaC56T3JpZ2luKSYmKFBlPyhtPSEwLGk9U2UsZj0oZnx8USh0LGksciwhMSxcIjUwJSA1MCVcIikpK1wiXCIsbj1uZXcgbWUoVCxpLDAsMCxuLC0xLGspLG4uYj1UW2ldLG4ucGx1Z2luPW8sUmU/KGM9aC56T3JpZ2luLGY9Zi5zcGxpdChcIiBcIiksaC56T3JpZ2luPShmLmxlbmd0aD4yJiYoMD09PWN8fFwiMHB4XCIhPT1mWzJdKT9wYXJzZUZsb2F0KGZbMl0pOmMpfHwwLG4ueHMwPW4uZT1mWzBdK1wiIFwiKyhmWzFdfHxcIjUwJVwiKStcIiAwcHhcIixuPW5ldyBtZShoLFwiek9yaWdpblwiLDAsMCxuLC0xLG4ubiksbi5iPWMsbi54czA9bi5lPWguek9yaWdpbik6bi54czA9bi5lPWYpOnNlKGYrXCJcIixoKSksbSYmKHMuX3RyYW5zZm9ybVR5cGU9aC5zdmcmJndlfHwhcCYmMyE9PXRoaXMuX3RyYW5zZm9ybVR5cGU/MjozKSxufSxwcmVmaXg6ITB9KSxUZShcImJveFNoYWRvd1wiLHtkZWZhdWx0VmFsdWU6XCIwcHggMHB4IDBweCAwcHggIzk5OVwiLHByZWZpeDohMCxjb2xvcjohMCxtdWx0aTohMCxrZXl3b3JkOlwiaW5zZXRcIn0pLFRlKFwiYm9yZGVyUmFkaXVzXCIse2RlZmF1bHRWYWx1ZTpcIjBweFwiLHBhcnNlcjpmdW5jdGlvbih0LGUsaSxuLGEpe2U9dGhpcy5mb3JtYXQoZSk7dmFyIG8sbCxoLF8sdSxjLGYscCxtLGQsZyx2LHksVCx4LHcsYj1bXCJib3JkZXJUb3BMZWZ0UmFkaXVzXCIsXCJib3JkZXJUb3BSaWdodFJhZGl1c1wiLFwiYm9yZGVyQm90dG9tUmlnaHRSYWRpdXNcIixcImJvcmRlckJvdHRvbUxlZnRSYWRpdXNcIl0sUD10LnN0eWxlO2ZvcihtPXBhcnNlRmxvYXQodC5vZmZzZXRXaWR0aCksZD1wYXJzZUZsb2F0KHQub2Zmc2V0SGVpZ2h0KSxvPWUuc3BsaXQoXCIgXCIpLGw9MDtiLmxlbmd0aD5sO2wrKyl0aGlzLnAuaW5kZXhPZihcImJvcmRlclwiKSYmKGJbbF09VyhiW2xdKSksdT1fPVEodCxiW2xdLHIsITEsXCIwcHhcIiksLTEhPT11LmluZGV4T2YoXCIgXCIpJiYoXz11LnNwbGl0KFwiIFwiKSx1PV9bMF0sXz1fWzFdKSxjPWg9b1tsXSxmPXBhcnNlRmxvYXQodSksdj11LnN1YnN0cigoZitcIlwiKS5sZW5ndGgpLHk9XCI9XCI9PT1jLmNoYXJBdCgxKSx5PyhwPXBhcnNlSW50KGMuY2hhckF0KDApK1wiMVwiLDEwKSxjPWMuc3Vic3RyKDIpLHAqPXBhcnNlRmxvYXQoYyksZz1jLnN1YnN0cigocCtcIlwiKS5sZW5ndGgtKDA+cD8xOjApKXx8XCJcIik6KHA9cGFyc2VGbG9hdChjKSxnPWMuc3Vic3RyKChwK1wiXCIpLmxlbmd0aCkpLFwiXCI9PT1nJiYoZz1zW2ldfHx2KSxnIT09diYmKFQ9JCh0LFwiYm9yZGVyTGVmdFwiLGYsdikseD0kKHQsXCJib3JkZXJUb3BcIixmLHYpLFwiJVwiPT09Zz8odT0xMDAqKFQvbSkrXCIlXCIsXz0xMDAqKHgvZCkrXCIlXCIpOlwiZW1cIj09PWc/KHc9JCh0LFwiYm9yZGVyTGVmdFwiLDEsXCJlbVwiKSx1PVQvdytcImVtXCIsXz14L3crXCJlbVwiKToodT1UK1wicHhcIixfPXgrXCJweFwiKSx5JiYoYz1wYXJzZUZsb2F0KHUpK3ArZyxoPXBhcnNlRmxvYXQoXykrcCtnKSksYT1nZShQLGJbbF0sdStcIiBcIitfLGMrXCIgXCIraCwhMSxcIjBweFwiLGEpO3JldHVybiBhfSxwcmVmaXg6ITAsZm9ybWF0dGVyOmNlKFwiMHB4IDBweCAwcHggMHB4XCIsITEsITApfSksVGUoXCJiYWNrZ3JvdW5kUG9zaXRpb25cIix7ZGVmYXVsdFZhbHVlOlwiMCAwXCIscGFyc2VyOmZ1bmN0aW9uKHQsZSxpLHMsbixhKXt2YXIgbyxsLGgsXyx1LGMsZj1cImJhY2tncm91bmQtcG9zaXRpb25cIixwPXJ8fFoodCxudWxsKSxkPXRoaXMuZm9ybWF0KChwP20/cC5nZXRQcm9wZXJ0eVZhbHVlKGYrXCIteFwiKStcIiBcIitwLmdldFByb3BlcnR5VmFsdWUoZitcIi15XCIpOnAuZ2V0UHJvcGVydHlWYWx1ZShmKTp0LmN1cnJlbnRTdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb25YK1wiIFwiK3QuY3VycmVudFN0eWxlLmJhY2tncm91bmRQb3NpdGlvblkpfHxcIjAgMFwiKSxnPXRoaXMuZm9ybWF0KGUpO1xuaWYoLTEhPT1kLmluZGV4T2YoXCIlXCIpIT0oLTEhPT1nLmluZGV4T2YoXCIlXCIpKSYmKGM9USh0LFwiYmFja2dyb3VuZEltYWdlXCIpLnJlcGxhY2UoUixcIlwiKSxjJiZcIm5vbmVcIiE9PWMpKXtmb3Iobz1kLnNwbGl0KFwiIFwiKSxsPWcuc3BsaXQoXCIgXCIpLFguc2V0QXR0cmlidXRlKFwic3JjXCIsYyksaD0yOy0taD4tMTspZD1vW2hdLF89LTEhPT1kLmluZGV4T2YoXCIlXCIpLF8hPT0oLTEhPT1sW2hdLmluZGV4T2YoXCIlXCIpKSYmKHU9MD09PWg/dC5vZmZzZXRXaWR0aC1YLndpZHRoOnQub2Zmc2V0SGVpZ2h0LVguaGVpZ2h0LG9baF09Xz9wYXJzZUZsb2F0KGQpLzEwMCp1K1wicHhcIjoxMDAqKHBhcnNlRmxvYXQoZCkvdSkrXCIlXCIpO2Q9by5qb2luKFwiIFwiKX1yZXR1cm4gdGhpcy5wYXJzZUNvbXBsZXgodC5zdHlsZSxkLGcsbixhKX0sZm9ybWF0dGVyOnNlfSksVGUoXCJiYWNrZ3JvdW5kU2l6ZVwiLHtkZWZhdWx0VmFsdWU6XCIwIDBcIixmb3JtYXR0ZXI6c2V9KSxUZShcInBlcnNwZWN0aXZlXCIse2RlZmF1bHRWYWx1ZTpcIjBweFwiLHByZWZpeDohMH0pLFRlKFwicGVyc3BlY3RpdmVPcmlnaW5cIix7ZGVmYXVsdFZhbHVlOlwiNTAlIDUwJVwiLHByZWZpeDohMH0pLFRlKFwidHJhbnNmb3JtU3R5bGVcIix7cHJlZml4OiEwfSksVGUoXCJiYWNrZmFjZVZpc2liaWxpdHlcIix7cHJlZml4OiEwfSksVGUoXCJ1c2VyU2VsZWN0XCIse3ByZWZpeDohMH0pLFRlKFwibWFyZ2luXCIse3BhcnNlcjpmZShcIm1hcmdpblRvcCxtYXJnaW5SaWdodCxtYXJnaW5Cb3R0b20sbWFyZ2luTGVmdFwiKX0pLFRlKFwicGFkZGluZ1wiLHtwYXJzZXI6ZmUoXCJwYWRkaW5nVG9wLHBhZGRpbmdSaWdodCxwYWRkaW5nQm90dG9tLHBhZGRpbmdMZWZ0XCIpfSksVGUoXCJjbGlwXCIse2RlZmF1bHRWYWx1ZTpcInJlY3QoMHB4LDBweCwwcHgsMHB4KVwiLHBhcnNlcjpmdW5jdGlvbih0LGUsaSxzLG4sYSl7dmFyIG8sbCxoO3JldHVybiA5Pm0/KGw9dC5jdXJyZW50U3R5bGUsaD04Pm0/XCIgXCI6XCIsXCIsbz1cInJlY3QoXCIrbC5jbGlwVG9wK2grbC5jbGlwUmlnaHQraCtsLmNsaXBCb3R0b20raCtsLmNsaXBMZWZ0K1wiKVwiLGU9dGhpcy5mb3JtYXQoZSkuc3BsaXQoXCIsXCIpLmpvaW4oaCkpOihvPXRoaXMuZm9ybWF0KFEodCx0aGlzLnAsciwhMSx0aGlzLmRmbHQpKSxlPXRoaXMuZm9ybWF0KGUpKSx0aGlzLnBhcnNlQ29tcGxleCh0LnN0eWxlLG8sZSxuLGEpfX0pLFRlKFwidGV4dFNoYWRvd1wiLHtkZWZhdWx0VmFsdWU6XCIwcHggMHB4IDBweCAjOTk5XCIsY29sb3I6ITAsbXVsdGk6ITB9KSxUZShcImF1dG9Sb3VuZCxzdHJpY3RVbml0c1wiLHtwYXJzZXI6ZnVuY3Rpb24odCxlLGkscyxyKXtyZXR1cm4gcn19KSxUZShcImJvcmRlclwiLHtkZWZhdWx0VmFsdWU6XCIwcHggc29saWQgIzAwMFwiLHBhcnNlcjpmdW5jdGlvbih0LGUsaSxzLG4sYSl7cmV0dXJuIHRoaXMucGFyc2VDb21wbGV4KHQuc3R5bGUsdGhpcy5mb3JtYXQoUSh0LFwiYm9yZGVyVG9wV2lkdGhcIixyLCExLFwiMHB4XCIpK1wiIFwiK1EodCxcImJvcmRlclRvcFN0eWxlXCIsciwhMSxcInNvbGlkXCIpK1wiIFwiK1EodCxcImJvcmRlclRvcENvbG9yXCIsciwhMSxcIiMwMDBcIikpLHRoaXMuZm9ybWF0KGUpLG4sYSl9LGNvbG9yOiEwLGZvcm1hdHRlcjpmdW5jdGlvbih0KXt2YXIgZT10LnNwbGl0KFwiIFwiKTtyZXR1cm4gZVswXStcIiBcIisoZVsxXXx8XCJzb2xpZFwiKStcIiBcIisodC5tYXRjaCh1ZSl8fFtcIiMwMDBcIl0pWzBdfX0pLFRlKFwiYm9yZGVyV2lkdGhcIix7cGFyc2VyOmZlKFwiYm9yZGVyVG9wV2lkdGgsYm9yZGVyUmlnaHRXaWR0aCxib3JkZXJCb3R0b21XaWR0aCxib3JkZXJMZWZ0V2lkdGhcIil9KSxUZShcImZsb2F0LGNzc0Zsb2F0LHN0eWxlRmxvYXRcIix7cGFyc2VyOmZ1bmN0aW9uKHQsZSxpLHMscil7dmFyIG49dC5zdHlsZSxhPVwiY3NzRmxvYXRcImluIG4/XCJjc3NGbG9hdFwiOlwic3R5bGVGbG9hdFwiO3JldHVybiBuZXcgbWUobixhLDAsMCxyLC0xLGksITEsMCxuW2FdLGUpfX0pO3ZhciBCZT1mdW5jdGlvbih0KXt2YXIgZSxpPXRoaXMudCxzPWkuZmlsdGVyfHxRKHRoaXMuZGF0YSxcImZpbHRlclwiKXx8XCJcIixyPTB8dGhpcy5zK3RoaXMuYyp0OzEwMD09PXImJigtMT09PXMuaW5kZXhPZihcImF0cml4KFwiKSYmLTE9PT1zLmluZGV4T2YoXCJyYWRpZW50KFwiKSYmLTE9PT1zLmluZGV4T2YoXCJvYWRlcihcIik/KGkucmVtb3ZlQXR0cmlidXRlKFwiZmlsdGVyXCIpLGU9IVEodGhpcy5kYXRhLFwiZmlsdGVyXCIpKTooaS5maWx0ZXI9cy5yZXBsYWNlKGIsXCJcIiksZT0hMCkpLGV8fCh0aGlzLnhuMSYmKGkuZmlsdGVyPXM9c3x8XCJhbHBoYShvcGFjaXR5PVwiK3IrXCIpXCIpLC0xPT09cy5pbmRleE9mKFwicGFjaXR5XCIpPzA9PT1yJiZ0aGlzLnhuMXx8KGkuZmlsdGVyPXMrXCIgYWxwaGEob3BhY2l0eT1cIityK1wiKVwiKTppLmZpbHRlcj1zLnJlcGxhY2UoeCxcIm9wYWNpdHk9XCIrcikpfTtUZShcIm9wYWNpdHksYWxwaGEsYXV0b0FscGhhXCIse2RlZmF1bHRWYWx1ZTpcIjFcIixwYXJzZXI6ZnVuY3Rpb24odCxlLGkscyxuLGEpe3ZhciBvPXBhcnNlRmxvYXQoUSh0LFwib3BhY2l0eVwiLHIsITEsXCIxXCIpKSxsPXQuc3R5bGUsaD1cImF1dG9BbHBoYVwiPT09aTtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZSYmXCI9XCI9PT1lLmNoYXJBdCgxKSYmKGU9KFwiLVwiPT09ZS5jaGFyQXQoMCk/LTE6MSkqcGFyc2VGbG9hdChlLnN1YnN0cigyKSkrbyksaCYmMT09PW8mJlwiaGlkZGVuXCI9PT1RKHQsXCJ2aXNpYmlsaXR5XCIscikmJjAhPT1lJiYobz0wKSxZP249bmV3IG1lKGwsXCJvcGFjaXR5XCIsbyxlLW8sbik6KG49bmV3IG1lKGwsXCJvcGFjaXR5XCIsMTAwKm8sMTAwKihlLW8pLG4pLG4ueG4xPWg/MTowLGwuem9vbT0xLG4udHlwZT0yLG4uYj1cImFscGhhKG9wYWNpdHk9XCIrbi5zK1wiKVwiLG4uZT1cImFscGhhKG9wYWNpdHk9XCIrKG4ucytuLmMpK1wiKVwiLG4uZGF0YT10LG4ucGx1Z2luPWEsbi5zZXRSYXRpbz1CZSksaCYmKG49bmV3IG1lKGwsXCJ2aXNpYmlsaXR5XCIsMCwwLG4sLTEsbnVsbCwhMSwwLDAhPT1vP1wiaW5oZXJpdFwiOlwiaGlkZGVuXCIsMD09PWU/XCJoaWRkZW5cIjpcImluaGVyaXRcIiksbi54czA9XCJpbmhlcml0XCIscy5fb3ZlcndyaXRlUHJvcHMucHVzaChuLm4pLHMuX292ZXJ3cml0ZVByb3BzLnB1c2goaSkpLG59fSk7dmFyIGplPWZ1bmN0aW9uKHQsZSl7ZSYmKHQucmVtb3ZlUHJvcGVydHk/KChcIm1zXCI9PT1lLnN1YnN0cigwLDIpfHxcIndlYmtpdFwiPT09ZS5zdWJzdHIoMCw2KSkmJihlPVwiLVwiK2UpLHQucmVtb3ZlUHJvcGVydHkoZS5yZXBsYWNlKGssXCItJDFcIikudG9Mb3dlckNhc2UoKSkpOnQucmVtb3ZlQXR0cmlidXRlKGUpKX0sWWU9ZnVuY3Rpb24odCl7aWYodGhpcy50Ll9nc0NsYXNzUFQ9dGhpcywxPT09dHx8MD09PXQpe3RoaXMudC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLDA9PT10P3RoaXMuYjp0aGlzLmUpO2Zvcih2YXIgZT10aGlzLmRhdGEsaT10aGlzLnQuc3R5bGU7ZTspZS52P2lbZS5wXT1lLnY6amUoaSxlLnApLGU9ZS5fbmV4dDsxPT09dCYmdGhpcy50Ll9nc0NsYXNzUFQ9PT10aGlzJiYodGhpcy50Ll9nc0NsYXNzUFQ9bnVsbCl9ZWxzZSB0aGlzLnQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikhPT10aGlzLmUmJnRoaXMudC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLHRoaXMuZSl9O1RlKFwiY2xhc3NOYW1lXCIse3BhcnNlcjpmdW5jdGlvbih0LGUscyxuLGEsbyxsKXt2YXIgaCxfLHUsYyxmLHA9dC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKXx8XCJcIixtPXQuc3R5bGUuY3NzVGV4dDtpZihhPW4uX2NsYXNzTmFtZVBUPW5ldyBtZSh0LHMsMCwwLGEsMiksYS5zZXRSYXRpbz1ZZSxhLnByPS0xMSxpPSEwLGEuYj1wLF89Syh0LHIpLHU9dC5fZ3NDbGFzc1BUKXtmb3IoYz17fSxmPXUuZGF0YTtmOyljW2YucF09MSxmPWYuX25leHQ7dS5zZXRSYXRpbygxKX1yZXR1cm4gdC5fZ3NDbGFzc1BUPWEsYS5lPVwiPVwiIT09ZS5jaGFyQXQoMSk/ZTpwLnJlcGxhY2UoUmVnRXhwKFwiXFxcXHMqXFxcXGJcIitlLnN1YnN0cigyKStcIlxcXFxiXCIpLFwiXCIpKyhcIitcIj09PWUuY2hhckF0KDApP1wiIFwiK2Uuc3Vic3RyKDIpOlwiXCIpLHQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIixhLmUpLGg9Sih0LF8sSyh0KSxsLGMpLHQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIixwKSxhLmRhdGE9aC5maXJzdE1QVCx0LnN0eWxlLmNzc1RleHQ9bSxhPWEueGZpcnN0PW4ucGFyc2UodCxoLmRpZnMsYSxvKX19KTt2YXIgVWU9ZnVuY3Rpb24odCl7aWYoKDE9PT10fHwwPT09dCkmJnRoaXMuZGF0YS5fdG90YWxUaW1lPT09dGhpcy5kYXRhLl90b3RhbER1cmF0aW9uJiZcImlzRnJvbVN0YXJ0XCIhPT10aGlzLmRhdGEuZGF0YSl7dmFyIGUsaSxzLHIsbixhPXRoaXMudC5zdHlsZSxvPWwudHJhbnNmb3JtLnBhcnNlO2lmKFwiYWxsXCI9PT10aGlzLmUpYS5jc3NUZXh0PVwiXCIscj0hMDtlbHNlIGZvcihlPXRoaXMuZS5zcGxpdChcIiBcIikuam9pbihcIlwiKS5zcGxpdChcIixcIikscz1lLmxlbmd0aDstLXM+LTE7KWk9ZVtzXSxsW2ldJiYobFtpXS5wYXJzZT09PW8/cj0hMDppPVwidHJhbnNmb3JtT3JpZ2luXCI9PT1pP1NlOmxbaV0ucCksamUoYSxpKTtyJiYoamUoYSxQZSksbj10aGlzLnQuX2dzVHJhbnNmb3JtLG4mJihuLnN2ZyYmdGhpcy50LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiKSxkZWxldGUgdGhpcy50Ll9nc1RyYW5zZm9ybSkpfX07Zm9yKFRlKFwiY2xlYXJQcm9wc1wiLHtwYXJzZXI6ZnVuY3Rpb24odCxlLHMscixuKXtyZXR1cm4gbj1uZXcgbWUodCxzLDAsMCxuLDIpLG4uc2V0UmF0aW89VWUsbi5lPWUsbi5wcj0tMTAsbi5kYXRhPXIuX3R3ZWVuLGk9ITAsbn19KSxoPVwiYmV6aWVyLHRocm93UHJvcHMscGh5c2ljc1Byb3BzLHBoeXNpY3MyRFwiLnNwbGl0KFwiLFwiKSx2ZT1oLmxlbmd0aDt2ZS0tOyl4ZShoW3ZlXSk7aD1hLnByb3RvdHlwZSxoLl9maXJzdFBUPWguX2xhc3RQYXJzZWRUcmFuc2Zvcm09aC5fdHJhbnNmb3JtPW51bGwsaC5fb25Jbml0VHdlZW49ZnVuY3Rpb24odCxlLG8pe2lmKCF0Lm5vZGVUeXBlKXJldHVybiExO3RoaXMuX3RhcmdldD10LHRoaXMuX3R3ZWVuPW8sdGhpcy5fdmFycz1lLF89ZS5hdXRvUm91bmQsaT0hMSxzPWUuc3VmZml4TWFwfHxhLnN1ZmZpeE1hcCxyPVoodCxcIlwiKSxuPXRoaXMuX292ZXJ3cml0ZVByb3BzO3ZhciBoLGYsbSxkLGcsdix5LFQseCxiPXQuc3R5bGU7aWYodSYmXCJcIj09PWIuekluZGV4JiYoaD1RKHQsXCJ6SW5kZXhcIixyKSwoXCJhdXRvXCI9PT1ofHxcIlwiPT09aCkmJnRoaXMuX2FkZExhenlTZXQoYixcInpJbmRleFwiLDApKSxcInN0cmluZ1wiPT10eXBlb2YgZSYmKGQ9Yi5jc3NUZXh0LGg9Syh0LHIpLGIuY3NzVGV4dD1kK1wiO1wiK2UsaD1KKHQsaCxLKHQpKS5kaWZzLCFZJiZ3LnRlc3QoZSkmJihoLm9wYWNpdHk9cGFyc2VGbG9hdChSZWdFeHAuJDEpKSxlPWgsYi5jc3NUZXh0PWQpLHRoaXMuX2ZpcnN0UFQ9Zj1lLmNsYXNzTmFtZT9sLmNsYXNzTmFtZS5wYXJzZSh0LGUuY2xhc3NOYW1lLFwiY2xhc3NOYW1lXCIsdGhpcyxudWxsLG51bGwsZSk6dGhpcy5wYXJzZSh0LGUsbnVsbCksdGhpcy5fdHJhbnNmb3JtVHlwZSl7Zm9yKHg9Mz09PXRoaXMuX3RyYW5zZm9ybVR5cGUsUGU/YyYmKHU9ITAsXCJcIj09PWIuekluZGV4JiYoeT1RKHQsXCJ6SW5kZXhcIixyKSwoXCJhdXRvXCI9PT15fHxcIlwiPT09eSkmJnRoaXMuX2FkZExhenlTZXQoYixcInpJbmRleFwiLDApKSxwJiZ0aGlzLl9hZGRMYXp5U2V0KGIsXCJXZWJraXRCYWNrZmFjZVZpc2liaWxpdHlcIix0aGlzLl92YXJzLldlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eXx8KHg/XCJ2aXNpYmxlXCI6XCJoaWRkZW5cIikpKTpiLnpvb209MSxtPWY7bSYmbS5fbmV4dDspbT1tLl9uZXh0O1Q9bmV3IG1lKHQsXCJ0cmFuc2Zvcm1cIiwwLDAsbnVsbCwyKSx0aGlzLl9saW5rQ1NTUChULG51bGwsbSksVC5zZXRSYXRpbz1QZT9YZTpMZSxULmRhdGE9dGhpcy5fdHJhbnNmb3JtfHxOZSh0LHIsITApLFQudHdlZW49byxULnByPS0xLG4ucG9wKCl9aWYoaSl7Zm9yKDtmOyl7Zm9yKHY9Zi5fbmV4dCxtPWQ7bSYmbS5wcj5mLnByOyltPW0uX25leHQ7KGYuX3ByZXY9bT9tLl9wcmV2OmcpP2YuX3ByZXYuX25leHQ9ZjpkPWYsKGYuX25leHQ9bSk/bS5fcHJldj1mOmc9ZixmPXZ9dGhpcy5fZmlyc3RQVD1kfXJldHVybiEwfSxoLnBhcnNlPWZ1bmN0aW9uKHQsZSxpLG4pe3ZhciBhLG8saCx1LGMsZixwLG0sZCxnLHY9dC5zdHlsZTtmb3IoYSBpbiBlKWY9ZVthXSxvPWxbYV0sbz9pPW8ucGFyc2UodCxmLGEsdGhpcyxpLG4sZSk6KGM9USh0LGEscikrXCJcIixkPVwic3RyaW5nXCI9PXR5cGVvZiBmLFwiY29sb3JcIj09PWF8fFwiZmlsbFwiPT09YXx8XCJzdHJva2VcIj09PWF8fC0xIT09YS5pbmRleE9mKFwiQ29sb3JcIil8fGQmJlAudGVzdChmKT8oZHx8KGY9aGUoZiksZj0oZi5sZW5ndGg+Mz9cInJnYmEoXCI6XCJyZ2IoXCIpK2Yuam9pbihcIixcIikrXCIpXCIpLGk9Z2UodixhLGMsZiwhMCxcInRyYW5zcGFyZW50XCIsaSwwLG4pKTohZHx8LTE9PT1mLmluZGV4T2YoXCIgXCIpJiYtMT09PWYuaW5kZXhPZihcIixcIik/KGg9cGFyc2VGbG9hdChjKSxwPWh8fDA9PT1oP2Muc3Vic3RyKChoK1wiXCIpLmxlbmd0aCk6XCJcIiwoXCJcIj09PWN8fFwiYXV0b1wiPT09YykmJihcIndpZHRoXCI9PT1hfHxcImhlaWdodFwiPT09YT8oaD1pZSh0LGEscikscD1cInB4XCIpOlwibGVmdFwiPT09YXx8XCJ0b3BcIj09PWE/KGg9SCh0LGEscikscD1cInB4XCIpOihoPVwib3BhY2l0eVwiIT09YT8wOjEscD1cIlwiKSksZz1kJiZcIj1cIj09PWYuY2hhckF0KDEpLGc/KHU9cGFyc2VJbnQoZi5jaGFyQXQoMCkrXCIxXCIsMTApLGY9Zi5zdWJzdHIoMiksdSo9cGFyc2VGbG9hdChmKSxtPWYucmVwbGFjZShULFwiXCIpKToodT1wYXJzZUZsb2F0KGYpLG09ZD9mLnJlcGxhY2UoVCxcIlwiKTpcIlwiKSxcIlwiPT09bSYmKG09YSBpbiBzP3NbYV06cCksZj11fHwwPT09dT8oZz91K2g6dSkrbTplW2FdLHAhPT1tJiZcIlwiIT09bSYmKHV8fDA9PT11KSYmaCYmKGg9JCh0LGEsaCxwKSxcIiVcIj09PW0/KGgvPSQodCxhLDEwMCxcIiVcIikvMTAwLGUuc3RyaWN0VW5pdHMhPT0hMCYmKGM9aCtcIiVcIikpOlwiZW1cIj09PW18fFwicmVtXCI9PT1tP2gvPSQodCxhLDEsbSk6XCJweFwiIT09bSYmKHU9JCh0LGEsdSxtKSxtPVwicHhcIiksZyYmKHV8fDA9PT11KSYmKGY9dStoK20pKSxnJiYodSs9aCksIWgmJjAhPT1ofHwhdSYmMCE9PXU/dm9pZCAwIT09dlthXSYmKGZ8fFwiTmFOXCIhPWYrXCJcIiYmbnVsbCE9Zik/KGk9bmV3IG1lKHYsYSx1fHxofHwwLDAsaSwtMSxhLCExLDAsYyxmKSxpLnhzMD1cIm5vbmVcIiE9PWZ8fFwiZGlzcGxheVwiIT09YSYmLTE9PT1hLmluZGV4T2YoXCJTdHlsZVwiKT9mOmMpOnEoXCJpbnZhbGlkIFwiK2ErXCIgdHdlZW4gdmFsdWU6IFwiK2VbYV0pOihpPW5ldyBtZSh2LGEsaCx1LWgsaSwwLGEsXyE9PSExJiYoXCJweFwiPT09bXx8XCJ6SW5kZXhcIj09PWEpLDAsYyxmKSxpLnhzMD1tKSk6aT1nZSh2LGEsYyxmLCEwLG51bGwsaSwwLG4pKSxuJiZpJiYhaS5wbHVnaW4mJihpLnBsdWdpbj1uKTtyZXR1cm4gaX0saC5zZXRSYXRpbz1mdW5jdGlvbih0KXt2YXIgZSxpLHMscj10aGlzLl9maXJzdFBULG49MWUtNjtpZigxIT09dHx8dGhpcy5fdHdlZW4uX3RpbWUhPT10aGlzLl90d2Vlbi5fZHVyYXRpb24mJjAhPT10aGlzLl90d2Vlbi5fdGltZSlpZih0fHx0aGlzLl90d2Vlbi5fdGltZSE9PXRoaXMuX3R3ZWVuLl9kdXJhdGlvbiYmMCE9PXRoaXMuX3R3ZWVuLl90aW1lfHx0aGlzLl90d2Vlbi5fcmF3UHJldlRpbWU9PT0tMWUtNilmb3IoO3I7KXtpZihlPXIuYyp0K3IucyxyLnI/ZT1NYXRoLnJvdW5kKGUpOm4+ZSYmZT4tbiYmKGU9MCksci50eXBlKWlmKDE9PT1yLnR5cGUpaWYocz1yLmwsMj09PXMpci50W3IucF09ci54czArZStyLnhzMStyLnhuMStyLnhzMjtlbHNlIGlmKDM9PT1zKXIudFtyLnBdPXIueHMwK2Urci54czErci54bjErci54czIrci54bjIrci54czM7ZWxzZSBpZig0PT09cylyLnRbci5wXT1yLnhzMCtlK3IueHMxK3IueG4xK3IueHMyK3IueG4yK3IueHMzK3IueG4zK3IueHM0O2Vsc2UgaWYoNT09PXMpci50W3IucF09ci54czArZStyLnhzMStyLnhuMStyLnhzMityLnhuMityLnhzMytyLnhuMytyLnhzNCtyLnhuNCtyLnhzNTtlbHNle2ZvcihpPXIueHMwK2Urci54czEscz0xO3IubD5zO3MrKylpKz1yW1wieG5cIitzXStyW1wieHNcIisocysxKV07ci50W3IucF09aX1lbHNlLTE9PT1yLnR5cGU/ci50W3IucF09ci54czA6ci5zZXRSYXRpbyYmci5zZXRSYXRpbyh0KTtlbHNlIHIudFtyLnBdPWUrci54czA7cj1yLl9uZXh0fWVsc2UgZm9yKDtyOykyIT09ci50eXBlP3IudFtyLnBdPXIuYjpyLnNldFJhdGlvKHQpLHI9ci5fbmV4dDtlbHNlIGZvcig7cjspe2lmKDIhPT1yLnR5cGUpaWYoci5yJiYtMSE9PXIudHlwZSlpZihlPU1hdGgucm91bmQoci5zK3IuYyksci50eXBlKXtpZigxPT09ci50eXBlKXtmb3Iocz1yLmwsaT1yLnhzMCtlK3IueHMxLHM9MTtyLmw+cztzKyspaSs9cltcInhuXCIrc10rcltcInhzXCIrKHMrMSldO3IudFtyLnBdPWl9fWVsc2Ugci50W3IucF09ZStyLnhzMDtlbHNlIHIudFtyLnBdPXIuZTtlbHNlIHIuc2V0UmF0aW8odCk7cj1yLl9uZXh0fX0saC5fZW5hYmxlVHJhbnNmb3Jtcz1mdW5jdGlvbih0KXt0aGlzLl90cmFuc2Zvcm09dGhpcy5fdHJhbnNmb3JtfHxOZSh0aGlzLl90YXJnZXQsciwhMCksdGhpcy5fdHJhbnNmb3JtVHlwZT10aGlzLl90cmFuc2Zvcm0uc3ZnJiZ3ZXx8IXQmJjMhPT10aGlzLl90cmFuc2Zvcm1UeXBlPzI6M307dmFyIHFlPWZ1bmN0aW9uKCl7dGhpcy50W3RoaXMucF09dGhpcy5lLHRoaXMuZGF0YS5fbGlua0NTU1AodGhpcyx0aGlzLl9uZXh0LG51bGwsITApfTtoLl9hZGRMYXp5U2V0PWZ1bmN0aW9uKHQsZSxpKXt2YXIgcz10aGlzLl9maXJzdFBUPW5ldyBtZSh0LGUsMCwwLHRoaXMuX2ZpcnN0UFQsMik7cy5lPWkscy5zZXRSYXRpbz1xZSxzLmRhdGE9dGhpc30saC5fbGlua0NTU1A9ZnVuY3Rpb24odCxlLGkscyl7cmV0dXJuIHQmJihlJiYoZS5fcHJldj10KSx0Ll9uZXh0JiYodC5fbmV4dC5fcHJldj10Ll9wcmV2KSx0Ll9wcmV2P3QuX3ByZXYuX25leHQ9dC5fbmV4dDp0aGlzLl9maXJzdFBUPT09dCYmKHRoaXMuX2ZpcnN0UFQ9dC5fbmV4dCxzPSEwKSxpP2kuX25leHQ9dDpzfHxudWxsIT09dGhpcy5fZmlyc3RQVHx8KHRoaXMuX2ZpcnN0UFQ9dCksdC5fbmV4dD1lLHQuX3ByZXY9aSksdH0saC5fa2lsbD1mdW5jdGlvbihlKXt2YXIgaSxzLHIsbj1lO2lmKGUuYXV0b0FscGhhfHxlLmFscGhhKXtuPXt9O2ZvcihzIGluIGUpbltzXT1lW3NdO24ub3BhY2l0eT0xLG4uYXV0b0FscGhhJiYobi52aXNpYmlsaXR5PTEpfXJldHVybiBlLmNsYXNzTmFtZSYmKGk9dGhpcy5fY2xhc3NOYW1lUFQpJiYocj1pLnhmaXJzdCxyJiZyLl9wcmV2P3RoaXMuX2xpbmtDU1NQKHIuX3ByZXYsaS5fbmV4dCxyLl9wcmV2Ll9wcmV2KTpyPT09dGhpcy5fZmlyc3RQVCYmKHRoaXMuX2ZpcnN0UFQ9aS5fbmV4dCksaS5fbmV4dCYmdGhpcy5fbGlua0NTU1AoaS5fbmV4dCxpLl9uZXh0Ll9uZXh0LHIuX3ByZXYpLHRoaXMuX2NsYXNzTmFtZVBUPW51bGwpLHQucHJvdG90eXBlLl9raWxsLmNhbGwodGhpcyxuKX07dmFyIFZlPWZ1bmN0aW9uKHQsZSxpKXt2YXIgcyxyLG4sYTtpZih0LnNsaWNlKWZvcihyPXQubGVuZ3RoOy0tcj4tMTspVmUodFtyXSxlLGkpO2Vsc2UgZm9yKHM9dC5jaGlsZE5vZGVzLHI9cy5sZW5ndGg7LS1yPi0xOyluPXNbcl0sYT1uLnR5cGUsbi5zdHlsZSYmKGUucHVzaChLKG4pKSxpJiZpLnB1c2gobikpLDEhPT1hJiY5IT09YSYmMTEhPT1hfHwhbi5jaGlsZE5vZGVzLmxlbmd0aHx8VmUobixlLGkpfTtyZXR1cm4gYS5jYXNjYWRlVG89ZnVuY3Rpb24odCxpLHMpe3ZhciByLG4sYSxvLGw9ZS50byh0LGkscyksaD1bbF0sXz1bXSx1PVtdLGM9W10sZj1lLl9pbnRlcm5hbHMucmVzZXJ2ZWRQcm9wcztmb3IodD1sLl90YXJnZXRzfHxsLnRhcmdldCxWZSh0LF8sYyksbC5yZW5kZXIoaSwhMCwhMCksVmUodCx1KSxsLnJlbmRlcigwLCEwLCEwKSxsLl9lbmFibGVkKCEwKSxyPWMubGVuZ3RoOy0tcj4tMTspaWYobj1KKGNbcl0sX1tyXSx1W3JdKSxuLmZpcnN0TVBUKXtuPW4uZGlmcztmb3IoYSBpbiBzKWZbYV0mJihuW2FdPXNbYV0pO289e307Zm9yKGEgaW4gbilvW2FdPV9bcl1bYV07aC5wdXNoKGUuZnJvbVRvKGNbcl0saSxvLG4pKX1yZXR1cm4gaH0sdC5hY3RpdmF0ZShbYV0pLGF9LCEwKSxmdW5jdGlvbigpe3ZhciB0PV9nc1Njb3BlLl9nc0RlZmluZS5wbHVnaW4oe3Byb3BOYW1lOlwicm91bmRQcm9wc1wiLHZlcnNpb246XCIxLjVcIixwcmlvcml0eTotMSxBUEk6Mixpbml0OmZ1bmN0aW9uKHQsZSxpKXtyZXR1cm4gdGhpcy5fdHdlZW49aSwhMH19KSxlPWZ1bmN0aW9uKHQpe2Zvcig7dDspdC5mfHx0LmJsb2J8fCh0LnI9MSksdD10Ll9uZXh0fSxpPXQucHJvdG90eXBlO2kuX29uSW5pdEFsbFByb3BzPWZ1bmN0aW9uKCl7Zm9yKHZhciB0LGkscyxyPXRoaXMuX3R3ZWVuLG49ci52YXJzLnJvdW5kUHJvcHMuam9pbj9yLnZhcnMucm91bmRQcm9wczpyLnZhcnMucm91bmRQcm9wcy5zcGxpdChcIixcIiksYT1uLmxlbmd0aCxvPXt9LGw9ci5fcHJvcExvb2t1cC5yb3VuZFByb3BzOy0tYT4tMTspb1tuW2FdXT0xO2ZvcihhPW4ubGVuZ3RoOy0tYT4tMTspZm9yKHQ9blthXSxpPXIuX2ZpcnN0UFQ7aTspcz1pLl9uZXh0LGkucGc/aS50Ll9yb3VuZFByb3BzKG8sITApOmkubj09PXQmJigyPT09aS5mJiZpLnQ/ZShpLnQuX2ZpcnN0UFQpOih0aGlzLl9hZGQoaS50LHQsaS5zLGkuYykscyYmKHMuX3ByZXY9aS5fcHJldiksaS5fcHJldj9pLl9wcmV2Ll9uZXh0PXM6ci5fZmlyc3RQVD09PWkmJihyLl9maXJzdFBUPXMpLGkuX25leHQ9aS5fcHJldj1udWxsLHIuX3Byb3BMb29rdXBbdF09bCkpLGk9cztyZXR1cm4hMX0saS5fYWRkPWZ1bmN0aW9uKHQsZSxpLHMpe3RoaXMuX2FkZFR3ZWVuKHQsZSxpLGkrcyxlLCEwKSx0aGlzLl9vdmVyd3JpdGVQcm9wcy5wdXNoKGUpfX0oKSxmdW5jdGlvbigpe19nc1Njb3BlLl9nc0RlZmluZS5wbHVnaW4oe3Byb3BOYW1lOlwiYXR0clwiLEFQSToyLHZlcnNpb246XCIwLjUuMFwiLGluaXQ6ZnVuY3Rpb24odCxlKXt2YXIgaTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0LnNldEF0dHJpYnV0ZSlyZXR1cm4hMTtmb3IoaSBpbiBlKXRoaXMuX2FkZFR3ZWVuKHQsXCJzZXRBdHRyaWJ1dGVcIix0LmdldEF0dHJpYnV0ZShpKStcIlwiLGVbaV0rXCJcIixpLCExLGkpLHRoaXMuX292ZXJ3cml0ZVByb3BzLnB1c2goaSk7cmV0dXJuITB9fSl9KCksX2dzU2NvcGUuX2dzRGVmaW5lLnBsdWdpbih7cHJvcE5hbWU6XCJkaXJlY3Rpb25hbFJvdGF0aW9uXCIsdmVyc2lvbjpcIjAuMi4xXCIsQVBJOjIsaW5pdDpmdW5jdGlvbih0LGUpe1wib2JqZWN0XCIhPXR5cGVvZiBlJiYoZT17cm90YXRpb246ZX0pLHRoaXMuZmluYWxzPXt9O3ZhciBpLHMscixuLGEsbyxsPWUudXNlUmFkaWFucz09PSEwPzIqTWF0aC5QSTozNjAsaD0xZS02O2ZvcihpIGluIGUpXCJ1c2VSYWRpYW5zXCIhPT1pJiYobz0oZVtpXStcIlwiKS5zcGxpdChcIl9cIikscz1vWzBdLHI9cGFyc2VGbG9hdChcImZ1bmN0aW9uXCIhPXR5cGVvZiB0W2ldP3RbaV06dFtpLmluZGV4T2YoXCJzZXRcIil8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIHRbXCJnZXRcIitpLnN1YnN0cigzKV0/aTpcImdldFwiK2kuc3Vic3RyKDMpXSgpKSxuPXRoaXMuZmluYWxzW2ldPVwic3RyaW5nXCI9PXR5cGVvZiBzJiZcIj1cIj09PXMuY2hhckF0KDEpP3IrcGFyc2VJbnQocy5jaGFyQXQoMCkrXCIxXCIsMTApKk51bWJlcihzLnN1YnN0cigyKSk6TnVtYmVyKHMpfHwwLGE9bi1yLG8ubGVuZ3RoJiYocz1vLmpvaW4oXCJfXCIpLC0xIT09cy5pbmRleE9mKFwic2hvcnRcIikmJihhJT1sLGEhPT1hJShsLzIpJiYoYT0wPmE/YStsOmEtbCkpLC0xIT09cy5pbmRleE9mKFwiX2N3XCIpJiYwPmE/YT0oYSs5OTk5OTk5OTk5KmwpJWwtKDB8YS9sKSpsOi0xIT09cy5pbmRleE9mKFwiY2N3XCIpJiZhPjAmJihhPShhLTk5OTk5OTk5OTkqbCklbC0oMHxhL2wpKmwpKSwoYT5ofHwtaD5hKSYmKHRoaXMuX2FkZFR3ZWVuKHQsaSxyLHIrYSxpKSx0aGlzLl9vdmVyd3JpdGVQcm9wcy5wdXNoKGkpKSk7cmV0dXJuITB9LHNldDpmdW5jdGlvbih0KXt2YXIgZTtpZigxIT09dCl0aGlzLl9zdXBlci5zZXRSYXRpby5jYWxsKHRoaXMsdCk7ZWxzZSBmb3IoZT10aGlzLl9maXJzdFBUO2U7KWUuZj9lLnRbZS5wXSh0aGlzLmZpbmFsc1tlLnBdKTplLnRbZS5wXT10aGlzLmZpbmFsc1tlLnBdLGU9ZS5fbmV4dH19KS5fYXV0b0NTUz0hMCxfZ3NTY29wZS5fZ3NEZWZpbmUoXCJlYXNpbmcuQmFja1wiLFtcImVhc2luZy5FYXNlXCJdLGZ1bmN0aW9uKHQpe3ZhciBlLGkscyxyPV9nc1Njb3BlLkdyZWVuU29ja0dsb2JhbHN8fF9nc1Njb3BlLG49ci5jb20uZ3JlZW5zb2NrLGE9MipNYXRoLlBJLG89TWF0aC5QSS8yLGw9bi5fY2xhc3MsaD1mdW5jdGlvbihlLGkpe3ZhciBzPWwoXCJlYXNpbmcuXCIrZSxmdW5jdGlvbigpe30sITApLHI9cy5wcm90b3R5cGU9bmV3IHQ7cmV0dXJuIHIuY29uc3RydWN0b3I9cyxyLmdldFJhdGlvPWksc30sXz10LnJlZ2lzdGVyfHxmdW5jdGlvbigpe30sdT1mdW5jdGlvbih0LGUsaSxzKXt2YXIgcj1sKFwiZWFzaW5nLlwiK3Qse2Vhc2VPdXQ6bmV3IGUsZWFzZUluOm5ldyBpLGVhc2VJbk91dDpuZXcgc30sITApO3JldHVybiBfKHIsdCkscn0sYz1mdW5jdGlvbih0LGUsaSl7dGhpcy50PXQsdGhpcy52PWUsaSYmKHRoaXMubmV4dD1pLGkucHJldj10aGlzLHRoaXMuYz1pLnYtZSx0aGlzLmdhcD1pLnQtdCl9LGY9ZnVuY3Rpb24oZSxpKXt2YXIgcz1sKFwiZWFzaW5nLlwiK2UsZnVuY3Rpb24odCl7dGhpcy5fcDE9dHx8MD09PXQ/dDoxLjcwMTU4LHRoaXMuX3AyPTEuNTI1KnRoaXMuX3AxfSwhMCkscj1zLnByb3RvdHlwZT1uZXcgdDtyZXR1cm4gci5jb25zdHJ1Y3Rvcj1zLHIuZ2V0UmF0aW89aSxyLmNvbmZpZz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IHModCl9LHN9LHA9dShcIkJhY2tcIixmKFwiQmFja091dFwiLGZ1bmN0aW9uKHQpe3JldHVybih0LT0xKSp0KigodGhpcy5fcDErMSkqdCt0aGlzLl9wMSkrMX0pLGYoXCJCYWNrSW5cIixmdW5jdGlvbih0KXtyZXR1cm4gdCp0KigodGhpcy5fcDErMSkqdC10aGlzLl9wMSl9KSxmKFwiQmFja0luT3V0XCIsZnVuY3Rpb24odCl7cmV0dXJuIDE+KHQqPTIpPy41KnQqdCooKHRoaXMuX3AyKzEpKnQtdGhpcy5fcDIpOi41KigodC09MikqdCooKHRoaXMuX3AyKzEpKnQrdGhpcy5fcDIpKzIpfSkpLG09bChcImVhc2luZy5TbG93TW9cIixmdW5jdGlvbih0LGUsaSl7ZT1lfHwwPT09ZT9lOi43LG51bGw9PXQ/dD0uNzp0PjEmJih0PTEpLHRoaXMuX3A9MSE9PXQ/ZTowLHRoaXMuX3AxPSgxLXQpLzIsdGhpcy5fcDI9dCx0aGlzLl9wMz10aGlzLl9wMSt0aGlzLl9wMix0aGlzLl9jYWxjRW5kPWk9PT0hMH0sITApLGQ9bS5wcm90b3R5cGU9bmV3IHQ7cmV0dXJuIGQuY29uc3RydWN0b3I9bSxkLmdldFJhdGlvPWZ1bmN0aW9uKHQpe3ZhciBlPXQrKC41LXQpKnRoaXMuX3A7cmV0dXJuIHRoaXMuX3AxPnQ/dGhpcy5fY2FsY0VuZD8xLSh0PTEtdC90aGlzLl9wMSkqdDplLSh0PTEtdC90aGlzLl9wMSkqdCp0KnQqZTp0PnRoaXMuX3AzP3RoaXMuX2NhbGNFbmQ/MS0odD0odC10aGlzLl9wMykvdGhpcy5fcDEpKnQ6ZSsodC1lKSoodD0odC10aGlzLl9wMykvdGhpcy5fcDEpKnQqdCp0OnRoaXMuX2NhbGNFbmQ/MTplfSxtLmVhc2U9bmV3IG0oLjcsLjcpLGQuY29uZmlnPW0uY29uZmlnPWZ1bmN0aW9uKHQsZSxpKXtyZXR1cm4gbmV3IG0odCxlLGkpfSxlPWwoXCJlYXNpbmcuU3RlcHBlZEVhc2VcIixmdW5jdGlvbih0KXt0PXR8fDEsdGhpcy5fcDE9MS90LHRoaXMuX3AyPXQrMX0sITApLGQ9ZS5wcm90b3R5cGU9bmV3IHQsZC5jb25zdHJ1Y3Rvcj1lLGQuZ2V0UmF0aW89ZnVuY3Rpb24odCl7cmV0dXJuIDA+dD90PTA6dD49MSYmKHQ9Ljk5OTk5OTk5OSksKHRoaXMuX3AyKnQ+PjApKnRoaXMuX3AxfSxkLmNvbmZpZz1lLmNvbmZpZz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCl9LGk9bChcImVhc2luZy5Sb3VnaEVhc2VcIixmdW5jdGlvbihlKXtlPWV8fHt9O2Zvcih2YXIgaSxzLHIsbixhLG8sbD1lLnRhcGVyfHxcIm5vbmVcIixoPVtdLF89MCx1PTB8KGUucG9pbnRzfHwyMCksZj11LHA9ZS5yYW5kb21pemUhPT0hMSxtPWUuY2xhbXA9PT0hMCxkPWUudGVtcGxhdGUgaW5zdGFuY2VvZiB0P2UudGVtcGxhdGU6bnVsbCxnPVwibnVtYmVyXCI9PXR5cGVvZiBlLnN0cmVuZ3RoPy40KmUuc3RyZW5ndGg6LjQ7LS1mPi0xOylpPXA/TWF0aC5yYW5kb20oKToxL3UqZixzPWQ/ZC5nZXRSYXRpbyhpKTppLFwibm9uZVwiPT09bD9yPWc6XCJvdXRcIj09PWw/KG49MS1pLHI9bipuKmcpOlwiaW5cIj09PWw/cj1pKmkqZzouNT5pPyhuPTIqaSxyPS41Km4qbipnKToobj0yKigxLWkpLHI9LjUqbipuKmcpLHA/cys9TWF0aC5yYW5kb20oKSpyLS41KnI6ZiUyP3MrPS41KnI6cy09LjUqcixtJiYocz4xP3M9MTowPnMmJihzPTApKSxoW18rK109e3g6aSx5OnN9O2ZvcihoLnNvcnQoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC54LWUueH0pLG89bmV3IGMoMSwxLG51bGwpLGY9dTstLWY+LTE7KWE9aFtmXSxvPW5ldyBjKGEueCxhLnksbyk7dGhpcy5fcHJldj1uZXcgYygwLDAsMCE9PW8udD9vOm8ubmV4dCl9LCEwKSxkPWkucHJvdG90eXBlPW5ldyB0LGQuY29uc3RydWN0b3I9aSxkLmdldFJhdGlvPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX3ByZXY7aWYodD5lLnQpe2Zvcig7ZS5uZXh0JiZ0Pj1lLnQ7KWU9ZS5uZXh0O2U9ZS5wcmV2fWVsc2UgZm9yKDtlLnByZXYmJmUudD49dDspZT1lLnByZXY7cmV0dXJuIHRoaXMuX3ByZXY9ZSxlLnYrKHQtZS50KS9lLmdhcCplLmN9LGQuY29uZmlnPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgaSh0KX0saS5lYXNlPW5ldyBpLHUoXCJCb3VuY2VcIixoKFwiQm91bmNlT3V0XCIsZnVuY3Rpb24odCl7cmV0dXJuIDEvMi43NT50PzcuNTYyNSp0KnQ6Mi8yLjc1PnQ/Ny41NjI1Kih0LT0xLjUvMi43NSkqdCsuNzU6Mi41LzIuNzU+dD83LjU2MjUqKHQtPTIuMjUvMi43NSkqdCsuOTM3NTo3LjU2MjUqKHQtPTIuNjI1LzIuNzUpKnQrLjk4NDM3NX0pLGgoXCJCb3VuY2VJblwiLGZ1bmN0aW9uKHQpe3JldHVybiAxLzIuNzU+KHQ9MS10KT8xLTcuNTYyNSp0KnQ6Mi8yLjc1PnQ/MS0oNy41NjI1Kih0LT0xLjUvMi43NSkqdCsuNzUpOjIuNS8yLjc1PnQ/MS0oNy41NjI1Kih0LT0yLjI1LzIuNzUpKnQrLjkzNzUpOjEtKDcuNTYyNSoodC09Mi42MjUvMi43NSkqdCsuOTg0Mzc1KX0pLGgoXCJCb3VuY2VJbk91dFwiLGZ1bmN0aW9uKHQpe3ZhciBlPS41PnQ7cmV0dXJuIHQ9ZT8xLTIqdDoyKnQtMSx0PTEvMi43NT50PzcuNTYyNSp0KnQ6Mi8yLjc1PnQ/Ny41NjI1Kih0LT0xLjUvMi43NSkqdCsuNzU6Mi41LzIuNzU+dD83LjU2MjUqKHQtPTIuMjUvMi43NSkqdCsuOTM3NTo3LjU2MjUqKHQtPTIuNjI1LzIuNzUpKnQrLjk4NDM3NSxlPy41KigxLXQpOi41KnQrLjV9KSksdShcIkNpcmNcIixoKFwiQ2lyY091dFwiLGZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLnNxcnQoMS0odC09MSkqdCl9KSxoKFwiQ2lyY0luXCIsZnVuY3Rpb24odCl7cmV0dXJuLShNYXRoLnNxcnQoMS10KnQpLTEpfSksaChcIkNpcmNJbk91dFwiLGZ1bmN0aW9uKHQpe3JldHVybiAxPih0Kj0yKT8tLjUqKE1hdGguc3FydCgxLXQqdCktMSk6LjUqKE1hdGguc3FydCgxLSh0LT0yKSp0KSsxKX0pKSxzPWZ1bmN0aW9uKGUsaSxzKXt2YXIgcj1sKFwiZWFzaW5nLlwiK2UsZnVuY3Rpb24odCxlKXt0aGlzLl9wMT10Pj0xP3Q6MSx0aGlzLl9wMj0oZXx8cykvKDE+dD90OjEpLHRoaXMuX3AzPXRoaXMuX3AyL2EqKE1hdGguYXNpbigxL3RoaXMuX3AxKXx8MCksdGhpcy5fcDI9YS90aGlzLl9wMn0sITApLG49ci5wcm90b3R5cGU9bmV3IHQ7cmV0dXJuIG4uY29uc3RydWN0b3I9cixuLmdldFJhdGlvPWksbi5jb25maWc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IHIodCxlKX0scn0sdShcIkVsYXN0aWNcIixzKFwiRWxhc3RpY091dFwiLGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9wMSpNYXRoLnBvdygyLC0xMCp0KSpNYXRoLnNpbigodC10aGlzLl9wMykqdGhpcy5fcDIpKzF9LC4zKSxzKFwiRWxhc3RpY0luXCIsZnVuY3Rpb24odCl7cmV0dXJuLSh0aGlzLl9wMSpNYXRoLnBvdygyLDEwKih0LT0xKSkqTWF0aC5zaW4oKHQtdGhpcy5fcDMpKnRoaXMuX3AyKSl9LC4zKSxzKFwiRWxhc3RpY0luT3V0XCIsZnVuY3Rpb24odCl7cmV0dXJuIDE+KHQqPTIpPy0uNSp0aGlzLl9wMSpNYXRoLnBvdygyLDEwKih0LT0xKSkqTWF0aC5zaW4oKHQtdGhpcy5fcDMpKnRoaXMuX3AyKTouNSp0aGlzLl9wMSpNYXRoLnBvdygyLC0xMCoodC09MSkpKk1hdGguc2luKCh0LXRoaXMuX3AzKSp0aGlzLl9wMikrMX0sLjQ1KSksdShcIkV4cG9cIixoKFwiRXhwb091dFwiLGZ1bmN0aW9uKHQpe3JldHVybiAxLU1hdGgucG93KDIsLTEwKnQpfSksaChcIkV4cG9JblwiLGZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLnBvdygyLDEwKih0LTEpKS0uMDAxfSksaChcIkV4cG9Jbk91dFwiLGZ1bmN0aW9uKHQpe3JldHVybiAxPih0Kj0yKT8uNSpNYXRoLnBvdygyLDEwKih0LTEpKTouNSooMi1NYXRoLnBvdygyLC0xMCoodC0xKSkpfSkpLHUoXCJTaW5lXCIsaChcIlNpbmVPdXRcIixmdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5zaW4odCpvKX0pLGgoXCJTaW5lSW5cIixmdW5jdGlvbih0KXtyZXR1cm4tTWF0aC5jb3ModCpvKSsxfSksaChcIlNpbmVJbk91dFwiLGZ1bmN0aW9uKHQpe3JldHVybi0uNSooTWF0aC5jb3MoTWF0aC5QSSp0KS0xKX0pKSxsKFwiZWFzaW5nLkVhc2VMb29rdXBcIix7ZmluZDpmdW5jdGlvbihlKXtyZXR1cm4gdC5tYXBbZV19fSwhMCksXyhyLlNsb3dNbyxcIlNsb3dNb1wiLFwiZWFzZSxcIiksXyhpLFwiUm91Z2hFYXNlXCIsXCJlYXNlLFwiKSxfKGUsXCJTdGVwcGVkRWFzZVwiLFwiZWFzZSxcIikscH0sITApfSksX2dzU2NvcGUuX2dzRGVmaW5lJiZfZ3NTY29wZS5fZ3NRdWV1ZS5wb3AoKSgpLGZ1bmN0aW9uKHQsZSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9dC5HcmVlblNvY2tHbG9iYWxzPXQuR3JlZW5Tb2NrR2xvYmFsc3x8dDtpZighaS5Ud2VlbkxpdGUpe3ZhciBzLHIsbixhLG8sbD1mdW5jdGlvbih0KXt2YXIgZSxzPXQuc3BsaXQoXCIuXCIpLHI9aTtmb3IoZT0wO3MubGVuZ3RoPmU7ZSsrKXJbc1tlXV09cj1yW3NbZV1dfHx7fTtyZXR1cm4gcn0saD1sKFwiY29tLmdyZWVuc29ja1wiKSxfPTFlLTEwLHU9ZnVuY3Rpb24odCl7dmFyIGUsaT1bXSxzPXQubGVuZ3RoO2ZvcihlPTA7ZSE9PXM7aS5wdXNoKHRbZSsrXSkpO3JldHVybiBpfSxjPWZ1bmN0aW9uKCl7fSxmPWZ1bmN0aW9uKCl7dmFyIHQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxlPXQuY2FsbChbXSk7cmV0dXJuIGZ1bmN0aW9uKGkpe3JldHVybiBudWxsIT1pJiYoaSBpbnN0YW5jZW9mIEFycmF5fHxcIm9iamVjdFwiPT10eXBlb2YgaSYmISFpLnB1c2gmJnQuY2FsbChpKT09PWUpfX0oKSxwPXt9LG09ZnVuY3Rpb24ocyxyLG4sYSl7dGhpcy5zYz1wW3NdP3Bbc10uc2M6W10scFtzXT10aGlzLHRoaXMuZ3NDbGFzcz1udWxsLHRoaXMuZnVuYz1uO3ZhciBvPVtdO3RoaXMuY2hlY2s9ZnVuY3Rpb24oaCl7Zm9yKHZhciBfLHUsYyxmLGQsZz1yLmxlbmd0aCx2PWc7LS1nPi0xOykoXz1wW3JbZ11dfHxuZXcgbShyW2ddLFtdKSkuZ3NDbGFzcz8ob1tnXT1fLmdzQ2xhc3Msdi0tKTpoJiZfLnNjLnB1c2godGhpcyk7aWYoMD09PXYmJm4pZm9yKHU9KFwiY29tLmdyZWVuc29jay5cIitzKS5zcGxpdChcIi5cIiksYz11LnBvcCgpLGY9bCh1LmpvaW4oXCIuXCIpKVtjXT10aGlzLmdzQ2xhc3M9bi5hcHBseShuLG8pLGEmJihpW2NdPWYsZD1cInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cywhZCYmXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZSgodC5HcmVlblNvY2tBTURQYXRoP3QuR3JlZW5Tb2NrQU1EUGF0aCtcIi9cIjpcIlwiKStzLnNwbGl0KFwiLlwiKS5wb3AoKSxbXSxmdW5jdGlvbigpe3JldHVybiBmfSk6cz09PWUmJmQmJihtb2R1bGUuZXhwb3J0cz1mKSksZz0wO3RoaXMuc2MubGVuZ3RoPmc7ZysrKXRoaXMuc2NbZ10uY2hlY2soKX0sdGhpcy5jaGVjayghMCl9LGQ9dC5fZ3NEZWZpbmU9ZnVuY3Rpb24odCxlLGkscyl7cmV0dXJuIG5ldyBtKHQsZSxpLHMpfSxnPWguX2NsYXNzPWZ1bmN0aW9uKHQsZSxpKXtyZXR1cm4gZT1lfHxmdW5jdGlvbigpe30sZCh0LFtdLGZ1bmN0aW9uKCl7cmV0dXJuIGV9LGkpLGV9O2QuZ2xvYmFscz1pO3ZhciB2PVswLDAsMSwxXSx5PVtdLFQ9ZyhcImVhc2luZy5FYXNlXCIsZnVuY3Rpb24odCxlLGkscyl7dGhpcy5fZnVuYz10LHRoaXMuX3R5cGU9aXx8MCx0aGlzLl9wb3dlcj1zfHwwLHRoaXMuX3BhcmFtcz1lP3YuY29uY2F0KGUpOnZ9LCEwKSx4PVQubWFwPXt9LHc9VC5yZWdpc3Rlcj1mdW5jdGlvbih0LGUsaSxzKXtmb3IodmFyIHIsbixhLG8sbD1lLnNwbGl0KFwiLFwiKSxfPWwubGVuZ3RoLHU9KGl8fFwiZWFzZUluLGVhc2VPdXQsZWFzZUluT3V0XCIpLnNwbGl0KFwiLFwiKTstLV8+LTE7KWZvcihuPWxbX10scj1zP2coXCJlYXNpbmcuXCIrbixudWxsLCEwKTpoLmVhc2luZ1tuXXx8e30sYT11Lmxlbmd0aDstLWE+LTE7KW89dVthXSx4W24rXCIuXCIrb109eFtvK25dPXJbb109dC5nZXRSYXRpbz90OnRbb118fG5ldyB0fTtmb3Iobj1ULnByb3RvdHlwZSxuLl9jYWxjRW5kPSExLG4uZ2V0UmF0aW89ZnVuY3Rpb24odCl7aWYodGhpcy5fZnVuYylyZXR1cm4gdGhpcy5fcGFyYW1zWzBdPXQsdGhpcy5fZnVuYy5hcHBseShudWxsLHRoaXMuX3BhcmFtcyk7dmFyIGU9dGhpcy5fdHlwZSxpPXRoaXMuX3Bvd2VyLHM9MT09PWU/MS10OjI9PT1lP3Q6LjU+dD8yKnQ6MiooMS10KTtyZXR1cm4gMT09PWk/cyo9czoyPT09aT9zKj1zKnM6Mz09PWk/cyo9cypzKnM6ND09PWkmJihzKj1zKnMqcypzKSwxPT09ZT8xLXM6Mj09PWU/czouNT50P3MvMjoxLXMvMn0scz1bXCJMaW5lYXJcIixcIlF1YWRcIixcIkN1YmljXCIsXCJRdWFydFwiLFwiUXVpbnQsU3Ryb25nXCJdLHI9cy5sZW5ndGg7LS1yPi0xOyluPXNbcl0rXCIsUG93ZXJcIityLHcobmV3IFQobnVsbCxudWxsLDEsciksbixcImVhc2VPdXRcIiwhMCksdyhuZXcgVChudWxsLG51bGwsMixyKSxuLFwiZWFzZUluXCIrKDA9PT1yP1wiLGVhc2VOb25lXCI6XCJcIikpLHcobmV3IFQobnVsbCxudWxsLDMsciksbixcImVhc2VJbk91dFwiKTt4LmxpbmVhcj1oLmVhc2luZy5MaW5lYXIuZWFzZUluLHguc3dpbmc9aC5lYXNpbmcuUXVhZC5lYXNlSW5PdXQ7dmFyIGI9ZyhcImV2ZW50cy5FdmVudERpc3BhdGNoZXJcIixmdW5jdGlvbih0KXt0aGlzLl9saXN0ZW5lcnM9e30sdGhpcy5fZXZlbnRUYXJnZXQ9dHx8dGhpc30pO249Yi5wcm90b3R5cGUsbi5hZGRFdmVudExpc3RlbmVyPWZ1bmN0aW9uKHQsZSxpLHMscil7cj1yfHwwO3ZhciBuLGwsaD10aGlzLl9saXN0ZW5lcnNbdF0sXz0wO2ZvcihudWxsPT1oJiYodGhpcy5fbGlzdGVuZXJzW3RdPWg9W10pLGw9aC5sZW5ndGg7LS1sPi0xOyluPWhbbF0sbi5jPT09ZSYmbi5zPT09aT9oLnNwbGljZShsLDEpOjA9PT1fJiZyPm4ucHImJihfPWwrMSk7aC5zcGxpY2UoXywwLHtjOmUsczppLHVwOnMscHI6cn0pLHRoaXMhPT1hfHxvfHxhLndha2UoKX0sbi5yZW1vdmVFdmVudExpc3RlbmVyPWZ1bmN0aW9uKHQsZSl7dmFyIGkscz10aGlzLl9saXN0ZW5lcnNbdF07aWYocylmb3IoaT1zLmxlbmd0aDstLWk+LTE7KWlmKHNbaV0uYz09PWUpcmV0dXJuIHMuc3BsaWNlKGksMSksdm9pZCAwfSxuLmRpc3BhdGNoRXZlbnQ9ZnVuY3Rpb24odCl7dmFyIGUsaSxzLHI9dGhpcy5fbGlzdGVuZXJzW3RdO2lmKHIpZm9yKGU9ci5sZW5ndGgsaT10aGlzLl9ldmVudFRhcmdldDstLWU+LTE7KXM9cltlXSxzJiYocy51cD9zLmMuY2FsbChzLnN8fGkse3R5cGU6dCx0YXJnZXQ6aX0pOnMuYy5jYWxsKHMuc3x8aSkpfTt2YXIgUD10LnJlcXVlc3RBbmltYXRpb25GcmFtZSxrPXQuY2FuY2VsQW5pbWF0aW9uRnJhbWUsUz1EYXRlLm5vd3x8ZnVuY3Rpb24oKXtyZXR1cm4obmV3IERhdGUpLmdldFRpbWUoKX0sUj1TKCk7Zm9yKHM9W1wibXNcIixcIm1velwiLFwid2Via2l0XCIsXCJvXCJdLHI9cy5sZW5ndGg7LS1yPi0xJiYhUDspUD10W3Nbcl0rXCJSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl0saz10W3Nbcl0rXCJDYW5jZWxBbmltYXRpb25GcmFtZVwiXXx8dFtzW3JdK1wiQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdO2coXCJUaWNrZXJcIixmdW5jdGlvbih0LGUpe3ZhciBpLHMscixuLGwsaD10aGlzLHU9UygpLGY9ZSE9PSExJiZQLHA9NTAwLG09MzMsZD1cInRpY2tcIixnPWZ1bmN0aW9uKHQpe3ZhciBlLGEsbz1TKCktUjtvPnAmJih1Kz1vLW0pLFIrPW8saC50aW1lPShSLXUpLzFlMyxlPWgudGltZS1sLCghaXx8ZT4wfHx0PT09ITApJiYoaC5mcmFtZSsrLGwrPWUrKGU+PW4/LjAwNDpuLWUpLGE9ITApLHQhPT0hMCYmKHI9cyhnKSksYSYmaC5kaXNwYXRjaEV2ZW50KGQpfTtiLmNhbGwoaCksaC50aW1lPWguZnJhbWU9MCxoLnRpY2s9ZnVuY3Rpb24oKXtnKCEwKX0saC5sYWdTbW9vdGhpbmc9ZnVuY3Rpb24odCxlKXtwPXR8fDEvXyxtPU1hdGgubWluKGUscCwwKX0saC5zbGVlcD1mdW5jdGlvbigpe251bGwhPXImJihmJiZrP2socik6Y2xlYXJUaW1lb3V0KHIpLHM9YyxyPW51bGwsaD09PWEmJihvPSExKSl9LGgud2FrZT1mdW5jdGlvbigpe251bGwhPT1yP2guc2xlZXAoKTpoLmZyYW1lPjEwJiYoUj1TKCktcCs1KSxzPTA9PT1pP2M6ZiYmUD9QOmZ1bmN0aW9uKHQpe3JldHVybiBzZXRUaW1lb3V0KHQsMHwxZTMqKGwtaC50aW1lKSsxKX0saD09PWEmJihvPSEwKSxnKDIpfSxoLmZwcz1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oaT10LG49MS8oaXx8NjApLGw9dGhpcy50aW1lK24saC53YWtlKCksdm9pZCAwKTppfSxoLnVzZVJBRj1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oaC5zbGVlcCgpLGY9dCxoLmZwcyhpKSx2b2lkIDApOmZ9LGguZnBzKHQpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtmJiY1PmguZnJhbWUmJmgudXNlUkFGKCExKX0sMTUwMCl9KSxuPWguVGlja2VyLnByb3RvdHlwZT1uZXcgaC5ldmVudHMuRXZlbnREaXNwYXRjaGVyLG4uY29uc3RydWN0b3I9aC5UaWNrZXI7dmFyIE89ZyhcImNvcmUuQW5pbWF0aW9uXCIsZnVuY3Rpb24odCxlKXtpZih0aGlzLnZhcnM9ZT1lfHx7fSx0aGlzLl9kdXJhdGlvbj10aGlzLl90b3RhbER1cmF0aW9uPXR8fDAsdGhpcy5fZGVsYXk9TnVtYmVyKGUuZGVsYXkpfHwwLHRoaXMuX3RpbWVTY2FsZT0xLHRoaXMuX2FjdGl2ZT1lLmltbWVkaWF0ZVJlbmRlcj09PSEwLHRoaXMuZGF0YT1lLmRhdGEsdGhpcy5fcmV2ZXJzZWQ9ZS5yZXZlcnNlZD09PSEwLFcpe298fGEud2FrZSgpO3ZhciBpPXRoaXMudmFycy51c2VGcmFtZXM/RzpXO2kuYWRkKHRoaXMsaS5fdGltZSksdGhpcy52YXJzLnBhdXNlZCYmdGhpcy5wYXVzZWQoITApfX0pO2E9Ty50aWNrZXI9bmV3IGguVGlja2VyLG49Ty5wcm90b3R5cGUsbi5fZGlydHk9bi5fZ2M9bi5faW5pdHRlZD1uLl9wYXVzZWQ9ITEsbi5fdG90YWxUaW1lPW4uX3RpbWU9MCxuLl9yYXdQcmV2VGltZT0tMSxuLl9uZXh0PW4uX2xhc3Q9bi5fb25VcGRhdGU9bi5fdGltZWxpbmU9bi50aW1lbGluZT1udWxsLG4uX3BhdXNlZD0hMTt2YXIgQT1mdW5jdGlvbigpe28mJlMoKS1SPjJlMyYmYS53YWtlKCksc2V0VGltZW91dChBLDJlMyl9O0EoKSxuLnBsYXk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbCE9dCYmdGhpcy5zZWVrKHQsZSksdGhpcy5yZXZlcnNlZCghMSkucGF1c2VkKCExKX0sbi5wYXVzZT1mdW5jdGlvbih0LGUpe3JldHVybiBudWxsIT10JiZ0aGlzLnNlZWsodCxlKSx0aGlzLnBhdXNlZCghMCl9LG4ucmVzdW1lPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG51bGwhPXQmJnRoaXMuc2Vlayh0LGUpLHRoaXMucGF1c2VkKCExKX0sbi5zZWVrPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudG90YWxUaW1lKE51bWJlcih0KSxlIT09ITEpfSxuLnJlc3RhcnQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5yZXZlcnNlZCghMSkucGF1c2VkKCExKS50b3RhbFRpbWUodD8tdGhpcy5fZGVsYXk6MCxlIT09ITEsITApfSxuLnJldmVyc2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbCE9dCYmdGhpcy5zZWVrKHR8fHRoaXMudG90YWxEdXJhdGlvbigpLGUpLHRoaXMucmV2ZXJzZWQoITApLnBhdXNlZCghMSl9LG4ucmVuZGVyPWZ1bmN0aW9uKCl7fSxuLmludmFsaWRhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdGltZT10aGlzLl90b3RhbFRpbWU9MCx0aGlzLl9pbml0dGVkPXRoaXMuX2djPSExLHRoaXMuX3Jhd1ByZXZUaW1lPS0xLCh0aGlzLl9nY3x8IXRoaXMudGltZWxpbmUpJiZ0aGlzLl9lbmFibGVkKCEwKSx0aGlzfSxuLmlzQWN0aXZlPWZ1bmN0aW9uKCl7dmFyIHQsZT10aGlzLl90aW1lbGluZSxpPXRoaXMuX3N0YXJ0VGltZTtyZXR1cm4hZXx8IXRoaXMuX2djJiYhdGhpcy5fcGF1c2VkJiZlLmlzQWN0aXZlKCkmJih0PWUucmF3VGltZSgpKT49aSYmaSt0aGlzLnRvdGFsRHVyYXRpb24oKS90aGlzLl90aW1lU2NhbGU+dH0sbi5fZW5hYmxlZD1mdW5jdGlvbih0LGUpe3JldHVybiBvfHxhLndha2UoKSx0aGlzLl9nYz0hdCx0aGlzLl9hY3RpdmU9dGhpcy5pc0FjdGl2ZSgpLGUhPT0hMCYmKHQmJiF0aGlzLnRpbWVsaW5lP3RoaXMuX3RpbWVsaW5lLmFkZCh0aGlzLHRoaXMuX3N0YXJ0VGltZS10aGlzLl9kZWxheSk6IXQmJnRoaXMudGltZWxpbmUmJnRoaXMuX3RpbWVsaW5lLl9yZW1vdmUodGhpcywhMCkpLCExfSxuLl9raWxsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2VuYWJsZWQoITEsITEpfSxuLmtpbGw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fa2lsbCh0LGUpLHRoaXN9LG4uX3VuY2FjaGU9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQ/dGhpczp0aGlzLnRpbWVsaW5lO2U7KWUuX2RpcnR5PSEwLGU9ZS50aW1lbGluZTtyZXR1cm4gdGhpc30sbi5fc3dhcFNlbGZJblBhcmFtcz1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5sZW5ndGgsaT10LmNvbmNhdCgpOy0tZT4tMTspXCJ7c2VsZn1cIj09PXRbZV0mJihpW2VdPXRoaXMpO3JldHVybiBpfSxuLl9jYWxsYmFjaz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLnZhcnM7ZVt0XS5hcHBseShlW3QrXCJTY29wZVwiXXx8ZS5jYWxsYmFja1Njb3BlfHx0aGlzLGVbdCtcIlBhcmFtc1wiXXx8eSl9LG4uZXZlbnRDYWxsYmFjaz1mdW5jdGlvbih0LGUsaSxzKXtpZihcIm9uXCI9PT0odHx8XCJcIikuc3Vic3RyKDAsMikpe3ZhciByPXRoaXMudmFycztpZigxPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gclt0XTtudWxsPT1lP2RlbGV0ZSByW3RdOihyW3RdPWUsclt0K1wiUGFyYW1zXCJdPWYoaSkmJi0xIT09aS5qb2luKFwiXCIpLmluZGV4T2YoXCJ7c2VsZn1cIik/dGhpcy5fc3dhcFNlbGZJblBhcmFtcyhpKTppLHJbdCtcIlNjb3BlXCJdPXMpLFwib25VcGRhdGVcIj09PXQmJih0aGlzLl9vblVwZGF0ZT1lKX1yZXR1cm4gdGhpc30sbi5kZWxheT1mdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcmJnRoaXMuc3RhcnRUaW1lKHRoaXMuX3N0YXJ0VGltZSt0LXRoaXMuX2RlbGF5KSx0aGlzLl9kZWxheT10LHRoaXMpOnRoaXMuX2RlbGF5fSxuLmR1cmF0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh0aGlzLl9kdXJhdGlvbj10aGlzLl90b3RhbER1cmF0aW9uPXQsdGhpcy5fdW5jYWNoZSghMCksdGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcmJnRoaXMuX3RpbWU+MCYmdGhpcy5fdGltZTx0aGlzLl9kdXJhdGlvbiYmMCE9PXQmJnRoaXMudG90YWxUaW1lKHRoaXMuX3RvdGFsVGltZSoodC90aGlzLl9kdXJhdGlvbiksITApLHRoaXMpOih0aGlzLl9kaXJ0eT0hMSx0aGlzLl9kdXJhdGlvbil9LG4udG90YWxEdXJhdGlvbj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fZGlydHk9ITEsYXJndW1lbnRzLmxlbmd0aD90aGlzLmR1cmF0aW9uKHQpOnRoaXMuX3RvdGFsRHVyYXRpb259LG4udGltZT1mdW5jdGlvbih0LGUpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh0aGlzLl9kaXJ0eSYmdGhpcy50b3RhbER1cmF0aW9uKCksdGhpcy50b3RhbFRpbWUodD50aGlzLl9kdXJhdGlvbj90aGlzLl9kdXJhdGlvbjp0LGUpKTp0aGlzLl90aW1lfSxuLnRvdGFsVGltZT1mdW5jdGlvbih0LGUsaSl7aWYob3x8YS53YWtlKCksIWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuX3RvdGFsVGltZTtpZih0aGlzLl90aW1lbGluZSl7aWYoMD50JiYhaSYmKHQrPXRoaXMudG90YWxEdXJhdGlvbigpKSx0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZyl7dGhpcy5fZGlydHkmJnRoaXMudG90YWxEdXJhdGlvbigpO3ZhciBzPXRoaXMuX3RvdGFsRHVyYXRpb24scj10aGlzLl90aW1lbGluZTtpZih0PnMmJiFpJiYodD1zKSx0aGlzLl9zdGFydFRpbWU9KHRoaXMuX3BhdXNlZD90aGlzLl9wYXVzZVRpbWU6ci5fdGltZSktKHRoaXMuX3JldmVyc2VkP3MtdDp0KS90aGlzLl90aW1lU2NhbGUsci5fZGlydHl8fHRoaXMuX3VuY2FjaGUoITEpLHIuX3RpbWVsaW5lKWZvcig7ci5fdGltZWxpbmU7KXIuX3RpbWVsaW5lLl90aW1lIT09KHIuX3N0YXJ0VGltZStyLl90b3RhbFRpbWUpL3IuX3RpbWVTY2FsZSYmci50b3RhbFRpbWUoci5fdG90YWxUaW1lLCEwKSxyPXIuX3RpbWVsaW5lfXRoaXMuX2djJiZ0aGlzLl9lbmFibGVkKCEwLCExKSwodGhpcy5fdG90YWxUaW1lIT09dHx8MD09PXRoaXMuX2R1cmF0aW9uKSYmKEYubGVuZ3RoJiZRKCksdGhpcy5yZW5kZXIodCxlLCExKSxGLmxlbmd0aCYmUSgpKX1yZXR1cm4gdGhpc30sbi5wcm9ncmVzcz1uLnRvdGFsUHJvZ3Jlc3M9ZnVuY3Rpb24odCxlKXt2YXIgaT10aGlzLmR1cmF0aW9uKCk7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/dGhpcy50b3RhbFRpbWUoaSp0LGUpOmk/dGhpcy5fdGltZS9pOnRoaXMucmF0aW99LG4uc3RhcnRUaW1lPWZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh0IT09dGhpcy5fc3RhcnRUaW1lJiYodGhpcy5fc3RhcnRUaW1lPXQsdGhpcy50aW1lbGluZSYmdGhpcy50aW1lbGluZS5fc29ydENoaWxkcmVuJiZ0aGlzLnRpbWVsaW5lLmFkZCh0aGlzLHQtdGhpcy5fZGVsYXkpKSx0aGlzKTp0aGlzLl9zdGFydFRpbWV9LG4uZW5kVGltZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fc3RhcnRUaW1lKygwIT10P3RoaXMudG90YWxEdXJhdGlvbigpOnRoaXMuZHVyYXRpb24oKSkvdGhpcy5fdGltZVNjYWxlfSxuLnRpbWVTY2FsZT1mdW5jdGlvbih0KXtpZighYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5fdGltZVNjYWxlO2lmKHQ9dHx8Xyx0aGlzLl90aW1lbGluZSYmdGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpe3ZhciBlPXRoaXMuX3BhdXNlVGltZSxpPWV8fDA9PT1lP2U6dGhpcy5fdGltZWxpbmUudG90YWxUaW1lKCk7dGhpcy5fc3RhcnRUaW1lPWktKGktdGhpcy5fc3RhcnRUaW1lKSp0aGlzLl90aW1lU2NhbGUvdH1yZXR1cm4gdGhpcy5fdGltZVNjYWxlPXQsdGhpcy5fdW5jYWNoZSghMSl9LG4ucmV2ZXJzZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHQhPXRoaXMuX3JldmVyc2VkJiYodGhpcy5fcmV2ZXJzZWQ9dCx0aGlzLnRvdGFsVGltZSh0aGlzLl90aW1lbGluZSYmIXRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nP3RoaXMudG90YWxEdXJhdGlvbigpLXRoaXMuX3RvdGFsVGltZTp0aGlzLl90b3RhbFRpbWUsITApKSx0aGlzKTp0aGlzLl9yZXZlcnNlZH0sbi5wYXVzZWQ9ZnVuY3Rpb24odCl7aWYoIWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuX3BhdXNlZDt2YXIgZSxpLHM9dGhpcy5fdGltZWxpbmU7cmV0dXJuIHQhPXRoaXMuX3BhdXNlZCYmcyYmKG98fHR8fGEud2FrZSgpLGU9cy5yYXdUaW1lKCksaT1lLXRoaXMuX3BhdXNlVGltZSwhdCYmcy5zbW9vdGhDaGlsZFRpbWluZyYmKHRoaXMuX3N0YXJ0VGltZSs9aSx0aGlzLl91bmNhY2hlKCExKSksdGhpcy5fcGF1c2VUaW1lPXQ/ZTpudWxsLHRoaXMuX3BhdXNlZD10LHRoaXMuX2FjdGl2ZT10aGlzLmlzQWN0aXZlKCksIXQmJjAhPT1pJiZ0aGlzLl9pbml0dGVkJiZ0aGlzLmR1cmF0aW9uKCkmJihlPXMuc21vb3RoQ2hpbGRUaW1pbmc/dGhpcy5fdG90YWxUaW1lOihlLXRoaXMuX3N0YXJ0VGltZSkvdGhpcy5fdGltZVNjYWxlLHRoaXMucmVuZGVyKGUsZT09PXRoaXMuX3RvdGFsVGltZSwhMCkpKSx0aGlzLl9nYyYmIXQmJnRoaXMuX2VuYWJsZWQoITAsITEpLHRoaXN9O3ZhciBDPWcoXCJjb3JlLlNpbXBsZVRpbWVsaW5lXCIsZnVuY3Rpb24odCl7Ty5jYWxsKHRoaXMsMCx0KSx0aGlzLmF1dG9SZW1vdmVDaGlsZHJlbj10aGlzLnNtb290aENoaWxkVGltaW5nPSEwfSk7bj1DLnByb3RvdHlwZT1uZXcgTyxuLmNvbnN0cnVjdG9yPUMsbi5raWxsKCkuX2djPSExLG4uX2ZpcnN0PW4uX2xhc3Q9bi5fcmVjZW50PW51bGwsbi5fc29ydENoaWxkcmVuPSExLG4uYWRkPW4uaW5zZXJ0PWZ1bmN0aW9uKHQsZSl7dmFyIGkscztpZih0Ll9zdGFydFRpbWU9TnVtYmVyKGV8fDApK3QuX2RlbGF5LHQuX3BhdXNlZCYmdGhpcyE9PXQuX3RpbWVsaW5lJiYodC5fcGF1c2VUaW1lPXQuX3N0YXJ0VGltZSsodGhpcy5yYXdUaW1lKCktdC5fc3RhcnRUaW1lKS90Ll90aW1lU2NhbGUpLHQudGltZWxpbmUmJnQudGltZWxpbmUuX3JlbW92ZSh0LCEwKSx0LnRpbWVsaW5lPXQuX3RpbWVsaW5lPXRoaXMsdC5fZ2MmJnQuX2VuYWJsZWQoITAsITApLGk9dGhpcy5fbGFzdCx0aGlzLl9zb3J0Q2hpbGRyZW4pZm9yKHM9dC5fc3RhcnRUaW1lO2kmJmkuX3N0YXJ0VGltZT5zOylpPWkuX3ByZXY7cmV0dXJuIGk/KHQuX25leHQ9aS5fbmV4dCxpLl9uZXh0PXQpOih0Ll9uZXh0PXRoaXMuX2ZpcnN0LHRoaXMuX2ZpcnN0PXQpLHQuX25leHQ/dC5fbmV4dC5fcHJldj10OnRoaXMuX2xhc3Q9dCx0Ll9wcmV2PWksdGhpcy5fcmVjZW50PXQsdGhpcy5fdGltZWxpbmUmJnRoaXMuX3VuY2FjaGUoITApLHRoaXN9LG4uX3JlbW92ZT1mdW5jdGlvbih0LGUpe3JldHVybiB0LnRpbWVsaW5lPT09dGhpcyYmKGV8fHQuX2VuYWJsZWQoITEsITApLHQuX3ByZXY/dC5fcHJldi5fbmV4dD10Ll9uZXh0OnRoaXMuX2ZpcnN0PT09dCYmKHRoaXMuX2ZpcnN0PXQuX25leHQpLHQuX25leHQ/dC5fbmV4dC5fcHJldj10Ll9wcmV2OnRoaXMuX2xhc3Q9PT10JiYodGhpcy5fbGFzdD10Ll9wcmV2KSx0Ll9uZXh0PXQuX3ByZXY9dC50aW1lbGluZT1udWxsLHQ9PT10aGlzLl9yZWNlbnQmJih0aGlzLl9yZWNlbnQ9dGhpcy5fbGFzdCksdGhpcy5fdGltZWxpbmUmJnRoaXMuX3VuY2FjaGUoITApKSx0aGlzfSxuLnJlbmRlcj1mdW5jdGlvbih0LGUsaSl7dmFyIHMscj10aGlzLl9maXJzdDtmb3IodGhpcy5fdG90YWxUaW1lPXRoaXMuX3RpbWU9dGhpcy5fcmF3UHJldlRpbWU9dDtyOylzPXIuX25leHQsKHIuX2FjdGl2ZXx8dD49ci5fc3RhcnRUaW1lJiYhci5fcGF1c2VkKSYmKHIuX3JldmVyc2VkP3IucmVuZGVyKChyLl9kaXJ0eT9yLnRvdGFsRHVyYXRpb24oKTpyLl90b3RhbER1cmF0aW9uKS0odC1yLl9zdGFydFRpbWUpKnIuX3RpbWVTY2FsZSxlLGkpOnIucmVuZGVyKCh0LXIuX3N0YXJ0VGltZSkqci5fdGltZVNjYWxlLGUsaSkpLHI9c30sbi5yYXdUaW1lPWZ1bmN0aW9uKCl7cmV0dXJuIG98fGEud2FrZSgpLHRoaXMuX3RvdGFsVGltZX07dmFyIEQ9ZyhcIlR3ZWVuTGl0ZVwiLGZ1bmN0aW9uKGUsaSxzKXtpZihPLmNhbGwodGhpcyxpLHMpLHRoaXMucmVuZGVyPUQucHJvdG90eXBlLnJlbmRlcixudWxsPT1lKXRocm93XCJDYW5ub3QgdHdlZW4gYSBudWxsIHRhcmdldC5cIjt0aGlzLnRhcmdldD1lPVwic3RyaW5nXCIhPXR5cGVvZiBlP2U6RC5zZWxlY3RvcihlKXx8ZTt2YXIgcixuLGEsbz1lLmpxdWVyeXx8ZS5sZW5ndGgmJmUhPT10JiZlWzBdJiYoZVswXT09PXR8fGVbMF0ubm9kZVR5cGUmJmVbMF0uc3R5bGUmJiFlLm5vZGVUeXBlKSxsPXRoaXMudmFycy5vdmVyd3JpdGU7aWYodGhpcy5fb3ZlcndyaXRlPWw9bnVsbD09bD9WW0QuZGVmYXVsdE92ZXJ3cml0ZV06XCJudW1iZXJcIj09dHlwZW9mIGw/bD4+MDpWW2xdLChvfHxlIGluc3RhbmNlb2YgQXJyYXl8fGUucHVzaCYmZihlKSkmJlwibnVtYmVyXCIhPXR5cGVvZiBlWzBdKWZvcih0aGlzLl90YXJnZXRzPWE9dShlKSx0aGlzLl9wcm9wTG9va3VwPVtdLHRoaXMuX3NpYmxpbmdzPVtdLHI9MDthLmxlbmd0aD5yO3IrKyluPWFbcl0sbj9cInN0cmluZ1wiIT10eXBlb2Ygbj9uLmxlbmd0aCYmbiE9PXQmJm5bMF0mJihuWzBdPT09dHx8blswXS5ub2RlVHlwZSYmblswXS5zdHlsZSYmIW4ubm9kZVR5cGUpPyhhLnNwbGljZShyLS0sMSksdGhpcy5fdGFyZ2V0cz1hPWEuY29uY2F0KHUobikpKToodGhpcy5fc2libGluZ3Nbcl09JChuLHRoaXMsITEpLDE9PT1sJiZ0aGlzLl9zaWJsaW5nc1tyXS5sZW5ndGg+MSYmSyhuLHRoaXMsbnVsbCwxLHRoaXMuX3NpYmxpbmdzW3JdKSk6KG49YVtyLS1dPUQuc2VsZWN0b3IobiksXCJzdHJpbmdcIj09dHlwZW9mIG4mJmEuc3BsaWNlKHIrMSwxKSk6YS5zcGxpY2Uoci0tLDEpO2Vsc2UgdGhpcy5fcHJvcExvb2t1cD17fSx0aGlzLl9zaWJsaW5ncz0kKGUsdGhpcywhMSksMT09PWwmJnRoaXMuX3NpYmxpbmdzLmxlbmd0aD4xJiZLKGUsdGhpcyxudWxsLDEsdGhpcy5fc2libGluZ3MpOyh0aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyfHwwPT09aSYmMD09PXRoaXMuX2RlbGF5JiZ0aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyIT09ITEpJiYodGhpcy5fdGltZT0tXyx0aGlzLnJlbmRlcigtdGhpcy5fZGVsYXkpKX0sITApLE09ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUubGVuZ3RoJiZlIT09dCYmZVswXSYmKGVbMF09PT10fHxlWzBdLm5vZGVUeXBlJiZlWzBdLnN0eWxlJiYhZS5ub2RlVHlwZSl9LHo9ZnVuY3Rpb24odCxlKXt2YXIgaSxzPXt9O2ZvcihpIGluIHQpcVtpXXx8aSBpbiBlJiZcInRyYW5zZm9ybVwiIT09aSYmXCJ4XCIhPT1pJiZcInlcIiE9PWkmJlwid2lkdGhcIiE9PWkmJlwiaGVpZ2h0XCIhPT1pJiZcImNsYXNzTmFtZVwiIT09aSYmXCJib3JkZXJcIiE9PWl8fCEoIWpbaV18fGpbaV0mJmpbaV0uX2F1dG9DU1MpfHwoc1tpXT10W2ldLGRlbGV0ZSB0W2ldKTt0LmNzcz1zfTtuPUQucHJvdG90eXBlPW5ldyBPLG4uY29uc3RydWN0b3I9RCxuLmtpbGwoKS5fZ2M9ITEsbi5yYXRpbz0wLG4uX2ZpcnN0UFQ9bi5fdGFyZ2V0cz1uLl9vdmVyd3JpdHRlblByb3BzPW4uX3N0YXJ0QXQ9bnVsbCxuLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkPW4uX2xhenk9ITEsRC52ZXJzaW9uPVwiMS4xOC4wXCIsRC5kZWZhdWx0RWFzZT1uLl9lYXNlPW5ldyBUKG51bGwsbnVsbCwxLDEpLEQuZGVmYXVsdE92ZXJ3cml0ZT1cImF1dG9cIixELnRpY2tlcj1hLEQuYXV0b1NsZWVwPTEyMCxELmxhZ1Ntb290aGluZz1mdW5jdGlvbih0LGUpe2EubGFnU21vb3RoaW5nKHQsZSl9LEQuc2VsZWN0b3I9dC4kfHx0LmpRdWVyeXx8ZnVuY3Rpb24oZSl7dmFyIGk9dC4kfHx0LmpRdWVyeTtyZXR1cm4gaT8oRC5zZWxlY3Rvcj1pLGkoZSkpOlwidW5kZWZpbmVkXCI9PXR5cGVvZiBkb2N1bWVudD9lOmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGw/ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlKTpkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIiNcIj09PWUuY2hhckF0KDApP2Uuc3Vic3RyKDEpOmUpfTt2YXIgRj1bXSxJPXt9LEU9Lyg/OigtfC09fFxcKz0pP1xcZCpcXC4/XFxkKig/OmVbXFwtK10/XFxkKyk/KVswLTldL2dpLE49ZnVuY3Rpb24odCl7Zm9yKHZhciBlLGk9dGhpcy5fZmlyc3RQVCxzPTFlLTY7aTspZT1pLmJsb2I/dD90aGlzLmpvaW4oXCJcIik6dGhpcy5zdGFydDppLmMqdCtpLnMsaS5yP2U9TWF0aC5yb3VuZChlKTpzPmUmJmU+LXMmJihlPTApLGkuZj9pLmZwP2kudFtpLnBdKGkuZnAsZSk6aS50W2kucF0oZSk6aS50W2kucF09ZSxpPWkuX25leHR9LEw9ZnVuY3Rpb24odCxlLGkscyl7dmFyIHIsbixhLG8sbCxoLF8sdT1bdCxlXSxjPTAsZj1cIlwiLHA9MDtmb3IodS5zdGFydD10LGkmJihpKHUpLHQ9dVswXSxlPXVbMV0pLHUubGVuZ3RoPTAscj10Lm1hdGNoKEUpfHxbXSxuPWUubWF0Y2goRSl8fFtdLHMmJihzLl9uZXh0PW51bGwscy5ibG9iPTEsdS5fZmlyc3RQVD1zKSxsPW4ubGVuZ3RoLG89MDtsPm87bysrKV89bltvXSxoPWUuc3Vic3RyKGMsZS5pbmRleE9mKF8sYyktYyksZis9aHx8IW8/aDpcIixcIixjKz1oLmxlbmd0aCxwP3A9KHArMSklNTpcInJnYmEoXCI9PT1oLnN1YnN0cigtNSkmJihwPTEpLF89PT1yW29dfHxvPj1yLmxlbmd0aD9mKz1fOihmJiYodS5wdXNoKGYpLGY9XCJcIiksYT1wYXJzZUZsb2F0KHJbb10pLHUucHVzaChhKSx1Ll9maXJzdFBUPXtfbmV4dDp1Ll9maXJzdFBULHQ6dSxwOnUubGVuZ3RoLTEsczphLGM6KFwiPVwiPT09Xy5jaGFyQXQoMSk/cGFyc2VJbnQoXy5jaGFyQXQoMCkrXCIxXCIsMTApKnBhcnNlRmxvYXQoXy5zdWJzdHIoMikpOnBhcnNlRmxvYXQoXyktYSl8fDAsZjowLHI6cCYmND5wfSksYys9Xy5sZW5ndGg7cmV0dXJuIGYrPWUuc3Vic3RyKGMpLGYmJnUucHVzaChmKSx1LnNldFJhdGlvPU4sdX0sWD1mdW5jdGlvbih0LGUsaSxzLHIsbixhLG8pe3ZhciBsLGgsXz1cImdldFwiPT09aT90W2VdOmksdT10eXBlb2YgdFtlXSxjPVwic3RyaW5nXCI9PXR5cGVvZiBzJiZcIj1cIj09PXMuY2hhckF0KDEpLGY9e3Q6dCxwOmUsczpfLGY6XCJmdW5jdGlvblwiPT09dSxwZzowLG46cnx8ZSxyOm4scHI6MCxjOmM/cGFyc2VJbnQocy5jaGFyQXQoMCkrXCIxXCIsMTApKnBhcnNlRmxvYXQocy5zdWJzdHIoMikpOnBhcnNlRmxvYXQocyktX3x8MH07cmV0dXJuXCJudW1iZXJcIiE9PXUmJihcImZ1bmN0aW9uXCI9PT11JiZcImdldFwiPT09aSYmKGg9ZS5pbmRleE9mKFwic2V0XCIpfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiB0W1wiZ2V0XCIrZS5zdWJzdHIoMyldP2U6XCJnZXRcIitlLnN1YnN0cigzKSxmLnM9Xz1hP3RbaF0oYSk6dFtoXSgpKSxcInN0cmluZ1wiPT10eXBlb2YgXyYmKGF8fGlzTmFOKF8pKT8oZi5mcD1hLGw9TChfLHMsb3x8RC5kZWZhdWx0U3RyaW5nRmlsdGVyLGYpLGY9e3Q6bCxwOlwic2V0UmF0aW9cIixzOjAsYzoxLGY6MixwZzowLG46cnx8ZSxwcjowfSk6Y3x8KGYuYz1wYXJzZUZsb2F0KHMpLXBhcnNlRmxvYXQoXyl8fDApKSxmLmM/KChmLl9uZXh0PXRoaXMuX2ZpcnN0UFQpJiYoZi5fbmV4dC5fcHJldj1mKSx0aGlzLl9maXJzdFBUPWYsZik6dm9pZCAwfSxCPUQuX2ludGVybmFscz17aXNBcnJheTpmLGlzU2VsZWN0b3I6TSxsYXp5VHdlZW5zOkYsYmxvYkRpZjpMfSxqPUQuX3BsdWdpbnM9e30sWT1CLnR3ZWVuTG9va3VwPXt9LFU9MCxxPUIucmVzZXJ2ZWRQcm9wcz17ZWFzZToxLGRlbGF5OjEsb3ZlcndyaXRlOjEsb25Db21wbGV0ZToxLG9uQ29tcGxldGVQYXJhbXM6MSxvbkNvbXBsZXRlU2NvcGU6MSx1c2VGcmFtZXM6MSxydW5CYWNrd2FyZHM6MSxzdGFydEF0OjEsb25VcGRhdGU6MSxvblVwZGF0ZVBhcmFtczoxLG9uVXBkYXRlU2NvcGU6MSxvblN0YXJ0OjEsb25TdGFydFBhcmFtczoxLG9uU3RhcnRTY29wZToxLG9uUmV2ZXJzZUNvbXBsZXRlOjEsb25SZXZlcnNlQ29tcGxldGVQYXJhbXM6MSxvblJldmVyc2VDb21wbGV0ZVNjb3BlOjEsb25SZXBlYXQ6MSxvblJlcGVhdFBhcmFtczoxLG9uUmVwZWF0U2NvcGU6MSxlYXNlUGFyYW1zOjEseW95bzoxLGltbWVkaWF0ZVJlbmRlcjoxLHJlcGVhdDoxLHJlcGVhdERlbGF5OjEsZGF0YToxLHBhdXNlZDoxLHJldmVyc2VkOjEsYXV0b0NTUzoxLGxhenk6MSxvbk92ZXJ3cml0ZToxLGNhbGxiYWNrU2NvcGU6MSxzdHJpbmdGaWx0ZXI6MX0sVj17bm9uZTowLGFsbDoxLGF1dG86Mixjb25jdXJyZW50OjMsYWxsT25TdGFydDo0LHByZWV4aXN0aW5nOjUsXCJ0cnVlXCI6MSxcImZhbHNlXCI6MH0sRz1PLl9yb290RnJhbWVzVGltZWxpbmU9bmV3IEMsVz1PLl9yb290VGltZWxpbmU9bmV3IEMsWj0zMCxRPUIubGF6eVJlbmRlcj1mdW5jdGlvbigpe3ZhciB0LGU9Ri5sZW5ndGg7Zm9yKEk9e307LS1lPi0xOyl0PUZbZV0sdCYmdC5fbGF6eSE9PSExJiYodC5yZW5kZXIodC5fbGF6eVswXSx0Ll9sYXp5WzFdLCEwKSx0Ll9sYXp5PSExKTtGLmxlbmd0aD0wfTtXLl9zdGFydFRpbWU9YS50aW1lLEcuX3N0YXJ0VGltZT1hLmZyYW1lLFcuX2FjdGl2ZT1HLl9hY3RpdmU9ITAsc2V0VGltZW91dChRLDEpLE8uX3VwZGF0ZVJvb3Q9RC5yZW5kZXI9ZnVuY3Rpb24oKXt2YXIgdCxlLGk7aWYoRi5sZW5ndGgmJlEoKSxXLnJlbmRlcigoYS50aW1lLVcuX3N0YXJ0VGltZSkqVy5fdGltZVNjYWxlLCExLCExKSxHLnJlbmRlcigoYS5mcmFtZS1HLl9zdGFydFRpbWUpKkcuX3RpbWVTY2FsZSwhMSwhMSksRi5sZW5ndGgmJlEoKSxhLmZyYW1lPj1aKXtaPWEuZnJhbWUrKHBhcnNlSW50KEQuYXV0b1NsZWVwLDEwKXx8MTIwKTtcbmZvcihpIGluIFkpe2ZvcihlPVlbaV0udHdlZW5zLHQ9ZS5sZW5ndGg7LS10Pi0xOyllW3RdLl9nYyYmZS5zcGxpY2UodCwxKTswPT09ZS5sZW5ndGgmJmRlbGV0ZSBZW2ldfWlmKGk9Vy5fZmlyc3QsKCFpfHxpLl9wYXVzZWQpJiZELmF1dG9TbGVlcCYmIUcuX2ZpcnN0JiYxPT09YS5fbGlzdGVuZXJzLnRpY2subGVuZ3RoKXtmb3IoO2kmJmkuX3BhdXNlZDspaT1pLl9uZXh0O2l8fGEuc2xlZXAoKX19fSxhLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsTy5fdXBkYXRlUm9vdCk7dmFyICQ9ZnVuY3Rpb24odCxlLGkpe3ZhciBzLHIsbj10Ll9nc1R3ZWVuSUQ7aWYoWVtufHwodC5fZ3NUd2VlbklEPW49XCJ0XCIrVSsrKV18fChZW25dPXt0YXJnZXQ6dCx0d2VlbnM6W119KSxlJiYocz1ZW25dLnR3ZWVucyxzW3I9cy5sZW5ndGhdPWUsaSkpZm9yKDstLXI+LTE7KXNbcl09PT1lJiZzLnNwbGljZShyLDEpO3JldHVybiBZW25dLnR3ZWVuc30sSD1mdW5jdGlvbih0LGUsaSxzKXt2YXIgcixuLGE9dC52YXJzLm9uT3ZlcndyaXRlO3JldHVybiBhJiYocj1hKHQsZSxpLHMpKSxhPUQub25PdmVyd3JpdGUsYSYmKG49YSh0LGUsaSxzKSksciE9PSExJiZuIT09ITF9LEs9ZnVuY3Rpb24odCxlLGkscyxyKXt2YXIgbixhLG8sbDtpZigxPT09c3x8cz49NCl7Zm9yKGw9ci5sZW5ndGgsbj0wO2w+bjtuKyspaWYoKG89cltuXSkhPT1lKW8uX2djfHxvLl9raWxsKG51bGwsdCxlKSYmKGE9ITApO2Vsc2UgaWYoNT09PXMpYnJlYWs7cmV0dXJuIGF9dmFyIGgsdT1lLl9zdGFydFRpbWUrXyxjPVtdLGY9MCxwPTA9PT1lLl9kdXJhdGlvbjtmb3Iobj1yLmxlbmd0aDstLW4+LTE7KShvPXJbbl0pPT09ZXx8by5fZ2N8fG8uX3BhdXNlZHx8KG8uX3RpbWVsaW5lIT09ZS5fdGltZWxpbmU/KGg9aHx8SihlLDAscCksMD09PUoobyxoLHApJiYoY1tmKytdPW8pKTp1Pj1vLl9zdGFydFRpbWUmJm8uX3N0YXJ0VGltZStvLnRvdGFsRHVyYXRpb24oKS9vLl90aW1lU2NhbGU+dSYmKChwfHwhby5faW5pdHRlZCkmJjJlLTEwPj11LW8uX3N0YXJ0VGltZXx8KGNbZisrXT1vKSkpO2ZvcihuPWY7LS1uPi0xOylpZihvPWNbbl0sMj09PXMmJm8uX2tpbGwoaSx0LGUpJiYoYT0hMCksMiE9PXN8fCFvLl9maXJzdFBUJiZvLl9pbml0dGVkKXtpZigyIT09cyYmIUgobyxlKSljb250aW51ZTtvLl9lbmFibGVkKCExLCExKSYmKGE9ITApfXJldHVybiBhfSxKPWZ1bmN0aW9uKHQsZSxpKXtmb3IodmFyIHM9dC5fdGltZWxpbmUscj1zLl90aW1lU2NhbGUsbj10Ll9zdGFydFRpbWU7cy5fdGltZWxpbmU7KXtpZihuKz1zLl9zdGFydFRpbWUscio9cy5fdGltZVNjYWxlLHMuX3BhdXNlZClyZXR1cm4tMTAwO3M9cy5fdGltZWxpbmV9cmV0dXJuIG4vPXIsbj5lP24tZTppJiZuPT09ZXx8IXQuX2luaXR0ZWQmJjIqXz5uLWU/Xzoobis9dC50b3RhbER1cmF0aW9uKCkvdC5fdGltZVNjYWxlL3IpPmUrXz8wOm4tZS1ffTtuLl9pbml0PWZ1bmN0aW9uKCl7dmFyIHQsZSxpLHMscixuPXRoaXMudmFycyxhPXRoaXMuX292ZXJ3cml0dGVuUHJvcHMsbz10aGlzLl9kdXJhdGlvbixsPSEhbi5pbW1lZGlhdGVSZW5kZXIsaD1uLmVhc2U7aWYobi5zdGFydEF0KXt0aGlzLl9zdGFydEF0JiYodGhpcy5fc3RhcnRBdC5yZW5kZXIoLTEsITApLHRoaXMuX3N0YXJ0QXQua2lsbCgpKSxyPXt9O2ZvcihzIGluIG4uc3RhcnRBdClyW3NdPW4uc3RhcnRBdFtzXTtpZihyLm92ZXJ3cml0ZT0hMSxyLmltbWVkaWF0ZVJlbmRlcj0hMCxyLmxhenk9bCYmbi5sYXp5IT09ITEsci5zdGFydEF0PXIuZGVsYXk9bnVsbCx0aGlzLl9zdGFydEF0PUQudG8odGhpcy50YXJnZXQsMCxyKSxsKWlmKHRoaXMuX3RpbWU+MCl0aGlzLl9zdGFydEF0PW51bGw7ZWxzZSBpZigwIT09bylyZXR1cm59ZWxzZSBpZihuLnJ1bkJhY2t3YXJkcyYmMCE9PW8paWYodGhpcy5fc3RhcnRBdCl0aGlzLl9zdGFydEF0LnJlbmRlcigtMSwhMCksdGhpcy5fc3RhcnRBdC5raWxsKCksdGhpcy5fc3RhcnRBdD1udWxsO2Vsc2V7MCE9PXRoaXMuX3RpbWUmJihsPSExKSxpPXt9O2ZvcihzIGluIG4pcVtzXSYmXCJhdXRvQ1NTXCIhPT1zfHwoaVtzXT1uW3NdKTtpZihpLm92ZXJ3cml0ZT0wLGkuZGF0YT1cImlzRnJvbVN0YXJ0XCIsaS5sYXp5PWwmJm4ubGF6eSE9PSExLGkuaW1tZWRpYXRlUmVuZGVyPWwsdGhpcy5fc3RhcnRBdD1ELnRvKHRoaXMudGFyZ2V0LDAsaSksbCl7aWYoMD09PXRoaXMuX3RpbWUpcmV0dXJufWVsc2UgdGhpcy5fc3RhcnRBdC5faW5pdCgpLHRoaXMuX3N0YXJ0QXQuX2VuYWJsZWQoITEpLHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXImJih0aGlzLl9zdGFydEF0PW51bGwpfWlmKHRoaXMuX2Vhc2U9aD1oP2ggaW5zdGFuY2VvZiBUP2g6XCJmdW5jdGlvblwiPT10eXBlb2YgaD9uZXcgVChoLG4uZWFzZVBhcmFtcyk6eFtoXXx8RC5kZWZhdWx0RWFzZTpELmRlZmF1bHRFYXNlLG4uZWFzZVBhcmFtcyBpbnN0YW5jZW9mIEFycmF5JiZoLmNvbmZpZyYmKHRoaXMuX2Vhc2U9aC5jb25maWcuYXBwbHkoaCxuLmVhc2VQYXJhbXMpKSx0aGlzLl9lYXNlVHlwZT10aGlzLl9lYXNlLl90eXBlLHRoaXMuX2Vhc2VQb3dlcj10aGlzLl9lYXNlLl9wb3dlcix0aGlzLl9maXJzdFBUPW51bGwsdGhpcy5fdGFyZ2V0cylmb3IodD10aGlzLl90YXJnZXRzLmxlbmd0aDstLXQ+LTE7KXRoaXMuX2luaXRQcm9wcyh0aGlzLl90YXJnZXRzW3RdLHRoaXMuX3Byb3BMb29rdXBbdF09e30sdGhpcy5fc2libGluZ3NbdF0sYT9hW3RdOm51bGwpJiYoZT0hMCk7ZWxzZSBlPXRoaXMuX2luaXRQcm9wcyh0aGlzLnRhcmdldCx0aGlzLl9wcm9wTG9va3VwLHRoaXMuX3NpYmxpbmdzLGEpO2lmKGUmJkQuX29uUGx1Z2luRXZlbnQoXCJfb25Jbml0QWxsUHJvcHNcIix0aGlzKSxhJiYodGhpcy5fZmlyc3RQVHx8XCJmdW5jdGlvblwiIT10eXBlb2YgdGhpcy50YXJnZXQmJnRoaXMuX2VuYWJsZWQoITEsITEpKSxuLnJ1bkJhY2t3YXJkcylmb3IoaT10aGlzLl9maXJzdFBUO2k7KWkucys9aS5jLGkuYz0taS5jLGk9aS5fbmV4dDt0aGlzLl9vblVwZGF0ZT1uLm9uVXBkYXRlLHRoaXMuX2luaXR0ZWQ9ITB9LG4uX2luaXRQcm9wcz1mdW5jdGlvbihlLGkscyxyKXt2YXIgbixhLG8sbCxoLF87aWYobnVsbD09ZSlyZXR1cm4hMTtJW2UuX2dzVHdlZW5JRF0mJlEoKSx0aGlzLnZhcnMuY3NzfHxlLnN0eWxlJiZlIT09dCYmZS5ub2RlVHlwZSYmai5jc3MmJnRoaXMudmFycy5hdXRvQ1NTIT09ITEmJnoodGhpcy52YXJzLGUpO2ZvcihuIGluIHRoaXMudmFycylpZihfPXRoaXMudmFyc1tuXSxxW25dKV8mJihfIGluc3RhbmNlb2YgQXJyYXl8fF8ucHVzaCYmZihfKSkmJi0xIT09Xy5qb2luKFwiXCIpLmluZGV4T2YoXCJ7c2VsZn1cIikmJih0aGlzLnZhcnNbbl09Xz10aGlzLl9zd2FwU2VsZkluUGFyYW1zKF8sdGhpcykpO2Vsc2UgaWYoaltuXSYmKGw9bmV3IGpbbl0pLl9vbkluaXRUd2VlbihlLHRoaXMudmFyc1tuXSx0aGlzKSl7Zm9yKHRoaXMuX2ZpcnN0UFQ9aD17X25leHQ6dGhpcy5fZmlyc3RQVCx0OmwscDpcInNldFJhdGlvXCIsczowLGM6MSxmOjEsbjpuLHBnOjEscHI6bC5fcHJpb3JpdHl9LGE9bC5fb3ZlcndyaXRlUHJvcHMubGVuZ3RoOy0tYT4tMTspaVtsLl9vdmVyd3JpdGVQcm9wc1thXV09dGhpcy5fZmlyc3RQVDsobC5fcHJpb3JpdHl8fGwuX29uSW5pdEFsbFByb3BzKSYmKG89ITApLChsLl9vbkRpc2FibGV8fGwuX29uRW5hYmxlKSYmKHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQ9ITApLGguX25leHQmJihoLl9uZXh0Ll9wcmV2PWgpfWVsc2UgaVtuXT1YLmNhbGwodGhpcyxlLG4sXCJnZXRcIixfLG4sMCxudWxsLHRoaXMudmFycy5zdHJpbmdGaWx0ZXIpO3JldHVybiByJiZ0aGlzLl9raWxsKHIsZSk/dGhpcy5faW5pdFByb3BzKGUsaSxzLHIpOnRoaXMuX292ZXJ3cml0ZT4xJiZ0aGlzLl9maXJzdFBUJiZzLmxlbmd0aD4xJiZLKGUsdGhpcyxpLHRoaXMuX292ZXJ3cml0ZSxzKT8odGhpcy5fa2lsbChpLGUpLHRoaXMuX2luaXRQcm9wcyhlLGkscyxyKSk6KHRoaXMuX2ZpcnN0UFQmJih0aGlzLnZhcnMubGF6eSE9PSExJiZ0aGlzLl9kdXJhdGlvbnx8dGhpcy52YXJzLmxhenkmJiF0aGlzLl9kdXJhdGlvbikmJihJW2UuX2dzVHdlZW5JRF09ITApLG8pfSxuLnJlbmRlcj1mdW5jdGlvbih0LGUsaSl7dmFyIHMscixuLGEsbz10aGlzLl90aW1lLGw9dGhpcy5fZHVyYXRpb24saD10aGlzLl9yYXdQcmV2VGltZTtpZih0Pj1sKXRoaXMuX3RvdGFsVGltZT10aGlzLl90aW1lPWwsdGhpcy5yYXRpbz10aGlzLl9lYXNlLl9jYWxjRW5kP3RoaXMuX2Vhc2UuZ2V0UmF0aW8oMSk6MSx0aGlzLl9yZXZlcnNlZHx8KHM9ITAscj1cIm9uQ29tcGxldGVcIixpPWl8fHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbiksMD09PWwmJih0aGlzLl9pbml0dGVkfHwhdGhpcy52YXJzLmxhenl8fGkpJiYodGhpcy5fc3RhcnRUaW1lPT09dGhpcy5fdGltZWxpbmUuX2R1cmF0aW9uJiYodD0wKSwoMD09PXR8fDA+aHx8aD09PV8mJlwiaXNQYXVzZVwiIT09dGhpcy5kYXRhKSYmaCE9PXQmJihpPSEwLGg+XyYmKHI9XCJvblJldmVyc2VDb21wbGV0ZVwiKSksdGhpcy5fcmF3UHJldlRpbWU9YT0hZXx8dHx8aD09PXQ/dDpfKTtlbHNlIGlmKDFlLTc+dCl0aGlzLl90b3RhbFRpbWU9dGhpcy5fdGltZT0wLHRoaXMucmF0aW89dGhpcy5fZWFzZS5fY2FsY0VuZD90aGlzLl9lYXNlLmdldFJhdGlvKDApOjAsKDAhPT1vfHwwPT09bCYmaD4wKSYmKHI9XCJvblJldmVyc2VDb21wbGV0ZVwiLHM9dGhpcy5fcmV2ZXJzZWQpLDA+dCYmKHRoaXMuX2FjdGl2ZT0hMSwwPT09bCYmKHRoaXMuX2luaXR0ZWR8fCF0aGlzLnZhcnMubGF6eXx8aSkmJihoPj0wJiYoaCE9PV98fFwiaXNQYXVzZVwiIT09dGhpcy5kYXRhKSYmKGk9ITApLHRoaXMuX3Jhd1ByZXZUaW1lPWE9IWV8fHR8fGg9PT10P3Q6XykpLHRoaXMuX2luaXR0ZWR8fChpPSEwKTtlbHNlIGlmKHRoaXMuX3RvdGFsVGltZT10aGlzLl90aW1lPXQsdGhpcy5fZWFzZVR5cGUpe3ZhciB1PXQvbCxjPXRoaXMuX2Vhc2VUeXBlLGY9dGhpcy5fZWFzZVBvd2VyOygxPT09Y3x8Mz09PWMmJnU+PS41KSYmKHU9MS11KSwzPT09YyYmKHUqPTIpLDE9PT1mP3UqPXU6Mj09PWY/dSo9dSp1OjM9PT1mP3UqPXUqdSp1OjQ9PT1mJiYodSo9dSp1KnUqdSksdGhpcy5yYXRpbz0xPT09Yz8xLXU6Mj09PWM/dTouNT50L2w/dS8yOjEtdS8yfWVsc2UgdGhpcy5yYXRpbz10aGlzLl9lYXNlLmdldFJhdGlvKHQvbCk7aWYodGhpcy5fdGltZSE9PW98fGkpe2lmKCF0aGlzLl9pbml0dGVkKXtpZih0aGlzLl9pbml0KCksIXRoaXMuX2luaXR0ZWR8fHRoaXMuX2djKXJldHVybjtpZighaSYmdGhpcy5fZmlyc3RQVCYmKHRoaXMudmFycy5sYXp5IT09ITEmJnRoaXMuX2R1cmF0aW9ufHx0aGlzLnZhcnMubGF6eSYmIXRoaXMuX2R1cmF0aW9uKSlyZXR1cm4gdGhpcy5fdGltZT10aGlzLl90b3RhbFRpbWU9byx0aGlzLl9yYXdQcmV2VGltZT1oLEYucHVzaCh0aGlzKSx0aGlzLl9sYXp5PVt0LGVdLHZvaWQgMDt0aGlzLl90aW1lJiYhcz90aGlzLnJhdGlvPXRoaXMuX2Vhc2UuZ2V0UmF0aW8odGhpcy5fdGltZS9sKTpzJiZ0aGlzLl9lYXNlLl9jYWxjRW5kJiYodGhpcy5yYXRpbz10aGlzLl9lYXNlLmdldFJhdGlvKDA9PT10aGlzLl90aW1lPzA6MSkpfWZvcih0aGlzLl9sYXp5IT09ITEmJih0aGlzLl9sYXp5PSExKSx0aGlzLl9hY3RpdmV8fCF0aGlzLl9wYXVzZWQmJnRoaXMuX3RpbWUhPT1vJiZ0Pj0wJiYodGhpcy5fYWN0aXZlPSEwKSwwPT09byYmKHRoaXMuX3N0YXJ0QXQmJih0Pj0wP3RoaXMuX3N0YXJ0QXQucmVuZGVyKHQsZSxpKTpyfHwocj1cIl9kdW1teUdTXCIpKSx0aGlzLnZhcnMub25TdGFydCYmKDAhPT10aGlzLl90aW1lfHwwPT09bCkmJihlfHx0aGlzLl9jYWxsYmFjayhcIm9uU3RhcnRcIikpKSxuPXRoaXMuX2ZpcnN0UFQ7bjspbi5mP24udFtuLnBdKG4uYyp0aGlzLnJhdGlvK24ucyk6bi50W24ucF09bi5jKnRoaXMucmF0aW8rbi5zLG49bi5fbmV4dDt0aGlzLl9vblVwZGF0ZSYmKDA+dCYmdGhpcy5fc3RhcnRBdCYmdCE9PS0xZS00JiZ0aGlzLl9zdGFydEF0LnJlbmRlcih0LGUsaSksZXx8KHRoaXMuX3RpbWUhPT1vfHxzKSYmdGhpcy5fY2FsbGJhY2soXCJvblVwZGF0ZVwiKSksciYmKCF0aGlzLl9nY3x8aSkmJigwPnQmJnRoaXMuX3N0YXJ0QXQmJiF0aGlzLl9vblVwZGF0ZSYmdCE9PS0xZS00JiZ0aGlzLl9zdGFydEF0LnJlbmRlcih0LGUsaSkscyYmKHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbiYmdGhpcy5fZW5hYmxlZCghMSwhMSksdGhpcy5fYWN0aXZlPSExKSwhZSYmdGhpcy52YXJzW3JdJiZ0aGlzLl9jYWxsYmFjayhyKSwwPT09bCYmdGhpcy5fcmF3UHJldlRpbWU9PT1fJiZhIT09XyYmKHRoaXMuX3Jhd1ByZXZUaW1lPTApKX19LG4uX2tpbGw9ZnVuY3Rpb24odCxlLGkpe2lmKFwiYWxsXCI9PT10JiYodD1udWxsKSxudWxsPT10JiYobnVsbD09ZXx8ZT09PXRoaXMudGFyZ2V0KSlyZXR1cm4gdGhpcy5fbGF6eT0hMSx0aGlzLl9lbmFibGVkKCExLCExKTtlPVwic3RyaW5nXCIhPXR5cGVvZiBlP2V8fHRoaXMuX3RhcmdldHN8fHRoaXMudGFyZ2V0OkQuc2VsZWN0b3IoZSl8fGU7dmFyIHMscixuLGEsbyxsLGgsXyx1LGM9aSYmdGhpcy5fdGltZSYmaS5fc3RhcnRUaW1lPT09dGhpcy5fc3RhcnRUaW1lJiZ0aGlzLl90aW1lbGluZT09PWkuX3RpbWVsaW5lO2lmKChmKGUpfHxNKGUpKSYmXCJudW1iZXJcIiE9dHlwZW9mIGVbMF0pZm9yKHM9ZS5sZW5ndGg7LS1zPi0xOyl0aGlzLl9raWxsKHQsZVtzXSxpKSYmKGw9ITApO2Vsc2V7aWYodGhpcy5fdGFyZ2V0cyl7Zm9yKHM9dGhpcy5fdGFyZ2V0cy5sZW5ndGg7LS1zPi0xOylpZihlPT09dGhpcy5fdGFyZ2V0c1tzXSl7bz10aGlzLl9wcm9wTG9va3VwW3NdfHx7fSx0aGlzLl9vdmVyd3JpdHRlblByb3BzPXRoaXMuX292ZXJ3cml0dGVuUHJvcHN8fFtdLHI9dGhpcy5fb3ZlcndyaXR0ZW5Qcm9wc1tzXT10P3RoaXMuX292ZXJ3cml0dGVuUHJvcHNbc118fHt9OlwiYWxsXCI7YnJlYWt9fWVsc2V7aWYoZSE9PXRoaXMudGFyZ2V0KXJldHVybiExO289dGhpcy5fcHJvcExvb2t1cCxyPXRoaXMuX292ZXJ3cml0dGVuUHJvcHM9dD90aGlzLl9vdmVyd3JpdHRlblByb3BzfHx7fTpcImFsbFwifWlmKG8pe2lmKGg9dHx8byxfPXQhPT1yJiZcImFsbFwiIT09ciYmdCE9PW8mJihcIm9iamVjdFwiIT10eXBlb2YgdHx8IXQuX3RlbXBLaWxsKSxpJiYoRC5vbk92ZXJ3cml0ZXx8dGhpcy52YXJzLm9uT3ZlcndyaXRlKSl7Zm9yKG4gaW4gaClvW25dJiYodXx8KHU9W10pLHUucHVzaChuKSk7aWYoKHV8fCF0KSYmIUgodGhpcyxpLGUsdSkpcmV0dXJuITF9Zm9yKG4gaW4gaCkoYT1vW25dKSYmKGMmJihhLmY/YS50W2EucF0oYS5zKTphLnRbYS5wXT1hLnMsbD0hMCksYS5wZyYmYS50Ll9raWxsKGgpJiYobD0hMCksYS5wZyYmMCE9PWEudC5fb3ZlcndyaXRlUHJvcHMubGVuZ3RofHwoYS5fcHJldj9hLl9wcmV2Ll9uZXh0PWEuX25leHQ6YT09PXRoaXMuX2ZpcnN0UFQmJih0aGlzLl9maXJzdFBUPWEuX25leHQpLGEuX25leHQmJihhLl9uZXh0Ll9wcmV2PWEuX3ByZXYpLGEuX25leHQ9YS5fcHJldj1udWxsKSxkZWxldGUgb1tuXSksXyYmKHJbbl09MSk7IXRoaXMuX2ZpcnN0UFQmJnRoaXMuX2luaXR0ZWQmJnRoaXMuX2VuYWJsZWQoITEsITEpfX1yZXR1cm4gbH0sbi5pbnZhbGlkYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQmJkQuX29uUGx1Z2luRXZlbnQoXCJfb25EaXNhYmxlXCIsdGhpcyksdGhpcy5fZmlyc3RQVD10aGlzLl9vdmVyd3JpdHRlblByb3BzPXRoaXMuX3N0YXJ0QXQ9dGhpcy5fb25VcGRhdGU9bnVsbCx0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkPXRoaXMuX2FjdGl2ZT10aGlzLl9sYXp5PSExLHRoaXMuX3Byb3BMb29rdXA9dGhpcy5fdGFyZ2V0cz97fTpbXSxPLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyksdGhpcy52YXJzLmltbWVkaWF0ZVJlbmRlciYmKHRoaXMuX3RpbWU9LV8sdGhpcy5yZW5kZXIoLXRoaXMuX2RlbGF5KSksdGhpc30sbi5fZW5hYmxlZD1mdW5jdGlvbih0LGUpe2lmKG98fGEud2FrZSgpLHQmJnRoaXMuX2djKXt2YXIgaSxzPXRoaXMuX3RhcmdldHM7aWYocylmb3IoaT1zLmxlbmd0aDstLWk+LTE7KXRoaXMuX3NpYmxpbmdzW2ldPSQoc1tpXSx0aGlzLCEwKTtlbHNlIHRoaXMuX3NpYmxpbmdzPSQodGhpcy50YXJnZXQsdGhpcywhMCl9cmV0dXJuIE8ucHJvdG90eXBlLl9lbmFibGVkLmNhbGwodGhpcyx0LGUpLHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQmJnRoaXMuX2ZpcnN0UFQ/RC5fb25QbHVnaW5FdmVudCh0P1wiX29uRW5hYmxlXCI6XCJfb25EaXNhYmxlXCIsdGhpcyk6ITF9LEQudG89ZnVuY3Rpb24odCxlLGkpe3JldHVybiBuZXcgRCh0LGUsaSl9LEQuZnJvbT1mdW5jdGlvbih0LGUsaSl7cmV0dXJuIGkucnVuQmFja3dhcmRzPSEwLGkuaW1tZWRpYXRlUmVuZGVyPTAhPWkuaW1tZWRpYXRlUmVuZGVyLG5ldyBEKHQsZSxpKX0sRC5mcm9tVG89ZnVuY3Rpb24odCxlLGkscyl7cmV0dXJuIHMuc3RhcnRBdD1pLHMuaW1tZWRpYXRlUmVuZGVyPTAhPXMuaW1tZWRpYXRlUmVuZGVyJiYwIT1pLmltbWVkaWF0ZVJlbmRlcixuZXcgRCh0LGUscyl9LEQuZGVsYXllZENhbGw9ZnVuY3Rpb24odCxlLGkscyxyKXtyZXR1cm4gbmV3IEQoZSwwLHtkZWxheTp0LG9uQ29tcGxldGU6ZSxvbkNvbXBsZXRlUGFyYW1zOmksY2FsbGJhY2tTY29wZTpzLG9uUmV2ZXJzZUNvbXBsZXRlOmUsb25SZXZlcnNlQ29tcGxldGVQYXJhbXM6aSxpbW1lZGlhdGVSZW5kZXI6ITEsbGF6eTohMSx1c2VGcmFtZXM6cixvdmVyd3JpdGU6MH0pfSxELnNldD1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgRCh0LDAsZSl9LEQuZ2V0VHdlZW5zT2Y9ZnVuY3Rpb24odCxlKXtpZihudWxsPT10KXJldHVybltdO3Q9XCJzdHJpbmdcIiE9dHlwZW9mIHQ/dDpELnNlbGVjdG9yKHQpfHx0O3ZhciBpLHMscixuO2lmKChmKHQpfHxNKHQpKSYmXCJudW1iZXJcIiE9dHlwZW9mIHRbMF0pe2ZvcihpPXQubGVuZ3RoLHM9W107LS1pPi0xOylzPXMuY29uY2F0KEQuZ2V0VHdlZW5zT2YodFtpXSxlKSk7Zm9yKGk9cy5sZW5ndGg7LS1pPi0xOylmb3Iobj1zW2ldLHI9aTstLXI+LTE7KW49PT1zW3JdJiZzLnNwbGljZShpLDEpfWVsc2UgZm9yKHM9JCh0KS5jb25jYXQoKSxpPXMubGVuZ3RoOy0taT4tMTspKHNbaV0uX2djfHxlJiYhc1tpXS5pc0FjdGl2ZSgpKSYmcy5zcGxpY2UoaSwxKTtyZXR1cm4gc30sRC5raWxsVHdlZW5zT2Y9RC5raWxsRGVsYXllZENhbGxzVG89ZnVuY3Rpb24odCxlLGkpe1wib2JqZWN0XCI9PXR5cGVvZiBlJiYoaT1lLGU9ITEpO2Zvcih2YXIgcz1ELmdldFR3ZWVuc09mKHQsZSkscj1zLmxlbmd0aDstLXI+LTE7KXNbcl0uX2tpbGwoaSx0KX07dmFyIHRlPWcoXCJwbHVnaW5zLlR3ZWVuUGx1Z2luXCIsZnVuY3Rpb24odCxlKXt0aGlzLl9vdmVyd3JpdGVQcm9wcz0odHx8XCJcIikuc3BsaXQoXCIsXCIpLHRoaXMuX3Byb3BOYW1lPXRoaXMuX292ZXJ3cml0ZVByb3BzWzBdLHRoaXMuX3ByaW9yaXR5PWV8fDAsdGhpcy5fc3VwZXI9dGUucHJvdG90eXBlfSwhMCk7aWYobj10ZS5wcm90b3R5cGUsdGUudmVyc2lvbj1cIjEuMTguMFwiLHRlLkFQST0yLG4uX2ZpcnN0UFQ9bnVsbCxuLl9hZGRUd2Vlbj1YLG4uc2V0UmF0aW89TixuLl9raWxsPWZ1bmN0aW9uKHQpe3ZhciBlLGk9dGhpcy5fb3ZlcndyaXRlUHJvcHMscz10aGlzLl9maXJzdFBUO2lmKG51bGwhPXRbdGhpcy5fcHJvcE5hbWVdKXRoaXMuX292ZXJ3cml0ZVByb3BzPVtdO2Vsc2UgZm9yKGU9aS5sZW5ndGg7LS1lPi0xOyludWxsIT10W2lbZV1dJiZpLnNwbGljZShlLDEpO2Zvcig7czspbnVsbCE9dFtzLm5dJiYocy5fbmV4dCYmKHMuX25leHQuX3ByZXY9cy5fcHJldikscy5fcHJldj8ocy5fcHJldi5fbmV4dD1zLl9uZXh0LHMuX3ByZXY9bnVsbCk6dGhpcy5fZmlyc3RQVD09PXMmJih0aGlzLl9maXJzdFBUPXMuX25leHQpKSxzPXMuX25leHQ7cmV0dXJuITF9LG4uX3JvdW5kUHJvcHM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIGk9dGhpcy5fZmlyc3RQVDtpOykodFt0aGlzLl9wcm9wTmFtZV18fG51bGwhPWkubiYmdFtpLm4uc3BsaXQodGhpcy5fcHJvcE5hbWUrXCJfXCIpLmpvaW4oXCJcIildKSYmKGkucj1lKSxpPWkuX25leHR9LEQuX29uUGx1Z2luRXZlbnQ9ZnVuY3Rpb24odCxlKXt2YXIgaSxzLHIsbixhLG89ZS5fZmlyc3RQVDtpZihcIl9vbkluaXRBbGxQcm9wc1wiPT09dCl7Zm9yKDtvOyl7Zm9yKGE9by5fbmV4dCxzPXI7cyYmcy5wcj5vLnByOylzPXMuX25leHQ7KG8uX3ByZXY9cz9zLl9wcmV2Om4pP28uX3ByZXYuX25leHQ9bzpyPW8sKG8uX25leHQ9cyk/cy5fcHJldj1vOm49byxvPWF9bz1lLl9maXJzdFBUPXJ9Zm9yKDtvOylvLnBnJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBvLnRbdF0mJm8udFt0XSgpJiYoaT0hMCksbz1vLl9uZXh0O3JldHVybiBpfSx0ZS5hY3RpdmF0ZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5sZW5ndGg7LS1lPi0xOyl0W2VdLkFQST09PXRlLkFQSSYmKGpbKG5ldyB0W2VdKS5fcHJvcE5hbWVdPXRbZV0pO3JldHVybiEwfSxkLnBsdWdpbj1mdW5jdGlvbih0KXtpZighKHQmJnQucHJvcE5hbWUmJnQuaW5pdCYmdC5BUEkpKXRocm93XCJpbGxlZ2FsIHBsdWdpbiBkZWZpbml0aW9uLlwiO3ZhciBlLGk9dC5wcm9wTmFtZSxzPXQucHJpb3JpdHl8fDAscj10Lm92ZXJ3cml0ZVByb3BzLG49e2luaXQ6XCJfb25Jbml0VHdlZW5cIixzZXQ6XCJzZXRSYXRpb1wiLGtpbGw6XCJfa2lsbFwiLHJvdW5kOlwiX3JvdW5kUHJvcHNcIixpbml0QWxsOlwiX29uSW5pdEFsbFByb3BzXCJ9LGE9ZyhcInBsdWdpbnMuXCIraS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStpLnN1YnN0cigxKStcIlBsdWdpblwiLGZ1bmN0aW9uKCl7dGUuY2FsbCh0aGlzLGkscyksdGhpcy5fb3ZlcndyaXRlUHJvcHM9cnx8W119LHQuZ2xvYmFsPT09ITApLG89YS5wcm90b3R5cGU9bmV3IHRlKGkpO28uY29uc3RydWN0b3I9YSxhLkFQST10LkFQSTtmb3IoZSBpbiBuKVwiZnVuY3Rpb25cIj09dHlwZW9mIHRbZV0mJihvW25bZV1dPXRbZV0pO3JldHVybiBhLnZlcnNpb249dC52ZXJzaW9uLHRlLmFjdGl2YXRlKFthXSksYX0scz10Ll9nc1F1ZXVlKXtmb3Iocj0wO3MubGVuZ3RoPnI7cisrKXNbcl0oKTtmb3IobiBpbiBwKXBbbl0uZnVuY3x8dC5jb25zb2xlLmxvZyhcIkdTQVAgZW5jb3VudGVyZWQgbWlzc2luZyBkZXBlbmRlbmN5OiBjb20uZ3JlZW5zb2NrLlwiK24pfW89ITF9fShcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6dGhpc3x8d2luZG93LFwiVHdlZW5NYXhcIik7XG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0OnV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluTnlZeTlxWVhaaGMyTnlhWEIwTDJ4cFluTXZWSGRsWlc1TllYZ3ZWSGRsWlc1TllYZ3Vhbk1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFN1FVRkRRVHRCUVVOQk8wRkJRMEU3UVVGRFFUdEJRVU5CTzBGQlEwRTdRVUZEUVR0QlFVTkJPMEZCUTBFaUxDSm1hV3hsSWpvaVoyVnVaWEpoZEdWa0xtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJaThxSVZ4dUlDb2dWa1ZTVTBsUFRqb2dNUzR4T0M0d1hHNGdLaUJFUVZSRk9pQXlNREUxTFRBNUxUQTFYRzRnS2lCVlVFUkJWRVZUSUVGT1JDQkVUME5USUVGVU9pQm9kSFJ3T2k4dlozSmxaVzV6YjJOckxtTnZiVnh1SUNvZ1hHNGdLaUJKYm1Oc2RXUmxjeUJoYkd3Z2IyWWdkR2hsSUdadmJHeHZkMmx1WnpvZ1ZIZGxaVzVNYVhSbExDQlVkMlZsYmsxaGVDd2dWR2x0Wld4cGJtVk1hWFJsTENCVWFXMWxiR2x1WlUxaGVDd2dSV0Z6WlZCaFkyc3NJRU5UVTFCc2RXZHBiaXdnVW05MWJtUlFjbTl3YzFCc2RXZHBiaXdnUW1WNmFXVnlVR3gxWjJsdUxDQkJkSFJ5VUd4MVoybHVMQ0JFYVhKbFkzUnBiMjVoYkZKdmRHRjBhVzl1VUd4MVoybHVYRzRnS2x4dUlDb2dRR3hwWTJWdWMyVWdRMjl3ZVhKcFoyaDBJQ2hqS1NBeU1EQTRMVEl3TVRVc0lFZHlaV1Z1VTI5amF5NGdRV3hzSUhKcFoyaDBjeUJ5WlhObGNuWmxaQzVjYmlBcUlGUm9hWE1nZDI5eWF5QnBjeUJ6ZFdKcVpXTjBJSFJ2SUhSb1pTQjBaWEp0Y3lCaGRDQm9kSFJ3T2k4dlozSmxaVzV6YjJOckxtTnZiUzl6ZEdGdVpHRnlaQzFzYVdObGJuTmxJRzl5SUdadmNseHVJQ29nUTJ4MVlpQkhjbVZsYmxOdlkyc2diV1Z0WW1WeWN5d2dkR2hsSUhOdlpuUjNZWEpsSUdGbmNtVmxiV1Z1ZENCMGFHRjBJSGRoY3lCcGMzTjFaV1FnZDJsMGFDQjViM1Z5SUcxbGJXSmxjbk5vYVhBdVhHNGdLaUJjYmlBcUlFQmhkWFJvYjNJNklFcGhZMnNnUkc5NWJHVXNJR3BoWTJ0QVozSmxaVzV6YjJOckxtTnZiVnh1SUNvcUwxeHVkbUZ5SUY5bmMxTmpiM0JsUFZ3aWRXNWtaV1pwYm1Wa1hDSWhQWFI1Y0dWdlppQnRiMlIxYkdVbUptMXZaSFZzWlM1bGVIQnZjblJ6SmlaY0luVnVaR1ZtYVc1bFpGd2lJVDEwZVhCbGIyWWdaMnh2WW1Gc1AyZHNiMkpoYkRwMGFHbHpmSHgzYVc1a2IzYzdLRjluYzFOamIzQmxMbDluYzFGMVpYVmxmSHdvWDJkelUyTnZjR1V1WDJkelVYVmxkV1U5VzEwcEtTNXdkWE5vS0daMWJtTjBhVzl1S0NsN1hDSjFjMlVnYzNSeWFXTjBYQ0k3WDJkelUyTnZjR1V1WDJkelJHVm1hVzVsS0Z3aVZIZGxaVzVOWVhoY0lpeGJYQ0pqYjNKbExrRnVhVzFoZEdsdmJsd2lMRndpWTI5eVpTNVRhVzF3YkdWVWFXMWxiR2x1WlZ3aUxGd2lWSGRsWlc1TWFYUmxYQ0pkTEdaMWJtTjBhVzl1S0hRc1pTeHBLWHQyWVhJZ2N6MW1kVzVqZEdsdmJpaDBLWHQyWVhJZ1pTeHBQVnRkTEhNOWRDNXNaVzVuZEdnN1ptOXlLR1U5TUR0bElUMDljenRwTG5CMWMyZ29kRnRsS3l0ZEtTazdjbVYwZFhKdUlHbDlMSEk5Wm5WdVkzUnBiMjRvZEN4bExHa3BlM1poY2lCekxISXNiajEwTG1ONVkyeGxPMlp2Y2loeklHbHVJRzRwY2oxdVczTmRMSFJiYzEwOVhDSm1kVzVqZEdsdmJsd2lQVDEwZVhCbGIyWWdjajl5TG1OaGJHd29aVnRwWFN4cEtUcHlXMmtsY2k1c1pXNW5kR2hkTzJSbGJHVjBaU0IwTG1ONVkyeGxmU3h1UFdaMWJtTjBhVzl1S0hRc1pTeHpLWHRwTG1OaGJHd29kR2hwY3l4MExHVXNjeWtzZEdocGN5NWZZM2xqYkdVOU1DeDBhR2x6TGw5NWIzbHZQWFJvYVhNdWRtRnljeTU1YjNsdlBUMDlJVEFzZEdocGN5NWZjbVZ3WldGMFBYUm9hWE11ZG1GeWN5NXlaWEJsWVhSOGZEQXNkR2hwY3k1ZmNtVndaV0YwUkdWc1lYazlkR2hwY3k1MllYSnpMbkpsY0dWaGRFUmxiR0Y1Zkh3d0xIUm9hWE11WDJScGNuUjVQU0V3TEhSb2FYTXVjbVZ1WkdWeVBXNHVjSEp2ZEc5MGVYQmxMbkpsYm1SbGNuMHNZVDB4WlMweE1DeHZQV2t1WDJsdWRHVnlibUZzY3l4c1BXOHVhWE5UWld4bFkzUnZjaXhvUFc4dWFYTkJjbkpoZVN4ZlBXNHVjSEp2ZEc5MGVYQmxQV2t1ZEc4b2UzMHNMakVzZTMwcExIVTlXMTA3Ymk1MlpYSnphVzl1UFZ3aU1TNHhPQzR3WENJc1h5NWpiMjV6ZEhKMVkzUnZjajF1TEY4dWEybHNiQ2dwTGw5bll6MGhNU3h1TG10cGJHeFVkMlZsYm5OUFpqMXVMbXRwYkd4RVpXeGhlV1ZrUTJGc2JITlViejFwTG10cGJHeFVkMlZsYm5OUFppeHVMbWRsZEZSM1pXVnVjMDltUFdrdVoyVjBWSGRsWlc1elQyWXNiaTVzWVdkVGJXOXZkR2hwYm1jOWFTNXNZV2RUYlc5dmRHaHBibWNzYmk1MGFXTnJaWEk5YVM1MGFXTnJaWElzYmk1eVpXNWtaWEk5YVM1eVpXNWtaWElzWHk1cGJuWmhiR2xrWVhSbFBXWjFibU4wYVc5dUtDbDdjbVYwZFhKdUlIUm9hWE11WDNsdmVXODlkR2hwY3k1MllYSnpMbmx2ZVc4OVBUMGhNQ3gwYUdsekxsOXlaWEJsWVhROWRHaHBjeTUyWVhKekxuSmxjR1ZoZEh4OE1DeDBhR2x6TGw5eVpYQmxZWFJFWld4aGVUMTBhR2x6TG5aaGNuTXVjbVZ3WldGMFJHVnNZWGw4ZkRBc2RHaHBjeTVmZFc1allXTm9aU2doTUNrc2FTNXdjbTkwYjNSNWNHVXVhVzUyWVd4cFpHRjBaUzVqWVd4c0tIUm9hWE1wZlN4ZkxuVndaR0YwWlZSdlBXWjFibU4wYVc5dUtIUXNaU2w3ZG1GeUlITXNjajEwYUdsekxuSmhkR2x2TEc0OWRHaHBjeTUyWVhKekxtbHRiV1ZrYVdGMFpWSmxibVJsY254OGRDNXBiVzFsWkdsaGRHVlNaVzVrWlhJN1pTWW1kR2hwY3k1ZmMzUmhjblJVYVcxbFBIUm9hWE11WDNScGJXVnNhVzVsTGw5MGFXMWxKaVlvZEdocGN5NWZjM1JoY25SVWFXMWxQWFJvYVhNdVgzUnBiV1ZzYVc1bExsOTBhVzFsTEhSb2FYTXVYM1Z1WTJGamFHVW9JVEVwTEhSb2FYTXVYMmRqUDNSb2FYTXVYMlZ1WVdKc1pXUW9JVEFzSVRFcE9uUm9hWE11WDNScGJXVnNhVzVsTG1sdWMyVnlkQ2gwYUdsekxIUm9hWE11WDNOMFlYSjBWR2x0WlMxMGFHbHpMbDlrWld4aGVTa3BPMlp2Y2loeklHbHVJSFFwZEdocGN5NTJZWEp6VzNOZFBYUmJjMTA3YVdZb2RHaHBjeTVmYVc1cGRIUmxaSHg4YmlscFppaGxLWFJvYVhNdVgybHVhWFIwWldROUlURXNiaVltZEdocGN5NXlaVzVrWlhJb01Dd2hNQ3doTUNrN1pXeHpaU0JwWmloMGFHbHpMbDluWXlZbWRHaHBjeTVmWlc1aFlteGxaQ2doTUN3aE1Ta3NkR2hwY3k1ZmJtOTBhV1o1VUd4MVoybHVjMDltUlc1aFlteGxaQ1ltZEdocGN5NWZabWx5YzNSUVZDWW1hUzVmYjI1UWJIVm5hVzVGZG1WdWRDaGNJbDl2YmtScGMyRmliR1ZjSWl4MGFHbHpLU3gwYUdsekxsOTBhVzFsTDNSb2FYTXVYMlIxY21GMGFXOXVQaTQ1T1RncGUzWmhjaUJoUFhSb2FYTXVYM1JwYldVN2RHaHBjeTV5Wlc1a1pYSW9NQ3doTUN3aE1Ta3NkR2hwY3k1ZmFXNXBkSFJsWkQwaE1TeDBhR2x6TG5KbGJtUmxjaWhoTENFd0xDRXhLWDFsYkhObElHbG1LSFJvYVhNdVgzUnBiV1UrTUh4OGJpbDdkR2hwY3k1ZmFXNXBkSFJsWkQwaE1TeDBhR2x6TGw5cGJtbDBLQ2s3Wm05eUtIWmhjaUJ2TEd3OU1TOG9NUzF5S1N4b1BYUm9hWE11WDJacGNuTjBVRlE3YURzcGJ6MW9Mbk1yYUM1akxHZ3VZeW85YkN4b0xuTTlieTFvTG1Nc2FEMW9MbDl1WlhoMGZYSmxkSFZ5YmlCMGFHbHpmU3hmTG5KbGJtUmxjajFtZFc1amRHbHZiaWgwTEdVc2FTbDdkR2hwY3k1ZmFXNXBkSFJsWkh4OE1EMDlQWFJvYVhNdVgyUjFjbUYwYVc5dUppWjBhR2x6TG5aaGNuTXVjbVZ3WldGMEppWjBhR2x6TG1sdWRtRnNhV1JoZEdVb0tUdDJZWElnY3l4eUxHNHNiQ3hvTEY4c2RTeGpMR1k5ZEdocGN5NWZaR2x5ZEhrL2RHaHBjeTUwYjNSaGJFUjFjbUYwYVc5dUtDazZkR2hwY3k1ZmRHOTBZV3hFZFhKaGRHbHZiaXh3UFhSb2FYTXVYM1JwYldVc2JUMTBhR2x6TGw5MGIzUmhiRlJwYldVc1pEMTBhR2x6TGw5amVXTnNaU3huUFhSb2FYTXVYMlIxY21GMGFXOXVMSFk5ZEdocGN5NWZjbUYzVUhKbGRsUnBiV1U3YVdZb2RENDlaajhvZEdocGN5NWZkRzkwWVd4VWFXMWxQV1lzZEdocGN5NWZZM2xqYkdVOWRHaHBjeTVmY21Wd1pXRjBMSFJvYVhNdVgzbHZlVzhtSmpBaFBUMG9NU1owYUdsekxsOWplV05zWlNrL0tIUm9hWE11WDNScGJXVTlNQ3gwYUdsekxuSmhkR2x2UFhSb2FYTXVYMlZoYzJVdVgyTmhiR05GYm1RL2RHaHBjeTVmWldGelpTNW5aWFJTWVhScGJ5Z3dLVG93S1Rvb2RHaHBjeTVmZEdsdFpUMW5MSFJvYVhNdWNtRjBhVzg5ZEdocGN5NWZaV0Z6WlM1ZlkyRnNZMFZ1WkQ5MGFHbHpMbDlsWVhObExtZGxkRkpoZEdsdktERXBPakVwTEhSb2FYTXVYM0psZG1WeWMyVmtmSHdvY3owaE1DeHlQVndpYjI1RGIyMXdiR1YwWlZ3aUxHazlhWHg4ZEdocGN5NWZkR2x0Wld4cGJtVXVZWFYwYjFKbGJXOTJaVU5vYVd4a2NtVnVLU3d3UFQwOVp5WW1LSFJvYVhNdVgybHVhWFIwWldSOGZDRjBhR2x6TG5aaGNuTXViR0Y2ZVh4OGFTa21KaWgwYUdsekxsOXpkR0Z5ZEZScGJXVTlQVDEwYUdsekxsOTBhVzFsYkdsdVpTNWZaSFZ5WVhScGIyNG1KaWgwUFRBcExDZ3dQVDA5ZEh4OE1ENTJmSHgyUFQwOVlTa21KblloUFQxMEppWW9hVDBoTUN4MlBtRW1KaWh5UFZ3aWIyNVNaWFpsY25ObFEyOXRjR3hsZEdWY0lpa3BMSFJvYVhNdVgzSmhkMUJ5WlhaVWFXMWxQV005SVdWOGZIUjhmSFk5UFQxMFAzUTZZU2twT2pGbExUYytkRDhvZEdocGN5NWZkRzkwWVd4VWFXMWxQWFJvYVhNdVgzUnBiV1U5ZEdocGN5NWZZM2xqYkdVOU1DeDBhR2x6TG5KaGRHbHZQWFJvYVhNdVgyVmhjMlV1WDJOaGJHTkZibVEvZEdocGN5NWZaV0Z6WlM1blpYUlNZWFJwYnlnd0tUb3dMQ2d3SVQwOWJYeDhNRDA5UFdjbUpuWStNQ2ttSmloeVBWd2liMjVTWlhabGNuTmxRMjl0Y0d4bGRHVmNJaXh6UFhSb2FYTXVYM0psZG1WeWMyVmtLU3d3UG5RbUppaDBhR2x6TGw5aFkzUnBkbVU5SVRFc01EMDlQV2NtSmloMGFHbHpMbDlwYm1sMGRHVmtmSHdoZEdocGN5NTJZWEp6TG14aGVubDhmR2twSmlZb2RqNDlNQ1ltS0drOUlUQXBMSFJvYVhNdVgzSmhkMUJ5WlhaVWFXMWxQV005SVdWOGZIUjhmSFk5UFQxMFAzUTZZU2twTEhSb2FYTXVYMmx1YVhSMFpXUjhmQ2hwUFNFd0tTazZLSFJvYVhNdVgzUnZkR0ZzVkdsdFpUMTBhR2x6TGw5MGFXMWxQWFFzTUNFOVBYUm9hWE11WDNKbGNHVmhkQ1ltS0d3OVp5dDBhR2x6TGw5eVpYQmxZWFJFWld4aGVTeDBhR2x6TGw5amVXTnNaVDEwYUdsekxsOTBiM1JoYkZScGJXVXZiRDQrTUN3d0lUMDlkR2hwY3k1ZlkzbGpiR1VtSm5Sb2FYTXVYMk41WTJ4bFBUMDlkR2hwY3k1ZmRHOTBZV3hVYVcxbEwyd21KblJvYVhNdVgyTjVZMnhsTFMwc2RHaHBjeTVmZEdsdFpUMTBhR2x6TGw5MGIzUmhiRlJwYldVdGRHaHBjeTVmWTNsamJHVXFiQ3gwYUdsekxsOTViM2x2SmlZd0lUMDlLREVtZEdocGN5NWZZM2xqYkdVcEppWW9kR2hwY3k1ZmRHbHRaVDFuTFhSb2FYTXVYM1JwYldVcExIUm9hWE11WDNScGJXVStaejkwYUdsekxsOTBhVzFsUFdjNk1ENTBhR2x6TGw5MGFXMWxKaVlvZEdocGN5NWZkR2x0WlQwd0tTa3NkR2hwY3k1ZlpXRnpaVlI1Y0dVL0tHZzlkR2hwY3k1ZmRHbHRaUzluTEY4OWRHaHBjeTVmWldGelpWUjVjR1VzZFQxMGFHbHpMbDlsWVhObFVHOTNaWElzS0RFOVBUMWZmSHd6UFQwOVh5WW1hRDQ5TGpVcEppWW9hRDB4TFdncExETTlQVDFmSmlZb2FDbzlNaWtzTVQwOVBYVS9hQ285YURveVBUMDlkVDlvS2oxb0ttZzZNejA5UFhVL2FDbzlhQ3BvS21nNk5EMDlQWFVtSmlob0tqMW9LbWdxYUNwb0tTeDBhR2x6TG5KaGRHbHZQVEU5UFQxZlB6RXRhRG95UFQwOVh6OW9PaTQxUG5Sb2FYTXVYM1JwYldVdlp6OW9Mekk2TVMxb0x6SXBPblJvYVhNdWNtRjBhVzg5ZEdocGN5NWZaV0Z6WlM1blpYUlNZWFJwYnloMGFHbHpMbDkwYVcxbEwyY3BLU3h3UFQwOWRHaHBjeTVmZEdsdFpTWW1JV2ttSm1ROVBUMTBhR2x6TGw5amVXTnNaU2x5WlhSMWNtNGdiU0U5UFhSb2FYTXVYM1J2ZEdGc1ZHbHRaU1ltZEdocGN5NWZiMjVWY0dSaGRHVW1KaWhsZkh4MGFHbHpMbDlqWVd4c1ltRmpheWhjSW05dVZYQmtZWFJsWENJcEtTeDJiMmxrSURBN2FXWW9JWFJvYVhNdVgybHVhWFIwWldRcGUybG1LSFJvYVhNdVgybHVhWFFvS1N3aGRHaHBjeTVmYVc1cGRIUmxaSHg4ZEdocGN5NWZaMk1wY21WMGRYSnVPMmxtS0NGcEppWjBhR2x6TGw5bWFYSnpkRkJVSmlZb2RHaHBjeTUyWVhKekxteGhlbmtoUFQwaE1TWW1kR2hwY3k1ZlpIVnlZWFJwYjI1OGZIUm9hWE11ZG1GeWN5NXNZWHA1SmlZaGRHaHBjeTVmWkhWeVlYUnBiMjRwS1hKbGRIVnliaUIwYUdsekxsOTBhVzFsUFhBc2RHaHBjeTVmZEc5MFlXeFVhVzFsUFcwc2RHaHBjeTVmY21GM1VISmxkbFJwYldVOWRpeDBhR2x6TGw5amVXTnNaVDFrTEc4dWJHRjZlVlIzWldWdWN5NXdkWE5vS0hSb2FYTXBMSFJvYVhNdVgyeGhlbms5VzNRc1pWMHNkbTlwWkNBd08zUm9hWE11WDNScGJXVW1KaUZ6UDNSb2FYTXVjbUYwYVc4OWRHaHBjeTVmWldGelpTNW5aWFJTWVhScGJ5aDBhR2x6TGw5MGFXMWxMMmNwT25NbUpuUm9hWE11WDJWaGMyVXVYMk5oYkdORmJtUW1KaWgwYUdsekxuSmhkR2x2UFhSb2FYTXVYMlZoYzJVdVoyVjBVbUYwYVc4b01EMDlQWFJvYVhNdVgzUnBiV1UvTURveEtTbDlabTl5S0hSb2FYTXVYMnhoZW5raFBUMGhNU1ltS0hSb2FYTXVYMnhoZW5rOUlURXBMSFJvYVhNdVgyRmpkR2wyWlh4OElYUm9hWE11WDNCaGRYTmxaQ1ltZEdocGN5NWZkR2x0WlNFOVBYQW1KblErUFRBbUppaDBhR2x6TGw5aFkzUnBkbVU5SVRBcExEQTlQVDF0SmlZb01qMDlQWFJvYVhNdVgybHVhWFIwWldRbUpuUStNQ1ltZEdocGN5NWZhVzVwZENncExIUm9hWE11WDNOMFlYSjBRWFFtSmloMFBqMHdQM1JvYVhNdVgzTjBZWEowUVhRdWNtVnVaR1Z5S0hRc1pTeHBLVHB5Zkh3b2NqMWNJbDlrZFcxdGVVZFRYQ0lwS1N4MGFHbHpMblpoY25NdWIyNVRkR0Z5ZENZbUtEQWhQVDEwYUdsekxsOTBiM1JoYkZScGJXVjhmREE5UFQxbktTWW1LR1Y4ZkhSb2FYTXVYMk5oYkd4aVlXTnJLRndpYjI1VGRHRnlkRndpS1NrcExHNDlkR2hwY3k1ZlptbHljM1JRVkR0dU95bHVMbVkvYmk1MFcyNHVjRjBvYmk1aktuUm9hWE11Y21GMGFXOHJiaTV6S1RwdUxuUmJiaTV3WFQxdUxtTXFkR2hwY3k1eVlYUnBieXR1TG5Nc2JqMXVMbDl1WlhoME8zUm9hWE11WDI5dVZYQmtZWFJsSmlZb01ENTBKaVowYUdsekxsOXpkR0Z5ZEVGMEppWjBhR2x6TGw5emRHRnlkRlJwYldVbUpuUm9hWE11WDNOMFlYSjBRWFF1Y21WdVpHVnlLSFFzWlN4cEtTeGxmSHdvZEdocGN5NWZkRzkwWVd4VWFXMWxJVDA5Ylh4OGN5a21KblJvYVhNdVgyTmhiR3hpWVdOcktGd2liMjVWY0dSaGRHVmNJaWtwTEhSb2FYTXVYMk41WTJ4bElUMDlaQ1ltS0dWOGZIUm9hWE11WDJkamZIeDBhR2x6TG5aaGNuTXViMjVTWlhCbFlYUW1KblJvYVhNdVgyTmhiR3hpWVdOcktGd2liMjVTWlhCbFlYUmNJaWtwTEhJbUppZ2hkR2hwY3k1ZloyTjhmR2twSmlZb01ENTBKaVowYUdsekxsOXpkR0Z5ZEVGMEppWWhkR2hwY3k1ZmIyNVZjR1JoZEdVbUpuUm9hWE11WDNOMFlYSjBWR2x0WlNZbWRHaHBjeTVmYzNSaGNuUkJkQzV5Wlc1a1pYSW9kQ3hsTEdrcExITW1KaWgwYUdsekxsOTBhVzFsYkdsdVpTNWhkWFJ2VW1WdGIzWmxRMmhwYkdSeVpXNG1KblJvYVhNdVgyVnVZV0pzWldRb0lURXNJVEVwTEhSb2FYTXVYMkZqZEdsMlpUMGhNU2tzSVdVbUpuUm9hWE11ZG1GeWMxdHlYU1ltZEdocGN5NWZZMkZzYkdKaFkyc29jaWtzTUQwOVBXY21KblJvYVhNdVgzSmhkMUJ5WlhaVWFXMWxQVDA5WVNZbVl5RTlQV0VtSmloMGFHbHpMbDl5WVhkUWNtVjJWR2x0WlQwd0tTbDlMRzR1ZEc4OVpuVnVZM1JwYjI0b2RDeGxMR2twZTNKbGRIVnliaUJ1WlhjZ2JpaDBMR1VzYVNsOUxHNHVabkp2YlQxbWRXNWpkR2x2YmloMExHVXNhU2w3Y21WMGRYSnVJR2t1Y25WdVFtRmphM2RoY21SelBTRXdMR2t1YVcxdFpXUnBZWFJsVW1WdVpHVnlQVEFoUFdrdWFXMXRaV1JwWVhSbFVtVnVaR1Z5TEc1bGR5QnVLSFFzWlN4cEtYMHNiaTVtY205dFZHODlablZ1WTNScGIyNG9kQ3hsTEdrc2N5bDdjbVYwZFhKdUlITXVjM1JoY25SQmREMXBMSE11YVcxdFpXUnBZWFJsVW1WdVpHVnlQVEFoUFhNdWFXMXRaV1JwWVhSbFVtVnVaR1Z5SmlZd0lUMXBMbWx0YldWa2FXRjBaVkpsYm1SbGNpeHVaWGNnYmloMExHVXNjeWw5TEc0dWMzUmhaMmRsY2xSdlBXNHVZV3hzVkc4OVpuVnVZM1JwYjI0b2RDeGxMR0VzYnl4ZkxHTXNaaWw3YnoxdmZId3dPM1poY2lCd0xHMHNaQ3huTEhZOVlTNWtaV3hoZVh4OE1DeDVQVnRkTEZROVpuVnVZM1JwYjI0b0tYdGhMbTl1UTI5dGNHeGxkR1VtSm1FdWIyNURiMjF3YkdWMFpTNWhjSEJzZVNoaExtOXVRMjl0Y0d4bGRHVlRZMjl3Wlh4OGRHaHBjeXhoY21kMWJXVnVkSE1wTEY4dVlYQndiSGtvWm54OFlTNWpZV3hzWW1GamExTmpiM0JsZkh4MGFHbHpMR044ZkhVcGZTeDRQV0V1WTNsamJHVXNkejFoTG5OMFlYSjBRWFFtSm1FdWMzUmhjblJCZEM1amVXTnNaVHRtYjNJb2FDaDBLWHg4S0Z3aWMzUnlhVzVuWENJOVBYUjVjR1Z2WmlCMEppWW9kRDFwTG5ObGJHVmpkRzl5S0hRcGZIeDBLU3hzS0hRcEppWW9kRDF6S0hRcEtTa3NkRDEwZkh4YlhTd3dQbThtSmloMFBYTW9kQ2tzZEM1eVpYWmxjbk5sS0Nrc2J5bzlMVEVwTEhBOWRDNXNaVzVuZEdndE1TeGtQVEE3Y0Q0OVpEdGtLeXNwZTIwOWUzMDdabTl5S0djZ2FXNGdZU2x0VzJkZFBXRmJaMTA3YVdZb2VDWW1jaWh0TEhRc1pDa3NkeWw3ZHoxdExuTjBZWEowUVhROWUzMDdabTl5S0djZ2FXNGdZUzV6ZEdGeWRFRjBLWGRiWjEwOVlTNXpkR0Z5ZEVGMFcyZGRPM0lvYlM1emRHRnlkRUYwTEhRc1pDbDliUzVrWld4aGVUMTJMR1E5UFQxd0ppWmZKaVlvYlM1dmJrTnZiWEJzWlhSbFBWUXBMSGxiWkYwOWJtVjNJRzRvZEZ0a1hTeGxMRzBwTEhZclBXOTljbVYwZFhKdUlIbDlMRzR1YzNSaFoyZGxja1p5YjIwOWJpNWhiR3hHY205dFBXWjFibU4wYVc5dUtIUXNaU3hwTEhNc2NpeGhMRzhwZTNKbGRIVnliaUJwTG5KMWJrSmhZMnQzWVhKa2N6MGhNQ3hwTG1sdGJXVmthV0YwWlZKbGJtUmxjajB3SVQxcExtbHRiV1ZrYVdGMFpWSmxibVJsY2l4dUxuTjBZV2RuWlhKVWJ5aDBMR1VzYVN4ekxISXNZU3h2S1gwc2JpNXpkR0ZuWjJWeVJuSnZiVlJ2UFc0dVlXeHNSbkp2YlZSdlBXWjFibU4wYVc5dUtIUXNaU3hwTEhNc2NpeGhMRzhzYkNsN2NtVjBkWEp1SUhNdWMzUmhjblJCZEQxcExITXVhVzF0WldScFlYUmxVbVZ1WkdWeVBUQWhQWE11YVcxdFpXUnBZWFJsVW1WdVpHVnlKaVl3SVQxcExtbHRiV1ZrYVdGMFpWSmxibVJsY2l4dUxuTjBZV2RuWlhKVWJ5aDBMR1VzY3l4eUxHRXNieXhzS1gwc2JpNWtaV3hoZVdWa1EyRnNiRDFtZFc1amRHbHZiaWgwTEdVc2FTeHpMSElwZTNKbGRIVnliaUJ1WlhjZ2JpaGxMREFzZTJSbGJHRjVPblFzYjI1RGIyMXdiR1YwWlRwbExHOXVRMjl0Y0d4bGRHVlFZWEpoYlhNNmFTeGpZV3hzWW1GamExTmpiM0JsT25Nc2IyNVNaWFpsY25ObFEyOXRjR3hsZEdVNlpTeHZibEpsZG1WeWMyVkRiMjF3YkdWMFpWQmhjbUZ0Y3pwcExHbHRiV1ZrYVdGMFpWSmxibVJsY2pvaE1TeDFjMlZHY21GdFpYTTZjaXh2ZG1WeWQzSnBkR1U2TUgwcGZTeHVMbk5sZEQxbWRXNWpkR2x2YmloMExHVXBlM0psZEhWeWJpQnVaWGNnYmloMExEQXNaU2w5TEc0dWFYTlVkMlZsYm1sdVp6MW1kVzVqZEdsdmJpaDBLWHR5WlhSMWNtNGdhUzVuWlhSVWQyVmxibk5QWmloMExDRXdLUzVzWlc1bmRHZytNSDA3ZG1GeUlHTTlablZ1WTNScGIyNG9kQ3hsS1h0bWIzSW9kbUZ5SUhNOVcxMHNjajB3TEc0OWRDNWZabWx5YzNRN2Jqc3BiaUJwYm5OMFlXNWpaVzltSUdrL2MxdHlLeXRkUFc0NktHVW1KaWh6VzNJcksxMDliaWtzY3oxekxtTnZibU5oZENoaktHNHNaU2twTEhJOWN5NXNaVzVuZEdncExHNDliaTVmYm1WNGREdHlaWFIxY200Z2MzMHNaajF1TG1kbGRFRnNiRlIzWldWdWN6MW1kVzVqZEdsdmJpaGxLWHR5WlhSMWNtNGdZeWgwTGw5eWIyOTBWR2x0Wld4cGJtVXNaU2t1WTI5dVkyRjBLR01vZEM1ZmNtOXZkRVp5WVcxbGMxUnBiV1ZzYVc1bExHVXBLWDA3Ymk1cmFXeHNRV3hzUFdaMWJtTjBhVzl1S0hRc2FTeHpMSElwZTI1MWJHdzlQV2ttSmlocFBTRXdLU3h1ZFd4c1BUMXpKaVlvY3owaE1DazdkbUZ5SUc0c1lTeHZMR3c5Wmlnd0lUMXlLU3hvUFd3dWJHVnVaM1JvTEY4OWFTWW1jeVltY2p0bWIzSW9iejB3TzJnK2J6dHZLeXNwWVQxc1cyOWRMQ2hmZkh4aElHbHVjM1JoYm1ObGIyWWdaWHg4S0c0OVlTNTBZWEpuWlhROVBUMWhMblpoY25NdWIyNURiMjF3YkdWMFpTa21Kbk44ZkdrbUppRnVLU1ltS0hRL1lTNTBiM1JoYkZScGJXVW9ZUzVmY21WMlpYSnpaV1EvTURwaExuUnZkR0ZzUkhWeVlYUnBiMjRvS1NrNllTNWZaVzVoWW14bFpDZ2hNU3doTVNrcGZTeHVMbXRwYkd4RGFHbHNaRlIzWldWdWMwOW1QV1oxYm1OMGFXOXVLSFFzWlNsN2FXWW9iblZzYkNFOWRDbDdkbUZ5SUhJc1lTeGZMSFVzWXl4bVBXOHVkSGRsWlc1TWIyOXJkWEE3YVdZb1hDSnpkSEpwYm1kY0lqMDlkSGx3Wlc5bUlIUW1KaWgwUFdrdWMyVnNaV04wYjNJb2RDbDhmSFFwTEd3b2RDa21KaWgwUFhNb2RDa3BMR2dvZENrcFptOXlLSFU5ZEM1c1pXNW5kR2c3TFMxMVBpMHhPeWx1TG10cGJHeERhR2xzWkZSM1pXVnVjMDltS0hSYmRWMHNaU2s3Wld4elpYdHlQVnRkTzJadmNpaGZJR2x1SUdZcFptOXlLR0U5Wmx0ZlhTNTBZWEpuWlhRdWNHRnlaVzUwVG05a1pUdGhPeWxoUFQwOWRDWW1LSEk5Y2k1amIyNWpZWFFvWmx0ZlhTNTBkMlZsYm5NcEtTeGhQV0V1Y0dGeVpXNTBUbTlrWlR0bWIzSW9ZejF5TG14bGJtZDBhQ3gxUFRBN1l6NTFPM1VyS3lsbEppWnlXM1ZkTG5SdmRHRnNWR2x0WlNoeVczVmRMblJ2ZEdGc1JIVnlZWFJwYjI0b0tTa3NjbHQxWFM1ZlpXNWhZbXhsWkNnaE1Td2hNU2w5ZlgwN2RtRnlJSEE5Wm5WdVkzUnBiMjRvZEN4cExITXNjaWw3YVQxcElUMDlJVEVzY3oxeklUMDlJVEVzY2oxeUlUMDlJVEU3Wm05eUtIWmhjaUJ1TEdFc2J6MW1LSElwTEd3OWFTWW1jeVltY2l4b1BXOHViR1Z1WjNSb095MHRhRDR0TVRzcFlUMXZXMmhkTENoc2ZIeGhJR2x1YzNSaGJtTmxiMllnWlh4OEtHNDlZUzUwWVhKblpYUTlQVDFoTG5aaGNuTXViMjVEYjIxd2JHVjBaU2ttSm5OOGZHa21KaUZ1S1NZbVlTNXdZWFZ6WldRb2RDbDlPM0psZEhWeWJpQnVMbkJoZFhObFFXeHNQV1oxYm1OMGFXOXVLSFFzWlN4cEtYdHdLQ0V3TEhRc1pTeHBLWDBzYmk1eVpYTjFiV1ZCYkd3OVpuVnVZM1JwYjI0b2RDeGxMR2twZTNBb0lURXNkQ3hsTEdrcGZTeHVMbWRzYjJKaGJGUnBiV1ZUWTJGc1pUMW1kVzVqZEdsdmJpaGxLWHQyWVhJZ2N6MTBMbDl5YjI5MFZHbHRaV3hwYm1Vc2NqMXBMblJwWTJ0bGNpNTBhVzFsTzNKbGRIVnliaUJoY21kMWJXVnVkSE11YkdWdVozUm9QeWhsUFdWOGZHRXNjeTVmYzNSaGNuUlVhVzFsUFhJdEtISXRjeTVmYzNSaGNuUlVhVzFsS1NwekxsOTBhVzFsVTJOaGJHVXZaU3h6UFhRdVgzSnZiM1JHY21GdFpYTlVhVzFsYkdsdVpTeHlQV2t1ZEdsamEyVnlMbVp5WVcxbExITXVYM04wWVhKMFZHbHRaVDF5TFNoeUxYTXVYM04wWVhKMFZHbHRaU2txY3k1ZmRHbHRaVk5qWVd4bEwyVXNjeTVmZEdsdFpWTmpZV3hsUFhRdVgzSnZiM1JVYVcxbGJHbHVaUzVmZEdsdFpWTmpZV3hsUFdVc1pTazZjeTVmZEdsdFpWTmpZV3hsZlN4ZkxuQnliMmR5WlhOelBXWjFibU4wYVc5dUtIUXBlM0psZEhWeWJpQmhjbWQxYldWdWRITXViR1Z1WjNSb1AzUm9hWE11ZEc5MFlXeFVhVzFsS0hSb2FYTXVaSFZ5WVhScGIyNG9LU29vZEdocGN5NWZlVzk1YnlZbU1DRTlQU2d4Sm5Sb2FYTXVYMk41WTJ4bEtUOHhMWFE2ZENrcmRHaHBjeTVmWTNsamJHVXFLSFJvYVhNdVgyUjFjbUYwYVc5dUszUm9hWE11WDNKbGNHVmhkRVJsYkdGNUtTd2hNU2s2ZEdocGN5NWZkR2x0WlM5MGFHbHpMbVIxY21GMGFXOXVLQ2w5TEY4dWRHOTBZV3hRY205bmNtVnpjejFtZFc1amRHbHZiaWgwS1h0eVpYUjFjbTRnWVhKbmRXMWxiblJ6TG14bGJtZDBhRDkwYUdsekxuUnZkR0ZzVkdsdFpTaDBhR2x6TG5SdmRHRnNSSFZ5WVhScGIyNG9LU3AwTENFeEtUcDBhR2x6TGw5MGIzUmhiRlJwYldVdmRHaHBjeTUwYjNSaGJFUjFjbUYwYVc5dUtDbDlMRjh1ZEdsdFpUMW1kVzVqZEdsdmJpaDBMR1VwZTNKbGRIVnliaUJoY21kMWJXVnVkSE11YkdWdVozUm9QeWgwYUdsekxsOWthWEowZVNZbWRHaHBjeTUwYjNSaGJFUjFjbUYwYVc5dUtDa3NkRDUwYUdsekxsOWtkWEpoZEdsdmJpWW1LSFE5ZEdocGN5NWZaSFZ5WVhScGIyNHBMSFJvYVhNdVgzbHZlVzhtSmpBaFBUMG9NU1owYUdsekxsOWplV05zWlNrL2REMTBhR2x6TGw5a2RYSmhkR2x2YmkxMEszUm9hWE11WDJONVkyeGxLaWgwYUdsekxsOWtkWEpoZEdsdmJpdDBhR2x6TGw5eVpYQmxZWFJFWld4aGVTazZNQ0U5UFhSb2FYTXVYM0psY0dWaGRDWW1LSFFyUFhSb2FYTXVYMk41WTJ4bEtpaDBhR2x6TGw5a2RYSmhkR2x2Yml0MGFHbHpMbDl5WlhCbFlYUkVaV3hoZVNrcExIUm9hWE11ZEc5MFlXeFVhVzFsS0hRc1pTa3BPblJvYVhNdVgzUnBiV1Y5TEY4dVpIVnlZWFJwYjI0OVpuVnVZM1JwYjI0b1pTbDdjbVYwZFhKdUlHRnlaM1Z0Wlc1MGN5NXNaVzVuZEdnL2RDNXdjbTkwYjNSNWNHVXVaSFZ5WVhScGIyNHVZMkZzYkNoMGFHbHpMR1VwT25Sb2FYTXVYMlIxY21GMGFXOXVmU3hmTG5SdmRHRnNSSFZ5WVhScGIyNDlablZ1WTNScGIyNG9kQ2w3Y21WMGRYSnVJR0Z5WjNWdFpXNTBjeTVzWlc1bmRHZy9MVEU5UFQxMGFHbHpMbDl5WlhCbFlYUS9kR2hwY3pwMGFHbHpMbVIxY21GMGFXOXVLQ2gwTFhSb2FYTXVYM0psY0dWaGRDcDBhR2x6TGw5eVpYQmxZWFJFWld4aGVTa3ZLSFJvYVhNdVgzSmxjR1ZoZENzeEtTazZLSFJvYVhNdVgyUnBjblI1SmlZb2RHaHBjeTVmZEc5MFlXeEVkWEpoZEdsdmJqMHRNVDA5UFhSb2FYTXVYM0psY0dWaGREODVPVGs1T1RrNU9UazVPVGs2ZEdocGN5NWZaSFZ5WVhScGIyNHFLSFJvYVhNdVgzSmxjR1ZoZENzeEtTdDBhR2x6TGw5eVpYQmxZWFJFWld4aGVTcDBhR2x6TGw5eVpYQmxZWFFzZEdocGN5NWZaR2x5ZEhrOUlURXBMSFJvYVhNdVgzUnZkR0ZzUkhWeVlYUnBiMjRwZlN4ZkxuSmxjR1ZoZEQxbWRXNWpkR2x2YmloMEtYdHlaWFIxY200Z1lYSm5kVzFsYm5SekxteGxibWQwYUQ4b2RHaHBjeTVmY21Wd1pXRjBQWFFzZEdocGN5NWZkVzVqWVdOb1pTZ2hNQ2twT25Sb2FYTXVYM0psY0dWaGRIMHNYeTV5WlhCbFlYUkVaV3hoZVQxbWRXNWpkR2x2YmloMEtYdHlaWFIxY200Z1lYSm5kVzFsYm5SekxteGxibWQwYUQ4b2RHaHBjeTVmY21Wd1pXRjBSR1ZzWVhrOWRDeDBhR2x6TGw5MWJtTmhZMmhsS0NFd0tTazZkR2hwY3k1ZmNtVndaV0YwUkdWc1lYbDlMRjh1ZVc5NWJ6MW1kVzVqZEdsdmJpaDBLWHR5WlhSMWNtNGdZWEpuZFcxbGJuUnpMbXhsYm1kMGFEOG9kR2hwY3k1ZmVXOTViejEwTEhSb2FYTXBPblJvYVhNdVgzbHZlVzk5TEc1OUxDRXdLU3hmWjNOVFkyOXdaUzVmWjNORVpXWnBibVVvWENKVWFXMWxiR2x1WlV4cGRHVmNJaXhiWENKamIzSmxMa0Z1YVcxaGRHbHZibHdpTEZ3aVkyOXlaUzVUYVcxd2JHVlVhVzFsYkdsdVpWd2lMRndpVkhkbFpXNU1hWFJsWENKZExHWjFibU4wYVc5dUtIUXNaU3hwS1h0MllYSWdjejFtZFc1amRHbHZiaWgwS1h0bExtTmhiR3dvZEdocGN5eDBLU3gwYUdsekxsOXNZV0psYkhNOWUzMHNkR2hwY3k1aGRYUnZVbVZ0YjNabFEyaHBiR1J5Wlc0OWRHaHBjeTUyWVhKekxtRjFkRzlTWlcxdmRtVkRhR2xzWkhKbGJqMDlQU0V3TEhSb2FYTXVjMjF2YjNSb1EyaHBiR1JVYVcxcGJtYzlkR2hwY3k1MllYSnpMbk50YjI5MGFFTm9hV3hrVkdsdGFXNW5QVDA5SVRBc2RHaHBjeTVmYzI5eWRFTm9hV3hrY21WdVBTRXdMSFJvYVhNdVgyOXVWWEJrWVhSbFBYUm9hWE11ZG1GeWN5NXZibFZ3WkdGMFpUdDJZWElnYVN4ekxISTlkR2hwY3k1MllYSnpPMlp2Y2loeklHbHVJSElwYVQxeVczTmRMR3dvYVNrbUppMHhJVDA5YVM1cWIybHVLRndpWENJcExtbHVaR1Y0VDJZb1hDSjdjMlZzWm4xY0lpa21KaWh5VzNOZFBYUm9hWE11WDNOM1lYQlRaV3htU1c1UVlYSmhiWE1vYVNrcE8yd29jaTUwZDJWbGJuTXBKaVowYUdsekxtRmtaQ2h5TG5SM1pXVnVjeXd3TEhJdVlXeHBaMjRzY2k1emRHRm5aMlZ5S1gwc2NqMHhaUzB4TUN4dVBXa3VYMmx1ZEdWeWJtRnNjeXhoUFhNdVgybHVkR1Z5Ym1Gc2N6MTdmU3h2UFc0dWFYTlRaV3hsWTNSdmNpeHNQVzR1YVhOQmNuSmhlU3hvUFc0dWJHRjZlVlIzWldWdWN5eGZQVzR1YkdGNmVWSmxibVJsY2l4MVBWOW5jMU5qYjNCbExsOW5jMFJsWm1sdVpTNW5iRzlpWVd4ekxHTTlablZ1WTNScGIyNG9kQ2w3ZG1GeUlHVXNhVDE3ZlR0bWIzSW9aU0JwYmlCMEtXbGJaVjA5ZEZ0bFhUdHlaWFIxY200Z2FYMHNaajFtZFc1amRHbHZiaWgwTEdVc2FTbDdkbUZ5SUhNc2NpeHVQWFF1WTNsamJHVTdabTl5S0hNZ2FXNGdiaWx5UFc1YmMxMHNkRnR6WFQxY0ltWjFibU4wYVc5dVhDSTlQWFI1Y0dWdlppQnlQM0l1WTJGc2JDaGxXMmxkTEdrcE9uSmJhU1Z5TG14bGJtZDBhRjA3WkdWc1pYUmxJSFF1WTNsamJHVjlMSEE5WVM1d1lYVnpaVU5oYkd4aVlXTnJQV1oxYm1OMGFXOXVLQ2w3ZlN4dFBXWjFibU4wYVc5dUtIUXBlM1poY2lCbExHazlXMTBzY3oxMExteGxibWQwYUR0bWIzSW9aVDB3TzJVaFBUMXpPMmt1Y0hWemFDaDBXMlVySzEwcEtUdHlaWFIxY200Z2FYMHNaRDF6TG5CeWIzUnZkSGx3WlQxdVpYY2daVHR5WlhSMWNtNGdjeTUyWlhKemFXOXVQVndpTVM0eE9DNHdYQ0lzWkM1amIyNXpkSEoxWTNSdmNqMXpMR1F1YTJsc2JDZ3BMbDluWXoxa0xsOW1iM0pqYVc1blVHeGhlV2hsWVdROVpDNWZhR0Z6VUdGMWMyVTlJVEVzWkM1MGJ6MW1kVzVqZEdsdmJpaDBMR1VzY3l4eUtYdDJZWElnYmoxekxuSmxjR1ZoZENZbWRTNVVkMlZsYmsxaGVIeDhhVHR5WlhSMWNtNGdaVDkwYUdsekxtRmtaQ2h1WlhjZ2JpaDBMR1VzY3lrc2NpazZkR2hwY3k1elpYUW9kQ3h6TEhJcGZTeGtMbVp5YjIwOVpuVnVZM1JwYjI0b2RDeGxMSE1zY2lsN2NtVjBkWEp1SUhSb2FYTXVZV1JrS0NoekxuSmxjR1ZoZENZbWRTNVVkMlZsYmsxaGVIeDhhU2t1Wm5KdmJTaDBMR1VzY3lrc2NpbDlMR1F1Wm5KdmJWUnZQV1oxYm1OMGFXOXVLSFFzWlN4ekxISXNiaWw3ZG1GeUlHRTljaTV5WlhCbFlYUW1KblV1VkhkbFpXNU5ZWGg4ZkdrN2NtVjBkWEp1SUdVL2RHaHBjeTVoWkdRb1lTNW1jbTl0Vkc4b2RDeGxMSE1zY2lrc2JpazZkR2hwY3k1elpYUW9kQ3h5TEc0cGZTeGtMbk4wWVdkblpYSlViejFtZFc1amRHbHZiaWgwTEdVc2NpeHVMR0VzYkN4b0xGOHBlM1poY2lCMUxIQXNaRDF1WlhjZ2N5aDdiMjVEYjIxd2JHVjBaVHBzTEc5dVEyOXRjR3hsZEdWUVlYSmhiWE02YUN4allXeHNZbUZqYTFOamIzQmxPbDhzYzIxdmIzUm9RMmhwYkdSVWFXMXBibWM2ZEdocGN5NXpiVzl2ZEdoRGFHbHNaRlJwYldsdVozMHBMR2M5Y2k1amVXTnNaVHRtYjNJb1hDSnpkSEpwYm1kY0lqMDlkSGx3Wlc5bUlIUW1KaWgwUFdrdWMyVnNaV04wYjNJb2RDbDhmSFFwTEhROWRIeDhXMTBzYnloMEtTWW1LSFE5YlNoMEtTa3NiajF1Zkh3d0xEQStiaVltS0hROWJTaDBLU3gwTG5KbGRtVnljMlVvS1N4dUtqMHRNU2tzY0Qwd08zUXViR1Z1WjNSb1BuQTdjQ3NyS1hVOVl5aHlLU3gxTG5OMFlYSjBRWFFtSmloMUxuTjBZWEowUVhROVl5aDFMbk4wWVhKMFFYUXBMSFV1YzNSaGNuUkJkQzVqZVdOc1pTWW1aaWgxTG5OMFlYSjBRWFFzZEN4d0tTa3NaeVltWmloMUxIUXNjQ2tzWkM1MGJ5aDBXM0JkTEdVc2RTeHdLbTRwTzNKbGRIVnliaUIwYUdsekxtRmtaQ2hrTEdFcGZTeGtMbk4wWVdkblpYSkdjbTl0UFdaMWJtTjBhVzl1S0hRc1pTeHBMSE1zY2l4dUxHRXNieWw3Y21WMGRYSnVJR2t1YVcxdFpXUnBZWFJsVW1WdVpHVnlQVEFoUFdrdWFXMXRaV1JwWVhSbFVtVnVaR1Z5TEdrdWNuVnVRbUZqYTNkaGNtUnpQU0V3TEhSb2FYTXVjM1JoWjJkbGNsUnZLSFFzWlN4cExITXNjaXh1TEdFc2J5bDlMR1F1YzNSaFoyZGxja1p5YjIxVWJ6MW1kVzVqZEdsdmJpaDBMR1VzYVN4ekxISXNiaXhoTEc4c2JDbDdjbVYwZFhKdUlITXVjM1JoY25SQmREMXBMSE11YVcxdFpXUnBZWFJsVW1WdVpHVnlQVEFoUFhNdWFXMXRaV1JwWVhSbFVtVnVaR1Z5SmlZd0lUMXBMbWx0YldWa2FXRjBaVkpsYm1SbGNpeDBhR2x6TG5OMFlXZG5aWEpVYnloMExHVXNjeXh5TEc0c1lTeHZMR3dwZlN4a0xtTmhiR3c5Wm5WdVkzUnBiMjRvZEN4bExITXNjaWw3Y21WMGRYSnVJSFJvYVhNdVlXUmtLR2t1WkdWc1lYbGxaRU5oYkd3b01DeDBMR1VzY3lrc2NpbDlMR1F1YzJWMFBXWjFibU4wYVc5dUtIUXNaU3h6S1h0eVpYUjFjbTRnY3oxMGFHbHpMbDl3WVhKelpWUnBiV1ZQY2t4aFltVnNLSE1zTUN3aE1Da3NiblZzYkQwOVpTNXBiVzFsWkdsaGRHVlNaVzVrWlhJbUppaGxMbWx0YldWa2FXRjBaVkpsYm1SbGNqMXpQVDA5ZEdocGN5NWZkR2x0WlNZbUlYUm9hWE11WDNCaGRYTmxaQ2tzZEdocGN5NWhaR1FvYm1WM0lHa29kQ3d3TEdVcExITXBmU3h6TG1WNGNHOXlkRkp2YjNROVpuVnVZM1JwYjI0b2RDeGxLWHQwUFhSOGZIdDlMRzUxYkd3OVBYUXVjMjF2YjNSb1EyaHBiR1JVYVcxcGJtY21KaWgwTG5OdGIyOTBhRU5vYVd4a1ZHbHRhVzVuUFNFd0tUdDJZWElnY2l4dUxHRTlibVYzSUhNb2RDa3NiejFoTGw5MGFXMWxiR2x1WlR0bWIzSW9iblZzYkQwOVpTWW1LR1U5SVRBcExHOHVYM0psYlc5MlpTaGhMQ0V3S1N4aExsOXpkR0Z5ZEZScGJXVTlNQ3hoTGw5eVlYZFFjbVYyVkdsdFpUMWhMbDkwYVcxbFBXRXVYM1J2ZEdGc1ZHbHRaVDF2TGw5MGFXMWxMSEk5Ynk1ZlptbHljM1E3Y2pzcGJqMXlMbDl1WlhoMExHVW1KbklnYVc1emRHRnVZMlZ2WmlCcEppWnlMblJoY21kbGREMDlQWEl1ZG1GeWN5NXZia052YlhCc1pYUmxmSHhoTG1Ga1pDaHlMSEl1WDNOMFlYSjBWR2x0WlMxeUxsOWtaV3hoZVNrc2NqMXVPM0psZEhWeWJpQnZMbUZrWkNoaExEQXBMR0Y5TEdRdVlXUmtQV1oxYm1OMGFXOXVLSElzYml4aExHOHBlM1poY2lCb0xGOHNkU3hqTEdZc2NEdHBaaWhjSW01MWJXSmxjbHdpSVQxMGVYQmxiMllnYmlZbUtHNDlkR2hwY3k1ZmNHRnljMlZVYVcxbFQzSk1ZV0psYkNodUxEQXNJVEFzY2lrcExDRW9jaUJwYm5OMFlXNWpaVzltSUhRcEtYdHBaaWh5SUdsdWMzUmhibU5sYjJZZ1FYSnlZWGw4ZkhJbUpuSXVjSFZ6YUNZbWJDaHlLU2w3Wm05eUtHRTlZWHg4WENKdWIzSnRZV3hjSWl4dlBXOThmREFzYUQxdUxGODljaTVzWlc1bmRHZ3NkVDB3TzE4K2RUdDFLeXNwYkNoalBYSmJkVjBwSmlZb1l6MXVaWGNnY3loN2RIZGxaVzV6T21OOUtTa3NkR2hwY3k1aFpHUW9ZeXhvS1N4Y0luTjBjbWx1WjF3aUlUMTBlWEJsYjJZZ1l5WW1YQ0ptZFc1amRHbHZibHdpSVQxMGVYQmxiMllnWXlZbUtGd2ljMlZ4ZFdWdVkyVmNJajA5UFdFL2FEMWpMbDl6ZEdGeWRGUnBiV1VyWXk1MGIzUmhiRVIxY21GMGFXOXVLQ2t2WXk1ZmRHbHRaVk5qWVd4bE9sd2ljM1JoY25SY0lqMDlQV0VtSmloakxsOXpkR0Z5ZEZScGJXVXRQV011WkdWc1lYa29LU2twTEdnclBXODdjbVYwZFhKdUlIUm9hWE11WDNWdVkyRmphR1VvSVRBcGZXbG1LRndpYzNSeWFXNW5YQ0k5UFhSNWNHVnZaaUJ5S1hKbGRIVnliaUIwYUdsekxtRmtaRXhoWW1Wc0tISXNiaWs3YVdZb1hDSm1kVzVqZEdsdmJsd2lJVDEwZVhCbGIyWWdjaWwwYUhKdmQxd2lRMkZ1Ym05MElHRmtaQ0JjSWl0eUsxd2lJR2x1ZEc4Z2RHaGxJSFJwYldWc2FXNWxPeUJwZENCcGN5QnViM1FnWVNCMGQyVmxiaXdnZEdsdFpXeHBibVVzSUdaMWJtTjBhVzl1TENCdmNpQnpkSEpwYm1jdVhDSTdjajFwTG1SbGJHRjVaV1JEWVd4c0tEQXNjaWw5YVdZb1pTNXdjbTkwYjNSNWNHVXVZV1JrTG1OaGJHd29kR2hwY3l4eUxHNHBMQ2gwYUdsekxsOW5ZM3g4ZEdocGN5NWZkR2x0WlQwOVBYUm9hWE11WDJSMWNtRjBhVzl1S1NZbUlYUm9hWE11WDNCaGRYTmxaQ1ltZEdocGN5NWZaSFZ5WVhScGIyNDhkR2hwY3k1a2RYSmhkR2x2YmlncEtXWnZjaWhtUFhSb2FYTXNjRDFtTG5KaGQxUnBiV1VvS1Q1eUxsOXpkR0Z5ZEZScGJXVTdaaTVmZEdsdFpXeHBibVU3S1hBbUptWXVYM1JwYldWc2FXNWxMbk50YjI5MGFFTm9hV3hrVkdsdGFXNW5QMll1ZEc5MFlXeFVhVzFsS0dZdVgzUnZkR0ZzVkdsdFpTd2hNQ2s2Wmk1ZloyTW1KbVl1WDJWdVlXSnNaV1FvSVRBc0lURXBMR1k5Wmk1ZmRHbHRaV3hwYm1VN2NtVjBkWEp1SUhSb2FYTjlMR1F1Y21WdGIzWmxQV1oxYm1OMGFXOXVLR1VwZTJsbUtHVWdhVzV6ZEdGdVkyVnZaaUIwS1h0MGFHbHpMbDl5WlcxdmRtVW9aU3doTVNrN2RtRnlJR2s5WlM1ZmRHbHRaV3hwYm1VOVpTNTJZWEp6TG5WelpVWnlZVzFsY3o5MExsOXliMjkwUm5KaGJXVnpWR2x0Wld4cGJtVTZkQzVmY205dmRGUnBiV1ZzYVc1bE8zSmxkSFZ5YmlCbExsOXpkR0Z5ZEZScGJXVTlLR1V1WDNCaGRYTmxaRDlsTGw5d1lYVnpaVlJwYldVNmFTNWZkR2x0WlNrdEtHVXVYM0psZG1WeWMyVmtQMlV1ZEc5MFlXeEVkWEpoZEdsdmJpZ3BMV1V1WDNSdmRHRnNWR2x0WlRwbExsOTBiM1JoYkZScGJXVXBMMlV1WDNScGJXVlRZMkZzWlN4MGFHbHpmV2xtS0dVZ2FXNXpkR0Z1WTJWdlppQkJjbkpoZVh4OFpTWW1aUzV3ZFhOb0ppWnNLR1VwS1h0bWIzSW9kbUZ5SUhNOVpTNXNaVzVuZEdnN0xTMXpQaTB4T3lsMGFHbHpMbkpsYlc5MlpTaGxXM05kS1R0eVpYUjFjbTRnZEdocGMzMXlaWFIxY201Y0luTjBjbWx1WjF3aVBUMTBlWEJsYjJZZ1pUOTBhR2x6TG5KbGJXOTJaVXhoWW1Wc0tHVXBPblJvYVhNdWEybHNiQ2h1ZFd4c0xHVXBmU3hrTGw5eVpXMXZkbVU5Wm5WdVkzUnBiMjRvZEN4cEtYdGxMbkJ5YjNSdmRIbHdaUzVmY21WdGIzWmxMbU5oYkd3b2RHaHBjeXgwTEdrcE8zWmhjaUJ6UFhSb2FYTXVYMnhoYzNRN2NtVjBkWEp1SUhNL2RHaHBjeTVmZEdsdFpUNXpMbDl6ZEdGeWRGUnBiV1VyY3k1ZmRHOTBZV3hFZFhKaGRHbHZiaTl6TGw5MGFXMWxVMk5oYkdVbUppaDBhR2x6TGw5MGFXMWxQWFJvYVhNdVpIVnlZWFJwYjI0b0tTeDBhR2x6TGw5MGIzUmhiRlJwYldVOWRHaHBjeTVmZEc5MFlXeEVkWEpoZEdsdmJpazZkR2hwY3k1ZmRHbHRaVDEwYUdsekxsOTBiM1JoYkZScGJXVTlkR2hwY3k1ZlpIVnlZWFJwYjI0OWRHaHBjeTVmZEc5MFlXeEVkWEpoZEdsdmJqMHdMSFJvYVhOOUxHUXVZWEJ3Wlc1a1BXWjFibU4wYVc5dUtIUXNaU2w3Y21WMGRYSnVJSFJvYVhNdVlXUmtLSFFzZEdocGN5NWZjR0Z5YzJWVWFXMWxUM0pNWVdKbGJDaHVkV3hzTEdVc0lUQXNkQ2twZlN4a0xtbHVjMlZ5ZEQxa0xtbHVjMlZ5ZEUxMWJIUnBjR3hsUFdaMWJtTjBhVzl1S0hRc1pTeHBMSE1wZTNKbGRIVnliaUIwYUdsekxtRmtaQ2gwTEdWOGZEQXNhU3h6S1gwc1pDNWhjSEJsYm1STmRXeDBhWEJzWlQxbWRXNWpkR2x2YmloMExHVXNhU3h6S1h0eVpYUjFjbTRnZEdocGN5NWhaR1FvZEN4MGFHbHpMbDl3WVhKelpWUnBiV1ZQY2t4aFltVnNLRzUxYkd3c1pTd2hNQ3gwS1N4cExITXBmU3hrTG1Ga1pFeGhZbVZzUFdaMWJtTjBhVzl1S0hRc1pTbDdjbVYwZFhKdUlIUm9hWE11WDJ4aFltVnNjMXQwWFQxMGFHbHpMbDl3WVhKelpWUnBiV1ZQY2t4aFltVnNLR1VwTEhSb2FYTjlMR1F1WVdSa1VHRjFjMlU5Wm5WdVkzUnBiMjRvZEN4bExITXNjaWw3ZG1GeUlHNDlhUzVrWld4aGVXVmtRMkZzYkNnd0xIQXNjeXh5Zkh4MGFHbHpLVHR5WlhSMWNtNGdiaTUyWVhKekxtOXVRMjl0Y0d4bGRHVTliaTUyWVhKekxtOXVVbVYyWlhKelpVTnZiWEJzWlhSbFBXVXNiaTVrWVhSaFBWd2lhWE5RWVhWelpWd2lMSFJvYVhNdVgyaGhjMUJoZFhObFBTRXdMSFJvYVhNdVlXUmtLRzRzZENsOUxHUXVjbVZ0YjNabFRHRmlaV3c5Wm5WdVkzUnBiMjRvZENsN2NtVjBkWEp1SUdSbGJHVjBaU0IwYUdsekxsOXNZV0psYkhOYmRGMHNkR2hwYzMwc1pDNW5aWFJNWVdKbGJGUnBiV1U5Wm5WdVkzUnBiMjRvZENsN2NtVjBkWEp1SUc1MWJHd2hQWFJvYVhNdVgyeGhZbVZzYzF0MFhUOTBhR2x6TGw5c1lXSmxiSE5iZEYwNkxURjlMR1F1WDNCaGNuTmxWR2x0WlU5eVRHRmlaV3c5Wm5WdVkzUnBiMjRvWlN4cExITXNjaWw3ZG1GeUlHNDdhV1lvY2lCcGJuTjBZVzVqWlc5bUlIUW1Kbkl1ZEdsdFpXeHBibVU5UFQxMGFHbHpLWFJvYVhNdWNtVnRiM1psS0hJcE8yVnNjMlVnYVdZb2NpWW1LSElnYVc1emRHRnVZMlZ2WmlCQmNuSmhlWHg4Y2k1d2RYTm9KaVpzS0hJcEtTbG1iM0lvYmoxeUxteGxibWQwYURzdExXNCtMVEU3S1hKYmJsMXBibk4wWVc1alpXOW1JSFFtSm5KYmJsMHVkR2x0Wld4cGJtVTlQVDEwYUdsekppWjBhR2x6TG5KbGJXOTJaU2h5VzI1ZEtUdHBaaWhjSW5OMGNtbHVaMXdpUFQxMGVYQmxiMllnYVNseVpYUjFjbTRnZEdocGN5NWZjR0Z5YzJWVWFXMWxUM0pNWVdKbGJDaHBMSE1tSmx3aWJuVnRZbVZ5WENJOVBYUjVjR1Z2WmlCbEppWnVkV3hzUFQxMGFHbHpMbDlzWVdKbGJITmJhVjAvWlMxMGFHbHpMbVIxY21GMGFXOXVLQ2s2TUN4ektUdHBaaWhwUFdsOGZEQXNYQ0p6ZEhKcGJtZGNJaUU5ZEhsd1pXOW1JR1Y4ZkNGcGMwNWhUaWhsS1NZbWJuVnNiRDA5ZEdocGN5NWZiR0ZpWld4elcyVmRLVzUxYkd3OVBXVW1KaWhsUFhSb2FYTXVaSFZ5WVhScGIyNG9LU2s3Wld4elpYdHBaaWh1UFdVdWFXNWtaWGhQWmloY0lqMWNJaWtzTFRFOVBUMXVLWEpsZEhWeWJpQnVkV3hzUFQxMGFHbHpMbDlzWVdKbGJITmJaVjAvY3o5MGFHbHpMbDlzWVdKbGJITmJaVjA5ZEdocGN5NWtkWEpoZEdsdmJpZ3BLMms2YVRwMGFHbHpMbDlzWVdKbGJITmJaVjByYVR0cFBYQmhjbk5sU1c1MEtHVXVZMmhoY2tGMEtHNHRNU2tyWENJeFhDSXNNVEFwS2s1MWJXSmxjaWhsTG5OMVluTjBjaWh1S3pFcEtTeGxQVzQrTVQ5MGFHbHpMbDl3WVhKelpWUnBiV1ZQY2t4aFltVnNLR1V1YzNWaWMzUnlLREFzYmkweEtTd3dMSE1wT25Sb2FYTXVaSFZ5WVhScGIyNG9LWDF5WlhSMWNtNGdUblZ0WW1WeUtHVXBLMmw5TEdRdWMyVmxhejFtZFc1amRHbHZiaWgwTEdVcGUzSmxkSFZ5YmlCMGFHbHpMblJ2ZEdGc1ZHbHRaU2hjSW01MWJXSmxjbHdpUFQxMGVYQmxiMllnZEQ5ME9uUm9hWE11WDNCaGNuTmxWR2x0WlU5eVRHRmlaV3dvZENrc1pTRTlQU0V4S1gwc1pDNXpkRzl3UFdaMWJtTjBhVzl1S0NsN2NtVjBkWEp1SUhSb2FYTXVjR0YxYzJWa0tDRXdLWDBzWkM1bmIzUnZRVzVrVUd4aGVUMW1kVzVqZEdsdmJpaDBMR1VwZTNKbGRIVnliaUIwYUdsekxuQnNZWGtvZEN4bEtYMHNaQzVuYjNSdlFXNWtVM1J2Y0QxbWRXNWpkR2x2YmloMExHVXBlM0psZEhWeWJpQjBhR2x6TG5CaGRYTmxLSFFzWlNsOUxHUXVjbVZ1WkdWeVBXWjFibU4wYVc5dUtIUXNaU3hwS1h0MGFHbHpMbDluWXlZbWRHaHBjeTVmWlc1aFlteGxaQ2doTUN3aE1TazdkbUZ5SUhNc2JpeGhMRzhzYkN4MUxHTTlkR2hwY3k1ZlpHbHlkSGsvZEdocGN5NTBiM1JoYkVSMWNtRjBhVzl1S0NrNmRHaHBjeTVmZEc5MFlXeEVkWEpoZEdsdmJpeG1QWFJvYVhNdVgzUnBiV1VzY0QxMGFHbHpMbDl6ZEdGeWRGUnBiV1VzYlQxMGFHbHpMbDkwYVcxbFUyTmhiR1VzWkQxMGFHbHpMbDl3WVhWelpXUTdhV1lvZEQ0OVl5bDBhR2x6TGw5MGIzUmhiRlJwYldVOWRHaHBjeTVmZEdsdFpUMWpMSFJvYVhNdVgzSmxkbVZ5YzJWa2ZIeDBhR2x6TGw5b1lYTlFZWFZ6WldSRGFHbHNaQ2dwZkh3b2JqMGhNQ3h2UFZ3aWIyNURiMjF3YkdWMFpWd2lMR3c5SVNGMGFHbHpMbDkwYVcxbGJHbHVaUzVoZFhSdlVtVnRiM1psUTJocGJHUnlaVzRzTUQwOVBYUm9hWE11WDJSMWNtRjBhVzl1SmlZb01EMDlQWFI4ZkRBK2RHaHBjeTVmY21GM1VISmxkbFJwYldWOGZIUm9hWE11WDNKaGQxQnlaWFpVYVcxbFBUMDljaWttSm5Sb2FYTXVYM0poZDFCeVpYWlVhVzFsSVQwOWRDWW1kR2hwY3k1ZlptbHljM1FtSmloc1BTRXdMSFJvYVhNdVgzSmhkMUJ5WlhaVWFXMWxQbkltSmlodlBWd2liMjVTWlhabGNuTmxRMjl0Y0d4bGRHVmNJaWtwS1N4MGFHbHpMbDl5WVhkUWNtVjJWR2x0WlQxMGFHbHpMbDlrZFhKaGRHbHZibng4SVdWOGZIUjhmSFJvYVhNdVgzSmhkMUJ5WlhaVWFXMWxQVDA5ZEQ5ME9uSXNkRDFqS3pGbExUUTdaV3h6WlNCcFppZ3haUzAzUG5RcGFXWW9kR2hwY3k1ZmRHOTBZV3hVYVcxbFBYUm9hWE11WDNScGJXVTlNQ3dvTUNFOVBXWjhmREE5UFQxMGFHbHpMbDlrZFhKaGRHbHZiaVltZEdocGN5NWZjbUYzVUhKbGRsUnBiV1VoUFQxeUppWW9kR2hwY3k1ZmNtRjNVSEpsZGxScGJXVStNSHg4TUQ1MEppWjBhR2x6TGw5eVlYZFFjbVYyVkdsdFpUNDlNQ2twSmlZb2J6MWNJbTl1VW1WMlpYSnpaVU52YlhCc1pYUmxYQ0lzYmoxMGFHbHpMbDl5WlhabGNuTmxaQ2tzTUQ1MEtYUm9hWE11WDJGamRHbDJaVDBoTVN4MGFHbHpMbDkwYVcxbGJHbHVaUzVoZFhSdlVtVnRiM1psUTJocGJHUnlaVzRtSm5Sb2FYTXVYM0psZG1WeWMyVmtQeWhzUFc0OUlUQXNiejFjSW05dVVtVjJaWEp6WlVOdmJYQnNaWFJsWENJcE9uUm9hWE11WDNKaGQxQnlaWFpVYVcxbFBqMHdKaVowYUdsekxsOW1hWEp6ZENZbUtHdzlJVEFwTEhSb2FYTXVYM0poZDFCeVpYWlVhVzFsUFhRN1pXeHpaWHRwWmloMGFHbHpMbDl5WVhkUWNtVjJWR2x0WlQxMGFHbHpMbDlrZFhKaGRHbHZibng4SVdWOGZIUjhmSFJvYVhNdVgzSmhkMUJ5WlhaVWFXMWxQVDA5ZEQ5ME9uSXNNRDA5UFhRbUptNHBabTl5S0hNOWRHaHBjeTVmWm1seWMzUTdjeVltTUQwOVBYTXVYM04wWVhKMFZHbHRaVHNwY3k1ZlpIVnlZWFJwYjI1OGZDaHVQU0V4S1N4elBYTXVYMjVsZUhRN2REMHdMSFJvYVhNdVgybHVhWFIwWldSOGZDaHNQU0V3S1gxbGJITmxlMmxtS0hSb2FYTXVYMmhoYzFCaGRYTmxKaVloZEdocGN5NWZabTl5WTJsdVoxQnNZWGxvWldGa0ppWWhaU2w3YVdZb2RENDlaaWxtYjNJb2N6MTBhR2x6TGw5bWFYSnpkRHR6SmlaMFBqMXpMbDl6ZEdGeWRGUnBiV1VtSmlGMU95bHpMbDlrZFhKaGRHbHZibng4WENKcGMxQmhkWE5sWENJaFBUMXpMbVJoZEdGOGZITXVjbUYwYVc5OGZEQTlQVDF6TGw5emRHRnlkRlJwYldVbUpqQTlQVDEwYUdsekxsOXlZWGRRY21WMlZHbHRaWHg4S0hVOWN5a3NjejF6TGw5dVpYaDBPMlZzYzJVZ1ptOXlLSE05ZEdocGN5NWZiR0Z6ZER0ekppWnpMbDl6ZEdGeWRGUnBiV1UrUFhRbUppRjFPeWx6TGw5a2RYSmhkR2x2Ym54OFhDSnBjMUJoZFhObFhDSTlQVDF6TG1SaGRHRW1Kbk11WDNKaGQxQnlaWFpVYVcxbFBqQW1KaWgxUFhNcExITTljeTVmY0hKbGRqdDFKaVlvZEdocGN5NWZkR2x0WlQxMFBYVXVYM04wWVhKMFZHbHRaU3gwYUdsekxsOTBiM1JoYkZScGJXVTlkQ3QwYUdsekxsOWplV05zWlNvb2RHaHBjeTVmZEc5MFlXeEVkWEpoZEdsdmJpdDBhR2x6TGw5eVpYQmxZWFJFWld4aGVTa3BmWFJvYVhNdVgzUnZkR0ZzVkdsdFpUMTBhR2x6TGw5MGFXMWxQWFJvYVhNdVgzSmhkMUJ5WlhaVWFXMWxQWFI5YVdZb2RHaHBjeTVmZEdsdFpTRTlQV1ltSm5Sb2FYTXVYMlpwY25OMGZIeHBmSHhzZkh4MUtYdHBaaWgwYUdsekxsOXBibWwwZEdWa2ZId29kR2hwY3k1ZmFXNXBkSFJsWkQwaE1Da3NkR2hwY3k1ZllXTjBhWFpsZkh3aGRHaHBjeTVmY0dGMWMyVmtKaVowYUdsekxsOTBhVzFsSVQwOVppWW1kRDR3SmlZb2RHaHBjeTVmWVdOMGFYWmxQU0V3S1N3d1BUMDlaaVltZEdocGN5NTJZWEp6TG05dVUzUmhjblFtSmpBaFBUMTBhR2x6TGw5MGFXMWxKaVlvWlh4OGRHaHBjeTVmWTJGc2JHSmhZMnNvWENKdmJsTjBZWEowWENJcEtTeDBhR2x6TGw5MGFXMWxQajFtS1dadmNpaHpQWFJvYVhNdVgyWnBjbk4wTzNNbUppaGhQWE11WDI1bGVIUXNJWFJvYVhNdVgzQmhkWE5sWkh4OFpDazdLU2h6TGw5aFkzUnBkbVY4ZkhNdVgzTjBZWEowVkdsdFpUdzlkR2hwY3k1ZmRHbHRaU1ltSVhNdVgzQmhkWE5sWkNZbUlYTXVYMmRqS1NZbUtIVTlQVDF6SmlaMGFHbHpMbkJoZFhObEtDa3NjeTVmY21WMlpYSnpaV1EvY3k1eVpXNWtaWElvS0hNdVgyUnBjblI1UDNNdWRHOTBZV3hFZFhKaGRHbHZiaWdwT25NdVgzUnZkR0ZzUkhWeVlYUnBiMjRwTFNoMExYTXVYM04wWVhKMFZHbHRaU2txY3k1ZmRHbHRaVk5qWVd4bExHVXNhU2s2Y3k1eVpXNWtaWElvS0hRdGN5NWZjM1JoY25SVWFXMWxLU3B6TGw5MGFXMWxVMk5oYkdVc1pTeHBLU2tzY3oxaE8yVnNjMlVnWm05eUtITTlkR2hwY3k1ZmJHRnpkRHR6SmlZb1lUMXpMbDl3Y21WMkxDRjBhR2x6TGw5d1lYVnpaV1I4ZkdRcE95bDdhV1lvY3k1ZllXTjBhWFpsZkh4bVBqMXpMbDl6ZEdGeWRGUnBiV1VtSmlGekxsOXdZWFZ6WldRbUppRnpMbDluWXlsN2FXWW9kVDA5UFhNcGUyWnZjaWgxUFhNdVgzQnlaWFk3ZFNZbWRTNWxibVJVYVcxbEtDaytkR2hwY3k1ZmRHbHRaVHNwZFM1eVpXNWtaWElvZFM1ZmNtVjJaWEp6WldRL2RTNTBiM1JoYkVSMWNtRjBhVzl1S0NrdEtIUXRkUzVmYzNSaGNuUlVhVzFsS1NwMUxsOTBhVzFsVTJOaGJHVTZLSFF0ZFM1ZmMzUmhjblJVYVcxbEtTcDFMbDkwYVcxbFUyTmhiR1VzWlN4cEtTeDFQWFV1WDNCeVpYWTdkVDF1ZFd4c0xIUm9hWE11Y0dGMWMyVW9LWDF6TGw5eVpYWmxjbk5sWkQ5ekxuSmxibVJsY2lnb2N5NWZaR2x5ZEhrL2N5NTBiM1JoYkVSMWNtRjBhVzl1S0NrNmN5NWZkRzkwWVd4RWRYSmhkR2x2YmlrdEtIUXRjeTVmYzNSaGNuUlVhVzFsS1NwekxsOTBhVzFsVTJOaGJHVXNaU3hwS1RwekxuSmxibVJsY2lnb2RDMXpMbDl6ZEdGeWRGUnBiV1VwS25NdVgzUnBiV1ZUWTJGc1pTeGxMR2twZlhNOVlYMTBhR2x6TGw5dmJsVndaR0YwWlNZbUtHVjhmQ2hvTG14bGJtZDBhQ1ltWHlncExIUm9hWE11WDJOaGJHeGlZV05yS0Z3aWIyNVZjR1JoZEdWY0lpa3BLU3h2SmlZb2RHaHBjeTVmWjJOOGZDaHdQVDA5ZEdocGN5NWZjM1JoY25SVWFXMWxmSHh0SVQwOWRHaHBjeTVmZEdsdFpWTmpZV3hsS1NZbUtEQTlQVDEwYUdsekxsOTBhVzFsZkh4alBqMTBhR2x6TG5SdmRHRnNSSFZ5WVhScGIyNG9LU2ttSmlodUppWW9hQzVzWlc1bmRHZ21KbDhvS1N4MGFHbHpMbDkwYVcxbGJHbHVaUzVoZFhSdlVtVnRiM1psUTJocGJHUnlaVzRtSm5Sb2FYTXVYMlZ1WVdKc1pXUW9JVEVzSVRFcExIUm9hWE11WDJGamRHbDJaVDBoTVNrc0lXVW1KblJvYVhNdWRtRnljMXR2WFNZbWRHaHBjeTVmWTJGc2JHSmhZMnNvYnlrcEtYMTlMR1F1WDJoaGMxQmhkWE5sWkVOb2FXeGtQV1oxYm1OMGFXOXVLQ2w3Wm05eUtIWmhjaUIwUFhSb2FYTXVYMlpwY25OME8zUTdLWHRwWmloMExsOXdZWFZ6WldSOGZIUWdhVzV6ZEdGdVkyVnZaaUJ6SmlaMExsOW9ZWE5RWVhWelpXUkRhR2xzWkNncEtYSmxkSFZ5YmlFd08zUTlkQzVmYm1WNGRIMXlaWFIxY200aE1YMHNaQzVuWlhSRGFHbHNaSEpsYmoxbWRXNWpkR2x2YmloMExHVXNjeXh5S1h0eVBYSjhmQzA1T1RrNU9UazVPVGs1TzJadmNpaDJZWElnYmoxYlhTeGhQWFJvYVhNdVgyWnBjbk4wTEc4OU1EdGhPeWx5UG1FdVgzTjBZWEowVkdsdFpYeDhLR0VnYVc1emRHRnVZMlZ2WmlCcFAyVWhQVDBoTVNZbUtHNWJieXNyWFQxaEtUb29jeUU5UFNFeEppWW9ibHR2S3l0ZFBXRXBMSFFoUFQwaE1TWW1LRzQ5Ymk1amIyNWpZWFFvWVM1blpYUkRhR2xzWkhKbGJpZ2hNQ3hsTEhNcEtTeHZQVzR1YkdWdVozUm9LU2twTEdFOVlTNWZibVY0ZER0eVpYUjFjbTRnYm4wc1pDNW5aWFJVZDJWbGJuTlBaajFtZFc1amRHbHZiaWgwTEdVcGUzWmhjaUJ6TEhJc2JqMTBhR2x6TGw5bll5eGhQVnRkTEc4OU1EdG1iM0lvYmlZbWRHaHBjeTVmWlc1aFlteGxaQ2doTUN3aE1Da3NjejFwTG1kbGRGUjNaV1Z1YzA5bUtIUXBMSEk5Y3k1c1pXNW5kR2c3TFMxeVBpMHhPeWtvYzF0eVhTNTBhVzFsYkdsdVpUMDlQWFJvYVhOOGZHVW1KblJvYVhNdVgyTnZiblJoYVc1ektITmJjbDBwS1NZbUtHRmJieXNyWFQxelczSmRLVHR5WlhSMWNtNGdiaVltZEdocGN5NWZaVzVoWW14bFpDZ2hNU3doTUNrc1lYMHNaQzV5WldObGJuUTlablZ1WTNScGIyNG9LWHR5WlhSMWNtNGdkR2hwY3k1ZmNtVmpaVzUwZlN4a0xsOWpiMjUwWVdsdWN6MW1kVzVqZEdsdmJpaDBLWHRtYjNJb2RtRnlJR1U5ZEM1MGFXMWxiR2x1WlR0bE95bDdhV1lvWlQwOVBYUm9hWE1wY21WMGRYSnVJVEE3WlQxbExuUnBiV1ZzYVc1bGZYSmxkSFZ5YmlFeGZTeGtMbk5vYVdaMFEyaHBiR1J5Wlc0OVpuVnVZM1JwYjI0b2RDeGxMR2twZTJrOWFYeDhNRHRtYjNJb2RtRnlJSE1zY2oxMGFHbHpMbDltYVhKemRDeHVQWFJvYVhNdVgyeGhZbVZzY3p0eU95bHlMbDl6ZEdGeWRGUnBiV1UrUFdrbUppaHlMbDl6ZEdGeWRGUnBiV1VyUFhRcExISTljaTVmYm1WNGREdHBaaWhsS1dadmNpaHpJR2x1SUc0cGJsdHpYVDQ5YVNZbUtHNWJjMTByUFhRcE8zSmxkSFZ5YmlCMGFHbHpMbDkxYm1OaFkyaGxLQ0V3S1gwc1pDNWZhMmxzYkQxbWRXNWpkR2x2YmloMExHVXBlMmxtS0NGMEppWWhaU2x5WlhSMWNtNGdkR2hwY3k1ZlpXNWhZbXhsWkNnaE1Td2hNU2s3Wm05eUtIWmhjaUJwUFdVL2RHaHBjeTVuWlhSVWQyVmxibk5QWmlobEtUcDBhR2x6TG1kbGRFTm9hV3hrY21WdUtDRXdMQ0V3TENFeEtTeHpQV2t1YkdWdVozUm9MSEk5SVRFN0xTMXpQaTB4T3lscFczTmRMbDlyYVd4c0tIUXNaU2ttSmloeVBTRXdLVHR5WlhSMWNtNGdjbjBzWkM1amJHVmhjajFtZFc1amRHbHZiaWgwS1h0MllYSWdaVDEwYUdsekxtZGxkRU5vYVd4a2NtVnVLQ0V4TENFd0xDRXdLU3hwUFdVdWJHVnVaM1JvTzJadmNpaDBhR2x6TGw5MGFXMWxQWFJvYVhNdVgzUnZkR0ZzVkdsdFpUMHdPeTB0YVQ0dE1Uc3BaVnRwWFM1ZlpXNWhZbXhsWkNnaE1Td2hNU2s3Y21WMGRYSnVJSFFoUFQwaE1TWW1LSFJvYVhNdVgyeGhZbVZzY3oxN2ZTa3NkR2hwY3k1ZmRXNWpZV05vWlNnaE1DbDlMR1F1YVc1MllXeHBaR0YwWlQxbWRXNWpkR2x2YmlncGUyWnZjaWgyWVhJZ1pUMTBhR2x6TGw5bWFYSnpkRHRsT3lsbExtbHVkbUZzYVdSaGRHVW9LU3hsUFdVdVgyNWxlSFE3Y21WMGRYSnVJSFF1Y0hKdmRHOTBlWEJsTG1sdWRtRnNhV1JoZEdVdVkyRnNiQ2gwYUdsektYMHNaQzVmWlc1aFlteGxaRDFtZFc1amRHbHZiaWgwTEdrcGUybG1LSFE5UFQxMGFHbHpMbDluWXlsbWIzSW9kbUZ5SUhNOWRHaHBjeTVmWm1seWMzUTdjenNwY3k1ZlpXNWhZbXhsWkNoMExDRXdLU3h6UFhNdVgyNWxlSFE3Y21WMGRYSnVJR1V1Y0hKdmRHOTBlWEJsTGw5bGJtRmliR1ZrTG1OaGJHd29kR2hwY3l4MExHa3BmU3hrTG5SdmRHRnNWR2x0WlQxbWRXNWpkR2x2YmlncGUzUm9hWE11WDJadmNtTnBibWRRYkdGNWFHVmhaRDBoTUR0MllYSWdaVDEwTG5CeWIzUnZkSGx3WlM1MGIzUmhiRlJwYldVdVlYQndiSGtvZEdocGN5eGhjbWQxYldWdWRITXBPM0psZEhWeWJpQjBhR2x6TGw5bWIzSmphVzVuVUd4aGVXaGxZV1E5SVRFc1pYMHNaQzVrZFhKaGRHbHZiajFtZFc1amRHbHZiaWgwS1h0eVpYUjFjbTRnWVhKbmRXMWxiblJ6TG14bGJtZDBhRDhvTUNFOVBYUm9hWE11WkhWeVlYUnBiMjRvS1NZbU1DRTlQWFFtSm5Sb2FYTXVkR2x0WlZOallXeGxLSFJvYVhNdVgyUjFjbUYwYVc5dUwzUXBMSFJvYVhNcE9paDBhR2x6TGw5a2FYSjBlU1ltZEdocGN5NTBiM1JoYkVSMWNtRjBhVzl1S0Nrc2RHaHBjeTVmWkhWeVlYUnBiMjRwZlN4a0xuUnZkR0ZzUkhWeVlYUnBiMjQ5Wm5WdVkzUnBiMjRvZENsN2FXWW9JV0Z5WjNWdFpXNTBjeTVzWlc1bmRHZ3BlMmxtS0hSb2FYTXVYMlJwY25SNUtYdG1iM0lvZG1GeUlHVXNhU3h6UFRBc2NqMTBhR2x6TGw5c1lYTjBMRzQ5T1RrNU9UazVPVGs1T1RrNU8zSTdLV1U5Y2k1ZmNISmxkaXh5TGw5a2FYSjBlU1ltY2k1MGIzUmhiRVIxY21GMGFXOXVLQ2tzY2k1ZmMzUmhjblJVYVcxbFBtNG1KblJvYVhNdVgzTnZjblJEYUdsc1pISmxiaVltSVhJdVgzQmhkWE5sWkQ5MGFHbHpMbUZrWkNoeUxISXVYM04wWVhKMFZHbHRaUzF5TGw5a1pXeGhlU2s2YmoxeUxsOXpkR0Z5ZEZScGJXVXNNRDV5TGw5emRHRnlkRlJwYldVbUppRnlMbDl3WVhWelpXUW1KaWh6TFQxeUxsOXpkR0Z5ZEZScGJXVXNkR2hwY3k1ZmRHbHRaV3hwYm1VdWMyMXZiM1JvUTJocGJHUlVhVzFwYm1jbUppaDBhR2x6TGw5emRHRnlkRlJwYldVclBYSXVYM04wWVhKMFZHbHRaUzkwYUdsekxsOTBhVzFsVTJOaGJHVXBMSFJvYVhNdWMyaHBablJEYUdsc1pISmxiaWd0Y2k1ZmMzUmhjblJVYVcxbExDRXhMQzA1T1RrNU9UazVPVGs1S1N4dVBUQXBMR2s5Y2k1ZmMzUmhjblJVYVcxbEszSXVYM1J2ZEdGc1JIVnlZWFJwYjI0dmNpNWZkR2x0WlZOallXeGxMR2srY3lZbUtITTlhU2tzY2oxbE8zUm9hWE11WDJSMWNtRjBhVzl1UFhSb2FYTXVYM1J2ZEdGc1JIVnlZWFJwYjI0OWN5eDBhR2x6TGw5a2FYSjBlVDBoTVgxeVpYUjFjbTRnZEdocGN5NWZkRzkwWVd4RWRYSmhkR2x2Ym4xeVpYUjFjbTRnTUNFOVBYUm9hWE11ZEc5MFlXeEVkWEpoZEdsdmJpZ3BKaVl3SVQwOWRDWW1kR2hwY3k1MGFXMWxVMk5oYkdVb2RHaHBjeTVmZEc5MFlXeEVkWEpoZEdsdmJpOTBLU3gwYUdsemZTeGtMbkJoZFhObFpEMW1kVzVqZEdsdmJpaGxLWHRwWmlnaFpTbG1iM0lvZG1GeUlHazlkR2hwY3k1ZlptbHljM1FzY3oxMGFHbHpMbDkwYVcxbE8yazdLV2t1WDNOMFlYSjBWR2x0WlQwOVBYTW1KbHdpYVhOUVlYVnpaVndpUFQwOWFTNWtZWFJoSmlZb2FTNWZjbUYzVUhKbGRsUnBiV1U5TUNrc2FUMXBMbDl1WlhoME8zSmxkSFZ5YmlCMExuQnliM1J2ZEhsd1pTNXdZWFZ6WldRdVlYQndiSGtvZEdocGN5eGhjbWQxYldWdWRITXBmU3hrTG5WelpYTkdjbUZ0WlhNOVpuVnVZM1JwYjI0b0tYdG1iM0lvZG1GeUlHVTlkR2hwY3k1ZmRHbHRaV3hwYm1VN1pTNWZkR2x0Wld4cGJtVTdLV1U5WlM1ZmRHbHRaV3hwYm1VN2NtVjBkWEp1SUdVOVBUMTBMbDl5YjI5MFJuSmhiV1Z6VkdsdFpXeHBibVY5TEdRdWNtRjNWR2x0WlQxbWRXNWpkR2x2YmlncGUzSmxkSFZ5YmlCMGFHbHpMbDl3WVhWelpXUS9kR2hwY3k1ZmRHOTBZV3hVYVcxbE9paDBhR2x6TGw5MGFXMWxiR2x1WlM1eVlYZFVhVzFsS0NrdGRHaHBjeTVmYzNSaGNuUlVhVzFsS1NwMGFHbHpMbDkwYVcxbFUyTmhiR1Y5TEhOOUxDRXdLU3hmWjNOVFkyOXdaUzVmWjNORVpXWnBibVVvWENKVWFXMWxiR2x1WlUxaGVGd2lMRnRjSWxScGJXVnNhVzVsVEdsMFpWd2lMRndpVkhkbFpXNU1hWFJsWENJc1hDSmxZWE5wYm1jdVJXRnpaVndpWFN4bWRXNWpkR2x2YmloMExHVXNhU2w3ZG1GeUlITTlablZ1WTNScGIyNG9aU2w3ZEM1allXeHNLSFJvYVhNc1pTa3NkR2hwY3k1ZmNtVndaV0YwUFhSb2FYTXVkbUZ5Y3k1eVpYQmxZWFI4ZkRBc2RHaHBjeTVmY21Wd1pXRjBSR1ZzWVhrOWRHaHBjeTUyWVhKekxuSmxjR1ZoZEVSbGJHRjVmSHd3TEhSb2FYTXVYMk41WTJ4bFBUQXNkR2hwY3k1ZmVXOTViejEwYUdsekxuWmhjbk11ZVc5NWJ6MDlQU0V3TEhSb2FYTXVYMlJwY25SNVBTRXdmU3h5UFRGbExURXdMRzQ5WlM1ZmFXNTBaWEp1WVd4ekxHRTliaTVzWVhwNVZIZGxaVzV6TEc4OWJpNXNZWHA1VW1WdVpHVnlMR3c5Ym1WM0lHa29iblZzYkN4dWRXeHNMREVzTUNrc2FEMXpMbkJ5YjNSdmRIbHdaVDF1WlhjZ2REdHlaWFIxY200Z2FDNWpiMjV6ZEhKMVkzUnZjajF6TEdndWEybHNiQ2dwTGw5bll6MGhNU3h6TG5abGNuTnBiMjQ5WENJeExqRTRMakJjSWl4b0xtbHVkbUZzYVdSaGRHVTlablZ1WTNScGIyNG9LWHR5WlhSMWNtNGdkR2hwY3k1ZmVXOTViejEwYUdsekxuWmhjbk11ZVc5NWJ6MDlQU0V3TEhSb2FYTXVYM0psY0dWaGREMTBhR2x6TG5aaGNuTXVjbVZ3WldGMGZId3dMSFJvYVhNdVgzSmxjR1ZoZEVSbGJHRjVQWFJvYVhNdWRtRnljeTV5WlhCbFlYUkVaV3hoZVh4OE1DeDBhR2x6TGw5MWJtTmhZMmhsS0NFd0tTeDBMbkJ5YjNSdmRIbHdaUzVwYm5aaGJHbGtZWFJsTG1OaGJHd29kR2hwY3lsOUxHZ3VZV1JrUTJGc2JHSmhZMnM5Wm5WdVkzUnBiMjRvZEN4cExITXNjaWw3Y21WMGRYSnVJSFJvYVhNdVlXUmtLR1V1WkdWc1lYbGxaRU5oYkd3b01DeDBMSE1zY2lrc2FTbDlMR2d1Y21WdGIzWmxRMkZzYkdKaFkyczlablZ1WTNScGIyNG9kQ3hsS1h0cFppaDBLV2xtS0c1MWJHdzlQV1VwZEdocGN5NWZhMmxzYkNodWRXeHNMSFFwTzJWc2MyVWdabTl5S0haaGNpQnBQWFJvYVhNdVoyVjBWSGRsWlc1elQyWW9kQ3doTVNrc2N6MXBMbXhsYm1kMGFDeHlQWFJvYVhNdVgzQmhjbk5sVkdsdFpVOXlUR0ZpWld3b1pTazdMUzF6UGkweE95bHBXM05kTGw5emRHRnlkRlJwYldVOVBUMXlKaVpwVzNOZExsOWxibUZpYkdWa0tDRXhMQ0V4S1R0eVpYUjFjbTRnZEdocGMzMHNhQzV5WlcxdmRtVlFZWFZ6WlQxbWRXNWpkR2x2YmlobEtYdHlaWFIxY200Z2RHaHBjeTV5WlcxdmRtVkRZV3hzWW1GamF5aDBMbDlwYm5SbGNtNWhiSE11Y0dGMWMyVkRZV3hzWW1GamF5eGxLWDBzYUM1MGQyVmxibFJ2UFdaMWJtTjBhVzl1S0hRc2FTbDdhVDFwZkh4N2ZUdDJZWElnY3l4eUxHNHNZVDE3WldGelpUcHNMSFZ6WlVaeVlXMWxjenAwYUdsekxuVnpaWE5HY21GdFpYTW9LU3hwYlcxbFpHbGhkR1ZTWlc1a1pYSTZJVEY5TzJadmNpaHlJR2x1SUdrcFlWdHlYVDFwVzNKZE8zSmxkSFZ5YmlCaExuUnBiV1U5ZEdocGN5NWZjR0Z5YzJWVWFXMWxUM0pNWVdKbGJDaDBLU3h6UFUxaGRHZ3VZV0p6S0U1MWJXSmxjaWhoTG5ScGJXVXBMWFJvYVhNdVgzUnBiV1VwTDNSb2FYTXVYM1JwYldWVFkyRnNaWHg4TGpBd01TeHVQVzVsZHlCbEtIUm9hWE1zY3l4aEtTeGhMbTl1VTNSaGNuUTlablZ1WTNScGIyNG9LWHR1TG5SaGNtZGxkQzV3WVhWelpXUW9JVEFwTEc0dWRtRnljeTUwYVcxbElUMDliaTUwWVhKblpYUXVkR2x0WlNncEppWnpQVDA5Ymk1a2RYSmhkR2x2YmlncEppWnVMbVIxY21GMGFXOXVLRTFoZEdndVlXSnpLRzR1ZG1GeWN5NTBhVzFsTFc0dWRHRnlaMlYwTG5ScGJXVW9LU2t2Ymk1MFlYSm5aWFF1WDNScGJXVlRZMkZzWlNrc2FTNXZibE4wWVhKMEppWnVMbDlqWVd4c1ltRmpheWhjSW05dVUzUmhjblJjSWlsOUxHNTlMR2d1ZEhkbFpXNUdjbTl0Vkc4OVpuVnVZM1JwYjI0b2RDeGxMR2twZTJrOWFYeDhlMzBzZEQxMGFHbHpMbDl3WVhKelpWUnBiV1ZQY2t4aFltVnNLSFFwTEdrdWMzUmhjblJCZEQxN2IyNURiMjF3YkdWMFpUcDBhR2x6TG5ObFpXc3NiMjVEYjIxd2JHVjBaVkJoY21GdGN6cGJkRjBzWTJGc2JHSmhZMnRUWTI5d1pUcDBhR2x6ZlN4cExtbHRiV1ZrYVdGMFpWSmxibVJsY2oxcExtbHRiV1ZrYVdGMFpWSmxibVJsY2lFOVBTRXhPM1poY2lCelBYUm9hWE11ZEhkbFpXNVVieWhsTEdrcE8zSmxkSFZ5YmlCekxtUjFjbUYwYVc5dUtFMWhkR2d1WVdKektITXVkbUZ5Y3k1MGFXMWxMWFFwTDNSb2FYTXVYM1JwYldWVFkyRnNaWHg4TGpBd01TbDlMR2d1Y21WdVpHVnlQV1oxYm1OMGFXOXVLSFFzWlN4cEtYdDBhR2x6TGw5bll5WW1kR2hwY3k1ZlpXNWhZbXhsWkNnaE1Dd2hNU2s3ZG1GeUlITXNiaXhzTEdnc1h5eDFMR01zWmoxMGFHbHpMbDlrYVhKMGVUOTBhR2x6TG5SdmRHRnNSSFZ5WVhScGIyNG9LVHAwYUdsekxsOTBiM1JoYkVSMWNtRjBhVzl1TEhBOWRHaHBjeTVmWkhWeVlYUnBiMjRzYlQxMGFHbHpMbDkwYVcxbExHUTlkR2hwY3k1ZmRHOTBZV3hVYVcxbExHYzlkR2hwY3k1ZmMzUmhjblJVYVcxbExIWTlkR2hwY3k1ZmRHbHRaVk5qWVd4bExIazlkR2hwY3k1ZmNtRjNVSEpsZGxScGJXVXNWRDEwYUdsekxsOXdZWFZ6WldRc2VEMTBhR2x6TGw5amVXTnNaVHRwWmloMFBqMW1LWFJvYVhNdVgyeHZZMnRsWkh4OEtIUm9hWE11WDNSdmRHRnNWR2x0WlQxbUxIUm9hWE11WDJONVkyeGxQWFJvYVhNdVgzSmxjR1ZoZENrc2RHaHBjeTVmY21WMlpYSnpaV1I4ZkhSb2FYTXVYMmhoYzFCaGRYTmxaRU5vYVd4a0tDbDhmQ2h1UFNFd0xHZzlYQ0p2YmtOdmJYQnNaWFJsWENJc1h6MGhJWFJvYVhNdVgzUnBiV1ZzYVc1bExtRjFkRzlTWlcxdmRtVkRhR2xzWkhKbGJpd3dQVDA5ZEdocGN5NWZaSFZ5WVhScGIyNG1KaWd3UFQwOWRIeDhNRDU1Zkh4NVBUMDljaWttSm5raFBUMTBKaVowYUdsekxsOW1hWEp6ZENZbUtGODlJVEFzZVQ1eUppWW9hRDFjSW05dVVtVjJaWEp6WlVOdmJYQnNaWFJsWENJcEtTa3NkR2hwY3k1ZmNtRjNVSEpsZGxScGJXVTlkR2hwY3k1ZlpIVnlZWFJwYjI1OGZDRmxmSHgwZkh4MGFHbHpMbDl5WVhkUWNtVjJWR2x0WlQwOVBYUS9kRHB5TEhSb2FYTXVYM2x2ZVc4bUpqQWhQVDBvTVNaMGFHbHpMbDlqZVdOc1pTay9kR2hwY3k1ZmRHbHRaVDEwUFRBNktIUm9hWE11WDNScGJXVTljQ3gwUFhBck1XVXROQ2s3Wld4elpTQnBaaWd4WlMwM1BuUXBhV1lvZEdocGN5NWZiRzlqYTJWa2ZId29kR2hwY3k1ZmRHOTBZV3hVYVcxbFBYUm9hWE11WDJONVkyeGxQVEFwTEhSb2FYTXVYM1JwYldVOU1Dd29NQ0U5UFcxOGZEQTlQVDF3SmlaNUlUMDljaVltS0hrK01IeDhNRDUwSmlaNVBqMHdLU1ltSVhSb2FYTXVYMnh2WTJ0bFpDa21KaWhvUFZ3aWIyNVNaWFpsY25ObFEyOXRjR3hsZEdWY0lpeHVQWFJvYVhNdVgzSmxkbVZ5YzJWa0tTd3dQblFwZEdocGN5NWZZV04wYVhabFBTRXhMSFJvYVhNdVgzUnBiV1ZzYVc1bExtRjFkRzlTWlcxdmRtVkRhR2xzWkhKbGJpWW1kR2hwY3k1ZmNtVjJaWEp6WldRL0tGODliajBoTUN4b1BWd2liMjVTWlhabGNuTmxRMjl0Y0d4bGRHVmNJaWs2ZVQ0OU1DWW1kR2hwY3k1ZlptbHljM1FtSmloZlBTRXdLU3gwYUdsekxsOXlZWGRRY21WMlZHbHRaVDEwTzJWc2MyVjdhV1lvZEdocGN5NWZjbUYzVUhKbGRsUnBiV1U5Y0h4OElXVjhmSFI4ZkhSb2FYTXVYM0poZDFCeVpYWlVhVzFsUFQwOWREOTBPbklzTUQwOVBYUW1KbTRwWm05eUtITTlkR2hwY3k1ZlptbHljM1E3Y3lZbU1EMDlQWE11WDNOMFlYSjBWR2x0WlRzcGN5NWZaSFZ5WVhScGIyNThmQ2h1UFNFeEtTeHpQWE11WDI1bGVIUTdkRDB3TEhSb2FYTXVYMmx1YVhSMFpXUjhmQ2hmUFNFd0tYMWxiSE5sSUdsbUtEQTlQVDF3SmlZd1Bua21KaWhmUFNFd0tTeDBhR2x6TGw5MGFXMWxQWFJvYVhNdVgzSmhkMUJ5WlhaVWFXMWxQWFFzZEdocGN5NWZiRzlqYTJWa2ZId29kR2hwY3k1ZmRHOTBZV3hVYVcxbFBYUXNNQ0U5UFhSb2FYTXVYM0psY0dWaGRDWW1LSFU5Y0N0MGFHbHpMbDl5WlhCbFlYUkVaV3hoZVN4MGFHbHpMbDlqZVdOc1pUMTBhR2x6TGw5MGIzUmhiRlJwYldVdmRUNCtNQ3d3SVQwOWRHaHBjeTVmWTNsamJHVW1KblJvYVhNdVgyTjVZMnhsUFQwOWRHaHBjeTVmZEc5MFlXeFVhVzFsTDNVbUpuUm9hWE11WDJONVkyeGxMUzBzZEdocGN5NWZkR2x0WlQxMGFHbHpMbDkwYjNSaGJGUnBiV1V0ZEdocGN5NWZZM2xqYkdVcWRTeDBhR2x6TGw5NWIzbHZKaVl3SVQwOUtERW1kR2hwY3k1ZlkzbGpiR1VwSmlZb2RHaHBjeTVmZEdsdFpUMXdMWFJvYVhNdVgzUnBiV1VwTEhSb2FYTXVYM1JwYldVK2NEOG9kR2hwY3k1ZmRHbHRaVDF3TEhROWNDc3haUzAwS1Rvd1BuUm9hWE11WDNScGJXVS9kR2hwY3k1ZmRHbHRaVDEwUFRBNmREMTBhR2x6TGw5MGFXMWxLU2tzZEdocGN5NWZhR0Z6VUdGMWMyVW1KaUYwYUdsekxsOW1iM0pqYVc1blVHeGhlV2hsWVdRbUppRmxLWHRwWmloMFBYUm9hWE11WDNScGJXVXNkRDQ5YlNsbWIzSW9jejEwYUdsekxsOW1hWEp6ZER0ekppWjBQajF6TGw5emRHRnlkRlJwYldVbUppRmpPeWx6TGw5a2RYSmhkR2x2Ym54OFhDSnBjMUJoZFhObFhDSWhQVDF6TG1SaGRHRjhmSE11Y21GMGFXOThmREE5UFQxekxsOXpkR0Z5ZEZScGJXVW1KakE5UFQxMGFHbHpMbDl5WVhkUWNtVjJWR2x0Wlh4OEtHTTljeWtzY3oxekxsOXVaWGgwTzJWc2MyVWdabTl5S0hNOWRHaHBjeTVmYkdGemREdHpKaVp6TGw5emRHRnlkRlJwYldVK1BYUW1KaUZqT3lsekxsOWtkWEpoZEdsdmJueDhYQ0pwYzFCaGRYTmxYQ0k5UFQxekxtUmhkR0VtSm5NdVgzSmhkMUJ5WlhaVWFXMWxQakFtSmloalBYTXBMSE05Y3k1ZmNISmxkanRqSmlZb2RHaHBjeTVmZEdsdFpUMTBQV011WDNOMFlYSjBWR2x0WlN4MGFHbHpMbDkwYjNSaGJGUnBiV1U5ZEN0MGFHbHpMbDlqZVdOc1pTb29kR2hwY3k1ZmRHOTBZV3hFZFhKaGRHbHZiaXQwYUdsekxsOXlaWEJsWVhSRVpXeGhlU2twZldsbUtIUm9hWE11WDJONVkyeGxJVDA5ZUNZbUlYUm9hWE11WDJ4dlkydGxaQ2w3ZG1GeUlIYzlkR2hwY3k1ZmVXOTVieVltTUNFOVBTZ3hKbmdwTEdJOWR6MDlQU2gwYUdsekxsOTViM2x2SmlZd0lUMDlLREVtZEdocGN5NWZZM2xqYkdVcEtTeFFQWFJvYVhNdVgzUnZkR0ZzVkdsdFpTeHJQWFJvYVhNdVgyTjVZMnhsTEZNOWRHaHBjeTVmY21GM1VISmxkbFJwYldVc1VqMTBhR2x6TGw5MGFXMWxPMmxtS0hSb2FYTXVYM1J2ZEdGc1ZHbHRaVDE0S25Bc2VENTBhR2x6TGw5amVXTnNaVDkzUFNGM09uUm9hWE11WDNSdmRHRnNWR2x0WlNzOWNDeDBhR2x6TGw5MGFXMWxQVzBzZEdocGN5NWZjbUYzVUhKbGRsUnBiV1U5TUQwOVBYQS9lUzB4WlMwME9ua3NkR2hwY3k1ZlkzbGpiR1U5ZUN4MGFHbHpMbDlzYjJOclpXUTlJVEFzYlQxM1B6QTZjQ3gwYUdsekxuSmxibVJsY2lodExHVXNNRDA5UFhBcExHVjhmSFJvYVhNdVgyZGpmSHgwYUdsekxuWmhjbk11YjI1U1pYQmxZWFFtSm5Sb2FYTXVYMk5oYkd4aVlXTnJLRndpYjI1U1pYQmxZWFJjSWlrc1lpWW1LRzA5ZHo5d0t6RmxMVFE2TFRGbExUUXNkR2hwY3k1eVpXNWtaWElvYlN3aE1Dd2hNU2twTEhSb2FYTXVYMnh2WTJ0bFpEMGhNU3gwYUdsekxsOXdZWFZ6WldRbUppRlVLWEpsZEhWeWJqdDBhR2x6TGw5MGFXMWxQVklzZEdocGN5NWZkRzkwWVd4VWFXMWxQVkFzZEdocGN5NWZZM2xqYkdVOWF5eDBhR2x6TGw5eVlYZFFjbVYyVkdsdFpUMVRmV2xtS0NFb2RHaHBjeTVmZEdsdFpTRTlQVzBtSm5Sb2FYTXVYMlpwY25OMGZIeHBmSHhmZkh4aktTbHlaWFIxY200Z1pDRTlQWFJvYVhNdVgzUnZkR0ZzVkdsdFpTWW1kR2hwY3k1ZmIyNVZjR1JoZEdVbUppaGxmSHgwYUdsekxsOWpZV3hzWW1GamF5aGNJbTl1VlhCa1lYUmxYQ0lwS1N4MmIybGtJREE3YVdZb2RHaHBjeTVmYVc1cGRIUmxaSHg4S0hSb2FYTXVYMmx1YVhSMFpXUTlJVEFwTEhSb2FYTXVYMkZqZEdsMlpYeDhJWFJvYVhNdVgzQmhkWE5sWkNZbWRHaHBjeTVmZEc5MFlXeFVhVzFsSVQwOVpDWW1kRDR3SmlZb2RHaHBjeTVmWVdOMGFYWmxQU0V3S1N3d1BUMDlaQ1ltZEdocGN5NTJZWEp6TG05dVUzUmhjblFtSmpBaFBUMTBhR2x6TGw5MGIzUmhiRlJwYldVbUppaGxmSHgwYUdsekxsOWpZV3hzWW1GamF5aGNJbTl1VTNSaGNuUmNJaWtwTEhSb2FYTXVYM1JwYldVK1BXMHBabTl5S0hNOWRHaHBjeTVmWm1seWMzUTdjeVltS0d3OWN5NWZibVY0ZEN3aGRHaHBjeTVmY0dGMWMyVmtmSHhVS1RzcEtITXVYMkZqZEdsMlpYeDhjeTVmYzNSaGNuUlVhVzFsUEQxMGFHbHpMbDkwYVcxbEppWWhjeTVmY0dGMWMyVmtKaVloY3k1ZloyTXBKaVlvWXowOVBYTW1KblJvYVhNdWNHRjFjMlVvS1N4ekxsOXlaWFpsY25ObFpEOXpMbkpsYm1SbGNpZ29jeTVmWkdseWRIay9jeTUwYjNSaGJFUjFjbUYwYVc5dUtDazZjeTVmZEc5MFlXeEVkWEpoZEdsdmJpa3RLSFF0Y3k1ZmMzUmhjblJVYVcxbEtTcHpMbDkwYVcxbFUyTmhiR1VzWlN4cEtUcHpMbkpsYm1SbGNpZ29kQzF6TGw5emRHRnlkRlJwYldVcEtuTXVYM1JwYldWVFkyRnNaU3hsTEdrcEtTeHpQV3c3Wld4elpTQm1iM0lvY3oxMGFHbHpMbDlzWVhOME8zTW1KaWhzUFhNdVgzQnlaWFlzSVhSb2FYTXVYM0JoZFhObFpIeDhWQ2s3S1h0cFppaHpMbDloWTNScGRtVjhmRzArUFhNdVgzTjBZWEowVkdsdFpTWW1JWE11WDNCaGRYTmxaQ1ltSVhNdVgyZGpLWHRwWmloalBUMDljeWw3Wm05eUtHTTljeTVmY0hKbGRqdGpKaVpqTG1WdVpGUnBiV1VvS1Q1MGFHbHpMbDkwYVcxbE95bGpMbkpsYm1SbGNpaGpMbDl5WlhabGNuTmxaRDlqTG5SdmRHRnNSSFZ5WVhScGIyNG9LUzBvZEMxakxsOXpkR0Z5ZEZScGJXVXBLbU11WDNScGJXVlRZMkZzWlRvb2RDMWpMbDl6ZEdGeWRGUnBiV1VwS21NdVgzUnBiV1ZUWTJGc1pTeGxMR2twTEdNOVl5NWZjSEpsZGp0alBXNTFiR3dzZEdocGN5NXdZWFZ6WlNncGZYTXVYM0psZG1WeWMyVmtQM011Y21WdVpHVnlLQ2h6TGw5a2FYSjBlVDl6TG5SdmRHRnNSSFZ5WVhScGIyNG9LVHB6TGw5MGIzUmhiRVIxY21GMGFXOXVLUzBvZEMxekxsOXpkR0Z5ZEZScGJXVXBLbk11WDNScGJXVlRZMkZzWlN4bExHa3BPbk11Y21WdVpHVnlLQ2gwTFhNdVgzTjBZWEowVkdsdFpTa3FjeTVmZEdsdFpWTmpZV3hsTEdVc2FTbDljejFzZlhSb2FYTXVYMjl1VlhCa1lYUmxKaVlvWlh4OEtHRXViR1Z1WjNSb0ppWnZLQ2tzZEdocGN5NWZZMkZzYkdKaFkyc29YQ0p2YmxWd1pHRjBaVndpS1NrcExHZ21KaWgwYUdsekxsOXNiMk5yWldSOGZIUm9hWE11WDJkamZId29aejA5UFhSb2FYTXVYM04wWVhKMFZHbHRaWHg4ZGlFOVBYUm9hWE11WDNScGJXVlRZMkZzWlNrbUppZ3dQVDA5ZEdocGN5NWZkR2x0Wlh4OFpqNDlkR2hwY3k1MGIzUmhiRVIxY21GMGFXOXVLQ2twSmlZb2JpWW1LR0V1YkdWdVozUm9KaVp2S0Nrc2RHaHBjeTVmZEdsdFpXeHBibVV1WVhWMGIxSmxiVzkyWlVOb2FXeGtjbVZ1SmlaMGFHbHpMbDlsYm1GaWJHVmtLQ0V4TENFeEtTeDBhR2x6TGw5aFkzUnBkbVU5SVRFcExDRmxKaVowYUdsekxuWmhjbk5iYUYwbUpuUm9hWE11WDJOaGJHeGlZV05yS0dncEtTbDlMR2d1WjJWMFFXTjBhWFpsUFdaMWJtTjBhVzl1S0hRc1pTeHBLWHR1ZFd4c1BUMTBKaVlvZEQwaE1Da3NiblZzYkQwOVpTWW1LR1U5SVRBcExHNTFiR3c5UFdrbUppaHBQU0V4S1R0MllYSWdjeXh5TEc0OVcxMHNZVDEwYUdsekxtZGxkRU5vYVd4a2NtVnVLSFFzWlN4cEtTeHZQVEFzYkQxaExteGxibWQwYUR0bWIzSW9jejB3TzJ3K2N6dHpLeXNwY2oxaFczTmRMSEl1YVhOQlkzUnBkbVVvS1NZbUtHNWJieXNyWFQxeUtUdHlaWFIxY200Z2JuMHNhQzVuWlhSTVlXSmxiRUZtZEdWeVBXWjFibU4wYVc5dUtIUXBlM1I4ZkRBaFBUMTBKaVlvZEQxMGFHbHpMbDkwYVcxbEtUdDJZWElnWlN4cFBYUm9hWE11WjJWMFRHRmlaV3h6UVhKeVlYa29LU3h6UFdrdWJHVnVaM1JvTzJadmNpaGxQVEE3Y3o1bE8yVXJLeWxwWmlocFcyVmRMblJwYldVK2RDbHlaWFIxY200Z2FWdGxYUzV1WVcxbE8zSmxkSFZ5YmlCdWRXeHNmU3hvTG1kbGRFeGhZbVZzUW1WbWIzSmxQV1oxYm1OMGFXOXVLSFFwZTI1MWJHdzlQWFFtSmloMFBYUm9hWE11WDNScGJXVXBPMlp2Y2loMllYSWdaVDEwYUdsekxtZGxkRXhoWW1Wc2MwRnljbUY1S0Nrc2FUMWxMbXhsYm1kMGFEc3RMV2srTFRFN0tXbG1LSFErWlZ0cFhTNTBhVzFsS1hKbGRIVnliaUJsVzJsZExtNWhiV1U3Y21WMGRYSnVJRzUxYkd4OUxHZ3VaMlYwVEdGaVpXeHpRWEp5WVhrOVpuVnVZM1JwYjI0b0tYdDJZWElnZEN4bFBWdGRMR2s5TUR0bWIzSW9kQ0JwYmlCMGFHbHpMbDlzWVdKbGJITXBaVnRwS3l0ZFBYdDBhVzFsT25Sb2FYTXVYMnhoWW1Wc2MxdDBYU3h1WVcxbE9uUjlPM0psZEhWeWJpQmxMbk52Y25Rb1puVnVZM1JwYjI0b2RDeGxLWHR5WlhSMWNtNGdkQzUwYVcxbExXVXVkR2x0WlgwcExHVjlMR2d1Y0hKdlozSmxjM005Wm5WdVkzUnBiMjRvZEN4bEtYdHlaWFIxY200Z1lYSm5kVzFsYm5SekxteGxibWQwYUQ5MGFHbHpMblJ2ZEdGc1ZHbHRaU2gwYUdsekxtUjFjbUYwYVc5dUtDa3FLSFJvYVhNdVgzbHZlVzhtSmpBaFBUMG9NU1owYUdsekxsOWplV05zWlNrL01TMTBPblFwSzNSb2FYTXVYMk41WTJ4bEtpaDBhR2x6TGw5a2RYSmhkR2x2Yml0MGFHbHpMbDl5WlhCbFlYUkVaV3hoZVNrc1pTazZkR2hwY3k1ZmRHbHRaUzkwYUdsekxtUjFjbUYwYVc5dUtDbDlMR2d1ZEc5MFlXeFFjbTluY21WemN6MW1kVzVqZEdsdmJpaDBMR1VwZTNKbGRIVnliaUJoY21kMWJXVnVkSE11YkdWdVozUm9QM1JvYVhNdWRHOTBZV3hVYVcxbEtIUm9hWE11ZEc5MFlXeEVkWEpoZEdsdmJpZ3BLblFzWlNrNmRHaHBjeTVmZEc5MFlXeFVhVzFsTDNSb2FYTXVkRzkwWVd4RWRYSmhkR2x2YmlncGZTeG9MblJ2ZEdGc1JIVnlZWFJwYjI0OVpuVnVZM1JwYjI0b1pTbDdjbVYwZFhKdUlHRnlaM1Z0Wlc1MGN5NXNaVzVuZEdnL0xURTlQVDEwYUdsekxsOXlaWEJsWVhRL2RHaHBjenAwYUdsekxtUjFjbUYwYVc5dUtDaGxMWFJvYVhNdVgzSmxjR1ZoZENwMGFHbHpMbDl5WlhCbFlYUkVaV3hoZVNrdktIUm9hWE11WDNKbGNHVmhkQ3N4S1NrNktIUm9hWE11WDJScGNuUjVKaVlvZEM1d2NtOTBiM1I1Y0dVdWRHOTBZV3hFZFhKaGRHbHZiaTVqWVd4c0tIUm9hWE1wTEhSb2FYTXVYM1J2ZEdGc1JIVnlZWFJwYjI0OUxURTlQVDEwYUdsekxsOXlaWEJsWVhRL09UazVPVGs1T1RrNU9UazVPblJvYVhNdVgyUjFjbUYwYVc5dUtpaDBhR2x6TGw5eVpYQmxZWFFyTVNrcmRHaHBjeTVmY21Wd1pXRjBSR1ZzWVhrcWRHaHBjeTVmY21Wd1pXRjBLU3gwYUdsekxsOTBiM1JoYkVSMWNtRjBhVzl1S1gwc2FDNTBhVzFsUFdaMWJtTjBhVzl1S0hRc1pTbDdjbVYwZFhKdUlHRnlaM1Z0Wlc1MGN5NXNaVzVuZEdnL0tIUm9hWE11WDJScGNuUjVKaVowYUdsekxuUnZkR0ZzUkhWeVlYUnBiMjRvS1N4MFBuUm9hWE11WDJSMWNtRjBhVzl1SmlZb2REMTBhR2x6TGw5a2RYSmhkR2x2Ymlrc2RHaHBjeTVmZVc5NWJ5WW1NQ0U5UFNneEpuUm9hWE11WDJONVkyeGxLVDkwUFhSb2FYTXVYMlIxY21GMGFXOXVMWFFyZEdocGN5NWZZM2xqYkdVcUtIUm9hWE11WDJSMWNtRjBhVzl1SzNSb2FYTXVYM0psY0dWaGRFUmxiR0Y1S1Rvd0lUMDlkR2hwY3k1ZmNtVndaV0YwSmlZb2RDczlkR2hwY3k1ZlkzbGpiR1VxS0hSb2FYTXVYMlIxY21GMGFXOXVLM1JvYVhNdVgzSmxjR1ZoZEVSbGJHRjVLU2tzZEdocGN5NTBiM1JoYkZScGJXVW9kQ3hsS1NrNmRHaHBjeTVmZEdsdFpYMHNhQzV5WlhCbFlYUTlablZ1WTNScGIyNG9kQ2w3Y21WMGRYSnVJR0Z5WjNWdFpXNTBjeTVzWlc1bmRHZy9LSFJvYVhNdVgzSmxjR1ZoZEQxMExIUm9hWE11WDNWdVkyRmphR1VvSVRBcEtUcDBhR2x6TGw5eVpYQmxZWFI5TEdndWNtVndaV0YwUkdWc1lYazlablZ1WTNScGIyNG9kQ2w3Y21WMGRYSnVJR0Z5WjNWdFpXNTBjeTVzWlc1bmRHZy9LSFJvYVhNdVgzSmxjR1ZoZEVSbGJHRjVQWFFzZEdocGN5NWZkVzVqWVdOb1pTZ2hNQ2twT25Sb2FYTXVYM0psY0dWaGRFUmxiR0Y1ZlN4b0xubHZlVzg5Wm5WdVkzUnBiMjRvZENsN2NtVjBkWEp1SUdGeVozVnRaVzUwY3k1c1pXNW5kR2cvS0hSb2FYTXVYM2x2ZVc4OWRDeDBhR2x6S1RwMGFHbHpMbDk1YjNsdmZTeG9MbU4xY25KbGJuUk1ZV0psYkQxbWRXNWpkR2x2YmloMEtYdHlaWFIxY200Z1lYSm5kVzFsYm5SekxteGxibWQwYUQ5MGFHbHpMbk5sWldzb2RDd2hNQ2s2ZEdocGN5NW5aWFJNWVdKbGJFSmxabTl5WlNoMGFHbHpMbDkwYVcxbEt6RmxMVGdwZlN4emZTd2hNQ2tzWm5WdVkzUnBiMjRvS1h0MllYSWdkRDB4T0RBdlRXRjBhQzVRU1N4bFBWdGRMR2s5VzEwc2N6MWJYU3h5UFh0OUxHNDlYMmR6VTJOdmNHVXVYMmR6UkdWbWFXNWxMbWRzYjJKaGJITXNZVDFtZFc1amRHbHZiaWgwTEdVc2FTeHpLWHQwYUdsekxtRTlkQ3gwYUdsekxtSTlaU3gwYUdsekxtTTlhU3gwYUdsekxtUTljeXgwYUdsekxtUmhQWE10ZEN4MGFHbHpMbU5oUFdrdGRDeDBhR2x6TG1KaFBXVXRkSDBzYnoxY0lpeDRMSGtzZWl4c1pXWjBMSFJ2Y0N4eWFXZG9kQ3hpYjNSMGIyMHNiV0Z5WjJsdVZHOXdMRzFoY21kcGJreGxablFzYldGeVoybHVVbWxuYUhRc2JXRnlaMmx1UW05MGRHOXRMSEJoWkdScGJtZE1aV1owTEhCaFpHUnBibWRVYjNBc2NHRmtaR2x1WjFKcFoyaDBMSEJoWkdScGJtZENiM1IwYjIwc1ltRmphMmR5YjNWdVpGQnZjMmwwYVc5dUxHSmhZMnRuY205MWJtUlFiM05wZEdsdmJsOTVMRndpTEd3OVpuVnVZM1JwYjI0b2RDeGxMR2tzY3lsN2RtRnlJSEk5ZTJFNmRIMHNiajE3ZlN4aFBYdDlMRzg5ZTJNNmMzMHNiRDBvZEN0bEtTOHlMR2c5S0dVcmFTa3ZNaXhmUFNocEszTXBMeklzZFQwb2JDdG9LUzh5TEdNOUtHZ3JYeWt2TWl4bVBTaGpMWFVwTHpnN2NtVjBkWEp1SUhJdVlqMXNLeWgwTFd3cEx6UXNiaTVpUFhVclppeHlMbU05Ymk1aFBTaHlMbUlyYmk1aUtTOHlMRzR1WXoxaExtRTlLSFVyWXlrdk1peGhMbUk5WXkxbUxHOHVZajFmS3loekxWOHBMelFzWVM1alBXOHVZVDBvWVM1aUsyOHVZaWt2TWl4YmNpeHVMR0VzYjExOUxHZzlablZ1WTNScGIyNG9kQ3h5TEc0c1lTeHZLWHQyWVhJZ2FDeGZMSFVzWXl4bUxIQXNiU3hrTEdjc2RpeDVMRlFzZUN4M1BYUXViR1Z1WjNSb0xURXNZajB3TEZBOWRGc3dYUzVoTzJadmNpaG9QVEE3ZHo1b08yZ3JLeWxtUFhSYllsMHNYejFtTG1Fc2RUMW1MbVFzWXoxMFcySXJNVjB1WkN4dlB5aDVQV1ZiYUYwc1ZEMXBXMmhkTEhnOUxqSTFLaWhVSzNrcEtuSXZLR0UvTGpVNmMxdG9YWHg4TGpVcExIQTlkUzBvZFMxZktTb29ZVDh1TlNweU9qQWhQVDE1UDNndmVUb3dLU3h0UFhVcktHTXRkU2txS0dFL0xqVXFjam93SVQwOVZEOTRMMVE2TUNrc1pEMTFMU2h3S3lnb2JTMXdLU29vTXlwNUx5aDVLMVFwS3k0MUtTODBmSHd3S1NrcE9paHdQWFV0TGpVcUtIVXRYeWtxY2l4dFBYVXJMalVxS0dNdGRTa3FjaXhrUFhVdEtIQXJiU2t2TWlrc2NDczlaQ3h0S3oxa0xHWXVZejFuUFhBc1ppNWlQVEFoUFQxb1AxQTZVRDFtTG1FckxqWXFLR1l1WXkxbUxtRXBMR1l1WkdFOWRTMWZMR1l1WTJFOVp5MWZMR1l1WW1FOVVDMWZMRzQvS0hZOWJDaGZMRkFzWnl4MUtTeDBMbk53YkdsalpTaGlMREVzZGxzd1hTeDJXekZkTEhaYk1sMHNkbHN6WFNrc1lpczlOQ2s2WWlzckxGQTliVHRtUFhSYllsMHNaaTVpUFZBc1ppNWpQVkFyTGpRcUtHWXVaQzFRS1N4bUxtUmhQV1l1WkMxbUxtRXNaaTVqWVQxbUxtTXRaaTVoTEdZdVltRTlVQzFtTG1Fc2JpWW1LSFk5YkNobUxtRXNVQ3htTG1Nc1ppNWtLU3gwTG5Od2JHbGpaU2hpTERFc2Rsc3dYU3gyV3pGZExIWmJNbDBzZGxzelhTa3BmU3hmUFdaMWJtTjBhVzl1S0hRc2N5eHlMRzRwZTNaaGNpQnZMR3dzYUN4ZkxIVXNZeXhtUFZ0ZE8ybG1LRzRwWm05eUtIUTlXMjVkTG1OdmJtTmhkQ2gwS1N4c1BYUXViR1Z1WjNSb095MHRiRDR0TVRzcFhDSnpkSEpwYm1kY0lqMDlkSGx3Wlc5bUtHTTlkRnRzWFZ0elhTa21KbHdpUFZ3aVBUMDlZeTVqYUdGeVFYUW9NU2ttSmloMFcyeGRXM05kUFc1YmMxMHJUblZ0WW1WeUtHTXVZMmhoY2tGMEtEQXBLMk11YzNWaWMzUnlLRElwS1NrN2FXWW9iejEwTG14bGJtZDBhQzB5TERBK2J5bHlaWFIxY200Z1psc3dYVDF1WlhjZ1lTaDBXekJkVzNOZExEQXNNQ3gwV3kweFBtOC9NRG94WFZ0elhTa3NaanRtYjNJb2JEMHdPMjgrYkR0c0t5c3BhRDEwVzJ4ZFczTmRMRjg5ZEZ0c0t6RmRXM05kTEdaYmJGMDlibVYzSUdFb2FDd3dMREFzWHlrc2NpWW1LSFU5ZEZ0c0t6SmRXM05kTEdWYmJGMDlLR1ZiYkYxOGZEQXBLeWhmTFdncEtpaGZMV2dwTEdsYmJGMDlLR2xiYkYxOGZEQXBLeWgxTFY4cEtpaDFMVjhwS1R0eVpYUjFjbTRnWmx0c1hUMXVaWGNnWVNoMFcyeGRXM05kTERBc01DeDBXMndyTVYxYmMxMHBMR1o5TEhVOVpuVnVZM1JwYjI0b2RDeHVMR0VzYkN4MUxHTXBlM1poY2lCbUxIQXNiU3hrTEdjc2RpeDVMRlFzZUQxN2ZTeDNQVnRkTEdJOVkzeDhkRnN3WFR0MVBWd2ljM1J5YVc1blhDSTlQWFI1Y0dWdlppQjFQMXdpTEZ3aUszVXJYQ0lzWENJNmJ5eHVkV3hzUFQxdUppWW9iajB4S1R0bWIzSW9jQ0JwYmlCMFd6QmRLWGN1Y0hWemFDaHdLVHRwWmloMExteGxibWQwYUQ0eEtYdG1iM0lvVkQxMFczUXViR1Z1WjNSb0xURmRMSGs5SVRBc1pqMTNMbXhsYm1kMGFEc3RMV1krTFRFN0tXbG1LSEE5ZDF0bVhTeE5ZWFJvTG1GaWN5aGlXM0JkTFZSYmNGMHBQaTR3TlNsN2VUMGhNVHRpY21WaGEzMTVKaVlvZEQxMExtTnZibU5oZENncExHTW1KblF1ZFc1emFHbG1kQ2hqS1N4MExuQjFjMmdvZEZzeFhTa3NZejEwVzNRdWJHVnVaM1JvTFROZEtYMW1iM0lvWlM1c1pXNW5kR2c5YVM1c1pXNW5kR2c5Y3k1c1pXNW5kR2c5TUN4bVBYY3ViR1Z1WjNSb095MHRaajR0TVRzcGNEMTNXMlpkTEhKYmNGMDlMVEVoUFQxMUxtbHVaR1Y0VDJZb1hDSXNYQ0lyY0N0Y0lpeGNJaWtzZUZ0d1hUMWZLSFFzY0N4eVczQmRMR01wTzJadmNpaG1QV1V1YkdWdVozUm9PeTB0Wmo0dE1Uc3BaVnRtWFQxTllYUm9Mbk54Y25Rb1pWdG1YU2tzYVZ0bVhUMU5ZWFJvTG5OeGNuUW9hVnRtWFNrN2FXWW9JV3dwZTJadmNpaG1QWGN1YkdWdVozUm9PeTB0Wmo0dE1Uc3BhV1lvY2x0d1hTbG1iM0lvYlQxNFczZGJabDFkTEhZOWJTNXNaVzVuZEdndE1TeGtQVEE3ZGo1a08yUXJLeWxuUFcxYlpDc3hYUzVrWVM5cFcyUmRLMjFiWkYwdVpHRXZaVnRrWFN4elcyUmRQU2h6VzJSZGZId3dLU3RuS21jN1ptOXlLR1k5Y3k1c1pXNW5kR2c3TFMxbVBpMHhPeWx6VzJaZFBVMWhkR2d1YzNGeWRDaHpXMlpkS1gxbWIzSW9aajEzTG14bGJtZDBhQ3hrUFdFL05Eb3hPeTB0Wmo0dE1Uc3BjRDEzVzJaZExHMDllRnR3WFN4b0tHMHNiaXhoTEd3c2NsdHdYU2tzZVNZbUtHMHVjM0JzYVdObEtEQXNaQ2tzYlM1emNHeHBZMlVvYlM1c1pXNW5kR2d0WkN4a0tTazdjbVYwZFhKdUlIaDlMR005Wm5WdVkzUnBiMjRvZEN4bExHa3BlMlU5Wlh4OFhDSnpiMlowWENJN2RtRnlJSE1zY2l4dUxHOHNiQ3hvTEY4c2RTeGpMR1lzY0N4dFBYdDlMR1E5WENKamRXSnBZMXdpUFQwOVpUOHpPaklzWnoxY0luTnZablJjSWowOVBXVXNkajFiWFR0cFppaG5KaVpwSmlZb2REMWJhVjB1WTI5dVkyRjBLSFFwS1N4dWRXeHNQVDEwZkh4a0t6RStkQzVzWlc1bmRHZ3BkR2h5YjNkY0ltbHVkbUZzYVdRZ1FtVjZhV1Z5SUdSaGRHRmNJanRtYjNJb1l5QnBiaUIwV3pCZEtYWXVjSFZ6YUNoaktUdG1iM0lvYUQxMkxteGxibWQwYURzdExXZytMVEU3S1h0bWIzSW9ZejEyVzJoZExHMWJZMTA5YkQxYlhTeG1QVEFzZFQxMExteGxibWQwYUN4ZlBUQTdkVDVmTzE4ckt5bHpQVzUxYkd3OVBXay9kRnRmWFZ0alhUcGNJbk4wY21sdVoxd2lQVDEwZVhCbGIyWW9jRDEwVzE5ZFcyTmRLU1ltWENJOVhDSTlQVDF3TG1Ob1lYSkJkQ2d4S1Q5cFcyTmRLMDUxYldKbGNpaHdMbU5vWVhKQmRDZ3dLU3R3TG5OMVluTjBjaWd5S1NrNlRuVnRZbVZ5S0hBcExHY21KbDgrTVNZbWRTMHhQbDhtSmloc1cyWXJLMTA5S0hNcmJGdG1MVEpkS1M4eUtTeHNXMllySzEwOWN6dG1iM0lvZFQxbUxXUXJNU3htUFRBc1h6MHdPM1UrWHp0Zkt6MWtLWE05YkZ0ZlhTeHlQV3hiWHlzeFhTeHVQV3hiWHlzeVhTeHZQVEk5UFQxa1B6QTZiRnRmS3pOZExHeGJaaXNyWFQxd1BUTTlQVDFrUDI1bGR5QmhLSE1zY2l4dUxHOHBPbTVsZHlCaEtITXNLRElxY2l0ektTOHpMQ2d5S25JcmJpa3ZNeXh1S1R0c0xteGxibWQwYUQxbWZYSmxkSFZ5YmlCdGZTeG1QV1oxYm1OMGFXOXVLSFFzWlN4cEtYdG1iM0lvZG1GeUlITXNjaXh1TEdFc2J5eHNMR2dzWHl4MUxHTXNaaXh3UFRFdmFTeHRQWFF1YkdWdVozUm9PeTB0YlQ0dE1Uc3BabTl5S0dNOWRGdHRYU3h1UFdNdVlTeGhQV011WkMxdUxHODlZeTVqTFc0c2JEMWpMbUl0Yml4elBYSTlNQ3hmUFRFN2FUNDlYenRmS3lzcGFEMXdLbDhzZFQweExXZ3NjejF5TFNoeVBTaG9LbWdxWVNzektuVXFLR2dxYnl0MUttd3BLU3BvS1N4bVBXMHFhU3RmTFRFc1pWdG1YVDBvWlZ0bVhYeDhNQ2tyY3lwemZTeHdQV1oxYm1OMGFXOXVLSFFzWlNsN1pUMWxQajR3Zkh3Mk8zWmhjaUJwTEhNc2NpeHVMR0U5VzEwc2J6MWJYU3hzUFRBc2FEMHdMRjg5WlMweExIVTlXMTBzWXoxYlhUdG1iM0lvYVNCcGJpQjBLV1lvZEZ0cFhTeGhMR1VwTzJadmNpaHlQV0V1YkdWdVozUm9MSE05TUR0eVBuTTdjeXNyS1d3clBVMWhkR2d1YzNGeWRDaGhXM05kS1N4dVBYTWxaU3hqVzI1ZFBXd3NiajA5UFY4bUppaG9LejFzTEc0OWN5OWxQajR3TEhWYmJsMDlZeXh2VzI1ZFBXZ3NiRDB3TEdNOVcxMHBPM0psZEhWeWJudHNaVzVuZEdnNmFDeHNaVzVuZEdoek9tOHNjMlZuYldWdWRITTZkWDE5TEcwOVgyZHpVMk52Y0dVdVgyZHpSR1ZtYVc1bExuQnNkV2RwYmloN2NISnZjRTVoYldVNlhDSmlaWHBwWlhKY0lpeHdjbWx2Y21sMGVUb3RNU3gyWlhKemFXOXVPbHdpTVM0ekxqUmNJaXhCVUVrNk1peG5iRzlpWVd3NklUQXNhVzVwZERwbWRXNWpkR2x2YmloMExHVXNhU2w3ZEdocGN5NWZkR0Z5WjJWMFBYUXNaU0JwYm5OMFlXNWpaVzltSUVGeWNtRjVKaVlvWlQxN2RtRnNkV1Z6T21WOUtTeDBhR2x6TGw5bWRXNWpQWHQ5TEhSb2FYTXVYM0p2ZFc1a1BYdDlMSFJvYVhNdVgzQnliM0J6UFZ0ZExIUm9hWE11WDNScGJXVlNaWE05Ym5Wc2JEMDlaUzUwYVcxbFVtVnpiMngxZEdsdmJqODJPbkJoY25ObFNXNTBLR1V1ZEdsdFpWSmxjMjlzZFhScGIyNHNNVEFwTzNaaGNpQnpMSElzYml4aExHOHNiRDFsTG5aaGJIVmxjM3g4VzEwc2FEMTdmU3hmUFd4Yk1GMHNaajFsTG1GMWRHOVNiM1JoZEdWOGZHa3VkbUZ5Y3k1dmNtbGxiblJVYjBKbGVtbGxjanQwYUdsekxsOWhkWFJ2VW05MFlYUmxQV1kvWmlCcGJuTjBZVzVqWlc5bUlFRnljbUY1UDJZNlcxdGNJbmhjSWl4Y0lubGNJaXhjSW5KdmRHRjBhVzl1WENJc1pqMDlQU0V3UHpBNlRuVnRZbVZ5S0dZcGZId3dYVjA2Ym5Wc2JEdGNibVp2Y2loeklHbHVJRjhwZEdocGN5NWZjSEp2Y0hNdWNIVnphQ2h6S1R0bWIzSW9iajEwYUdsekxsOXdjbTl3Y3k1c1pXNW5kR2c3TFMxdVBpMHhPeWx6UFhSb2FYTXVYM0J5YjNCelcyNWRMSFJvYVhNdVgyOTJaWEozY21sMFpWQnliM0J6TG5CMWMyZ29jeWtzY2oxMGFHbHpMbDltZFc1alczTmRQVndpWm5WdVkzUnBiMjVjSWowOWRIbHdaVzltSUhSYmMxMHNhRnR6WFQxeVAzUmJjeTVwYm1SbGVFOW1LRndpYzJWMFhDSXBmSHhjSW1aMWJtTjBhVzl1WENJaFBYUjVjR1Z2WmlCMFcxd2laMlYwWENJcmN5NXpkV0p6ZEhJb015bGRQM002WENKblpYUmNJaXR6TG5OMVluTjBjaWd6S1Ywb0tUcHdZWEp6WlVac2IyRjBLSFJiYzEwcExHOThmR2hiYzEwaFBUMXNXekJkVzNOZEppWW9iejFvS1R0cFppaDBhR2x6TGw5aVpYcHBaWEp6UFZ3aVkzVmlhV05jSWlFOVBXVXVkSGx3WlNZbVhDSnhkV0ZrY21GMGFXTmNJaUU5UFdVdWRIbHdaU1ltWENKemIyWjBYQ0loUFQxbExuUjVjR1UvZFNoc0xHbHpUbUZPS0dVdVkzVnlkbWx1WlhOektUOHhPbVV1WTNWeWRtbHVaWE56TENFeExGd2lkR2h5ZFVKaGMybGpYQ0k5UFQxbExuUjVjR1VzWlM1amIzSnlaV3hoZEdVc2J5azZZeWhzTEdVdWRIbHdaU3hvS1N4MGFHbHpMbDl6WldkRGIzVnVkRDEwYUdsekxsOWlaWHBwWlhKelczTmRMbXhsYm1kMGFDeDBhR2x6TGw5MGFXMWxVbVZ6S1h0MllYSWdiVDF3S0hSb2FYTXVYMkpsZW1sbGNuTXNkR2hwY3k1ZmRHbHRaVkpsY3lrN2RHaHBjeTVmYkdWdVozUm9QVzB1YkdWdVozUm9MSFJvYVhNdVgyeGxibWQwYUhNOWJTNXNaVzVuZEdoekxIUm9hWE11WDNObFoyMWxiblJ6UFcwdWMyVm5iV1Z1ZEhNc2RHaHBjeTVmYkRFOWRHaHBjeTVmYkdrOWRHaHBjeTVmY3pFOWRHaHBjeTVmYzJrOU1DeDBhR2x6TGw5c01qMTBhR2x6TGw5c1pXNW5kR2h6V3pCZExIUm9hWE11WDJOMWNsTmxaejEwYUdsekxsOXpaV2R0Wlc1MGMxc3dYU3gwYUdsekxsOXpNajEwYUdsekxsOWpkWEpUWldkYk1GMHNkR2hwY3k1ZmNISmxZejB4TDNSb2FYTXVYMk4xY2xObFp5NXNaVzVuZEdoOWFXWW9aajEwYUdsekxsOWhkWFJ2VW05MFlYUmxLV1p2Y2loMGFHbHpMbDlwYm1sMGFXRnNVbTkwWVhScGIyNXpQVnRkTEdaYk1GMXBibk4wWVc1alpXOW1JRUZ5Y21GNWZId29kR2hwY3k1ZllYVjBiMUp2ZEdGMFpUMW1QVnRtWFNrc2JqMW1MbXhsYm1kMGFEc3RMVzQrTFRFN0tYdG1iM0lvWVQwd096TStZVHRoS3lzcGN6MW1XMjVkVzJGZExIUm9hWE11WDJaMWJtTmJjMTA5WENKbWRXNWpkR2x2Ymx3aVBUMTBlWEJsYjJZZ2RGdHpYVDkwVzNNdWFXNWtaWGhQWmloY0luTmxkRndpS1h4OFhDSm1kVzVqZEdsdmJsd2lJVDEwZVhCbGIyWWdkRnRjSW1kbGRGd2lLM011YzNWaWMzUnlLRE1wWFQ5ek9sd2laMlYwWENJcmN5NXpkV0p6ZEhJb015bGRPaUV4TzNNOVpsdHVYVnN5WFN4MGFHbHpMbDlwYm1sMGFXRnNVbTkwWVhScGIyNXpXMjVkUFhSb2FYTXVYMloxYm1OYmMxMC9kR2hwY3k1ZlpuVnVZMXR6WFM1allXeHNLSFJvYVhNdVgzUmhjbWRsZENrNmRHaHBjeTVmZEdGeVoyVjBXM05kZlhKbGRIVnliaUIwYUdsekxsOXpkR0Z5ZEZKaGRHbHZQV2t1ZG1GeWN5NXlkVzVDWVdOcmQyRnlaSE0vTVRvd0xDRXdmU3h6WlhRNlpuVnVZM1JwYjI0b1pTbDdkbUZ5SUdrc2N5eHlMRzRzWVN4dkxHd3NhQ3hmTEhVc1l6MTBhR2x6TGw5elpXZERiM1Z1ZEN4bVBYUm9hWE11WDJaMWJtTXNjRDEwYUdsekxsOTBZWEpuWlhRc2JUMWxJVDA5ZEdocGN5NWZjM1JoY25SU1lYUnBienRwWmloMGFHbHpMbDkwYVcxbFVtVnpLWHRwWmloZlBYUm9hWE11WDJ4bGJtZDBhSE1zZFQxMGFHbHpMbDlqZFhKVFpXY3NaU285ZEdocGN5NWZiR1Z1WjNSb0xISTlkR2hwY3k1ZmJHa3NaVDUwYUdsekxsOXNNaVltWXkweFBuSXBlMlp2Y2lob1BXTXRNVHRvUG5JbUptVStQU2gwYUdsekxsOXNNajFmV3lzcmNsMHBPeWs3ZEdocGN5NWZiREU5WDF0eUxURmRMSFJvYVhNdVgyeHBQWElzZEdocGN5NWZZM1Z5VTJWblBYVTlkR2hwY3k1ZmMyVm5iV1Z1ZEhOYmNsMHNkR2hwY3k1ZmN6STlkVnQwYUdsekxsOXpNVDEwYUdsekxsOXphVDB3WFgxbGJITmxJR2xtS0hSb2FYTXVYMnd4UG1VbUpuSStNQ2w3Wm05eUtEdHlQakFtSmloMGFHbHpMbDlzTVQxZld5MHRjbDBwUGoxbE95azdNRDA5UFhJbUpuUm9hWE11WDJ3eFBtVS9kR2hwY3k1ZmJERTlNRHB5S3lzc2RHaHBjeTVmYkRJOVgxdHlYU3gwYUdsekxsOXNhVDF5TEhSb2FYTXVYMk4xY2xObFp6MTFQWFJvYVhNdVgzTmxaMjFsYm5SelczSmRMSFJvYVhNdVgzTXhQWFZiS0hSb2FYTXVYM05wUFhVdWJHVnVaM1JvTFRFcExURmRmSHd3TEhSb2FYTXVYM015UFhWYmRHaHBjeTVmYzJsZGZXbG1LR2s5Y2l4bExUMTBhR2x6TGw5c01TeHlQWFJvYVhNdVgzTnBMR1UrZEdocGN5NWZjekltSm5VdWJHVnVaM1JvTFRFK2NpbDdabTl5S0dnOWRTNXNaVzVuZEdndE1UdG9QbkltSm1VK1BTaDBhR2x6TGw5ek1qMTFXeXNyY2wwcE95azdkR2hwY3k1ZmN6RTlkVnR5TFRGZExIUm9hWE11WDNOcFBYSjlaV3h6WlNCcFppaDBhR2x6TGw5ek1UNWxKaVp5UGpBcGUyWnZjaWc3Y2o0d0ppWW9kR2hwY3k1ZmN6RTlkVnN0TFhKZEtUNDlaVHNwT3pBOVBUMXlKaVowYUdsekxsOXpNVDVsUDNSb2FYTXVYM014UFRBNmNpc3JMSFJvYVhNdVgzTXlQWFZiY2wwc2RHaHBjeTVmYzJrOWNuMXZQU2h5S3lobExYUm9hWE11WDNNeEtTOG9kR2hwY3k1ZmN6SXRkR2hwY3k1ZmN6RXBLU3AwYUdsekxsOXdjbVZqZldWc2MyVWdhVDB3UG1VL01EcGxQajB4UDJNdE1UcGpLbVUrUGpBc2J6MG9aUzFwS2lneEwyTXBLU3BqTzJadmNpaHpQVEV0Ynl4eVBYUm9hWE11WDNCeWIzQnpMbXhsYm1kMGFEc3RMWEkrTFRFN0tXNDlkR2hwY3k1ZmNISnZjSE5iY2wwc1lUMTBhR2x6TGw5aVpYcHBaWEp6VzI1ZFcybGRMR3c5S0c4cWJ5cGhMbVJoS3pNcWN5b29ieXBoTG1OaEszTXFZUzVpWVNrcEttOHJZUzVoTEhSb2FYTXVYM0p2ZFc1a1cyNWRKaVlvYkQxTllYUm9Mbkp2ZFc1a0tHd3BLU3htVzI1ZFAzQmJibDBvYkNrNmNGdHVYVDFzTzJsbUtIUm9hWE11WDJGMWRHOVNiM1JoZEdVcGUzWmhjaUJrTEdjc2RpeDVMRlFzZUN4M0xHSTlkR2hwY3k1ZllYVjBiMUp2ZEdGMFpUdG1iM0lvY2oxaUxteGxibWQwYURzdExYSStMVEU3S1c0OVlsdHlYVnN5WFN4NFBXSmJjbDFiTTExOGZEQXNkejFpVzNKZFd6UmRQVDA5SVRBL01UcDBMR0U5ZEdocGN5NWZZbVY2YVdWeWMxdGlXM0pkV3pCZFhTeGtQWFJvYVhNdVgySmxlbWxsY25OYllsdHlYVnN4WFYwc1lTWW1aQ1ltS0dFOVlWdHBYU3hrUFdSYmFWMHNaejFoTG1FcktHRXVZaTFoTG1FcEttOHNlVDFoTG1JcktHRXVZeTFoTG1JcEttOHNaeXM5S0hrdFp5a3FieXg1S3owb1lTNWpLeWhoTG1RdFlTNWpLU3B2TFhrcEttOHNkajFrTG1FcktHUXVZaTFrTG1FcEttOHNWRDFrTG1JcktHUXVZeTFrTG1JcEttOHNkaXM5S0ZRdGRpa3FieXhVS3owb1pDNWpLeWhrTG1RdFpDNWpLU3B2TFZRcEttOHNiRDF0UDAxaGRHZ3VZWFJoYmpJb1ZDMTJMSGt0WnlrcWR5dDRPblJvYVhNdVgybHVhWFJwWVd4U2IzUmhkR2x2Ym5OYmNsMHNabHR1WFQ5d1cyNWRLR3dwT25CYmJsMDliQ2w5ZlgwcExHUTliUzV3Y205MGIzUjVjR1U3YlM1aVpYcHBaWEpVYUhKdmRXZG9QWFVzYlM1amRXSnBZMVJ2VVhWaFpISmhkR2xqUFd3c2JTNWZZWFYwYjBOVFV6MGhNQ3h0TG5GMVlXUnlZWFJwWTFSdlEzVmlhV005Wm5WdVkzUnBiMjRvZEN4bExHa3BlM0psZEhWeWJpQnVaWGNnWVNoMExDZ3lLbVVyZENrdk15d29NaXBsSzJrcEx6TXNhU2w5TEcwdVgyTnpjMUpsWjJsemRHVnlQV1oxYm1OMGFXOXVLQ2w3ZG1GeUlIUTliaTVEVTFOUWJIVm5hVzQ3YVdZb2RDbDdkbUZ5SUdVOWRDNWZhVzUwWlhKdVlXeHpMR2s5WlM1ZmNHRnljMlZVYjFCeWIzaDVMSE05WlM1ZmMyVjBVR3gxWjJsdVVtRjBhVzhzY2oxbExrTlRVMUJ5YjNCVWQyVmxianRsTGw5eVpXZHBjM1JsY2tOdmJYQnNaWGhUY0dWamFXRnNVSEp2Y0NoY0ltSmxlbWxsY2x3aUxIdHdZWEp6WlhJNlpuVnVZM1JwYjI0b2RDeGxMRzRzWVN4dkxHd3BlMlVnYVc1emRHRnVZMlZ2WmlCQmNuSmhlU1ltS0dVOWUzWmhiSFZsY3pwbGZTa3NiRDF1WlhjZ2JUdDJZWElnYUN4ZkxIVXNZejFsTG5aaGJIVmxjeXhtUFdNdWJHVnVaM1JvTFRFc2NEMWJYU3hrUFh0OU8ybG1LREErWmlseVpYUjFjbTRnYnp0bWIzSW9hRDB3TzJZK1BXZzdhQ3NyS1hVOWFTaDBMR05iYUYwc1lTeHZMR3dzWmlFOVBXZ3BMSEJiYUYwOWRTNWxibVE3Wm05eUtGOGdhVzRnWlNsa1cxOWRQV1ZiWDEwN2NtVjBkWEp1SUdRdWRtRnNkV1Z6UFhBc2J6MXVaWGNnY2loMExGd2lZbVY2YVdWeVhDSXNNQ3d3TEhVdWNIUXNNaWtzYnk1a1lYUmhQWFVzYnk1d2JIVm5hVzQ5YkN4dkxuTmxkRkpoZEdsdlBYTXNNRDA5UFdRdVlYVjBiMUp2ZEdGMFpTWW1LR1F1WVhWMGIxSnZkR0YwWlQwaE1Da3NJV1F1WVhWMGIxSnZkR0YwWlh4OFpDNWhkWFJ2VW05MFlYUmxJR2x1YzNSaGJtTmxiMllnUVhKeVlYbDhmQ2hvUFdRdVlYVjBiMUp2ZEdGMFpUMDlQU0V3UHpBNlRuVnRZbVZ5S0dRdVlYVjBiMUp2ZEdGMFpTa3NaQzVoZFhSdlVtOTBZWFJsUFc1MWJHd2hQWFV1Wlc1a0xteGxablEvVzF0Y0lteGxablJjSWl4Y0luUnZjRndpTEZ3aWNtOTBZWFJwYjI1Y0lpeG9MQ0V4WFYwNmJuVnNiQ0U5ZFM1bGJtUXVlRDliVzF3aWVGd2lMRndpZVZ3aUxGd2ljbTkwWVhScGIyNWNJaXhvTENFeFhWMDZJVEVwTEdRdVlYVjBiMUp2ZEdGMFpTWW1LR0V1WDNSeVlXNXpabTl5Ylh4OFlTNWZaVzVoWW14bFZISmhibk5tYjNKdGN5Z2hNU2tzZFM1aGRYUnZVbTkwWVhSbFBXRXVYM1JoY21kbGRDNWZaM05VY21GdWMyWnZjbTBwTEd3dVgyOXVTVzVwZEZSM1pXVnVLSFV1Y0hKdmVIa3NaQ3hoTGw5MGQyVmxiaWtzYjMxOUtYMTlMR1F1WDNKdmRXNWtVSEp2Y0hNOVpuVnVZM1JwYjI0b2RDeGxLWHRtYjNJb2RtRnlJR2s5ZEdocGN5NWZiM1psY25keWFYUmxVSEp2Y0hNc2N6MXBMbXhsYm1kMGFEc3RMWE0rTFRFN0tTaDBXMmxiYzExZGZIeDBMbUpsZW1sbGNueDhkQzVpWlhwcFpYSlVhSEp2ZFdkb0tTWW1LSFJvYVhNdVgzSnZkVzVrVzJsYmMxMWRQV1VwZlN4a0xsOXJhV3hzUFdaMWJtTjBhVzl1S0hRcGUzWmhjaUJsTEdrc2N6MTBhR2x6TGw5d2NtOXdjenRtYjNJb1pTQnBiaUIwYUdsekxsOWlaWHBwWlhKektXbG1LR1VnYVc0Z2RDbG1iM0lvWkdWc1pYUmxJSFJvYVhNdVgySmxlbWxsY25OYlpWMHNaR1ZzWlhSbElIUm9hWE11WDJaMWJtTmJaVjBzYVQxekxteGxibWQwYURzdExXaytMVEU3S1hOYmFWMDlQVDFsSmlaekxuTndiR2xqWlNocExERXBPM0psZEhWeWJpQjBhR2x6TGw5emRYQmxjaTVmYTJsc2JDNWpZV3hzS0hSb2FYTXNkQ2w5ZlNncExGOW5jMU5qYjNCbExsOW5jMFJsWm1sdVpTaGNJbkJzZFdkcGJuTXVRMU5UVUd4MVoybHVYQ0lzVzF3aWNHeDFaMmx1Y3k1VWQyVmxibEJzZFdkcGJsd2lMRndpVkhkbFpXNU1hWFJsWENKZExHWjFibU4wYVc5dUtIUXNaU2w3ZG1GeUlHa3NjeXh5TEc0c1lUMW1kVzVqZEdsdmJpZ3BlM1F1WTJGc2JDaDBhR2x6TEZ3aVkzTnpYQ0lwTEhSb2FYTXVYMjkyWlhKM2NtbDBaVkJ5YjNCekxteGxibWQwYUQwd0xIUm9hWE11YzJWMFVtRjBhVzg5WVM1d2NtOTBiM1I1Y0dVdWMyVjBVbUYwYVc5OUxHODlYMmR6VTJOdmNHVXVYMmR6UkdWbWFXNWxMbWRzYjJKaGJITXNiRDE3ZlN4b1BXRXVjSEp2ZEc5MGVYQmxQVzVsZHlCMEtGd2lZM056WENJcE8yZ3VZMjl1YzNSeWRXTjBiM0k5WVN4aExuWmxjbk5wYjI0OVhDSXhMakU0TGpCY0lpeGhMa0ZRU1QweUxHRXVaR1ZtWVhWc2RGUnlZVzV6Wm05eWJWQmxjbk53WldOMGFYWmxQVEFzWVM1a1pXWmhkV3gwVTJ0bGQxUjVjR1U5WENKamIyMXdaVzV6WVhSbFpGd2lMR0V1WkdWbVlYVnNkRk50YjI5MGFFOXlhV2RwYmowaE1DeG9QVndpY0hoY0lpeGhMbk4xWm1acGVFMWhjRDE3ZEc5d09tZ3NjbWxuYUhRNmFDeGliM1IwYjIwNmFDeHNaV1owT21nc2QybGtkR2c2YUN4b1pXbG5hSFE2YUN4bWIyNTBVMmw2WlRwb0xIQmhaR1JwYm1jNmFDeHRZWEpuYVc0NmFDeHdaWEp6Y0dWamRHbDJaVHBvTEd4cGJtVklaV2xuYUhRNlhDSmNJbjA3ZG1GeUlGOHNkU3hqTEdZc2NDeHRMR1E5THlnL09seGNaSHhjWEMxY1hHUjhYRnd1WEZ4a2ZGeGNMVnhjTGx4Y1pDa3JMMmNzWnowdktEODZYRnhrZkZ4Y0xWeGNaSHhjWEM1Y1hHUjhYRnd0WEZ3dVhGeGtmRnhjS3oxY1hHUjhYRnd0UFZ4Y1pIeGNYQ3M5TGx4Y1pIeGNYQzA5WEZ3dVhGeGtLU3N2Wnl4MlBTOG9QenBjWENzOWZGeGNMVDE4WEZ3dGZGeGNZaWxiWEZ4a1hGd3RYRnd1WFN0YllTMTZRUzFhTUMwNVhTb29Qem9sZkZ4Y1lpa3ZaMmtzZVQwdktEOGhXeXN0WFQ5Y1hHUXFYRnd1UDF4Y1pDdDhXeXN0WFh4bFd5c3RYVnhjWkNzcFcxNHdMVGxkTDJjc1ZEMHZLRDg2WEZ4a2ZGeGNMWHhjWEN0OFBYd2pmRnhjTGlrcUwyY3NlRDB2YjNCaFkybDBlU0FxUFNBcUtGdGVLVjBxS1M5cExIYzlMMjl3WVdOcGRIazZLRnRlTzEwcUtTOXBMR0k5TDJGc2NHaGhYRndvYjNCaFkybDBlU0FxUFM0clAxeGNLUzlwTEZBOUwxNG9jbWRpZkdoemJDa3ZMR3M5THloYlFTMWFYU2t2Wnl4VFBTOHRLRnRoTFhwZEtTOW5hU3hTUFM4b1hpZy9PblZ5YkZ4Y0tGeGNYQ0o4ZFhKc1hGd29LU2w4S0Q4NktGeGNYQ0pjWENrcEpIeGNYQ2trS1M5bmFTeFBQV1oxYm1OMGFXOXVLSFFzWlNsN2NtVjBkWEp1SUdVdWRHOVZjSEJsY2tOaGMyVW9LWDBzUVQwdktEODZUR1ZtZEh4U2FXZG9kSHhYYVdSMGFDa3ZhU3hEUFM4b1RURXhmRTB4TW54Tk1qRjhUVEl5S1QxYlhGeGtYRnd0WEZ3dVpWMHJMMmRwTEVROUwzQnliMmRwWkZ4Y09rUllTVzFoWjJWVWNtRnVjMlp2Y20xY1hDNU5hV055YjNOdlpuUmNYQzVOWVhSeWFYaGNYQ2d1S3o5Y1hDa3ZhU3hOUFM4c0tEODlXMTVjWENsZEtpZy9PbHhjS0h3a0tTa3ZaMmtzZWoxTllYUm9MbEJKTHpFNE1DeEdQVEU0TUM5TllYUm9MbEJKTEVrOWUzMHNSVDFrYjJOMWJXVnVkQ3hPUFdaMWJtTjBhVzl1S0hRcGUzSmxkSFZ5YmlCRkxtTnlaV0YwWlVWc1pXMWxiblJPVXo5RkxtTnlaV0YwWlVWc1pXMWxiblJPVXloY0ltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6RTVPVGt2ZUdoMGJXeGNJaXgwS1RwRkxtTnlaV0YwWlVWc1pXMWxiblFvZENsOUxFdzlUaWhjSW1ScGRsd2lLU3hZUFU0b1hDSnBiV2RjSWlrc1FqMWhMbDlwYm5SbGNtNWhiSE05ZTE5emNHVmphV0ZzVUhKdmNITTZiSDBzYWoxdVlYWnBaMkYwYjNJdWRYTmxja0ZuWlc1MExGazlablZ1WTNScGIyNG9LWHQyWVhJZ2REMXFMbWx1WkdWNFQyWW9YQ0pCYm1SeWIybGtYQ0lwTEdVOVRpaGNJbUZjSWlrN2NtVjBkWEp1SUdNOUxURWhQVDFxTG1sdVpHVjRUMllvWENKVFlXWmhjbWxjSWlrbUppMHhQVDA5YWk1cGJtUmxlRTltS0Z3aVEyaHliMjFsWENJcEppWW9MVEU5UFQxMGZIeE9kVzFpWlhJb2FpNXpkV0p6ZEhJb2RDczRMREVwS1Q0ektTeHdQV01tSmpZK1RuVnRZbVZ5S0dvdWMzVmljM1J5S0dvdWFXNWtaWGhQWmloY0lsWmxjbk5wYjI0dlhDSXBLemdzTVNrcExHWTlMVEVoUFQxcUxtbHVaR1Y0VDJZb1hDSkdhWEpsWm05NFhDSXBMQ2d2VFZOSlJTQW9XekF0T1YxN01TeDlXMXhjTGpBdE9WMTdNQ3g5S1M4dVpYaGxZeWhxS1h4OEwxUnlhV1JsYm5SY1hDOHVLbkoyT2loYk1DMDVYWHN4TEgxYlhGd3VNQzA1WFhzd0xIMHBMeTVsZUdWaktHb3BLU1ltS0cwOWNHRnljMlZHYkc5aGRDaFNaV2RGZUhBdUpERXBLU3hsUHlobExuTjBlV3hsTG1OemMxUmxlSFE5WENKMGIzQTZNWEI0TzI5d1lXTnBkSGs2TGpVMU8xd2lMQzllTUM0MU5TOHVkR1Z6ZENobExuTjBlV3hsTG05d1lXTnBkSGtwS1RvaE1YMG9LU3hWUFdaMWJtTjBhVzl1S0hRcGUzSmxkSFZ5YmlCNExuUmxjM1FvWENKemRISnBibWRjSWowOWRIbHdaVzltSUhRL2REb29kQzVqZFhKeVpXNTBVM1I1YkdVL2RDNWpkWEp5Wlc1MFUzUjViR1V1Wm1sc2RHVnlPblF1YzNSNWJHVXVabWxzZEdWeUtYeDhYQ0pjSWlrL2NHRnljMlZHYkc5aGRDaFNaV2RGZUhBdUpERXBMekV3TURveGZTeHhQV1oxYm1OMGFXOXVLSFFwZTNkcGJtUnZkeTVqYjI1emIyeGxKaVpqYjI1emIyeGxMbXh2WnloMEtYMHNWajFjSWx3aUxFYzlYQ0pjSWl4WFBXWjFibU4wYVc5dUtIUXNaU2w3WlQxbGZIeE1PM1poY2lCcExITXNjajFsTG5OMGVXeGxPMmxtS0hadmFXUWdNQ0U5UFhKYmRGMHBjbVYwZFhKdUlIUTdabTl5S0hROWRDNWphR0Z5UVhRb01Da3VkRzlWY0hCbGNrTmhjMlVvS1N0MExuTjFZbk4wY2lneEtTeHBQVnRjSWs5Y0lpeGNJazF2ZWx3aUxGd2liWE5jSWl4Y0lrMXpYQ0lzWENKWFpXSnJhWFJjSWwwc2N6MDFPeTB0Y3o0dE1TWW1kbTlwWkNBd1BUMDljbHRwVzNOZEszUmRPeWs3Y21WMGRYSnVJSE0rUFRBL0tFYzlNejA5UFhNL1hDSnRjMXdpT21sYmMxMHNWajFjSWkxY0lpdEhMblJ2VEc5M1pYSkRZWE5sS0NrclhDSXRYQ0lzUnl0MEtUcHVkV3hzZlN4YVBVVXVaR1ZtWVhWc2RGWnBaWGMvUlM1a1pXWmhkV3gwVm1sbGR5NW5aWFJEYjIxd2RYUmxaRk4wZVd4bE9tWjFibU4wYVc5dUtDbDdmU3hSUFdFdVoyVjBVM1I1YkdVOVpuVnVZM1JwYjI0b2RDeGxMR2tzY3l4eUtYdDJZWElnYmp0eVpYUjFjbTRnV1h4OFhDSnZjR0ZqYVhSNVhDSWhQVDFsUHlnaGN5WW1kQzV6ZEhsc1pWdGxYVDl1UFhRdWMzUjViR1ZiWlYwNktHazlhWHg4V2loMEtTay9iajFwVzJWZGZIeHBMbWRsZEZCeWIzQmxjblI1Vm1Gc2RXVW9aU2w4ZkdrdVoyVjBVSEp2Y0dWeWRIbFdZV3gxWlNobExuSmxjR3hoWTJVb2F5eGNJaTBrTVZ3aUtTNTBiMHh2ZDJWeVEyRnpaU2dwS1RwMExtTjFjbkpsYm5SVGRIbHNaU1ltS0c0OWRDNWpkWEp5Wlc1MFUzUjViR1ZiWlYwcExHNTFiR3c5UFhKOGZHNG1KbHdpYm05dVpWd2lJVDA5YmlZbVhDSmhkWFJ2WENJaFBUMXVKaVpjSW1GMWRHOGdZWFYwYjF3aUlUMDliajl1T25JcE9sVW9kQ2w5TENROVFpNWpiMjUyWlhKMFZHOVFhWGhsYkhNOVpuVnVZM1JwYjI0b2RDeHBMSE1zY2l4dUtYdHBaaWhjSW5CNFhDSTlQVDF5Zkh3aGNpbHlaWFIxY200Z2N6dHBaaWhjSW1GMWRHOWNJajA5UFhKOGZDRnpLWEpsZEhWeWJpQXdPM1poY2lCdkxHd3NhQ3hmUFVFdWRHVnpkQ2hwS1N4MVBYUXNZejFNTG5OMGVXeGxMR1k5TUQ1ek8ybG1LR1ltSmloelBTMXpLU3hjSWlWY0lqMDlQWEltSmkweElUMDlhUzVwYm1SbGVFOW1LRndpWW05eVpHVnlYQ0lwS1c4OWN5OHhNREFxS0Y4L2RDNWpiR2xsYm5SWGFXUjBhRHAwTG1Oc2FXVnVkRWhsYVdkb2RDazdaV3h6Wlh0cFppaGpMbU56YzFSbGVIUTlYQ0ppYjNKa1pYSTZNQ0J6YjJ4cFpDQnlaV1E3Y0c5emFYUnBiMjQ2WENJclVTaDBMRndpY0c5emFYUnBiMjVjSWlrclhDSTdiR2x1WlMxb1pXbG5hSFE2TUR0Y0lpeGNJaVZjSWlFOVBYSW1KblV1WVhCd1pXNWtRMmhwYkdRbUpsd2lkbHdpSVQwOWNpNWphR0Z5UVhRb01Da21KbHdpY21WdFhDSWhQVDF5S1dOYlh6OWNJbUp2Y21SbGNreGxablJYYVdSMGFGd2lPbHdpWW05eVpHVnlWRzl3VjJsa2RHaGNJbDA5Y3l0eU8yVnNjMlY3YVdZb2RUMTBMbkJoY21WdWRFNXZaR1Y4ZkVVdVltOWtlU3hzUFhVdVgyZHpRMkZqYUdVc2FEMWxMblJwWTJ0bGNpNW1jbUZ0WlN4c0ppWmZKaVpzTG5ScGJXVTlQVDFvS1hKbGRIVnliaUJzTG5kcFpIUm9Lbk12TVRBd08yTmJYejljSW5kcFpIUm9YQ0k2WENKb1pXbG5hSFJjSWwwOWN5dHlmWFV1WVhCd1pXNWtRMmhwYkdRb1RDa3NiejF3WVhKelpVWnNiMkYwS0V4Ylh6OWNJbTltWm5ObGRGZHBaSFJvWENJNlhDSnZabVp6WlhSSVpXbG5hSFJjSWwwcExIVXVjbVZ0YjNabFEyaHBiR1FvVENrc1h5WW1YQ0lsWENJOVBUMXlKaVpoTG1OaFkyaGxWMmxrZEdoeklUMDlJVEVtSmloc1BYVXVYMmR6UTJGamFHVTlkUzVmWjNORFlXTm9aWHg4ZTMwc2JDNTBhVzFsUFdnc2JDNTNhV1IwYUQweE1EQXFLRzh2Y3lrcExEQWhQVDF2Zkh4dWZId29iejBrS0hRc2FTeHpMSElzSVRBcEtYMXlaWFIxY200Z1pqOHRienB2ZlN4SVBVSXVZMkZzWTNWc1lYUmxUMlptYzJWMFBXWjFibU4wYVc5dUtIUXNaU3hwS1h0cFppaGNJbUZpYzI5c2RYUmxYQ0loUFQxUktIUXNYQ0p3YjNOcGRHbHZibHdpTEdrcEtYSmxkSFZ5YmlBd08zWmhjaUJ6UFZ3aWJHVm1kRndpUFQwOVpUOWNJa3hsWm5SY0lqcGNJbFJ2Y0Z3aUxISTlVU2gwTEZ3aWJXRnlaMmx1WENJcmN5eHBLVHR5WlhSMWNtNGdkRnRjSW05bVpuTmxkRndpSzNOZExTZ2tLSFFzWlN4d1lYSnpaVVpzYjJGMEtISXBMSEl1Y21Wd2JHRmpaU2hVTEZ3aVhDSXBLWHg4TUNsOUxFczlablZ1WTNScGIyNG9kQ3hsS1h0MllYSWdhU3h6TEhJc2JqMTdmVHRwWmlobFBXVjhmRm9vZEN4dWRXeHNLU2xwWmlocFBXVXViR1Z1WjNSb0tXWnZjaWc3TFMxcFBpMHhPeWx5UFdWYmFWMHNLQzB4UFQwOWNpNXBibVJsZUU5bUtGd2lMWFJ5WVc1elptOXliVndpS1h4OGEyVTlQVDF5S1NZbUtHNWJjaTV5WlhCc1lXTmxLRk1zVHlsZFBXVXVaMlYwVUhKdmNHVnlkSGxXWVd4MVpTaHlLU2s3Wld4elpTQm1iM0lvYVNCcGJpQmxLU2d0TVQwOVBXa3VhVzVrWlhoUFppaGNJbFJ5WVc1elptOXliVndpS1h4OFVHVTlQVDFwS1NZbUtHNWJhVjA5WlZ0cFhTazdaV3h6WlNCcFppaGxQWFF1WTNWeWNtVnVkRk4wZVd4bGZIeDBMbk4wZVd4bEtXWnZjaWhwSUdsdUlHVXBYQ0p6ZEhKcGJtZGNJajA5ZEhsd1pXOW1JR2ttSm5admFXUWdNRDA5UFc1YmFWMG1KaWh1VzJrdWNtVndiR0ZqWlNoVExFOHBYVDFsVzJsZEtUdHlaWFIxY200Z1dYeDhLRzR1YjNCaFkybDBlVDFWS0hRcEtTeHpQVTVsS0hRc1pTd2hNU2tzYmk1eWIzUmhkR2x2YmoxekxuSnZkR0YwYVc5dUxHNHVjMnRsZDFnOWN5NXphMlYzV0N4dUxuTmpZV3hsV0QxekxuTmpZV3hsV0N4dUxuTmpZV3hsV1QxekxuTmpZV3hsV1N4dUxuZzljeTU0TEc0dWVUMXpMbmtzVW1VbUppaHVMbm85Y3k1NkxHNHVjbTkwWVhScGIyNVlQWE11Y205MFlYUnBiMjVZTEc0dWNtOTBZWFJwYjI1WlBYTXVjbTkwWVhScGIyNVpMRzR1YzJOaGJHVmFQWE11YzJOaGJHVmFLU3h1TG1acGJIUmxjbk1tSm1SbGJHVjBaU0J1TG1acGJIUmxjbk1zYm4wc1NqMW1kVzVqZEdsdmJpaDBMR1VzYVN4ekxISXBlM1poY2lCdUxHRXNieXhzUFh0OUxHZzlkQzV6ZEhsc1pUdG1iM0lvWVNCcGJpQnBLVndpWTNOelZHVjRkRndpSVQwOVlTWW1YQ0pzWlc1bmRHaGNJaUU5UFdFbUptbHpUbUZPS0dFcEppWW9aVnRoWFNFOVBTaHVQV2xiWVYwcGZIeHlKaVp5VzJGZEtTWW1MVEU5UFQxaExtbHVaR1Y0VDJZb1hDSlBjbWxuYVc1Y0lpa21KaWhjSW01MWJXSmxjbHdpUFQxMGVYQmxiMllnYm54OFhDSnpkSEpwYm1kY0lqMDlkSGx3Wlc5bUlHNHBKaVlvYkZ0aFhUMWNJbUYxZEc5Y0lpRTlQVzU4ZkZ3aWJHVm1kRndpSVQwOVlTWW1YQ0owYjNCY0lpRTlQV0UvWENKY0lpRTlQVzRtSmx3aVlYVjBiMXdpSVQwOWJpWW1YQ0p1YjI1bFhDSWhQVDF1Zkh4Y0luTjBjbWx1WjF3aUlUMTBlWEJsYjJZZ1pWdGhYWHg4WENKY0lqMDlQV1ZiWVYwdWNtVndiR0ZqWlNoNUxGd2lYQ0lwUDI0Nk1EcElLSFFzWVNrc2RtOXBaQ0F3SVQwOWFGdGhYU1ltS0c4OWJtVjNJSEJsS0dnc1lTeG9XMkZkTEc4cEtTazdhV1lvY3lsbWIzSW9ZU0JwYmlCektWd2lZMnhoYzNOT1lXMWxYQ0loUFQxaEppWW9iRnRoWFQxelcyRmRLVHR5WlhSMWNtNTdaR2xtY3pwc0xHWnBjbk4wVFZCVU9tOTlmU3gwWlQxN2QybGtkR2c2VzF3aVRHVm1kRndpTEZ3aVVtbG5hSFJjSWwwc2FHVnBaMmgwT2x0Y0lsUnZjRndpTEZ3aVFtOTBkRzl0WENKZGZTeGxaVDFiWENKdFlYSm5hVzVNWldaMFhDSXNYQ0p0WVhKbmFXNVNhV2RvZEZ3aUxGd2liV0Z5WjJsdVZHOXdYQ0lzWENKdFlYSm5hVzVDYjNSMGIyMWNJbDBzYVdVOVpuVnVZM1JwYjI0b2RDeGxMR2twZTNaaGNpQnpQWEJoY25ObFJteHZZWFFvWENKM2FXUjBhRndpUFQwOVpUOTBMbTltWm5ObGRGZHBaSFJvT25RdWIyWm1jMlYwU0dWcFoyaDBLU3h5UFhSbFcyVmRMRzQ5Y2k1c1pXNW5kR2c3Wm05eUtHazlhWHg4V2loMExHNTFiR3dwT3kwdGJqNHRNVHNwY3kwOWNHRnljMlZHYkc5aGRDaFJLSFFzWENKd1lXUmthVzVuWENJcmNsdHVYU3hwTENFd0tTbDhmREFzY3kwOWNHRnljMlZHYkc5aGRDaFJLSFFzWENKaWIzSmtaWEpjSWl0eVcyNWRLMXdpVjJsa2RHaGNJaXhwTENFd0tTbDhmREE3Y21WMGRYSnVJSE45TEhObFBXWjFibU4wYVc5dUtIUXNaU2w3YVdZb1hDSmpiMjUwWVdsdVhDSTlQVDEwZkh4Y0ltRjFkRzljSWowOVBYUjhmRndpWVhWMGJ5QmhkWFJ2WENJOVBUMTBLWEpsZEhWeWJpQjBLMXdpSUZ3aU95aHVkV3hzUFQxMGZIeGNJbHdpUFQwOWRDa21KaWgwUFZ3aU1DQXdYQ0lwTzNaaGNpQnBQWFF1YzNCc2FYUW9YQ0lnWENJcExITTlMVEVoUFQxMExtbHVaR1Y0VDJZb1hDSnNaV1owWENJcFAxd2lNQ1ZjSWpvdE1TRTlQWFF1YVc1a1pYaFBaaWhjSW5KcFoyaDBYQ0lwUDF3aU1UQXdKVndpT21sYk1GMHNjajB0TVNFOVBYUXVhVzVrWlhoUFppaGNJblJ2Y0Z3aUtUOWNJakFsWENJNkxURWhQVDEwTG1sdVpHVjRUMllvWENKaWIzUjBiMjFjSWlrL1hDSXhNREFsWENJNmFWc3hYVHR5WlhSMWNtNGdiblZzYkQwOWNqOXlQVndpWTJWdWRHVnlYQ0k5UFQxelAxd2lOVEFsWENJNlhDSXdYQ0k2WENKalpXNTBaWEpjSWowOVBYSW1KaWh5UFZ3aU5UQWxYQ0lwTENoY0ltTmxiblJsY2x3aVBUMDljM3g4YVhOT1lVNG9jR0Z5YzJWR2JHOWhkQ2h6S1NrbUppMHhQVDA5S0hNclhDSmNJaWt1YVc1a1pYaFBaaWhjSWoxY0lpa3BKaVlvY3oxY0lqVXdKVndpS1N4MFBYTXJYQ0lnWENJcmNpc29hUzVzWlc1bmRHZytNajljSWlCY0lpdHBXekpkT2x3aVhDSXBMR1VtSmlobExtOTRjRDB0TVNFOVBYTXVhVzVrWlhoUFppaGNJaVZjSWlrc1pTNXZlWEE5TFRFaFBUMXlMbWx1WkdWNFQyWW9YQ0lsWENJcExHVXViM2h5UFZ3aVBWd2lQVDA5Y3k1amFHRnlRWFFvTVNrc1pTNXZlWEk5WENJOVhDSTlQVDF5TG1Ob1lYSkJkQ2d4S1N4bExtOTRQWEJoY25ObFJteHZZWFFvY3k1eVpYQnNZV05sS0hrc1hDSmNJaWtwTEdVdWIzazljR0Z5YzJWR2JHOWhkQ2h5TG5KbGNHeGhZMlVvZVN4Y0lsd2lLU2tzWlM1MlBYUXBMR1Y4ZkhSOUxISmxQV1oxYm1OMGFXOXVLSFFzWlNsN2NtVjBkWEp1WENKemRISnBibWRjSWowOWRIbHdaVzltSUhRbUpsd2lQVndpUFQwOWRDNWphR0Z5UVhRb01Tay9jR0Z5YzJWSmJuUW9kQzVqYUdGeVFYUW9NQ2tyWENJeFhDSXNNVEFwS25CaGNuTmxSbXh2WVhRb2RDNXpkV0p6ZEhJb01pa3BPbkJoY25ObFJteHZZWFFvZENrdGNHRnljMlZHYkc5aGRDaGxLWDBzYm1VOVpuVnVZM1JwYjI0b2RDeGxLWHR5WlhSMWNtNGdiblZzYkQwOWREOWxPbHdpYzNSeWFXNW5YQ0k5UFhSNWNHVnZaaUIwSmlaY0lqMWNJajA5UFhRdVkyaGhja0YwS0RFcFAzQmhjbk5sU1c1MEtIUXVZMmhoY2tGMEtEQXBLMXdpTVZ3aUxERXdLU3B3WVhKelpVWnNiMkYwS0hRdWMzVmljM1J5S0RJcEtTdGxPbkJoY25ObFJteHZZWFFvZENsOUxHRmxQV1oxYm1OMGFXOXVLSFFzWlN4cExITXBlM1poY2lCeUxHNHNZU3h2TEd3c2FEMHhaUzAyTzNKbGRIVnliaUJ1ZFd4c1BUMTBQMjg5WlRwY0ltNTFiV0psY2x3aVBUMTBlWEJsYjJZZ2REOXZQWFE2S0hJOU16WXdMRzQ5ZEM1emNHeHBkQ2hjSWw5Y0lpa3NiRDFjSWoxY0lqMDlQWFF1WTJoaGNrRjBLREVwTEdFOUtHdy9jR0Z5YzJWSmJuUW9kQzVqYUdGeVFYUW9NQ2tyWENJeFhDSXNNVEFwS25CaGNuTmxSbXh2WVhRb2Jsc3dYUzV6ZFdKemRISW9NaWtwT25CaGNuTmxSbXh2WVhRb2Jsc3dYU2twS2lndE1UMDlQWFF1YVc1a1pYaFBaaWhjSW5KaFpGd2lLVDh4T2tZcExTaHNQekE2WlNrc2JpNXNaVzVuZEdnbUppaHpKaVlvYzF0cFhUMWxLMkVwTEMweElUMDlkQzVwYm1SbGVFOW1LRndpYzJodmNuUmNJaWttSmloaEpUMXlMR0VoUFQxaEpTaHlMeklwSmlZb1lUMHdQbUUvWVN0eU9tRXRjaWtwTEMweElUMDlkQzVwYm1SbGVFOW1LRndpWDJOM1hDSXBKaVl3UG1FL1lUMG9ZU3M1T1RrNU9UazVPVGs1S25JcEpYSXRLREI4WVM5eUtTcHlPaTB4SVQwOWRDNXBibVJsZUU5bUtGd2lZMk4zWENJcEppWmhQakFtSmloaFBTaGhMVGs1T1RrNU9UazVPVGtxY2lrbGNpMG9NSHhoTDNJcEtuSXBLU3h2UFdVcllTa3NhRDV2SmladlBpMW9KaVlvYnowd0tTeHZmU3h2WlQxN1lYRjFZVHBiTUN3eU5UVXNNalUxWFN4c2FXMWxPbHN3TERJMU5Td3dYU3h6YVd4MlpYSTZXekU1TWl3eE9USXNNVGt5WFN4aWJHRmphenBiTUN3d0xEQmRMRzFoY205dmJqcGJNVEk0TERBc01GMHNkR1ZoYkRwYk1Dd3hNamdzTVRJNFhTeGliSFZsT2xzd0xEQXNNalUxWFN4dVlYWjVPbHN3TERBc01USTRYU3gzYUdsMFpUcGJNalUxTERJMU5Td3lOVFZkTEdaMVkyaHphV0U2V3pJMU5Td3dMREkxTlYwc2IyeHBkbVU2V3pFeU9Dd3hNamdzTUYwc2VXVnNiRzkzT2xzeU5UVXNNalUxTERCZExHOXlZVzVuWlRwYk1qVTFMREUyTlN3d1hTeG5jbUY1T2xzeE1qZ3NNVEk0TERFeU9GMHNjSFZ5Y0d4bE9sc3hNamdzTUN3eE1qaGRMR2R5WldWdU9sc3dMREV5T0N3d1hTeHlaV1E2V3pJMU5Td3dMREJkTEhCcGJtczZXekkxTlN3eE9USXNNakF6WFN4amVXRnVPbHN3TERJMU5Td3lOVFZkTEhSeVlXNXpjR0Z5Wlc1ME9sc3lOVFVzTWpVMUxESTFOU3d3WFgwc2JHVTlablZ1WTNScGIyNG9kQ3hsTEdrcGUzSmxkSFZ5YmlCMFBUQStkRDkwS3pFNmRENHhQM1F0TVRwMExEQjhNalUxS2lneFBqWXFkRDlsS3pZcUtHa3RaU2txZERvdU5UNTBQMms2TWo0ektuUS9aU3MyS2locExXVXBLaWd5THpNdGRDazZaU2tyTGpWOUxHaGxQV0V1Y0dGeWMyVkRiMnh2Y2oxbWRXNWpkR2x2YmloMExHVXBlM1poY2lCcExITXNjaXh1TEdFc2J5eHNMR2dzWHl4MUxHTTdhV1lvZENscFppaGNJbTUxYldKbGNsd2lQVDEwZVhCbGIyWWdkQ2xwUFZ0MFBqNHhOaXd5TlRVbWRENCtPQ3d5TlRVbWRGMDdaV3h6Wlh0cFppaGNJaXhjSWowOVBYUXVZMmhoY2tGMEtIUXViR1Z1WjNSb0xURXBKaVlvZEQxMExuTjFZbk4wY2lnd0xIUXViR1Z1WjNSb0xURXBLU3h2WlZ0MFhTbHBQVzlsVzNSZE8yVnNjMlVnYVdZb1hDSWpYQ0k5UFQxMExtTm9ZWEpCZENnd0tTazBQVDA5ZEM1c1pXNW5kR2dtSmloelBYUXVZMmhoY2tGMEtERXBMSEk5ZEM1amFHRnlRWFFvTWlrc2JqMTBMbU5vWVhKQmRDZ3pLU3gwUFZ3aUkxd2lLM01yY3l0eUszSXJiaXR1S1N4MFBYQmhjbk5sU1c1MEtIUXVjM1ZpYzNSeUtERXBMREUyS1N4cFBWdDBQajR4Tml3eU5UVW1kRDQrT0N3eU5UVW1kRjA3Wld4elpTQnBaaWhjSW1oemJGd2lQVDA5ZEM1emRXSnpkSElvTUN3ektTbHBaaWhwUFdNOWRDNXRZWFJqYUNoa0tTeGxLWHRwWmlndE1TRTlQWFF1YVc1a1pYaFBaaWhjSWoxY0lpa3BjbVYwZFhKdUlIUXViV0YwWTJnb1p5bDlaV3h6WlNCaFBVNTFiV0psY2locFd6QmRLU1V6TmpBdk16WXdMRzg5VG5WdFltVnlLR2xiTVYwcEx6RXdNQ3hzUFU1MWJXSmxjaWhwV3pKZEtTOHhNREFzY2owdU5UNDliRDlzS2lodkt6RXBPbXdyYnkxc0ttOHNjejB5S213dGNpeHBMbXhsYm1kMGFENHpKaVlvYVZzelhUMU9kVzFpWlhJb2RGc3pYU2twTEdsYk1GMDliR1VvWVNzeEx6TXNjeXh5S1N4cFd6RmRQV3hsS0dFc2N5eHlLU3hwV3pKZFBXeGxLR0V0TVM4ekxITXNjaWs3Wld4elpTQnBQWFF1YldGMFkyZ29aQ2w4Zkc5bExuUnlZVzV6Y0dGeVpXNTBPMmxiTUYwOVRuVnRZbVZ5S0dsYk1GMHBMR2xiTVYwOVRuVnRZbVZ5S0dsYk1WMHBMR2xiTWwwOVRuVnRZbVZ5S0dsYk1sMHBMR2t1YkdWdVozUm9Qak1tSmlocFd6TmRQVTUxYldKbGNpaHBXek5kS1NsOVpXeHpaU0JwUFc5bExtSnNZV05yTzNKbGRIVnliaUJsSmlZaFl5WW1LSE05YVZzd1hTOHlOVFVzY2oxcFd6RmRMekkxTlN4dVBXbGJNbDB2TWpVMUxHZzlUV0YwYUM1dFlYZ29jeXh5TEc0cExGODlUV0YwYUM1dGFXNG9jeXh5TEc0cExHdzlLR2dyWHlrdk1peG9QVDA5WHo5aFBXODlNRG9vZFQxb0xWOHNiejFzUGk0MVAzVXZLREl0YUMxZktUcDFMeWhvSzE4cExHRTlhRDA5UFhNL0tISXRiaWt2ZFNzb2JqNXlQelk2TUNrNmFEMDlQWEkvS0c0dGN5a3ZkU3N5T2loekxYSXBMM1VyTkN4aEtqMDJNQ2tzYVZzd1hUMHdmR0VyTGpVc2FWc3hYVDB3ZkRFd01DcHZLeTQxTEdsYk1sMDlNSHd4TURBcWJDc3VOU2tzYVgwc1gyVTlablZ1WTNScGIyNG9kQ3hsS1h0MllYSWdhU3h6TEhJc2JqMTBMbTFoZEdOb0tIVmxLWHg4VzEwc1lUMHdMRzg5Ymk1c1pXNW5kR2cvWENKY0lqcDBPMlp2Y2locFBUQTdiaTVzWlc1bmRHZythVHRwS3lzcGN6MXVXMmxkTEhJOWRDNXpkV0p6ZEhJb1lTeDBMbWx1WkdWNFQyWW9jeXhoS1MxaEtTeGhLejF5TG14bGJtZDBhQ3R6TG14bGJtZDBhQ3h6UFdobEtITXNaU2tzTXowOVBYTXViR1Z1WjNSb0ppWnpMbkIxYzJnb01Ta3NieXM5Y2lzb1pUOWNJbWh6YkdFb1hDSXJjMXN3WFN0Y0lpeGNJaXR6V3pGZEsxd2lKU3hjSWl0eld6SmRLMXdpSlN4Y0lpdHpXek5kT2x3aWNtZGlZU2hjSWl0ekxtcHZhVzRvWENJc1hDSXBLU3RjSWlsY0lqdHlaWFIxY200Z2IzMHNkV1U5WENJb1B6cGNYRnhjWWlnL09pZy9PbkpuWW54eVoySmhmR2h6Ykh4b2MyeGhLVnhjWEZ3b0xpcy9YRnhjWENrcGZGeGNYRnhDSXk0clAxeGNYRnhpWENJN1ptOXlLR2dnYVc0Z2IyVXBkV1VyUFZ3aWZGd2lLMmdyWENKY1hGeGNZbHdpTzNWbFBWSmxaMFY0Y0NoMVpTdGNJaWxjSWl4Y0ltZHBYQ0lwTEdFdVkyOXNiM0pUZEhKcGJtZEdhV3gwWlhJOVpuVnVZM1JwYjI0b2RDbDdkbUZ5SUdVc2FUMTBXekJkSzNSYk1WMDdkV1V1YkdGemRFbHVaR1Y0UFRBc2RXVXVkR1Z6ZENocEtTWW1LR1U5TFRFaFBUMXBMbWx1WkdWNFQyWW9YQ0pvYzJ3b1hDSXBmSHd0TVNFOVBXa3VhVzVrWlhoUFppaGNJbWh6YkdFb1hDSXBMSFJiTUYwOVgyVW9kRnN3WFN4bEtTeDBXekZkUFY5bEtIUmJNVjBzWlNrcGZTeGxMbVJsWm1GMWJIUlRkSEpwYm1kR2FXeDBaWEo4ZkNobExtUmxabUYxYkhSVGRISnBibWRHYVd4MFpYSTlZUzVqYjJ4dmNsTjBjbWx1WjBacGJIUmxjaWs3ZG1GeUlHTmxQV1oxYm1OMGFXOXVLSFFzWlN4cExITXBlMmxtS0c1MWJHdzlQWFFwY21WMGRYSnVJR1oxYm1OMGFXOXVLSFFwZTNKbGRIVnliaUIwZlR0MllYSWdjaXh1UFdVL0tIUXViV0YwWTJnb2RXVXBmSHhiWENKY0lsMHBXekJkT2x3aVhDSXNZVDEwTG5Od2JHbDBLRzRwTG1wdmFXNG9YQ0pjSWlrdWJXRjBZMmdvZGlsOGZGdGRMRzg5ZEM1emRXSnpkSElvTUN4MExtbHVaR1Y0VDJZb1lWc3dYU2twTEd3OVhDSXBYQ0k5UFQxMExtTm9ZWEpCZENoMExteGxibWQwYUMweEtUOWNJaWxjSWpwY0lsd2lMR2c5TFRFaFBUMTBMbWx1WkdWNFQyWW9YQ0lnWENJcFAxd2lJRndpT2x3aUxGd2lMRjg5WVM1c1pXNW5kR2dzZFQxZlBqQS9ZVnN3WFM1eVpYQnNZV05sS0dRc1hDSmNJaWs2WENKY0lqdHlaWFIxY200Z1h6OXlQV1UvWm5WdVkzUnBiMjRvZENsN2RtRnlJR1VzWXl4bUxIQTdhV1lvWENKdWRXMWlaWEpjSWowOWRIbHdaVzltSUhRcGRDczlkVHRsYkhObElHbG1LSE1tSmswdWRHVnpkQ2gwS1NsN1ptOXlLSEE5ZEM1eVpYQnNZV05sS0Uwc1hDSjhYQ0lwTG5Od2JHbDBLRndpZkZ3aUtTeG1QVEE3Y0M1c1pXNW5kR2crWmp0bUt5c3BjRnRtWFQxeUtIQmJabDBwTzNKbGRIVnliaUJ3TG1wdmFXNG9YQ0lzWENJcGZXbG1LR1U5S0hRdWJXRjBZMmdvZFdVcGZIeGJibDBwV3pCZExHTTlkQzV6Y0d4cGRDaGxLUzVxYjJsdUtGd2lYQ0lwTG0xaGRHTm9LSFlwZkh4YlhTeG1QV011YkdWdVozUm9MRjgrWmkwdEtXWnZjaWc3WHo0cksyWTdLV05iWmwwOWFUOWpXekI4S0dZdE1Ta3ZNbDA2WVZ0bVhUdHlaWFIxY200Z2J5dGpMbXB2YVc0b2FDa3JhQ3RsSzJ3cktDMHhJVDA5ZEM1cGJtUmxlRTltS0Z3aWFXNXpaWFJjSWlrL1hDSWdhVzV6WlhSY0lqcGNJbHdpS1gwNlpuVnVZM1JwYjI0b2RDbDdkbUZ5SUdVc2JpeGpPMmxtS0Z3aWJuVnRZbVZ5WENJOVBYUjVjR1Z2WmlCMEtYUXJQWFU3Wld4elpTQnBaaWh6SmlaTkxuUmxjM1FvZENrcGUyWnZjaWh1UFhRdWNtVndiR0ZqWlNoTkxGd2lmRndpS1M1emNHeHBkQ2hjSW54Y0lpa3NZejB3TzI0dWJHVnVaM1JvUG1NN1l5c3JLVzViWTEwOWNpaHVXMk5kS1R0eVpYUjFjbTRnYmk1cWIybHVLRndpTEZ3aUtYMXBaaWhsUFhRdWJXRjBZMmdvZGlsOGZGdGRMR005WlM1c1pXNW5kR2dzWHo1akxTMHBabTl5S0R0ZlBpc3JZenNwWlZ0alhUMXBQMlZiTUh3b1l5MHhLUzh5WFRwaFcyTmRPM0psZEhWeWJpQnZLMlV1YW05cGJpaG9LU3RzZlRwbWRXNWpkR2x2YmloMEtYdHlaWFIxY200Z2RIMTlMR1psUFdaMWJtTjBhVzl1S0hRcGUzSmxkSFZ5YmlCMFBYUXVjM0JzYVhRb1hDSXNYQ0lwTEdaMWJtTjBhVzl1S0dVc2FTeHpMSElzYml4aExHOHBlM1poY2lCc0xHZzlLR2tyWENKY0lpa3VjM0JzYVhRb1hDSWdYQ0lwTzJadmNpaHZQWHQ5TEd3OU1EczBQbXc3YkNzcktXOWJkRnRzWFYwOWFGdHNYVDFvVzJ4ZGZIeG9XeWhzTFRFcEx6SStQakJkTzNKbGRIVnliaUJ5TG5CaGNuTmxLR1VzYnl4dUxHRXBmWDBzY0dVOUtFSXVYM05sZEZCc2RXZHBibEpoZEdsdlBXWjFibU4wYVc5dUtIUXBlM1JvYVhNdWNHeDFaMmx1TG5ObGRGSmhkR2x2S0hRcE8yWnZjaWgyWVhJZ1pTeHBMSE1zY2l4dVBYUm9hWE11WkdGMFlTeGhQVzR1Y0hKdmVIa3NiejF1TG1acGNuTjBUVkJVTEd3OU1XVXROanR2T3lsbFBXRmJieTUyWFN4dkxuSS9aVDFOWVhSb0xuSnZkVzVrS0dVcE9tdytaU1ltWlQ0dGJDWW1LR1U5TUNrc2J5NTBXMjh1Y0YwOVpTeHZQVzh1WDI1bGVIUTdhV1lvYmk1aGRYUnZVbTkwWVhSbEppWW9iaTVoZFhSdlVtOTBZWFJsTG5KdmRHRjBhVzl1UFdFdWNtOTBZWFJwYjI0cExERTlQVDEwS1dadmNpaHZQVzR1Wm1seWMzUk5VRlE3YnpzcGUybG1LR2s5Ynk1MExHa3VkSGx3WlNsN2FXWW9NVDA5UFdrdWRIbHdaU2w3Wm05eUtISTlhUzU0Y3pBcmFTNXpLMmt1ZUhNeExITTlNVHRwTG13K2N6dHpLeXNwY2lzOWFWdGNJbmh1WENJcmMxMHJhVnRjSW5oelhDSXJLSE1yTVNsZE8ya3VaVDF5ZlgxbGJITmxJR2t1WlQxcExuTXJhUzU0Y3pBN2J6MXZMbDl1WlhoMGZYMHNablZ1WTNScGIyNG9kQ3hsTEdrc2N5eHlLWHQwYUdsekxuUTlkQ3gwYUdsekxuQTlaU3gwYUdsekxuWTlhU3gwYUdsekxuSTljaXh6SmlZb2N5NWZjSEpsZGoxMGFHbHpMSFJvYVhNdVgyNWxlSFE5Y3lsOUtTeHRaVDBvUWk1ZmNHRnljMlZVYjFCeWIzaDVQV1oxYm1OMGFXOXVLSFFzWlN4cExITXNjaXh1S1h0MllYSWdZU3h2TEd3c2FDeGZMSFU5Y3l4alBYdDlMR1k5ZTMwc2NEMXBMbDkwY21GdWMyWnZjbTBzYlQxSk8yWnZjaWhwTGw5MGNtRnVjMlp2Y20wOWJuVnNiQ3hKUFdVc2N6MWZQV2t1Y0dGeWMyVW9kQ3hsTEhNc2Npa3NTVDF0TEc0bUppaHBMbDkwY21GdWMyWnZjbTA5Y0N4MUppWW9kUzVmY0hKbGRqMXVkV3hzTEhVdVgzQnlaWFltSmloMUxsOXdjbVYyTGw5dVpYaDBQVzUxYkd3cEtTazdjeVltY3lFOVBYVTdLWHRwWmlneFBqMXpMblI1Y0dVbUppaHZQWE11Y0N4bVcyOWRQWE11Y3l0ekxtTXNZMXR2WFQxekxuTXNibng4S0dnOWJtVjNJSEJsS0hNc1hDSnpYQ0lzYnl4b0xITXVjaWtzY3k1alBUQXBMREU5UFQxekxuUjVjR1VwS1dadmNpaGhQWE11YkRzdExXRStNRHNwYkQxY0luaHVYQ0lyWVN4dlBYTXVjQ3RjSWw5Y0lpdHNMR1piYjEwOWN5NWtZWFJoVzJ4ZExHTmJiMTA5YzF0c1hTeHVmSHdvYUQxdVpYY2djR1VvY3l4c0xHOHNhQ3h6TG5KNGNGdHNYU2twTzNNOWN5NWZibVY0ZEgxeVpYUjFjbTU3Y0hKdmVIazZZeXhsYm1RNlppeG1hWEp6ZEUxUVZEcG9MSEIwT2w5OWZTeENMa05UVTFCeWIzQlVkMlZsYmoxbWRXNWpkR2x2YmloMExHVXNjeXh5TEdFc2J5eHNMR2dzWHl4MUxHTXBlM1JvYVhNdWREMTBMSFJvYVhNdWNEMWxMSFJvYVhNdWN6MXpMSFJvYVhNdVl6MXlMSFJvYVhNdWJqMXNmSHhsTEhRZ2FXNXpkR0Z1WTJWdlppQnRaWHg4Ymk1d2RYTm9LSFJvYVhNdWJpa3NkR2hwY3k1eVBXZ3NkR2hwY3k1MGVYQmxQVzk4ZkRBc1h5WW1LSFJvYVhNdWNISTlYeXhwUFNFd0tTeDBhR2x6TG1JOWRtOXBaQ0F3UFQwOWRUOXpPblVzZEdocGN5NWxQWFp2YVdRZ01EMDlQV00vY3l0eU9tTXNZU1ltS0hSb2FYTXVYMjVsZUhROVlTeGhMbDl3Y21WMlBYUm9hWE1wZlNrc1pHVTlablZ1WTNScGIyNG9kQ3hsTEdrc2N5eHlMRzRwZTNaaGNpQmhQVzVsZHlCdFpTaDBMR1VzYVN4ekxXa3NjaXd0TVN4dUtUdHlaWFIxY200Z1lTNWlQV2tzWVM1bFBXRXVlSE13UFhNc1lYMHNaMlU5WVM1d1lYSnpaVU52YlhCc1pYZzlablZ1WTNScGIyNG9kQ3hsTEdrc2N5eHlMRzRzWVN4dkxHd3NhQ2w3YVQxcGZIeHVmSHhjSWx3aUxHRTlibVYzSUcxbEtIUXNaU3d3TERBc1lTeG9Qekk2TVN4dWRXeHNMQ0V4TEc4c2FTeHpLU3h6S3oxY0lsd2lPM1poY2lCMUxHTXNaaXh3TEcwc2RpeDVMRlFzZUN4M0xHSXNVQ3hyTEZNOWFTNXpjR3hwZENoY0lpd2dYQ0lwTG1wdmFXNG9YQ0lzWENJcExuTndiR2wwS0Z3aUlGd2lLU3hTUFhNdWMzQnNhWFFvWENJc0lGd2lLUzVxYjJsdUtGd2lMRndpS1M1emNHeHBkQ2hjSWlCY0lpa3NUejFUTG14bGJtZDBhQ3hCUFY4aFBUMGhNVHRtYjNJb0tDMHhJVDA5Y3k1cGJtUmxlRTltS0Z3aUxGd2lLWHg4TFRFaFBUMXBMbWx1WkdWNFQyWW9YQ0lzWENJcEtTWW1LRk05VXk1cWIybHVLRndpSUZ3aUtTNXlaWEJzWVdObEtFMHNYQ0lzSUZ3aUtTNXpjR3hwZENoY0lpQmNJaWtzVWoxU0xtcHZhVzRvWENJZ1hDSXBMbkpsY0d4aFkyVW9UU3hjSWl3Z1hDSXBMbk53YkdsMEtGd2lJRndpS1N4UFBWTXViR1Z1WjNSb0tTeFBJVDA5VWk1c1pXNW5kR2dtSmloVFBTaHVmSHhjSWx3aUtTNXpjR3hwZENoY0lpQmNJaWtzVHoxVExteGxibWQwYUNrc1lTNXdiSFZuYVc0OWJDeGhMbk5sZEZKaGRHbHZQV2dzZFdVdWJHRnpkRWx1WkdWNFBUQXNkVDB3TzA4K2RUdDFLeXNwYVdZb2NEMVRXM1ZkTEcwOVVsdDFYU3hVUFhCaGNuTmxSbXh2WVhRb2NDa3NWSHg4TUQwOVBWUXBZUzVoY0hCbGJtUllkSEpoS0Z3aVhDSXNWQ3h5WlNodExGUXBMRzB1Y21Wd2JHRmpaU2huTEZ3aVhDSXBMRUVtSmkweElUMDliUzVwYm1SbGVFOW1LRndpY0hoY0lpa3NJVEFwTzJWc2MyVWdhV1lvY2lZbWRXVXVkR1Z6ZENod0tTbFFQVndpTEZ3aVBUMDliUzVqYUdGeVFYUW9iUzVzWlc1bmRHZ3RNU2svWENJcExGd2lPbHdpS1Z3aUxHczlMVEVoUFQxdExtbHVaR1Y0VDJZb1hDSm9jMnhjSWlrbUpsa3NjRDFvWlNod0xHc3BMRzA5YUdVb2JTeHJLU3g0UFhBdWJHVnVaM1JvSzIwdWJHVnVaM1JvUGpZc2VDWW1JVmttSmpBOVBUMXRXek5kUHloaFcxd2llSE5jSWl0aExteGRLejFoTG13L1hDSWdkSEpoYm5Od1lYSmxiblJjSWpwY0luUnlZVzV6Y0dGeVpXNTBYQ0lzWVM1bFBXRXVaUzV6Y0d4cGRDaFNXM1ZkS1M1cWIybHVLRndpZEhKaGJuTndZWEpsYm5SY0lpa3BPaWhaZkh3b2VEMGhNU2tzYXo5aExtRndjR1Z1WkZoMGNtRW9lRDljSW1oemJHRW9YQ0k2WENKb2Myd29YQ0lzY0Zzd1hTeHlaU2h0V3pCZExIQmJNRjBwTEZ3aUxGd2lMQ0V4TENFd0tTNWhjSEJsYm1SWWRISmhLRndpWENJc2NGc3hYU3h5WlNodFd6RmRMSEJiTVYwcExGd2lKU3hjSWl3aE1Ta3VZWEJ3Wlc1a1dIUnlZU2hjSWx3aUxIQmJNbDBzY21Vb2JWc3lYU3h3V3pKZEtTeDRQMXdpSlN4Y0lqcGNJaVZjSWl0UUxDRXhLVHBoTG1Gd2NHVnVaRmgwY21Fb2VEOWNJbkpuWW1Fb1hDSTZYQ0p5WjJJb1hDSXNjRnN3WFN4dFd6QmRMWEJiTUYwc1hDSXNYQ0lzSVRBc0lUQXBMbUZ3Y0dWdVpGaDBjbUVvWENKY0lpeHdXekZkTEcxYk1WMHRjRnN4WFN4Y0lpeGNJaXdoTUNrdVlYQndaVzVrV0hSeVlTaGNJbHdpTEhCYk1sMHNiVnN5WFMxd1d6SmRMSGcvWENJc1hDSTZVQ3doTUNrc2VDWW1LSEE5TkQ1d0xteGxibWQwYUQ4eE9uQmJNMTBzWVM1aGNIQmxibVJZZEhKaEtGd2lYQ0lzY0N3b05ENXRMbXhsYm1kMGFEOHhPbTFiTTEwcExYQXNVQ3doTVNrcEtTeDFaUzVzWVhOMFNXNWtaWGc5TUR0bGJITmxJR2xtS0hZOWNDNXRZWFJqYUNoa0tTbDdhV1lvZVQxdExtMWhkR05vS0djcExDRjVmSHg1TG14bGJtZDBhQ0U5UFhZdWJHVnVaM1JvS1hKbGRIVnliaUJoTzJadmNpaG1QVEFzWXowd08zWXViR1Z1WjNSb1BtTTdZeXNyS1dJOWRsdGpYU3gzUFhBdWFXNWtaWGhQWmloaUxHWXBMR0V1WVhCd1pXNWtXSFJ5WVNod0xuTjFZbk4wY2lobUxIY3RaaWtzVG5WdFltVnlLR0lwTEhKbEtIbGJZMTBzWWlrc1hDSmNJaXhCSmlaY0luQjRYQ0k5UFQxd0xuTjFZbk4wY2loM0sySXViR1Z1WjNSb0xESXBMREE5UFQxaktTeG1QWGNyWWk1c1pXNW5kR2c3WVZ0Y0luaHpYQ0lyWVM1c1hTczljQzV6ZFdKemRISW9aaWw5Wld4elpTQmhXMXdpZUhOY0lpdGhMbXhkS3oxaExtdy9YQ0lnWENJcmNEcHdPMmxtS0MweElUMDljeTVwYm1SbGVFOW1LRndpUFZ3aUtTWW1ZUzVrWVhSaEtYdG1iM0lvVUQxaExuaHpNQ3RoTG1SaGRHRXVjeXgxUFRFN1lTNXNQblU3ZFNzcktWQXJQV0ZiWENKNGMxd2lLM1ZkSzJFdVpHRjBZVnRjSW5odVhDSXJkVjA3WVM1bFBWQXJZVnRjSW5oelhDSXJkVjE5Y21WMGRYSnVJR0V1Ykh4OEtHRXVkSGx3WlQwdE1TeGhMbmh6TUQxaExtVXBMR0V1ZUdacGNuTjBmSHhoZlN4MlpUMDVPMlp2Y2lob1BXMWxMbkJ5YjNSdmRIbHdaU3hvTG13OWFDNXdjajB3T3kwdGRtVStNRHNwYUZ0Y0luaHVYQ0lyZG1WZFBUQXNhRnRjSW5oelhDSXJkbVZkUFZ3aVhDSTdhQzU0Y3pBOVhDSmNJaXhvTGw5dVpYaDBQV2d1WDNCeVpYWTlhQzU0Wm1seWMzUTlhQzVrWVhSaFBXZ3VjR3gxWjJsdVBXZ3VjMlYwVW1GMGFXODlhQzV5ZUhBOWJuVnNiQ3hvTG1Gd2NHVnVaRmgwY21FOVpuVnVZM1JwYjI0b2RDeGxMR2tzY3l4eUxHNHBlM1poY2lCaFBYUm9hWE1zYnoxaExtdzdjbVYwZFhKdUlHRmJYQ0o0YzF3aUsyOWRLejF1SmladlAxd2lJRndpSzNRNmRIeDhYQ0pjSWl4cGZId3dQVDA5YjN4OFlTNXdiSFZuYVc0L0tHRXViQ3NyTEdFdWRIbHdaVDFoTG5ObGRGSmhkR2x2UHpJNk1TeGhXMXdpZUhOY0lpdGhMbXhkUFhOOGZGd2lYQ0lzYno0d1B5aGhMbVJoZEdGYlhDSjRibHdpSzI5ZFBXVXJhU3hoTG5KNGNGdGNJbmh1WENJcmIxMDljaXhoVzF3aWVHNWNJaXR2WFQxbExHRXVjR3gxWjJsdWZId29ZUzU0Wm1seWMzUTlibVYzSUcxbEtHRXNYQ0o0Ymx3aUsyOHNaU3hwTEdFdWVHWnBjbk4wZkh4aExEQXNZUzV1TEhJc1lTNXdjaWtzWVM1NFptbHljM1F1ZUhNd1BUQXBMR0VwT2loaExtUmhkR0U5ZTNNNlpTdHBmU3hoTG5KNGNEMTdmU3hoTG5NOVpTeGhMbU05YVN4aExuSTljaXhoS1NrNktHRmJYQ0o0YzF3aUsyOWRLejFsS3loemZIeGNJbHdpS1N4aEtYMDdkbUZ5SUhsbFBXWjFibU4wYVc5dUtIUXNaU2w3WlQxbGZIeDdmU3gwYUdsekxuQTlaUzV3Y21WbWFYZy9WeWgwS1h4OGREcDBMR3hiZEYwOWJGdDBhR2x6TG5CZFBYUm9hWE1zZEdocGN5NW1iM0p0WVhROVpTNW1iM0p0WVhSMFpYSjhmR05sS0dVdVpHVm1ZWFZzZEZaaGJIVmxMR1V1WTI5c2IzSXNaUzVqYjJ4c1lYQnphV0pzWlN4bExtMTFiSFJwS1N4bExuQmhjbk5sY2lZbUtIUm9hWE11Y0dGeWMyVTlaUzV3WVhKelpYSXBMSFJvYVhNdVkyeHljejFsTG1OdmJHOXlMSFJvYVhNdWJYVnNkR2s5WlM1dGRXeDBhU3gwYUdsekxtdGxlWGR2Y21ROVpTNXJaWGwzYjNKa0xIUm9hWE11Wkdac2REMWxMbVJsWm1GMWJIUldZV3gxWlN4MGFHbHpMbkJ5UFdVdWNISnBiM0pwZEhsOGZEQjlMRlJsUFVJdVgzSmxaMmx6ZEdWeVEyOXRjR3hsZUZOd1pXTnBZV3hRY205d1BXWjFibU4wYVc5dUtIUXNaU3hwS1h0Y0ltOWlhbVZqZEZ3aUlUMTBlWEJsYjJZZ1pTWW1LR1U5ZTNCaGNuTmxjanBwZlNrN2RtRnlJSE1zY2l4dVBYUXVjM0JzYVhRb1hDSXNYQ0lwTEdFOVpTNWtaV1poZFd4MFZtRnNkV1U3Wm05eUtHazlhWHg4VzJGZExITTlNRHR1TG14bGJtZDBhRDV6TzNNckt5bGxMbkJ5WldacGVEMHdQVDA5Y3lZbVpTNXdjbVZtYVhnc1pTNWtaV1poZFd4MFZtRnNkV1U5YVZ0elhYeDhZU3h5UFc1bGR5QjVaU2h1VzNOZExHVXBmU3g0WlQxbWRXNWpkR2x2YmloMEtYdHBaaWdoYkZ0MFhTbDdkbUZ5SUdVOWRDNWphR0Z5UVhRb01Da3VkRzlWY0hCbGNrTmhjMlVvS1N0MExuTjFZbk4wY2lneEtTdGNJbEJzZFdkcGJsd2lPMVJsS0hRc2UzQmhjbk5sY2pwbWRXNWpkR2x2YmloMExHa3NjeXh5TEc0c1lTeG9LWHQyWVhJZ1h6MXZMbU52YlM1bmNtVmxibk52WTJzdWNHeDFaMmx1YzF0bFhUdHlaWFIxY200Z1h6OG9YeTVmWTNOelVtVm5hWE4wWlhJb0tTeHNXM05kTG5CaGNuTmxLSFFzYVN4ekxISXNiaXhoTEdncEtUb29jU2hjSWtWeWNtOXlPaUJjSWl0bEsxd2lJR3B6SUdacGJHVWdibTkwSUd4dllXUmxaQzVjSWlrc2JpbDlmU2w5ZlR0b1BYbGxMbkJ5YjNSdmRIbHdaU3hvTG5CaGNuTmxRMjl0Y0d4bGVEMW1kVzVqZEdsdmJpaDBMR1VzYVN4ekxISXNiaWw3ZG1GeUlHRXNieXhzTEdnc1h5eDFMR005ZEdocGN5NXJaWGwzYjNKa08ybG1LSFJvYVhNdWJYVnNkR2ttSmloTkxuUmxjM1FvYVNsOGZFMHVkR1Z6ZENobEtUOG9iejFsTG5KbGNHeGhZMlVvVFN4Y0lueGNJaWt1YzNCc2FYUW9YQ0o4WENJcExHdzlhUzV5WlhCc1lXTmxLRTBzWENKOFhDSXBMbk53YkdsMEtGd2lmRndpS1NrNll5WW1LRzg5VzJWZExHdzlXMmxkS1Nrc2JDbDdabTl5S0dnOWJDNXNaVzVuZEdnK2J5NXNaVzVuZEdnL2JDNXNaVzVuZEdnNmJ5NXNaVzVuZEdnc1lUMHdPMmcrWVR0aEt5c3BaVDF2VzJGZFBXOWJZVjE4ZkhSb2FYTXVaR1pzZEN4cFBXeGJZVjA5YkZ0aFhYeDhkR2hwY3k1a1pteDBMR01tSmloZlBXVXVhVzVrWlhoUFppaGpLU3gxUFdrdWFXNWtaWGhQWmloaktTeGZJVDA5ZFNZbUtDMHhQVDA5ZFQ5dlcyRmRQVzliWVYwdWMzQnNhWFFvWXlrdWFtOXBiaWhjSWx3aUtUb3RNVDA5UFY4bUppaHZXMkZkS3oxY0lpQmNJaXRqS1NrcE8yVTlieTVxYjJsdUtGd2lMQ0JjSWlrc2FUMXNMbXB2YVc0b1hDSXNJRndpS1gxeVpYUjFjbTRnWjJVb2RDeDBhR2x6TG5Bc1pTeHBMSFJvYVhNdVkyeHljeXgwYUdsekxtUm1iSFFzY3l4MGFHbHpMbkJ5TEhJc2JpbDlMR2d1Y0dGeWMyVTlablZ1WTNScGIyNG9kQ3hsTEdrc2N5eHVMR0VwZTNKbGRIVnliaUIwYUdsekxuQmhjbk5sUTI5dGNHeGxlQ2gwTG5OMGVXeGxMSFJvYVhNdVptOXliV0YwS0ZFb2RDeDBhR2x6TG5Bc2Npd2hNU3gwYUdsekxtUm1iSFFwS1N4MGFHbHpMbVp2Y20xaGRDaGxLU3h1TEdFcGZTeGhMbkpsWjJsemRHVnlVM0JsWTJsaGJGQnliM0E5Wm5WdVkzUnBiMjRvZEN4bExHa3BlMVJsS0hRc2UzQmhjbk5sY2pwbWRXNWpkR2x2YmloMExITXNjaXh1TEdFc2J5bDdkbUZ5SUd3OWJtVjNJRzFsS0hRc2Npd3dMREFzWVN3eUxISXNJVEVzYVNrN2NtVjBkWEp1SUd3dWNHeDFaMmx1UFc4c2JDNXpaWFJTWVhScGJ6MWxLSFFzY3l4dUxsOTBkMlZsYml4eUtTeHNmU3h3Y21sdmNtbDBlVHBwZlNsOUxHRXVkWE5sVTFaSFZISmhibk5tYjNKdFFYUjBjajFqZkh4bU8zWmhjaUIzWlN4aVpUMWNJbk5qWVd4bFdDeHpZMkZzWlZrc2MyTmhiR1ZhTEhnc2VTeDZMSE5yWlhkWUxITnJaWGRaTEhKdmRHRjBhVzl1TEhKdmRHRjBhVzl1V0N4eWIzUmhkR2x2Ymxrc2NHVnljM0JsWTNScGRtVXNlRkJsY21ObGJuUXNlVkJsY21ObGJuUmNJaTV6Y0d4cGRDaGNJaXhjSWlrc1VHVTlWeWhjSW5SeVlXNXpabTl5YlZ3aUtTeHJaVDFXSzF3aWRISmhibk5tYjNKdFhDSXNVMlU5VnloY0luUnlZVzV6Wm05eWJVOXlhV2RwYmx3aUtTeFNaVDF1ZFd4c0lUMDlWeWhjSW5CbGNuTndaV04wYVhabFhDSXBMRTlsUFVJdVZISmhibk5tYjNKdFBXWjFibU4wYVc5dUtDbDdkR2hwY3k1d1pYSnpjR1ZqZEdsMlpUMXdZWEp6WlVac2IyRjBLR0V1WkdWbVlYVnNkRlJ5WVc1elptOXliVkJsY25Od1pXTjBhWFpsS1h4OE1DeDBhR2x6TG1admNtTmxNMFE5WVM1a1pXWmhkV3gwUm05eVkyVXpSQ0U5UFNFeEppWlNaVDloTG1SbFptRjFiSFJHYjNKalpUTkVmSHhjSW1GMWRHOWNJam9oTVgwc1FXVTlkMmx1Wkc5M0xsTldSMFZzWlcxbGJuUXNRMlU5Wm5WdVkzUnBiMjRvZEN4bExHa3BlM1poY2lCekxISTlSUzVqY21WaGRHVkZiR1Z0Wlc1MFRsTW9YQ0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaMXdpTEhRcExHNDlMeWhiWVMxNlhTa29XMEV0V2wwcEwyYzdabTl5S0hNZ2FXNGdhU2x5TG5ObGRFRjBkSEpwWW5WMFpVNVRLRzUxYkd3c2N5NXlaWEJzWVdObEtHNHNYQ0lrTVMwa01sd2lLUzUwYjB4dmQyVnlRMkZ6WlNncExHbGJjMTBwTzNKbGRIVnliaUJsTG1Gd2NHVnVaRU5vYVd4a0tISXBMSEo5TEVSbFBVVXVaRzlqZFcxbGJuUkZiR1Z0Wlc1MExFMWxQV1oxYm1OMGFXOXVLQ2w3ZG1GeUlIUXNaU3hwTEhNOWJYeDhMMEZ1WkhKdmFXUXZhUzUwWlhOMEtHb3BKaVloZDJsdVpHOTNMbU5vY205dFpUdHlaWFIxY200Z1JTNWpjbVZoZEdWRmJHVnRaVzUwVGxNbUppRnpKaVlvZEQxRFpTaGNJbk4yWjF3aUxFUmxLU3hsUFVObEtGd2ljbVZqZEZ3aUxIUXNlM2RwWkhSb09qRXdNQ3hvWldsbmFIUTZOVEFzZURveE1EQjlLU3hwUFdVdVoyVjBRbTkxYm1ScGJtZERiR2xsYm5SU1pXTjBLQ2t1ZDJsa2RHZ3NaUzV6ZEhsc1pWdFRaVjA5WENJMU1DVWdOVEFsWENJc1pTNXpkSGxzWlZ0UVpWMDlYQ0p6WTJGc1pWZ29NQzQxS1Z3aUxITTlhVDA5UFdVdVoyVjBRbTkxYm1ScGJtZERiR2xsYm5SU1pXTjBLQ2t1ZDJsa2RHZ21KaUVvWmlZbVVtVXBMRVJsTG5KbGJXOTJaVU5vYVd4a0tIUXBLU3h6ZlNncExIcGxQV1oxYm1OMGFXOXVLSFFzWlN4cExITXNjaWw3ZG1GeUlHNHNieXhzTEdnc1h5eDFMR01zWml4d0xHMHNaQ3huTEhZc2VTeFVQWFF1WDJkelZISmhibk5tYjNKdExIZzlSV1VvZEN3aE1DazdWQ1ltS0hZOVZDNTRUM0pwWjJsdUxIazlWQzU1VDNKcFoybHVLU3dvSVhOOGZESStLRzQ5Y3k1emNHeHBkQ2hjSWlCY0lpa3BMbXhsYm1kMGFDa21KaWhqUFhRdVoyVjBRa0p2ZUNncExHVTljMlVvWlNrdWMzQnNhWFFvWENJZ1hDSXBMRzQ5V3lndE1TRTlQV1ZiTUYwdWFXNWtaWGhQWmloY0lpVmNJaWsvY0dGeWMyVkdiRzloZENobFd6QmRLUzh4TURBcVl5NTNhV1IwYURwd1lYSnpaVVpzYjJGMEtHVmJNRjBwS1N0akxuZ3NLQzB4SVQwOVpWc3hYUzVwYm1SbGVFOW1LRndpSlZ3aUtUOXdZWEp6WlVac2IyRjBLR1ZiTVYwcEx6RXdNQ3BqTG1obGFXZG9kRHB3WVhKelpVWnNiMkYwS0dWYk1WMHBLU3RqTG5sZEtTeHBMbmhQY21sbmFXNDlhRDF3WVhKelpVWnNiMkYwS0c1Yk1GMHBMR2t1ZVU5eWFXZHBiajFmUFhCaGNuTmxSbXh2WVhRb2Jsc3hYU2tzY3lZbWVDRTlQVWxsSmlZb2RUMTRXekJkTEdNOWVGc3hYU3htUFhoYk1sMHNjRDE0V3pOZExHMDllRnMwWFN4a1BYaGJOVjBzWnoxMUtuQXRZeXBtTEc4OWFDb29jQzluS1N0ZktpZ3RaaTluS1Nzb1ppcGtMWEFxYlNrdlp5eHNQV2dxS0MxakwyY3BLMThxS0hVdlp5a3RLSFVxWkMxakttMHBMMmNzYUQxcExuaFBjbWxuYVc0OWJsc3dYVDF2TEY4OWFTNTVUM0pwWjJsdVBXNWJNVjA5YkNrc1ZDWW1LSEo4ZkhJaFBUMGhNU1ltWVM1a1pXWmhkV3gwVTIxdmIzUm9UM0pwWjJsdUlUMDlJVEUvS0c4OWFDMTJMR3c5WHkxNUxGUXVlRTltWm5ObGRDczlieXA0V3pCZEsyd3FlRnN5WFMxdkxGUXVlVTltWm5ObGRDczlieXA0V3pGZEsyd3FlRnN6WFMxc0tUcFVMbmhQWm1aelpYUTlWQzU1VDJabWMyVjBQVEFwTEhRdWMyVjBRWFIwY21saWRYUmxLRndpWkdGMFlTMXpkbWN0YjNKcFoybHVYQ0lzYmk1cWIybHVLRndpSUZ3aUtTbDlMRVpsUFdaMWJtTjBhVzl1S0hRcGUzSmxkSFZ5YmlFaEtFRmxKaVpjSW1aMWJtTjBhVzl1WENJOVBYUjVjR1Z2WmlCMExtZGxkRUpDYjNnbUpuUXVaMlYwUTFSTkppWW9JWFF1Y0dGeVpXNTBUbTlrWlh4OGRDNXdZWEpsYm5ST2IyUmxMbWRsZEVKQ2IzZ21KblF1Y0dGeVpXNTBUbTlrWlM1blpYUkRWRTBwS1gwc1NXVTlXekVzTUN3d0xERXNNQ3d3WFN4RlpUMW1kVzVqZEdsdmJpaDBMR1VwZTNaaGNpQnBMSE1zY2l4dUxHRXNiejEwTGw5bmMxUnlZVzV6Wm05eWJYeDhibVYzSUU5bExHdzlNV1UxTzJsbUtGQmxQM005VVNoMExHdGxMRzUxYkd3c0lUQXBPblF1WTNWeWNtVnVkRk4wZVd4bEppWW9jejEwTG1OMWNuSmxiblJUZEhsc1pTNW1hV3gwWlhJdWJXRjBZMmdvUXlrc2N6MXpKaVkwUFQwOWN5NXNaVzVuZEdnL1czTmJNRjB1YzNWaWMzUnlLRFFwTEU1MWJXSmxjaWh6V3pKZExuTjFZbk4wY2lnMEtTa3NUblZ0WW1WeUtITmJNVjB1YzNWaWMzUnlLRFFwS1N4eld6TmRMbk4xWW5OMGNpZzBLU3h2TG5oOGZEQXNieTU1Zkh3d1hTNXFiMmx1S0Z3aUxGd2lLVHBjSWx3aUtTeHBQU0Z6Zkh4Y0ltNXZibVZjSWowOVBYTjhmRndpYldGMGNtbDRLREVzSURBc0lEQXNJREVzSURBc0lEQXBYQ0k5UFQxekxDaHZMbk4yWjN4OGRDNW5aWFJDUW05NEppWkdaU2gwS1NrbUppaHBKaVl0TVNFOVBTaDBMbk4wZVd4bFcxQmxYU3RjSWx3aUtTNXBibVJsZUU5bUtGd2liV0YwY21sNFhDSXBKaVlvY3oxMExuTjBlV3hsVzFCbFhTeHBQVEFwTEhJOWRDNW5aWFJCZEhSeWFXSjFkR1VvWENKMGNtRnVjMlp2Y20xY0lpa3NhU1ltY2lZbUtDMHhJVDA5Y2k1cGJtUmxlRTltS0Z3aWJXRjBjbWw0WENJcFB5aHpQWElzYVQwd0tUb3RNU0U5UFhJdWFXNWtaWGhQWmloY0luUnlZVzV6YkdGMFpWd2lLU1ltS0hNOVhDSnRZWFJ5YVhnb01Td3dMREFzTVN4Y0lpdHlMbTFoZEdOb0tDOG9QenBjWEMxOFhGeGlLVnRjWEdSY1hDMWNYQzVsWFN0Y1hHSXZaMmtwTG1wdmFXNG9YQ0lzWENJcEsxd2lLVndpTEdrOU1Da3BLU3hwS1hKbGRIVnliaUJKWlR0bWIzSW9jajBvYzN4OFhDSmNJaWt1YldGMFkyZ29MeWcvT2x4Y0xYeGNYR0lwVzF4Y1pGeGNMVnhjTG1WZEsxeGNZaTluYVNsOGZGdGRMSFpsUFhJdWJHVnVaM1JvT3kwdGRtVStMVEU3S1c0OVRuVnRZbVZ5S0hKYmRtVmRLU3h5VzNabFhUMG9ZVDF1TFNodWZEMHdLU2svS0RCOFlTcHNLeWd3UG1FL0xTNDFPaTQxS1NrdmJDdHVPbTQ3Y21WMGRYSnVJR1VtSm5JdWJHVnVaM1JvUGpZL1czSmJNRjBzY2xzeFhTeHlXelJkTEhKYk5WMHNjbHN4TWwwc2Nsc3hNMTFkT25KOUxFNWxQVUl1WjJWMFZISmhibk5tYjNKdFBXWjFibU4wYVc5dUtIUXNhU3h6TEc0cGUybG1LSFF1WDJkelZISmhibk5tYjNKdEppWnpKaVloYmlseVpYUjFjbTRnZEM1ZlozTlVjbUZ1YzJadmNtMDdkbUZ5SUc4c2JDeG9MRjhzZFN4akxHWTljejkwTGw5bmMxUnlZVzV6Wm05eWJYeDhibVYzSUU5bE9tNWxkeUJQWlN4d1BUQStaaTV6WTJGc1pWZ3NiVDB5WlMwMUxHUTlNV1UxTEdjOVVtVS9jR0Z5YzJWR2JHOWhkQ2hSS0hRc1UyVXNhU3doTVN4Y0lqQWdNQ0F3WENJcExuTndiR2wwS0Z3aUlGd2lLVnN5WFNsOGZHWXVlazl5YVdkcGJueDhNRG93TEhZOWNHRnljMlZHYkc5aGRDaGhMbVJsWm1GMWJIUlVjbUZ1YzJadmNtMVFaWEp6Y0dWamRHbDJaU2w4ZkRBN2FXWW9aaTV6ZG1jOUlTZ2hkQzVuWlhSQ1FtOTRmSHdoUm1Vb2RDa3BMR1l1YzNabkppWW9lbVVvZEN4UktIUXNVMlVzY2l3aE1TeGNJalV3SlNBMU1DVmNJaWtyWENKY0lpeG1MSFF1WjJWMFFYUjBjbWxpZFhSbEtGd2laR0YwWVMxemRtY3RiM0pwWjJsdVhDSXBLU3gzWlQxaExuVnpaVk5XUjFSeVlXNXpabTl5YlVGMGRISjhmRTFsS1N4dlBVVmxLSFFwTEc4aFBUMUpaU2w3YVdZb01UWTlQVDF2TG14bGJtZDBhQ2w3ZG1GeUlIa3NWQ3g0TEhjc1lpeFFQVzliTUYwc2F6MXZXekZkTEZNOWIxc3lYU3hTUFc5Yk0xMHNUejF2V3pSZExFRTliMXMxWFN4RFBXOWJObDBzUkQxdld6ZGRMRTA5YjFzNFhTeDZQVzliT1Ywc1NUMXZXekV3WFN4RlBXOWJNVEpkTEU0OWIxc3hNMTBzVEQxdld6RTBYU3hZUFc5Yk1URmRMRUk5VFdGMGFDNWhkR0Z1TWloRExFa3BPMll1ZWs5eWFXZHBiaVltS0V3OUxXWXVlazl5YVdkcGJpeEZQVTBxVEMxdld6RXlYU3hPUFhvcVRDMXZXekV6WFN4TVBVa3FUQ3RtTG5wUGNtbG5hVzR0YjFzeE5GMHBMR1l1Y205MFlYUnBiMjVZUFVJcVJpeENKaVlvZHoxTllYUm9MbU52Y3lndFFpa3NZajFOWVhSb0xuTnBiaWd0UWlrc2VUMVBLbmNyVFNwaUxGUTlRU3AzSzNvcVlpeDRQVU1xZHl0SkttSXNUVDFQS2kxaUswMHFkeXg2UFVFcUxXSXJlaXAzTEVrOVF5b3RZaXRKS25jc1dEMUVLaTFpSzFncWR5eFBQWGtzUVQxVUxFTTllQ2tzUWoxTllYUm9MbUYwWVc0eUtFMHNTU2tzWmk1eWIzUmhkR2x2YmxrOVFpcEdMRUltSmloM1BVMWhkR2d1WTI5ektDMUNLU3hpUFUxaGRHZ3VjMmx1S0MxQ0tTeDVQVkFxZHkxTkttSXNWRDFyS25jdGVpcGlMSGc5VXlwM0xVa3FZaXg2UFdzcVlpdDZLbmNzU1QxVEttSXJTU3AzTEZnOVVpcGlLMWdxZHl4UVBYa3NhejFVTEZNOWVDa3NRajFOWVhSb0xtRjBZVzR5S0dzc1VDa3NaaTV5YjNSaGRHbHZiajFDS2tZc1FpWW1LSGM5VFdGMGFDNWpiM01vTFVJcExHSTlUV0YwYUM1emFXNG9MVUlwTEZBOVVDcDNLMDhxWWl4VVBXc3FkeXRCS21Jc1FUMXJLaTFpSzBFcWR5eERQVk1xTFdJclF5cDNMR3M5VkNrc1ppNXliM1JoZEdsdmJsZ21KazFoZEdndVlXSnpLR1l1Y205MFlYUnBiMjVZS1N0TllYUm9MbUZpY3lobUxuSnZkR0YwYVc5dUtUNHpOVGt1T1NZbUtHWXVjbTkwWVhScGIyNVlQV1l1Y205MFlYUnBiMjQ5TUN4bUxuSnZkR0YwYVc5dVdTczlNVGd3S1N4bUxuTmpZV3hsV0Qwb01IeE5ZWFJvTG5OeGNuUW9VQ3BRSzJzcWF5a3FaQ3N1TlNrdlpDeG1Mbk5qWVd4bFdUMG9NSHhOWVhSb0xuTnhjblFvUVNwQkszb3FlaWtxWkNzdU5Ta3ZaQ3htTG5OallXeGxXajBvTUh4TllYUm9Mbk54Y25Rb1F5cERLMGtxU1NrcVpDc3VOU2t2WkN4bUxuTnJaWGRZUFRBc1ppNXdaWEp6Y0dWamRHbDJaVDFZUHpFdktEQStXRDh0V0RwWUtUb3dMR1l1ZUQxRkxHWXVlVDFPTEdZdWVqMU1MR1l1YzNabkppWW9aaTU0TFQxbUxuaFBjbWxuYVc0dEtHWXVlRTl5YVdkcGJpcFFMV1l1ZVU5eWFXZHBiaXBQS1N4bUxua3RQV1l1ZVU5eWFXZHBiaTBvWmk1NVQzSnBaMmx1S21zdFppNTRUM0pwWjJsdUtrRXBLWDFsYkhObElHbG1LQ0VvVW1VbUppRnVKaVp2TG14bGJtZDBhQ1ltWmk1NFBUMDliMXMwWFNZbVppNTVQVDA5YjFzMVhTWW1LR1l1Y205MFlYUnBiMjVZZkh4bUxuSnZkR0YwYVc5dVdTbDhmSFp2YVdRZ01DRTlQV1l1ZUNZbVhDSnViMjVsWENJOVBUMVJLSFFzWENKa2FYTndiR0Y1WENJc2FTa3BLWHQyWVhJZ2FqMXZMbXhsYm1kMGFENDlOaXhaUFdvL2Ixc3dYVG94TEZVOWIxc3hYWHg4TUN4eFBXOWJNbDE4ZkRBc1ZqMXFQMjliTTEwNk1UdG1Mbmc5YjFzMFhYeDhNQ3htTG5rOWIxczFYWHg4TUN4b1BVMWhkR2d1YzNGeWRDaFpLbGtyVlNwVktTeGZQVTFoZEdndWMzRnlkQ2hXS2xZcmNTcHhLU3gxUFZsOGZGVS9UV0YwYUM1aGRHRnVNaWhWTEZrcEtrWTZaaTV5YjNSaGRHbHZibng4TUN4alBYRjhmRlkvVFdGMGFDNWhkR0Z1TWloeExGWXBLa1lyZFRwbUxuTnJaWGRZZkh3d0xFMWhkR2d1WVdKektHTXBQamt3SmlZeU56QStUV0YwYUM1aFluTW9ZeWttSmlod1B5aG9LajB0TVN4akt6MHdQajExUHpFNE1Eb3RNVGd3TEhVclBUQStQWFUvTVRnd09pMHhPREFwT2loZktqMHRNU3hqS3owd1BqMWpQekU0TURvdE1UZ3dLU2tzWmk1elkyRnNaVmc5YUN4bUxuTmpZV3hsV1QxZkxHWXVjbTkwWVhScGIyNDlkU3htTG5OclpYZFlQV01zVW1VbUppaG1Mbkp2ZEdGMGFXOXVXRDFtTG5KdmRHRjBhVzl1V1QxbUxubzlNQ3htTG5CbGNuTndaV04wYVhabFBYWXNaaTV6WTJGc1pWbzlNU2tzWmk1emRtY21KaWhtTG5ndFBXWXVlRTl5YVdkcGJpMG9aaTU0VDNKcFoybHVLbGtyWmk1NVQzSnBaMmx1S25FcExHWXVlUzA5Wmk1NVQzSnBaMmx1TFNobUxuaFBjbWxuYVc0cVZTdG1MbmxQY21sbmFXNHFWaWtwZldZdWVrOXlhV2RwYmoxbk8yWnZjaWhzSUdsdUlHWXBiVDVtVzJ4ZEppWm1XMnhkUGkxdEppWW9abHRzWFQwd0tYMXlaWFIxY200Z2N5WW1LSFF1WDJkelZISmhibk5tYjNKdFBXWXNaaTV6ZG1jbUppaDNaU1ltZEM1emRIbHNaVnRRWlYwL1pTNWtaV3hoZVdWa1EyRnNiQ2d1TURBeExHWjFibU4wYVc5dUtDbDdhbVVvZEM1emRIbHNaU3hRWlNsOUtUb2hkMlVtSm5RdVoyVjBRWFIwY21saWRYUmxLRndpZEhKaGJuTm1iM0p0WENJcEppWmxMbVJsYkdGNVpXUkRZV3hzS0M0d01ERXNablZ1WTNScGIyNG9LWHQwTG5KbGJXOTJaVUYwZEhKcFluVjBaU2hjSW5SeVlXNXpabTl5YlZ3aUtYMHBLU2tzWm4wc1RHVTlablZ1WTNScGIyNG9kQ2w3ZG1GeUlHVXNhU3h6UFhSb2FYTXVaR0YwWVN4eVBTMXpMbkp2ZEdGMGFXOXVLbm9zYmoxeUszTXVjMnRsZDFncWVpeGhQVEZsTlN4dlBTZ3dmRTFoZEdndVkyOXpLSElwS25NdWMyTmhiR1ZZS21FcEwyRXNiRDBvTUh4TllYUm9Mbk5wYmloeUtTcHpMbk5qWVd4bFdDcGhLUzloTEdnOUtEQjhUV0YwYUM1emFXNG9iaWtxTFhNdWMyTmhiR1ZaS21FcEwyRXNYejBvTUh4TllYUm9MbU52Y3lodUtTcHpMbk5qWVd4bFdTcGhLUzloTEhVOWRHaHBjeTUwTG5OMGVXeGxMR005ZEdocGN5NTBMbU4xY25KbGJuUlRkSGxzWlR0cFppaGpLWHRwUFd3c2JEMHRhQ3hvUFMxcExHVTlZeTVtYVd4MFpYSXNkUzVtYVd4MFpYSTlYQ0pjSWp0MllYSWdaaXh3TEdROWRHaHBjeTUwTG05bVpuTmxkRmRwWkhSb0xHYzlkR2hwY3k1MExtOW1abk5sZEVobGFXZG9kQ3gyUFZ3aVlXSnpiMngxZEdWY0lpRTlQV011Y0c5emFYUnBiMjRzZVQxY0luQnliMmRwWkRwRVdFbHRZV2RsVkhKaGJuTm1iM0p0TGsxcFkzSnZjMjltZEM1TllYUnlhWGdvVFRFeFBWd2lLMjhyWENJc0lFMHhNajFjSWl0c0sxd2lMQ0JOTWpFOVhDSXJhQ3RjSWl3Z1RUSXlQVndpSzE4c2R6MXpMbmdyWkNwekxuaFFaWEpqWlc1MEx6RXdNQ3hpUFhNdWVTdG5Lbk11ZVZCbGNtTmxiblF2TVRBd08ybG1LRzUxYkd3aFBYTXViM2dtSmlobVBTaHpMbTk0Y0Q4dU1ERXFaQ3B6TG05NE9uTXViM2dwTFdRdk1peHdQU2h6TG05NWNEOHVNREVxWnlwekxtOTVPbk11YjNrcExXY3ZNaXgzS3oxbUxTaG1LbThyY0Nwc0tTeGlLejF3TFNobUttZ3JjQ3BmS1Nrc2RqOG9aajFrTHpJc2NEMW5MeklzZVNzOVhDSXNJRVI0UFZ3aUt5aG1MU2htS204cmNDcHNLU3QzS1N0Y0lpd2dSSGs5WENJcktIQXRLR1lxYUN0d0tsOHBLMklwSzF3aUtWd2lLVHA1S3oxY0lpd2djMmw2YVc1blRXVjBhRzlrUFNkaGRYUnZJR1Y0Y0dGdVpDY3BYQ0lzZFM1bWFXeDBaWEk5TFRFaFBUMWxMbWx1WkdWNFQyWW9YQ0pFV0VsdFlXZGxWSEpoYm5ObWIzSnRMazFwWTNKdmMyOW1kQzVOWVhSeWFYZ29YQ0lwUDJVdWNtVndiR0ZqWlNoRUxIa3BPbmtyWENJZ1hDSXJaU3dvTUQwOVBYUjhmREU5UFQxMEtTWW1NVDA5UFc4bUpqQTlQVDFzSmlZd1BUMDlhQ1ltTVQwOVBWOG1KaWgySmlZdE1UMDlQWGt1YVc1a1pYaFBaaWhjSWtSNFBUQXNJRVI1UFRCY0lpbDhmSGd1ZEdWemRDaGxLU1ltTVRBd0lUMDljR0Z5YzJWR2JHOWhkQ2hTWldkRmVIQXVKREVwZkh3dE1UMDlQV1V1YVc1a1pYaFBaaWhjSW1keVlXUnBaVzUwS0Z3aUppWmxMbWx1WkdWNFQyWW9YQ0pCYkhCb1lWd2lLU2ttSm5VdWNtVnRiM1psUVhSMGNtbGlkWFJsS0Z3aVptbHNkR1Z5WENJcEtTd2hkaWw3ZG1GeUlGQXNheXhUTEZJOU9ENXRQekU2TFRFN1ptOXlLR1k5Y3k1cFpVOW1abk5sZEZoOGZEQXNjRDF6TG1sbFQyWm1jMlYwV1h4OE1DeHpMbWxsVDJabWMyVjBXRDFOWVhSb0xuSnZkVzVrS0Noa0xTZ29NRDV2UHkxdk9tOHBLbVFyS0RBK2JEOHRiRHBzS1NwbktTa3ZNaXQzS1N4ekxtbGxUMlptYzJWMFdUMU5ZWFJvTG5KdmRXNWtLQ2huTFNnb01ENWZQeTFmT2w4cEttY3JLREErYUQ4dGFEcG9LU3BrS1Nrdk1pdGlLU3gyWlQwd096UStkbVU3ZG1Vckt5bHJQV1ZsVzNabFhTeFFQV05iYTEwc2FUMHRNU0U5UFZBdWFXNWtaWGhQWmloY0luQjRYQ0lwUDNCaGNuTmxSbXh2WVhRb1VDazZKQ2gwYUdsekxuUXNheXh3WVhKelpVWnNiMkYwS0ZBcExGQXVjbVZ3YkdGalpTaFVMRndpWENJcEtYeDhNQ3hUUFdraFBUMXpXMnRkUHpJK2RtVS9MWE11YVdWUFptWnpaWFJZT2kxekxtbGxUMlptYzJWMFdUb3lQblpsUDJZdGN5NXBaVTltWm5ObGRGZzZjQzF6TG1sbFQyWm1jMlYwV1N4MVcydGRQU2h6VzJ0ZFBVMWhkR2d1Y205MWJtUW9hUzFUS2lnd1BUMDlkbVY4ZkRJOVBUMTJaVDh4T2xJcEtTa3JYQ0p3ZUZ3aWZYMTlMRmhsUFVJdWMyVjBNMFJVY21GdWMyWnZjbTFTWVhScGJ6MUNMbk5sZEZSeVlXNXpabTl5YlZKaGRHbHZQV1oxYm1OMGFXOXVLSFFwZTNaaGNpQmxMR2tzY3l4eUxHNHNZU3h2TEd3c2FDeGZMSFVzWXl4d0xHMHNaQ3huTEhZc2VTeFVMSGdzZHl4aUxGQXNhejEwYUdsekxtUmhkR0VzVXoxMGFHbHpMblF1YzNSNWJHVXNVajFyTG5KdmRHRjBhVzl1TEU4OWF5NXliM1JoZEdsdmJsZ3NRVDFyTG5KdmRHRjBhVzl1V1N4RFBXc3VjMk5oYkdWWUxFUTlheTV6WTJGc1pWa3NUVDFyTG5OallXeGxXaXhHUFdzdWVDeEpQV3N1ZVN4RlBXc3VlaXhPUFdzdWMzWm5MRXc5YXk1d1pYSnpjR1ZqZEdsMlpTeFlQV3N1Wm05eVkyVXpSRHRwWmlnaEtDZ29NU0U5UFhRbUpqQWhQVDEwZkh4Y0ltRjFkRzljSWlFOVBWaDhmSFJvYVhNdWRIZGxaVzR1WDNSdmRHRnNWR2x0WlNFOVBYUm9hWE11ZEhkbFpXNHVYM1J2ZEdGc1JIVnlZWFJwYjI0bUpuUm9hWE11ZEhkbFpXNHVYM1J2ZEdGc1ZHbHRaU2ttSmxoOGZFVjhmRXg4ZkVGOGZFOHBKaVlvSVhkbGZId2hUaWttSmxKbEtTbHlaWFIxY200Z1VueDhheTV6YTJWM1dIeDhUajhvVWlvOWVpeGlQV3N1YzJ0bGQxZ3FlaXhRUFRGbE5TeGxQVTFoZEdndVkyOXpLRklwS2tNc2NqMU5ZWFJvTG5OcGJpaFNLU3BETEdrOVRXRjBhQzV6YVc0b1VpMWlLU290UkN4dVBVMWhkR2d1WTI5ektGSXRZaWtxUkN4aUppWmNJbk5wYlhCc1pWd2lQVDA5YXk1emEyVjNWSGx3WlNZbUtIWTlUV0YwYUM1MFlXNG9ZaWtzZGoxTllYUm9Mbk54Y25Rb01TdDJLbllwTEdrcVBYWXNiaW85ZGl4ckxuTnJaWGRaSmlZb1pTbzlkaXh5S2oxMktTa3NUaVltS0VZclBXc3VlRTl5YVdkcGJpMG9heTU0VDNKcFoybHVLbVVyYXk1NVQzSnBaMmx1S21rcEsyc3VlRTltWm5ObGRDeEpLejFyTG5sUGNtbG5hVzR0S0dzdWVFOXlhV2RwYmlweUsyc3VlVTl5YVdkcGJpcHVLU3RyTG5sUFptWnpaWFFzZDJVbUppaHJMbmhRWlhKalpXNTBmSHhyTG5sUVpYSmpaVzUwS1NZbUtHMDlkR2hwY3k1MExtZGxkRUpDYjNnb0tTeEdLejB1TURFcWF5NTRVR1Z5WTJWdWRDcHRMbmRwWkhSb0xFa3JQUzR3TVNwckxubFFaWEpqWlc1MEttMHVhR1ZwWjJoMEtTeHRQVEZsTFRZc2JUNUdKaVpHUGkxdEppWW9SajB3S1N4dFBra21Ka2srTFcwbUppaEpQVEFwS1N4VVBTZ3dmR1VxVUNrdlVDdGNJaXhjSWlzb01IeHlLbEFwTDFBclhDSXNYQ0lyS0RCOGFTcFFLUzlRSzF3aUxGd2lLeWd3Zkc0cVVDa3ZVQ3RjSWl4Y0lpdEdLMXdpTEZ3aUswa3JYQ0lwWENJc1RpWW1kMlUvZEdocGN5NTBMbk5sZEVGMGRISnBZblYwWlNoY0luUnlZVzV6Wm05eWJWd2lMRndpYldGMGNtbDRLRndpSzFRcE9sTmJVR1ZkUFNockxuaFFaWEpqWlc1MGZIeHJMbmxRWlhKalpXNTBQMXdpZEhKaGJuTnNZWFJsS0Z3aUsyc3VlRkJsY21ObGJuUXJYQ0lsTEZ3aUsyc3VlVkJsY21ObGJuUXJYQ0lsS1NCdFlYUnlhWGdvWENJNlhDSnRZWFJ5YVhnb1hDSXBLMVFwT2xOYlVHVmRQU2hyTG5oUVpYSmpaVzUwZkh4ckxubFFaWEpqWlc1MFAxd2lkSEpoYm5Oc1lYUmxLRndpSzJzdWVGQmxjbU5sYm5RclhDSWxMRndpSzJzdWVWQmxjbU5sYm5RclhDSWxLU0J0WVhSeWFYZ29YQ0k2WENKdFlYUnlhWGdvWENJcEswTXJYQ0lzTUN3d0xGd2lLMFFyWENJc1hDSXJSaXRjSWl4Y0lpdEpLMXdpS1Z3aUxIWnZhV1FnTUR0cFppaG1KaVlvYlQweFpTMDBMRzArUXlZbVF6NHRiU1ltS0VNOVRUMHlaUzAxS1N4dFBrUW1Ka1ErTFcwbUppaEVQVTA5TW1VdE5Ta3NJVXg4ZkdzdWVueDhheTV5YjNSaGRHbHZibGg4ZkdzdWNtOTBZWFJwYjI1WmZId29URDB3S1Nrc1VueDhheTV6YTJWM1dDbFNLajE2TEdROVpUMU5ZWFJvTG1OdmN5aFNLU3huUFhJOVRXRjBhQzV6YVc0b1Vpa3NheTV6YTJWM1dDWW1LRkl0UFdzdWMydGxkMWdxZWl4a1BVMWhkR2d1WTI5ektGSXBMR2M5VFdGMGFDNXphVzRvVWlrc1hDSnphVzF3YkdWY0lqMDlQV3N1YzJ0bGQxUjVjR1VtSmloMlBVMWhkR2d1ZEdGdUtHc3VjMnRsZDFncWVpa3NkajFOWVhSb0xuTnhjblFvTVN0MktuWXBMR1FxUFhZc1p5bzlkaXhyTG5OclpYZFpKaVlvWlNvOWRpeHlLajEyS1NrcExHazlMV2NzYmoxa08yVnNjMlY3YVdZb0lTaEJmSHhQZkh3eElUMDlUWHg4VEh4OFRpa3BjbVYwZFhKdUlGTmJVR1ZkUFNockxuaFFaWEpqWlc1MGZIeHJMbmxRWlhKalpXNTBQMXdpZEhKaGJuTnNZWFJsS0Z3aUsyc3VlRkJsY21ObGJuUXJYQ0lsTEZ3aUsyc3VlVkJsY21ObGJuUXJYQ0lsS1NCMGNtRnVjMnhoZEdVelpDaGNJanBjSW5SeVlXNXpiR0YwWlROa0tGd2lLU3RHSzF3aWNIZ3NYQ0lyU1N0Y0luQjRMRndpSzBVclhDSndlQ2xjSWlzb01TRTlQVU44ZkRFaFBUMUVQMXdpSUhOallXeGxLRndpSzBNclhDSXNYQ0lyUkN0Y0lpbGNJanBjSWx3aUtTeDJiMmxrSURBN1pUMXVQVEVzYVQxeVBUQjlhRDB4TEhNOVlUMXZQV3c5WHoxMVBUQXNZejFNUHkweEwwdzZNQ3h3UFdzdWVrOXlhV2RwYml4dFBURmxMVFlzZUQxY0lpeGNJaXgzUFZ3aU1Gd2lMRkk5UVNwNkxGSW1KaWhrUFUxaGRHZ3VZMjl6S0ZJcExHYzlUV0YwYUM1emFXNG9VaWtzYnowdFp5eGZQV01xTFdjc2N6MWxLbWNzWVQxeUttY3NhRDFrTEdNcVBXUXNaU285WkN4eUtqMWtLU3hTUFU4cWVpeFNKaVlvWkQxTllYUm9MbU52Y3loU0tTeG5QVTFoZEdndWMybHVLRklwTEhZOWFTcGtLM01xWnl4NVBXNHFaQ3RoS21jc2JEMW9LbWNzZFQxakttY3NjejFwS2kxbkszTXFaQ3hoUFc0cUxXY3JZU3BrTEdncVBXUXNZeW85WkN4cFBYWXNiajE1S1N3eElUMDlUU1ltS0hNcVBVMHNZU285VFN4b0tqMU5MR01xUFUwcExERWhQVDFFSmlZb2FTbzlSQ3h1S2oxRUxHd3FQVVFzZFNvOVJDa3NNU0U5UFVNbUppaGxLajFETEhJcVBVTXNieW85UXl4ZktqMURLU3dvY0h4OFRpa21KaWh3SmlZb1JpczljeW90Y0N4Skt6MWhLaTF3TEVVclBXZ3FMWEFyY0Nrc1RpWW1LRVlyUFdzdWVFOXlhV2RwYmkwb2F5NTRUM0pwWjJsdUttVXJheTU1VDNKcFoybHVLbWtwSzJzdWVFOW1abk5sZEN4Skt6MXJMbmxQY21sbmFXNHRLR3N1ZUU5eWFXZHBiaXB5SzJzdWVVOXlhV2RwYmlwdUtTdHJMbmxQWm1aelpYUXBMRzArUmlZbVJqNHRiU1ltS0VZOWR5a3NiVDVKSmlaSlBpMXRKaVlvU1QxM0tTeHRQa1VtSmtVK0xXMG1KaWhGUFRBcEtTeFVQV3N1ZUZCbGNtTmxiblI4ZkdzdWVWQmxjbU5sYm5RL1hDSjBjbUZ1YzJ4aGRHVW9YQ0lyYXk1NFVHVnlZMlZ1ZEN0Y0lpVXNYQ0lyYXk1NVVHVnlZMlZ1ZEN0Y0lpVXBJRzFoZEhKcGVETmtLRndpT2x3aWJXRjBjbWw0TTJRb1hDSXNWQ3M5S0cwK1pTWW1aVDR0YlQ5M09tVXBLM2dyS0cwK2NpWW1jajR0YlQ5M09uSXBLM2dyS0cwK2J5WW1iejR0YlQ5M09tOHBMRlFyUFhncktHMCtYeVltWHo0dGJUOTNPbDhwSzNncktHMCthU1ltYVQ0dGJUOTNPbWtwSzNncktHMCtiaVltYmo0dGJUOTNPbTRwTEU5OGZFRS9LRlFyUFhncktHMCtiQ1ltYkQ0dGJUOTNPbXdwSzNncktHMCtkU1ltZFQ0dGJUOTNPblVwSzNncktHMCtjeVltY3o0dGJUOTNPbk1wTEZRclBYZ3JLRzArWVNZbVlUNHRiVDkzT21FcEszZ3JLRzArYUNZbWFENHRiVDkzT21ncEszZ3JLRzArWXlZbVl6NHRiVDkzT21NcEszZ3BPbFFyUFZ3aUxEQXNNQ3d3TERBc01Td3dMRndpTEZRclBVWXJlQ3RKSzNnclJTdDRLeWhNUHpFckxVVXZURG94S1N0Y0lpbGNJaXhUVzFCbFhUMVVmVHRvUFU5bExuQnliM1J2ZEhsd1pTeG9Mbmc5YUM1NVBXZ3VlajFvTG5OclpYZFlQV2d1YzJ0bGQxazlhQzV5YjNSaGRHbHZiajFvTG5KdmRHRjBhVzl1V0Qxb0xuSnZkR0YwYVc5dVdUMW9MbnBQY21sbmFXNDlhQzU0VUdWeVkyVnVkRDFvTG5sUVpYSmpaVzUwUFdndWVFOW1abk5sZEQxb0xubFBabVp6WlhROU1DeG9Mbk5qWVd4bFdEMW9Mbk5qWVd4bFdUMW9Mbk5qWVd4bFdqMHhMRlJsS0Z3aWRISmhibk5tYjNKdExITmpZV3hsTEhOallXeGxXQ3h6WTJGc1pWa3NjMk5oYkdWYUxIZ3NlU3g2TEhKdmRHRjBhVzl1TEhKdmRHRjBhVzl1V0N4eWIzUmhkR2x2Ymxrc2NtOTBZWFJwYjI1YUxITnJaWGRZTEhOclpYZFpMSE5vYjNKMFVtOTBZWFJwYjI0c2MyaHZjblJTYjNSaGRHbHZibGdzYzJodmNuUlNiM1JoZEdsdmJsa3NjMmh2Y25SU2IzUmhkR2x2Ymxvc2RISmhibk5tYjNKdFQzSnBaMmx1TEhOMlowOXlhV2RwYml4MGNtRnVjMlp2Y20xUVpYSnpjR1ZqZEdsMlpTeGthWEpsWTNScGIyNWhiRkp2ZEdGMGFXOXVMSEJoY25ObFZISmhibk5tYjNKdExHWnZjbU5sTTBRc2MydGxkMVI1Y0dVc2VGQmxjbU5sYm5Rc2VWQmxjbU5sYm5Rc2MyMXZiM1JvVDNKcFoybHVYQ0lzZTNCaGNuTmxjanBtZFc1amRHbHZiaWgwTEdVc2FTeHpMRzRzYnl4c0tYdHBaaWh6TGw5c1lYTjBVR0Z5YzJWa1ZISmhibk5tYjNKdFBUMDliQ2x5WlhSMWNtNGdianR6TGw5c1lYTjBVR0Z5YzJWa1ZISmhibk5tYjNKdFBXdzdkbUZ5SUdnc1h5eDFMR01zWml4d0xHMHNaQ3huTEhZc2VUMTBMbDluYzFSeVlXNXpabTl5YlN4VVBYUXVjM1I1YkdVc2VEMHhaUzAyTEhjOVltVXViR1Z1WjNSb0xHSTliQ3hRUFh0OUxHczlYQ0owY21GdWMyWnZjbTFQY21sbmFXNWNJanRwWmloc0xtUnBjM0JzWVhrL0tHTTlVU2gwTEZ3aVpHbHpjR3hoZVZ3aUtTeFVMbVJwYzNCc1lYazlYQ0ppYkc5amExd2lMR2c5VG1Vb2RDeHlMQ0V3TEd3dWNHRnljMlZVY21GdWMyWnZjbTBwTEZRdVpHbHpjR3hoZVQxaktUcG9QVTVsS0hRc2Npd2hNQ3hzTG5CaGNuTmxWSEpoYm5ObWIzSnRLU3h6TGw5MGNtRnVjMlp2Y20wOWFDeGNJbk4wY21sdVoxd2lQVDEwZVhCbGIyWWdZaTUwY21GdWMyWnZjbTBtSmxCbEtXTTlUQzV6ZEhsc1pTeGpXMUJsWFQxaUxuUnlZVzV6Wm05eWJTeGpMbVJwYzNCc1lYazlYQ0ppYkc5amExd2lMR011Y0c5emFYUnBiMjQ5WENKaFluTnZiSFYwWlZ3aUxFVXVZbTlrZVM1aGNIQmxibVJEYUdsc1pDaE1LU3hmUFU1bEtFd3NiblZzYkN3aE1Ta3NSUzVpYjJSNUxuSmxiVzkyWlVOb2FXeGtLRXdwTEY4dWNHVnljM0JsWTNScGRtVjhmQ2hmTG5CbGNuTndaV04wYVhabFBXZ3VjR1Z5YzNCbFkzUnBkbVVwTEc1MWJHd2hQV0l1ZUZCbGNtTmxiblFtSmloZkxuaFFaWEpqWlc1MFBXNWxLR0l1ZUZCbGNtTmxiblFzYUM1NFVHVnlZMlZ1ZENrcExHNTFiR3doUFdJdWVWQmxjbU5sYm5RbUppaGZMbmxRWlhKalpXNTBQVzVsS0dJdWVWQmxjbU5sYm5Rc2FDNTVVR1Z5WTJWdWRDa3BPMlZzYzJVZ2FXWW9YQ0p2WW1wbFkzUmNJajA5ZEhsd1pXOW1JR0lwZTJsbUtGODllM05qWVd4bFdEcHVaU2h1ZFd4c0lUMWlMbk5qWVd4bFdEOWlMbk5qWVd4bFdEcGlMbk5qWVd4bExHZ3VjMk5oYkdWWUtTeHpZMkZzWlZrNmJtVW9iblZzYkNFOVlpNXpZMkZzWlZrL1lpNXpZMkZzWlZrNllpNXpZMkZzWlN4b0xuTmpZV3hsV1Nrc2MyTmhiR1ZhT201bEtHSXVjMk5oYkdWYUxHZ3VjMk5oYkdWYUtTeDRPbTVsS0dJdWVDeG9MbmdwTEhrNmJtVW9ZaTU1TEdndWVTa3NlanB1WlNoaUxub3NhQzU2S1N4NFVHVnlZMlZ1ZERwdVpTaGlMbmhRWlhKalpXNTBMR2d1ZUZCbGNtTmxiblFwTEhsUVpYSmpaVzUwT201bEtHSXVlVkJsY21ObGJuUXNhQzU1VUdWeVkyVnVkQ2tzY0dWeWMzQmxZM1JwZG1VNmJtVW9ZaTUwY21GdWMyWnZjbTFRWlhKemNHVmpkR2wyWlN4b0xuQmxjbk53WldOMGFYWmxLWDBzWkQxaUxtUnBjbVZqZEdsdmJtRnNVbTkwWVhScGIyNHNiblZzYkNFOVpDbHBaaWhjSW05aWFtVmpkRndpUFQxMGVYQmxiMllnWkNsbWIzSW9ZeUJwYmlCa0tXSmJZMTA5WkZ0alhUdGxiSE5sSUdJdWNtOTBZWFJwYjI0OVpEdGNJbk4wY21sdVoxd2lQVDEwZVhCbGIyWWdZaTU0SmlZdE1TRTlQV0l1ZUM1cGJtUmxlRTltS0Z3aUpWd2lLU1ltS0Y4dWVEMHdMRjh1ZUZCbGNtTmxiblE5Ym1Vb1lpNTRMR2d1ZUZCbGNtTmxiblFwS1N4Y0luTjBjbWx1WjF3aVBUMTBlWEJsYjJZZ1lpNTVKaVl0TVNFOVBXSXVlUzVwYm1SbGVFOW1LRndpSlZ3aUtTWW1LRjh1ZVQwd0xGOHVlVkJsY21ObGJuUTlibVVvWWk1NUxHZ3VlVkJsY21ObGJuUXBLU3hmTG5KdmRHRjBhVzl1UFdGbEtGd2ljbTkwWVhScGIyNWNJbWx1SUdJL1lpNXliM1JoZEdsdmJqcGNJbk5vYjNKMFVtOTBZWFJwYjI1Y0ltbHVJR0kvWWk1emFHOXlkRkp2ZEdGMGFXOXVLMXdpWDNOb2IzSjBYQ0k2WENKeWIzUmhkR2x2YmxwY0ltbHVJR0kvWWk1eWIzUmhkR2x2YmxvNmFDNXliM1JoZEdsdmJpeG9Mbkp2ZEdGMGFXOXVMRndpY205MFlYUnBiMjVjSWl4UUtTeFNaU1ltS0Y4dWNtOTBZWFJwYjI1WVBXRmxLRndpY205MFlYUnBiMjVZWENKcGJpQmlQMkl1Y205MFlYUnBiMjVZT2x3aWMyaHZjblJTYjNSaGRHbHZibGhjSW1sdUlHSS9ZaTV6YUc5eWRGSnZkR0YwYVc5dVdDdGNJbDl6YUc5eWRGd2lPbWd1Y205MFlYUnBiMjVZZkh3d0xHZ3VjbTkwWVhScGIyNVlMRndpY205MFlYUnBiMjVZWENJc1VDa3NYeTV5YjNSaGRHbHZibGs5WVdVb1hDSnliM1JoZEdsdmJsbGNJbWx1SUdJL1lpNXliM1JoZEdsdmJsazZYQ0p6YUc5eWRGSnZkR0YwYVc5dVdWd2lhVzRnWWo5aUxuTm9iM0owVW05MFlYUnBiMjVaSzF3aVgzTm9iM0owWENJNmFDNXliM1JoZEdsdmJsbDhmREFzYUM1eWIzUmhkR2x2Ymxrc1hDSnliM1JoZEdsdmJsbGNJaXhRS1Nrc1h5NXphMlYzV0QxdWRXeHNQVDFpTG5OclpYZFlQMmd1YzJ0bGQxZzZZV1VvWWk1emEyVjNXQ3hvTG5OclpYZFlLU3hmTG5OclpYZFpQVzUxYkd3OVBXSXVjMnRsZDFrL2FDNXphMlYzV1RwaFpTaGlMbk5yWlhkWkxHZ3VjMnRsZDFrcExDaDFQVjh1YzJ0bGQxa3RhQzV6YTJWM1dTa21KaWhmTG5OclpYZFlLejExTEY4dWNtOTBZWFJwYjI0clBYVXBmV1p2Y2loU1pTWW1iblZzYkNFOVlpNW1iM0pqWlRORUppWW9hQzVtYjNKalpUTkVQV0l1Wm05eVkyVXpSQ3h0UFNFd0tTeG9Mbk5yWlhkVWVYQmxQV0l1YzJ0bGQxUjVjR1Y4ZkdndWMydGxkMVI1Y0dWOGZHRXVaR1ZtWVhWc2RGTnJaWGRVZVhCbExIQTlhQzVtYjNKalpUTkVmSHhvTG5wOGZHZ3VjbTkwWVhScGIyNVlmSHhvTG5KdmRHRjBhVzl1V1h4OFh5NTZmSHhmTG5KdmRHRjBhVzl1V0h4OFh5NXliM1JoZEdsdmJsbDhmRjh1Y0dWeWMzQmxZM1JwZG1Vc2NIeDhiblZzYkQwOVlpNXpZMkZzWlh4OEtGOHVjMk5oYkdWYVBURXBPeTB0ZHo0dE1Uc3BhVDFpWlZ0M1hTeG1QVjliYVYwdGFGdHBYU3dvWmo1NGZId3RlRDVtZkh4dWRXeHNJVDFpVzJsZGZIeHVkV3hzSVQxSlcybGRLU1ltS0cwOUlUQXNiajF1WlhjZ2JXVW9hQ3hwTEdoYmFWMHNaaXh1S1N4cElHbHVJRkFtSmlodUxtVTlVRnRwWFNrc2JpNTRjekE5TUN4dUxuQnNkV2RwYmoxdkxITXVYMjkyWlhKM2NtbDBaVkJ5YjNCekxuQjFjMmdvYmk1dUtTazdjbVYwZFhKdUlHWTlZaTUwY21GdWMyWnZjbTFQY21sbmFXNHNhQzV6ZG1jbUppaG1mSHhpTG5OMlowOXlhV2RwYmlrbUppaG5QV2d1ZUU5bVpuTmxkQ3gyUFdndWVVOW1abk5sZEN4NlpTaDBMSE5sS0dZcExGOHNZaTV6ZG1kUGNtbG5hVzRzWWk1emJXOXZkR2hQY21sbmFXNHBMRzQ5WkdVb2FDeGNJbmhQY21sbmFXNWNJaXdvZVQ5b09sOHBMbmhQY21sbmFXNHNYeTU0VDNKcFoybHVMRzRzYXlrc2JqMWtaU2hvTEZ3aWVVOXlhV2RwYmx3aUxDaDVQMmc2WHlrdWVVOXlhV2RwYml4ZkxubFBjbWxuYVc0c2JpeHJLU3dvWnlFOVBXZ3VlRTltWm5ObGRIeDhkaUU5UFdndWVVOW1abk5sZENrbUppaHVQV1JsS0dnc1hDSjRUMlptYzJWMFhDSXNlVDluT21ndWVFOW1abk5sZEN4b0xuaFBabVp6WlhRc2JpeHJLU3h1UFdSbEtHZ3NYQ0o1VDJabWMyVjBYQ0lzZVQ5Mk9tZ3VlVTltWm5ObGRDeG9MbmxQWm1aelpYUXNiaXhyS1Nrc1pqMTNaVDl1ZFd4c09sd2lNSEI0SURCd2VGd2lLU3dvWm54OFVtVW1KbkFtSm1ndWVrOXlhV2RwYmlrbUppaFFaVDhvYlQwaE1DeHBQVk5sTEdZOUtHWjhmRkVvZEN4cExISXNJVEVzWENJMU1DVWdOVEFsWENJcEtTdGNJbHdpTEc0OWJtVjNJRzFsS0ZRc2FTd3dMREFzYml3dE1TeHJLU3h1TG1JOVZGdHBYU3h1TG5Cc2RXZHBiajF2TEZKbFB5aGpQV2d1ZWs5eWFXZHBiaXhtUFdZdWMzQnNhWFFvWENJZ1hDSXBMR2d1ZWs5eWFXZHBiajBvWmk1c1pXNW5kR2crTWlZbUtEQTlQVDFqZkh4Y0lqQndlRndpSVQwOVpsc3lYU2svY0dGeWMyVkdiRzloZENobVd6SmRLVHBqS1h4OE1DeHVMbmh6TUQxdUxtVTlabHN3WFN0Y0lpQmNJaXNvWmxzeFhYeDhYQ0kxTUNWY0lpa3JYQ0lnTUhCNFhDSXNiajF1WlhjZ2JXVW9hQ3hjSW5wUGNtbG5hVzVjSWl3d0xEQXNiaXd0TVN4dUxtNHBMRzR1WWoxakxHNHVlSE13UFc0dVpUMW9MbnBQY21sbmFXNHBPbTR1ZUhNd1BXNHVaVDFtS1RwelpTaG1LMXdpWENJc2FDa3BMRzBtSmloekxsOTBjbUZ1YzJadmNtMVVlWEJsUFdndWMzWm5KaVozWlh4OElYQW1Kak1oUFQxMGFHbHpMbDkwY21GdWMyWnZjbTFVZVhCbFB6STZNeWtzYm4wc2NISmxabWw0T2lFd2ZTa3NWR1VvWENKaWIzaFRhR0ZrYjNkY0lpeDdaR1ZtWVhWc2RGWmhiSFZsT2x3aU1IQjRJREJ3ZUNBd2NIZ2dNSEI0SUNNNU9UbGNJaXh3Y21WbWFYZzZJVEFzWTI5c2IzSTZJVEFzYlhWc2RHazZJVEFzYTJWNWQyOXlaRHBjSW1sdWMyVjBYQ0o5S1N4VVpTaGNJbUp2Y21SbGNsSmhaR2wxYzF3aUxIdGtaV1poZFd4MFZtRnNkV1U2WENJd2NIaGNJaXh3WVhKelpYSTZablZ1WTNScGIyNG9kQ3hsTEdrc2JpeGhLWHRsUFhSb2FYTXVabTl5YldGMEtHVXBPM1poY2lCdkxHd3NhQ3hmTEhVc1l5eG1MSEFzYlN4a0xHY3NkaXg1TEZRc2VDeDNMR0k5VzF3aVltOXlaR1Z5Vkc5d1RHVm1kRkpoWkdsMWMxd2lMRndpWW05eVpHVnlWRzl3VW1sbmFIUlNZV1JwZFhOY0lpeGNJbUp2Y21SbGNrSnZkSFJ2YlZKcFoyaDBVbUZrYVhWelhDSXNYQ0ppYjNKa1pYSkNiM1IwYjIxTVpXWjBVbUZrYVhWelhDSmRMRkE5ZEM1emRIbHNaVHRtYjNJb2JUMXdZWEp6WlVac2IyRjBLSFF1YjJabWMyVjBWMmxrZEdncExHUTljR0Z5YzJWR2JHOWhkQ2gwTG05bVpuTmxkRWhsYVdkb2RDa3NiejFsTG5Od2JHbDBLRndpSUZ3aUtTeHNQVEE3WWk1c1pXNW5kR2crYkR0c0t5c3BkR2hwY3k1d0xtbHVaR1Y0VDJZb1hDSmliM0prWlhKY0lpa21KaWhpVzJ4ZFBWY29ZbHRzWFNrcExIVTlYejFSS0hRc1lsdHNYU3h5TENFeExGd2lNSEI0WENJcExDMHhJVDA5ZFM1cGJtUmxlRTltS0Z3aUlGd2lLU1ltS0Y4OWRTNXpjR3hwZENoY0lpQmNJaWtzZFQxZld6QmRMRjg5WDFzeFhTa3NZejFvUFc5YmJGMHNaajF3WVhKelpVWnNiMkYwS0hVcExIWTlkUzV6ZFdKemRISW9LR1lyWENKY0lpa3ViR1Z1WjNSb0tTeDVQVndpUFZ3aVBUMDlZeTVqYUdGeVFYUW9NU2tzZVQ4b2NEMXdZWEp6WlVsdWRDaGpMbU5vWVhKQmRDZ3dLU3RjSWpGY0lpd3hNQ2tzWXoxakxuTjFZbk4wY2lneUtTeHdLajF3WVhKelpVWnNiMkYwS0dNcExHYzlZeTV6ZFdKemRISW9LSEFyWENKY0lpa3ViR1Z1WjNSb0xTZ3dQbkEvTVRvd0tTbDhmRndpWENJcE9paHdQWEJoY25ObFJteHZZWFFvWXlrc1p6MWpMbk4xWW5OMGNpZ29jQ3RjSWx3aUtTNXNaVzVuZEdncEtTeGNJbHdpUFQwOVp5WW1LR2M5YzF0cFhYeDhkaWtzWnlFOVBYWW1KaWhVUFNRb2RDeGNJbUp2Y21SbGNreGxablJjSWl4bUxIWXBMSGc5SkNoMExGd2lZbTl5WkdWeVZHOXdYQ0lzWml4MktTeGNJaVZjSWowOVBXYy9LSFU5TVRBd0tpaFVMMjBwSzF3aUpWd2lMRjg5TVRBd0tpaDRMMlFwSzF3aUpWd2lLVHBjSW1WdFhDSTlQVDFuUHloM1BTUW9kQ3hjSW1KdmNtUmxja3hsWm5SY0lpd3hMRndpWlcxY0lpa3NkVDFVTDNjclhDSmxiVndpTEY4OWVDOTNLMXdpWlcxY0lpazZLSFU5VkN0Y0luQjRYQ0lzWHoxNEsxd2ljSGhjSWlrc2VTWW1LR005Y0dGeWMyVkdiRzloZENoMUtTdHdLMmNzYUQxd1lYSnpaVVpzYjJGMEtGOHBLM0FyWnlrcExHRTlaMlVvVUN4aVcyeGRMSFVyWENJZ1hDSXJYeXhqSzF3aUlGd2lLMmdzSVRFc1hDSXdjSGhjSWl4aEtUdHlaWFIxY200Z1lYMHNjSEpsWm1sNE9pRXdMR1p2Y20xaGRIUmxjanBqWlNoY0lqQndlQ0F3Y0hnZ01IQjRJREJ3ZUZ3aUxDRXhMQ0V3S1gwcExGUmxLRndpWW1GamEyZHliM1Z1WkZCdmMybDBhVzl1WENJc2UyUmxabUYxYkhSV1lXeDFaVHBjSWpBZ01Gd2lMSEJoY25ObGNqcG1kVzVqZEdsdmJpaDBMR1VzYVN4ekxHNHNZU2w3ZG1GeUlHOHNiQ3hvTEY4c2RTeGpMR1k5WENKaVlXTnJaM0p2ZFc1a0xYQnZjMmwwYVc5dVhDSXNjRDF5Zkh4YUtIUXNiblZzYkNrc1pEMTBhR2x6TG1admNtMWhkQ2dvY0Q5dFAzQXVaMlYwVUhKdmNHVnlkSGxXWVd4MVpTaG1LMXdpTFhoY0lpa3JYQ0lnWENJcmNDNW5aWFJRY205d1pYSjBlVlpoYkhWbEtHWXJYQ0l0ZVZ3aUtUcHdMbWRsZEZCeWIzQmxjblI1Vm1Gc2RXVW9aaWs2ZEM1amRYSnlaVzUwVTNSNWJHVXVZbUZqYTJkeWIzVnVaRkJ2YzJsMGFXOXVXQ3RjSWlCY0lpdDBMbU4xY25KbGJuUlRkSGxzWlM1aVlXTnJaM0p2ZFc1a1VHOXphWFJwYjI1WktYeDhYQ0l3SURCY0lpa3NaejEwYUdsekxtWnZjbTFoZENobEtUdGNibWxtS0MweElUMDlaQzVwYm1SbGVFOW1LRndpSlZ3aUtTRTlLQzB4SVQwOVp5NXBibVJsZUU5bUtGd2lKVndpS1NrbUppaGpQVkVvZEN4Y0ltSmhZMnRuY205MWJtUkpiV0ZuWlZ3aUtTNXlaWEJzWVdObEtGSXNYQ0pjSWlrc1l5WW1YQ0p1YjI1bFhDSWhQVDFqS1NsN1ptOXlLRzg5WkM1emNHeHBkQ2hjSWlCY0lpa3NiRDFuTG5Od2JHbDBLRndpSUZ3aUtTeFlMbk5sZEVGMGRISnBZblYwWlNoY0luTnlZMXdpTEdNcExHZzlNanN0TFdnK0xURTdLV1E5YjF0b1hTeGZQUzB4SVQwOVpDNXBibVJsZUU5bUtGd2lKVndpS1N4ZklUMDlLQzB4SVQwOWJGdG9YUzVwYm1SbGVFOW1LRndpSlZ3aUtTa21KaWgxUFRBOVBUMW9QM1F1YjJabWMyVjBWMmxrZEdndFdDNTNhV1IwYURwMExtOW1abk5sZEVobGFXZG9kQzFZTG1obGFXZG9kQ3h2VzJoZFBWOC9jR0Z5YzJWR2JHOWhkQ2hrS1M4eE1EQXFkU3RjSW5CNFhDSTZNVEF3S2lod1lYSnpaVVpzYjJGMEtHUXBMM1VwSzF3aUpWd2lLVHRrUFc4dWFtOXBiaWhjSWlCY0lpbDljbVYwZFhKdUlIUm9hWE11Y0dGeWMyVkRiMjF3YkdWNEtIUXVjM1I1YkdVc1pDeG5MRzRzWVNsOUxHWnZjbTFoZEhSbGNqcHpaWDBwTEZSbEtGd2lZbUZqYTJkeWIzVnVaRk5wZW1WY0lpeDdaR1ZtWVhWc2RGWmhiSFZsT2x3aU1DQXdYQ0lzWm05eWJXRjBkR1Z5T25ObGZTa3NWR1VvWENKd1pYSnpjR1ZqZEdsMlpWd2lMSHRrWldaaGRXeDBWbUZzZFdVNlhDSXdjSGhjSWl4d2NtVm1hWGc2SVRCOUtTeFVaU2hjSW5CbGNuTndaV04wYVhabFQzSnBaMmx1WENJc2UyUmxabUYxYkhSV1lXeDFaVHBjSWpVd0pTQTFNQ1ZjSWl4d2NtVm1hWGc2SVRCOUtTeFVaU2hjSW5SeVlXNXpabTl5YlZOMGVXeGxYQ0lzZTNCeVpXWnBlRG9oTUgwcExGUmxLRndpWW1GamEyWmhZMlZXYVhOcFltbHNhWFI1WENJc2UzQnlaV1pwZURvaE1IMHBMRlJsS0Z3aWRYTmxjbE5sYkdWamRGd2lMSHR3Y21WbWFYZzZJVEI5S1N4VVpTaGNJbTFoY21kcGJsd2lMSHR3WVhKelpYSTZabVVvWENKdFlYSm5hVzVVYjNBc2JXRnlaMmx1VW1sbmFIUXNiV0Z5WjJsdVFtOTBkRzl0TEcxaGNtZHBia3hsWm5SY0lpbDlLU3hVWlNoY0luQmhaR1JwYm1kY0lpeDdjR0Z5YzJWeU9tWmxLRndpY0dGa1pHbHVaMVJ2Y0N4d1lXUmthVzVuVW1sbmFIUXNjR0ZrWkdsdVowSnZkSFJ2YlN4d1lXUmthVzVuVEdWbWRGd2lLWDBwTEZSbEtGd2lZMnhwY0Z3aUxIdGtaV1poZFd4MFZtRnNkV1U2WENKeVpXTjBLREJ3ZUN3d2NIZ3NNSEI0TERCd2VDbGNJaXh3WVhKelpYSTZablZ1WTNScGIyNG9kQ3hsTEdrc2N5eHVMR0VwZTNaaGNpQnZMR3dzYUR0eVpYUjFjbTRnT1Q1dFB5aHNQWFF1WTNWeWNtVnVkRk4wZVd4bExHZzlPRDV0UDF3aUlGd2lPbHdpTEZ3aUxHODlYQ0p5WldOMEtGd2lLMnd1WTJ4cGNGUnZjQ3RvSzJ3dVkyeHBjRkpwWjJoMEsyZ3JiQzVqYkdsd1FtOTBkRzl0SzJncmJDNWpiR2x3VEdWbWRDdGNJaWxjSWl4bFBYUm9hWE11Wm05eWJXRjBLR1VwTG5Od2JHbDBLRndpTEZ3aUtTNXFiMmx1S0dncEtUb29iejEwYUdsekxtWnZjbTFoZENoUktIUXNkR2hwY3k1d0xISXNJVEVzZEdocGN5NWtabXgwS1Nrc1pUMTBhR2x6TG1admNtMWhkQ2hsS1Nrc2RHaHBjeTV3WVhKelpVTnZiWEJzWlhnb2RDNXpkSGxzWlN4dkxHVXNiaXhoS1gxOUtTeFVaU2hjSW5SbGVIUlRhR0ZrYjNkY0lpeDdaR1ZtWVhWc2RGWmhiSFZsT2x3aU1IQjRJREJ3ZUNBd2NIZ2dJems1T1Z3aUxHTnZiRzl5T2lFd0xHMTFiSFJwT2lFd2ZTa3NWR1VvWENKaGRYUnZVbTkxYm1Rc2MzUnlhV04wVlc1cGRITmNJaXg3Y0dGeWMyVnlPbVoxYm1OMGFXOXVLSFFzWlN4cExITXNjaWw3Y21WMGRYSnVJSEo5ZlNrc1ZHVW9YQ0ppYjNKa1pYSmNJaXg3WkdWbVlYVnNkRlpoYkhWbE9sd2lNSEI0SUhOdmJHbGtJQ013TURCY0lpeHdZWEp6WlhJNlpuVnVZM1JwYjI0b2RDeGxMR2tzY3l4dUxHRXBlM0psZEhWeWJpQjBhR2x6TG5CaGNuTmxRMjl0Y0d4bGVDaDBMbk4wZVd4bExIUm9hWE11Wm05eWJXRjBLRkVvZEN4Y0ltSnZjbVJsY2xSdmNGZHBaSFJvWENJc2Npd2hNU3hjSWpCd2VGd2lLU3RjSWlCY0lpdFJLSFFzWENKaWIzSmtaWEpVYjNCVGRIbHNaVndpTEhJc0lURXNYQ0p6YjJ4cFpGd2lLU3RjSWlCY0lpdFJLSFFzWENKaWIzSmtaWEpVYjNCRGIyeHZjbHdpTEhJc0lURXNYQ0lqTURBd1hDSXBLU3gwYUdsekxtWnZjbTFoZENobEtTeHVMR0VwZlN4amIyeHZjam9oTUN4bWIzSnRZWFIwWlhJNlpuVnVZM1JwYjI0b2RDbDdkbUZ5SUdVOWRDNXpjR3hwZENoY0lpQmNJaWs3Y21WMGRYSnVJR1ZiTUYwclhDSWdYQ0lyS0dWYk1WMThmRndpYzI5c2FXUmNJaWtyWENJZ1hDSXJLSFF1YldGMFkyZ29kV1VwZkh4YlhDSWpNREF3WENKZEtWc3dYWDE5S1N4VVpTaGNJbUp2Y21SbGNsZHBaSFJvWENJc2UzQmhjbk5sY2pwbVpTaGNJbUp2Y21SbGNsUnZjRmRwWkhSb0xHSnZjbVJsY2xKcFoyaDBWMmxrZEdnc1ltOXlaR1Z5UW05MGRHOXRWMmxrZEdnc1ltOXlaR1Z5VEdWbWRGZHBaSFJvWENJcGZTa3NWR1VvWENKbWJHOWhkQ3hqYzNOR2JHOWhkQ3h6ZEhsc1pVWnNiMkYwWENJc2UzQmhjbk5sY2pwbWRXNWpkR2x2YmloMExHVXNhU3h6TEhJcGUzWmhjaUJ1UFhRdWMzUjViR1VzWVQxY0ltTnpjMFpzYjJGMFhDSnBiaUJ1UDF3aVkzTnpSbXh2WVhSY0lqcGNJbk4wZVd4bFJteHZZWFJjSWp0eVpYUjFjbTRnYm1WM0lHMWxLRzRzWVN3d0xEQXNjaXd0TVN4cExDRXhMREFzYmx0aFhTeGxLWDE5S1R0MllYSWdRbVU5Wm5WdVkzUnBiMjRvZENsN2RtRnlJR1VzYVQxMGFHbHpMblFzY3oxcExtWnBiSFJsY254OFVTaDBhR2x6TG1SaGRHRXNYQ0ptYVd4MFpYSmNJaWw4ZkZ3aVhDSXNjajB3ZkhSb2FYTXVjeXQwYUdsekxtTXFkRHN4TURBOVBUMXlKaVlvTFRFOVBUMXpMbWx1WkdWNFQyWW9YQ0poZEhKcGVDaGNJaWttSmkweFBUMDljeTVwYm1SbGVFOW1LRndpY21Ga2FXVnVkQ2hjSWlrbUppMHhQVDA5Y3k1cGJtUmxlRTltS0Z3aWIyRmtaWElvWENJcFB5aHBMbkpsYlc5MlpVRjBkSEpwWW5WMFpTaGNJbVpwYkhSbGNsd2lLU3hsUFNGUktIUm9hWE11WkdGMFlTeGNJbVpwYkhSbGNsd2lLU2s2S0drdVptbHNkR1Z5UFhNdWNtVndiR0ZqWlNoaUxGd2lYQ0lwTEdVOUlUQXBLU3hsZkh3b2RHaHBjeTU0YmpFbUppaHBMbVpwYkhSbGNqMXpQWE44ZkZ3aVlXeHdhR0VvYjNCaFkybDBlVDFjSWl0eUsxd2lLVndpS1N3dE1UMDlQWE11YVc1a1pYaFBaaWhjSW5CaFkybDBlVndpS1Q4d1BUMDljaVltZEdocGN5NTRiakY4ZkNocExtWnBiSFJsY2oxeksxd2lJR0ZzY0doaEtHOXdZV05wZEhrOVhDSXJjaXRjSWlsY0lpazZhUzVtYVd4MFpYSTljeTV5WlhCc1lXTmxLSGdzWENKdmNHRmphWFI1UFZ3aUszSXBLWDA3VkdVb1hDSnZjR0ZqYVhSNUxHRnNjR2hoTEdGMWRHOUJiSEJvWVZ3aUxIdGtaV1poZFd4MFZtRnNkV1U2WENJeFhDSXNjR0Z5YzJWeU9tWjFibU4wYVc5dUtIUXNaU3hwTEhNc2JpeGhLWHQyWVhJZ2J6MXdZWEp6WlVac2IyRjBLRkVvZEN4Y0ltOXdZV05wZEhsY0lpeHlMQ0V4TEZ3aU1Wd2lLU2tzYkQxMExuTjBlV3hsTEdnOVhDSmhkWFJ2UVd4d2FHRmNJajA5UFdrN2NtVjBkWEp1WENKemRISnBibWRjSWowOWRIbHdaVzltSUdVbUpsd2lQVndpUFQwOVpTNWphR0Z5UVhRb01Ta21KaWhsUFNoY0lpMWNJajA5UFdVdVkyaGhja0YwS0RBcFB5MHhPakVwS25CaGNuTmxSbXh2WVhRb1pTNXpkV0p6ZEhJb01pa3BLMjhwTEdnbUpqRTlQVDF2SmlaY0ltaHBaR1JsYmx3aVBUMDlVU2gwTEZ3aWRtbHphV0pwYkdsMGVWd2lMSElwSmlZd0lUMDlaU1ltS0c4OU1Da3NXVDl1UFc1bGR5QnRaU2hzTEZ3aWIzQmhZMmwwZVZ3aUxHOHNaUzF2TEc0cE9paHVQVzVsZHlCdFpTaHNMRndpYjNCaFkybDBlVndpTERFd01DcHZMREV3TUNvb1pTMXZLU3h1S1N4dUxuaHVNVDFvUHpFNk1DeHNMbnB2YjIwOU1TeHVMblI1Y0dVOU1peHVMbUk5WENKaGJIQm9ZU2h2Y0dGamFYUjVQVndpSzI0dWN5dGNJaWxjSWl4dUxtVTlYQ0poYkhCb1lTaHZjR0ZqYVhSNVBWd2lLeWh1TG5NcmJpNWpLU3RjSWlsY0lpeHVMbVJoZEdFOWRDeHVMbkJzZFdkcGJqMWhMRzR1YzJWMFVtRjBhVzg5UW1VcExHZ21KaWh1UFc1bGR5QnRaU2hzTEZ3aWRtbHphV0pwYkdsMGVWd2lMREFzTUN4dUxDMHhMRzUxYkd3c0lURXNNQ3d3SVQwOWJ6OWNJbWx1YUdWeWFYUmNJanBjSW1ocFpHUmxibHdpTERBOVBUMWxQMXdpYUdsa1pHVnVYQ0k2WENKcGJtaGxjbWwwWENJcExHNHVlSE13UFZ3aWFXNW9aWEpwZEZ3aUxITXVYMjkyWlhKM2NtbDBaVkJ5YjNCekxuQjFjMmdvYmk1dUtTeHpMbDl2ZG1WeWQzSnBkR1ZRY205d2N5NXdkWE5vS0drcEtTeHVmWDBwTzNaaGNpQnFaVDFtZFc1amRHbHZiaWgwTEdVcGUyVW1KaWgwTG5KbGJXOTJaVkJ5YjNCbGNuUjVQeWdvWENKdGMxd2lQVDA5WlM1emRXSnpkSElvTUN3eUtYeDhYQ0ozWldKcmFYUmNJajA5UFdVdWMzVmljM1J5S0RBc05pa3BKaVlvWlQxY0lpMWNJaXRsS1N4MExuSmxiVzkyWlZCeWIzQmxjblI1S0dVdWNtVndiR0ZqWlNockxGd2lMU1F4WENJcExuUnZURzkzWlhKRFlYTmxLQ2twS1RwMExuSmxiVzkyWlVGMGRISnBZblYwWlNobEtTbDlMRmxsUFdaMWJtTjBhVzl1S0hRcGUybG1LSFJvYVhNdWRDNWZaM05EYkdGemMxQlVQWFJvYVhNc01UMDlQWFI4ZkRBOVBUMTBLWHQwYUdsekxuUXVjMlYwUVhSMGNtbGlkWFJsS0Z3aVkyeGhjM05jSWl3d1BUMDlkRDkwYUdsekxtSTZkR2hwY3k1bEtUdG1iM0lvZG1GeUlHVTlkR2hwY3k1a1lYUmhMR2s5ZEdocGN5NTBMbk4wZVd4bE8yVTdLV1V1ZGo5cFcyVXVjRjA5WlM1Mk9tcGxLR2tzWlM1d0tTeGxQV1V1WDI1bGVIUTdNVDA5UFhRbUpuUm9hWE11ZEM1ZlozTkRiR0Z6YzFCVVBUMDlkR2hwY3lZbUtIUm9hWE11ZEM1ZlozTkRiR0Z6YzFCVVBXNTFiR3dwZldWc2MyVWdkR2hwY3k1MExtZGxkRUYwZEhKcFluVjBaU2hjSW1Oc1lYTnpYQ0lwSVQwOWRHaHBjeTVsSmlaMGFHbHpMblF1YzJWMFFYUjBjbWxpZFhSbEtGd2lZMnhoYzNOY0lpeDBhR2x6TG1VcGZUdFVaU2hjSW1Oc1lYTnpUbUZ0WlZ3aUxIdHdZWEp6WlhJNlpuVnVZM1JwYjI0b2RDeGxMSE1zYml4aExHOHNiQ2w3ZG1GeUlHZ3NYeXgxTEdNc1ppeHdQWFF1WjJWMFFYUjBjbWxpZFhSbEtGd2lZMnhoYzNOY0lpbDhmRndpWENJc2JUMTBMbk4wZVd4bExtTnpjMVJsZUhRN2FXWW9ZVDF1TGw5amJHRnpjMDVoYldWUVZEMXVaWGNnYldVb2RDeHpMREFzTUN4aExESXBMR0V1YzJWMFVtRjBhVzg5V1dVc1lTNXdjajB0TVRFc2FUMGhNQ3hoTG1JOWNDeGZQVXNvZEN4eUtTeDFQWFF1WDJkelEyeGhjM05RVkNsN1ptOXlLR005ZTMwc1pqMTFMbVJoZEdFN1pqc3BZMXRtTG5CZFBURXNaajFtTGw5dVpYaDBPM1V1YzJWMFVtRjBhVzhvTVNsOWNtVjBkWEp1SUhRdVgyZHpRMnhoYzNOUVZEMWhMR0V1WlQxY0lqMWNJaUU5UFdVdVkyaGhja0YwS0RFcFAyVTZjQzV5WlhCc1lXTmxLRkpsWjBWNGNDaGNJbHhjWEZ4ektseGNYRnhpWENJclpTNXpkV0p6ZEhJb01pa3JYQ0pjWEZ4Y1lsd2lLU3hjSWx3aUtTc29YQ0lyWENJOVBUMWxMbU5vWVhKQmRDZ3dLVDljSWlCY0lpdGxMbk4xWW5OMGNpZ3lLVHBjSWx3aUtTeDBMbk5sZEVGMGRISnBZblYwWlNoY0ltTnNZWE56WENJc1lTNWxLU3hvUFVvb2RDeGZMRXNvZENrc2JDeGpLU3gwTG5ObGRFRjBkSEpwWW5WMFpTaGNJbU5zWVhOelhDSXNjQ2tzWVM1a1lYUmhQV2d1Wm1seWMzUk5VRlFzZEM1emRIbHNaUzVqYzNOVVpYaDBQVzBzWVQxaExuaG1hWEp6ZEQxdUxuQmhjbk5sS0hRc2FDNWthV1p6TEdFc2J5bDlmU2s3ZG1GeUlGVmxQV1oxYm1OMGFXOXVLSFFwZTJsbUtDZ3hQVDA5ZEh4OE1EMDlQWFFwSmlaMGFHbHpMbVJoZEdFdVgzUnZkR0ZzVkdsdFpUMDlQWFJvYVhNdVpHRjBZUzVmZEc5MFlXeEVkWEpoZEdsdmJpWW1YQ0pwYzBaeWIyMVRkR0Z5ZEZ3aUlUMDlkR2hwY3k1a1lYUmhMbVJoZEdFcGUzWmhjaUJsTEdrc2N5eHlMRzRzWVQxMGFHbHpMblF1YzNSNWJHVXNiejFzTG5SeVlXNXpabTl5YlM1d1lYSnpaVHRwWmloY0ltRnNiRndpUFQwOWRHaHBjeTVsS1dFdVkzTnpWR1Y0ZEQxY0lsd2lMSEk5SVRBN1pXeHpaU0JtYjNJb1pUMTBhR2x6TG1VdWMzQnNhWFFvWENJZ1hDSXBMbXB2YVc0b1hDSmNJaWt1YzNCc2FYUW9YQ0lzWENJcExITTlaUzVzWlc1bmRHZzdMUzF6UGkweE95bHBQV1ZiYzEwc2JGdHBYU1ltS0d4YmFWMHVjR0Z5YzJVOVBUMXZQM0k5SVRBNmFUMWNJblJ5WVc1elptOXliVTl5YVdkcGJsd2lQVDA5YVQ5VFpUcHNXMmxkTG5BcExHcGxLR0VzYVNrN2NpWW1LR3BsS0dFc1VHVXBMRzQ5ZEdocGN5NTBMbDluYzFSeVlXNXpabTl5YlN4dUppWW9iaTV6ZG1jbUpuUm9hWE11ZEM1eVpXMXZkbVZCZEhSeWFXSjFkR1VvWENKa1lYUmhMWE4yWnkxdmNtbG5hVzVjSWlrc1pHVnNaWFJsSUhSb2FYTXVkQzVmWjNOVWNtRnVjMlp2Y20wcEtYMTlPMlp2Y2loVVpTaGNJbU5zWldGeVVISnZjSE5jSWl4N2NHRnljMlZ5T21aMWJtTjBhVzl1S0hRc1pTeHpMSElzYmlsN2NtVjBkWEp1SUc0OWJtVjNJRzFsS0hRc2N5d3dMREFzYml3eUtTeHVMbk5sZEZKaGRHbHZQVlZsTEc0dVpUMWxMRzR1Y0hJOUxURXdMRzR1WkdGMFlUMXlMbDkwZDJWbGJpeHBQU0V3TEc1OWZTa3NhRDFjSW1KbGVtbGxjaXgwYUhKdmQxQnliM0J6TEhCb2VYTnBZM05RY205d2N5eHdhSGx6YVdOek1rUmNJaTV6Y0d4cGRDaGNJaXhjSWlrc2RtVTlhQzVzWlc1bmRHZzdkbVV0TFRzcGVHVW9hRnQyWlYwcE8yZzlZUzV3Y205MGIzUjVjR1VzYUM1ZlptbHljM1JRVkQxb0xsOXNZWE4wVUdGeWMyVmtWSEpoYm5ObWIzSnRQV2d1WDNSeVlXNXpabTl5YlQxdWRXeHNMR2d1WDI5dVNXNXBkRlIzWldWdVBXWjFibU4wYVc5dUtIUXNaU3h2S1h0cFppZ2hkQzV1YjJSbFZIbHdaU2x5WlhSMWNtNGhNVHQwYUdsekxsOTBZWEpuWlhROWRDeDBhR2x6TGw5MGQyVmxiajF2TEhSb2FYTXVYM1poY25NOVpTeGZQV1V1WVhWMGIxSnZkVzVrTEdrOUlURXNjejFsTG5OMVptWnBlRTFoY0h4OFlTNXpkV1ptYVhoTllYQXNjajFhS0hRc1hDSmNJaWtzYmoxMGFHbHpMbDl2ZG1WeWQzSnBkR1ZRY205d2N6dDJZWElnYUN4bUxHMHNaQ3huTEhZc2VTeFVMSGdzWWoxMExuTjBlV3hsTzJsbUtIVW1KbHdpWENJOVBUMWlMbnBKYm1SbGVDWW1LR2c5VVNoMExGd2lla2x1WkdWNFhDSXNjaWtzS0Z3aVlYVjBiMXdpUFQwOWFIeDhYQ0pjSWowOVBXZ3BKaVowYUdsekxsOWhaR1JNWVhwNVUyVjBLR0lzWENKNlNXNWtaWGhjSWl3d0tTa3NYQ0p6ZEhKcGJtZGNJajA5ZEhsd1pXOW1JR1VtSmloa1BXSXVZM056VkdWNGRDeG9QVXNvZEN4eUtTeGlMbU56YzFSbGVIUTlaQ3RjSWp0Y0lpdGxMR2c5U2loMExHZ3NTeWgwS1NrdVpHbG1jeXdoV1NZbWR5NTBaWE4wS0dVcEppWW9hQzV2Y0dGamFYUjVQWEJoY25ObFJteHZZWFFvVW1WblJYaHdMaVF4S1Nrc1pUMW9MR0l1WTNOelZHVjRkRDFrS1N4MGFHbHpMbDltYVhKemRGQlVQV1k5WlM1amJHRnpjMDVoYldVL2JDNWpiR0Z6YzA1aGJXVXVjR0Z5YzJVb2RDeGxMbU5zWVhOelRtRnRaU3hjSW1Oc1lYTnpUbUZ0WlZ3aUxIUm9hWE1zYm5Wc2JDeHVkV3hzTEdVcE9uUm9hWE11Y0dGeWMyVW9kQ3hsTEc1MWJHd3BMSFJvYVhNdVgzUnlZVzV6Wm05eWJWUjVjR1VwZTJadmNpaDRQVE05UFQxMGFHbHpMbDkwY21GdWMyWnZjbTFVZVhCbExGQmxQMk1tSmloMVBTRXdMRndpWENJOVBUMWlMbnBKYm1SbGVDWW1LSGs5VVNoMExGd2lla2x1WkdWNFhDSXNjaWtzS0Z3aVlYVjBiMXdpUFQwOWVYeDhYQ0pjSWowOVBYa3BKaVowYUdsekxsOWhaR1JNWVhwNVUyVjBLR0lzWENKNlNXNWtaWGhjSWl3d0tTa3NjQ1ltZEdocGN5NWZZV1JrVEdGNmVWTmxkQ2hpTEZ3aVYyVmlhMmwwUW1GamEyWmhZMlZXYVhOcFltbHNhWFI1WENJc2RHaHBjeTVmZG1GeWN5NVhaV0pyYVhSQ1lXTnJabUZqWlZacGMybGlhV3hwZEhsOGZDaDRQMXdpZG1semFXSnNaVndpT2x3aWFHbGtaR1Z1WENJcEtTazZZaTU2YjI5dFBURXNiVDFtTzIwbUptMHVYMjVsZUhRN0tXMDliUzVmYm1WNGREdFVQVzVsZHlCdFpTaDBMRndpZEhKaGJuTm1iM0p0WENJc01Dd3dMRzUxYkd3c01pa3NkR2hwY3k1ZmJHbHVhME5UVTFBb1ZDeHVkV3hzTEcwcExGUXVjMlYwVW1GMGFXODlVR1UvV0dVNlRHVXNWQzVrWVhSaFBYUm9hWE11WDNSeVlXNXpabTl5Ylh4OFRtVW9kQ3h5TENFd0tTeFVMblIzWldWdVBXOHNWQzV3Y2owdE1TeHVMbkJ2Y0NncGZXbG1LR2twZTJadmNpZzdaanNwZTJadmNpaDJQV1l1WDI1bGVIUXNiVDFrTzIwbUptMHVjSEkrWmk1d2Nqc3BiVDF0TGw5dVpYaDBPeWhtTGw5d2NtVjJQVzAvYlM1ZmNISmxkanBuS1Q5bUxsOXdjbVYyTGw5dVpYaDBQV1k2WkQxbUxDaG1MbDl1WlhoMFBXMHBQMjB1WDNCeVpYWTlaanBuUFdZc1pqMTJmWFJvYVhNdVgyWnBjbk4wVUZROVpIMXlaWFIxY200aE1IMHNhQzV3WVhKelpUMW1kVzVqZEdsdmJpaDBMR1VzYVN4dUtYdDJZWElnWVN4dkxHZ3NkU3hqTEdZc2NDeHRMR1FzWnl4MlBYUXVjM1I1YkdVN1ptOXlLR0VnYVc0Z1pTbG1QV1ZiWVYwc2J6MXNXMkZkTEc4L2FUMXZMbkJoY25ObEtIUXNaaXhoTEhSb2FYTXNhU3h1TEdVcE9paGpQVkVvZEN4aExISXBLMXdpWENJc1pEMWNJbk4wY21sdVoxd2lQVDEwZVhCbGIyWWdaaXhjSW1OdmJHOXlYQ0k5UFQxaGZIeGNJbVpwYkd4Y0lqMDlQV0Y4ZkZ3aWMzUnliMnRsWENJOVBUMWhmSHd0TVNFOVBXRXVhVzVrWlhoUFppaGNJa052Ykc5eVhDSXBmSHhrSmlaUUxuUmxjM1FvWmlrL0tHUjhmQ2htUFdobEtHWXBMR1k5S0dZdWJHVnVaM1JvUGpNL1hDSnlaMkpoS0Z3aU9sd2ljbWRpS0Z3aUtTdG1MbXB2YVc0b1hDSXNYQ0lwSzF3aUtWd2lLU3hwUFdkbEtIWXNZU3hqTEdZc0lUQXNYQ0owY21GdWMzQmhjbVZ1ZEZ3aUxHa3NNQ3h1S1NrNklXUjhmQzB4UFQwOVppNXBibVJsZUU5bUtGd2lJRndpS1NZbUxURTlQVDFtTG1sdVpHVjRUMllvWENJc1hDSXBQeWhvUFhCaGNuTmxSbXh2WVhRb1l5a3NjRDFvZkh3d1BUMDlhRDlqTG5OMVluTjBjaWdvYUN0Y0lsd2lLUzVzWlc1bmRHZ3BPbHdpWENJc0tGd2lYQ0k5UFQxamZIeGNJbUYxZEc5Y0lqMDlQV01wSmlZb1hDSjNhV1IwYUZ3aVBUMDlZWHg4WENKb1pXbG5hSFJjSWowOVBXRS9LR2c5YVdVb2RDeGhMSElwTEhBOVhDSndlRndpS1RwY0lteGxablJjSWowOVBXRjhmRndpZEc5d1hDSTlQVDFoUHlob1BVZ29kQ3hoTEhJcExIQTlYQ0p3ZUZ3aUtUb29hRDFjSW05d1lXTnBkSGxjSWlFOVBXRS9NRG94TEhBOVhDSmNJaWtwTEdjOVpDWW1YQ0k5WENJOVBUMW1MbU5vWVhKQmRDZ3hLU3huUHloMVBYQmhjbk5sU1c1MEtHWXVZMmhoY2tGMEtEQXBLMXdpTVZ3aUxERXdLU3htUFdZdWMzVmljM1J5S0RJcExIVXFQWEJoY25ObFJteHZZWFFvWmlrc2JUMW1MbkpsY0d4aFkyVW9WQ3hjSWx3aUtTazZLSFU5Y0dGeWMyVkdiRzloZENobUtTeHRQV1EvWmk1eVpYQnNZV05sS0ZRc1hDSmNJaWs2WENKY0lpa3NYQ0pjSWowOVBXMG1KaWh0UFdFZ2FXNGdjejl6VzJGZE9uQXBMR1k5ZFh4OE1EMDlQWFUvS0djL2RTdG9PblVwSzIwNlpWdGhYU3h3SVQwOWJTWW1YQ0pjSWlFOVBXMG1KaWgxZkh3d1BUMDlkU2ttSm1nbUppaG9QU1FvZEN4aExHZ3NjQ2tzWENJbFhDSTlQVDF0UHlob0x6MGtLSFFzWVN3eE1EQXNYQ0lsWENJcEx6RXdNQ3hsTG5OMGNtbGpkRlZ1YVhSeklUMDlJVEFtSmloalBXZ3JYQ0lsWENJcEtUcGNJbVZ0WENJOVBUMXRmSHhjSW5KbGJWd2lQVDA5YlQ5b0x6MGtLSFFzWVN3eExHMHBPbHdpY0hoY0lpRTlQVzBtSmloMVBTUW9kQ3hoTEhVc2JTa3NiVDFjSW5CNFhDSXBMR2NtSmloMWZId3dQVDA5ZFNrbUppaG1QWFVyYUN0dEtTa3NaeVltS0hVclBXZ3BMQ0ZvSmlZd0lUMDlhSHg4SVhVbUpqQWhQVDExUDNadmFXUWdNQ0U5UFhaYllWMG1KaWhtZkh4Y0lrNWhUbHdpSVQxbUsxd2lYQ0ltSm01MWJHd2hQV1lwUHlocFBXNWxkeUJ0WlNoMkxHRXNkWHg4YUh4OE1Dd3dMR2tzTFRFc1lTd2hNU3d3TEdNc1ppa3NhUzU0Y3pBOVhDSnViMjVsWENJaFBUMW1mSHhjSW1ScGMzQnNZWGxjSWlFOVBXRW1KaTB4UFQwOVlTNXBibVJsZUU5bUtGd2lVM1I1YkdWY0lpay9aanBqS1RweEtGd2lhVzUyWVd4cFpDQmNJaXRoSzF3aUlIUjNaV1Z1SUhaaGJIVmxPaUJjSWl0bFcyRmRLVG9vYVQxdVpYY2diV1VvZGl4aExHZ3NkUzFvTEdrc01DeGhMRjhoUFQwaE1TWW1LRndpY0hoY0lqMDlQVzE4ZkZ3aWVrbHVaR1Y0WENJOVBUMWhLU3d3TEdNc1ppa3NhUzU0Y3pBOWJTa3BPbWs5WjJVb2RpeGhMR01zWml3aE1DeHVkV3hzTEdrc01DeHVLU2tzYmlZbWFTWW1JV2t1Y0d4MVoybHVKaVlvYVM1d2JIVm5hVzQ5YmlrN2NtVjBkWEp1SUdsOUxHZ3VjMlYwVW1GMGFXODlablZ1WTNScGIyNG9kQ2w3ZG1GeUlHVXNhU3h6TEhJOWRHaHBjeTVmWm1seWMzUlFWQ3h1UFRGbExUWTdhV1lvTVNFOVBYUjhmSFJvYVhNdVgzUjNaV1Z1TGw5MGFXMWxJVDA5ZEdocGN5NWZkSGRsWlc0dVgyUjFjbUYwYVc5dUppWXdJVDA5ZEdocGN5NWZkSGRsWlc0dVgzUnBiV1VwYVdZb2RIeDhkR2hwY3k1ZmRIZGxaVzR1WDNScGJXVWhQVDEwYUdsekxsOTBkMlZsYmk1ZlpIVnlZWFJwYjI0bUpqQWhQVDEwYUdsekxsOTBkMlZsYmk1ZmRHbHRaWHg4ZEdocGN5NWZkSGRsWlc0dVgzSmhkMUJ5WlhaVWFXMWxQVDA5TFRGbExUWXBabTl5S0R0eU95bDdhV1lvWlQxeUxtTXFkQ3R5TG5Nc2NpNXlQMlU5VFdGMGFDNXliM1Z1WkNobEtUcHVQbVVtSm1VK0xXNG1KaWhsUFRBcExISXVkSGx3WlNscFppZ3hQVDA5Y2k1MGVYQmxLV2xtS0hNOWNpNXNMREk5UFQxektYSXVkRnR5TG5CZFBYSXVlSE13SzJVcmNpNTRjekVyY2k1NGJqRXJjaTU0Y3pJN1pXeHpaU0JwWmlnelBUMDljeWx5TG5SYmNpNXdYVDF5TG5oek1DdGxLM0l1ZUhNeEszSXVlRzR4SzNJdWVITXlLM0l1ZUc0eUszSXVlSE16TzJWc2MyVWdhV1lvTkQwOVBYTXBjaTUwVzNJdWNGMDljaTU0Y3pBclpTdHlMbmh6TVN0eUxuaHVNU3R5TG5oek1pdHlMbmh1TWl0eUxuaHpNeXR5TG5odU15dHlMbmh6TkR0bGJITmxJR2xtS0RVOVBUMXpLWEl1ZEZ0eUxuQmRQWEl1ZUhNd0syVXJjaTU0Y3pFcmNpNTRiakVyY2k1NGN6SXJjaTU0YmpJcmNpNTRjek1yY2k1NGJqTXJjaTU0Y3pRcmNpNTRialFyY2k1NGN6VTdaV3h6Wlh0bWIzSW9hVDF5TG5oek1DdGxLM0l1ZUhNeExITTlNVHR5TG13K2N6dHpLeXNwYVNzOWNsdGNJbmh1WENJcmMxMHJjbHRjSW5oelhDSXJLSE1yTVNsZE8zSXVkRnR5TG5CZFBXbDlaV3h6WlMweFBUMDljaTUwZVhCbFAzSXVkRnR5TG5CZFBYSXVlSE13T25JdWMyVjBVbUYwYVc4bUpuSXVjMlYwVW1GMGFXOG9kQ2s3Wld4elpTQnlMblJiY2k1d1hUMWxLM0l1ZUhNd08zSTljaTVmYm1WNGRIMWxiSE5sSUdadmNpZzdjanNwTWlFOVBYSXVkSGx3WlQ5eUxuUmJjaTV3WFQxeUxtSTZjaTV6WlhSU1lYUnBieWgwS1N4eVBYSXVYMjVsZUhRN1pXeHpaU0JtYjNJb08zSTdLWHRwWmlneUlUMDljaTUwZVhCbEtXbG1LSEl1Y2lZbUxURWhQVDF5TG5SNWNHVXBhV1lvWlQxTllYUm9Mbkp2ZFc1a0tISXVjeXR5TG1NcExISXVkSGx3WlNsN2FXWW9NVDA5UFhJdWRIbHdaU2w3Wm05eUtITTljaTVzTEdrOWNpNTRjekFyWlN0eUxuaHpNU3h6UFRFN2NpNXNQbk03Y3lzcktXa3JQWEpiWENKNGJsd2lLM05kSzNKYlhDSjRjMXdpS3loekt6RXBYVHR5TG5SYmNpNXdYVDFwZlgxbGJITmxJSEl1ZEZ0eUxuQmRQV1VyY2k1NGN6QTdaV3h6WlNCeUxuUmJjaTV3WFQxeUxtVTdaV3h6WlNCeUxuTmxkRkpoZEdsdktIUXBPM0k5Y2k1ZmJtVjRkSDE5TEdndVgyVnVZV0pzWlZSeVlXNXpabTl5YlhNOVpuVnVZM1JwYjI0b2RDbDdkR2hwY3k1ZmRISmhibk5tYjNKdFBYUm9hWE11WDNSeVlXNXpabTl5Ylh4OFRtVW9kR2hwY3k1ZmRHRnlaMlYwTEhJc0lUQXBMSFJvYVhNdVgzUnlZVzV6Wm05eWJWUjVjR1U5ZEdocGN5NWZkSEpoYm5ObWIzSnRMbk4yWnlZbWQyVjhmQ0YwSmlZeklUMDlkR2hwY3k1ZmRISmhibk5tYjNKdFZIbHdaVDh5T2pOOU8zWmhjaUJ4WlQxbWRXNWpkR2x2YmlncGUzUm9hWE11ZEZ0MGFHbHpMbkJkUFhSb2FYTXVaU3gwYUdsekxtUmhkR0V1WDJ4cGJtdERVMU5RS0hSb2FYTXNkR2hwY3k1ZmJtVjRkQ3h1ZFd4c0xDRXdLWDA3YUM1ZllXUmtUR0Y2ZVZObGREMW1kVzVqZEdsdmJpaDBMR1VzYVNsN2RtRnlJSE05ZEdocGN5NWZabWx5YzNSUVZEMXVaWGNnYldVb2RDeGxMREFzTUN4MGFHbHpMbDltYVhKemRGQlVMRElwTzNNdVpUMXBMSE11YzJWMFVtRjBhVzg5Y1dVc2N5NWtZWFJoUFhSb2FYTjlMR2d1WDJ4cGJtdERVMU5RUFdaMWJtTjBhVzl1S0hRc1pTeHBMSE1wZTNKbGRIVnliaUIwSmlZb1pTWW1LR1V1WDNCeVpYWTlkQ2tzZEM1ZmJtVjRkQ1ltS0hRdVgyNWxlSFF1WDNCeVpYWTlkQzVmY0hKbGRpa3NkQzVmY0hKbGRqOTBMbDl3Y21WMkxsOXVaWGgwUFhRdVgyNWxlSFE2ZEdocGN5NWZabWx5YzNSUVZEMDlQWFFtSmloMGFHbHpMbDltYVhKemRGQlVQWFF1WDI1bGVIUXNjejBoTUNrc2FUOXBMbDl1WlhoMFBYUTZjM3g4Ym5Wc2JDRTlQWFJvYVhNdVgyWnBjbk4wVUZSOGZDaDBhR2x6TGw5bWFYSnpkRkJVUFhRcExIUXVYMjVsZUhROVpTeDBMbDl3Y21WMlBXa3BMSFI5TEdndVgydHBiR3c5Wm5WdVkzUnBiMjRvWlNsN2RtRnlJR2tzY3l4eUxHNDlaVHRwWmlobExtRjFkRzlCYkhCb1lYeDhaUzVoYkhCb1lTbDdiajE3ZlR0bWIzSW9jeUJwYmlCbEtXNWJjMTA5WlZ0elhUdHVMbTl3WVdOcGRIazlNU3h1TG1GMWRHOUJiSEJvWVNZbUtHNHVkbWx6YVdKcGJHbDBlVDB4S1gxeVpYUjFjbTRnWlM1amJHRnpjMDVoYldVbUppaHBQWFJvYVhNdVgyTnNZWE56VG1GdFpWQlVLU1ltS0hJOWFTNTRabWx5YzNRc2NpWW1jaTVmY0hKbGRqOTBhR2x6TGw5c2FXNXJRMU5UVUNoeUxsOXdjbVYyTEdrdVgyNWxlSFFzY2k1ZmNISmxkaTVmY0hKbGRpazZjajA5UFhSb2FYTXVYMlpwY25OMFVGUW1KaWgwYUdsekxsOW1hWEp6ZEZCVVBXa3VYMjVsZUhRcExHa3VYMjVsZUhRbUpuUm9hWE11WDJ4cGJtdERVMU5RS0drdVgyNWxlSFFzYVM1ZmJtVjRkQzVmYm1WNGRDeHlMbDl3Y21WMktTeDBhR2x6TGw5amJHRnpjMDVoYldWUVZEMXVkV3hzS1N4MExuQnliM1J2ZEhsd1pTNWZhMmxzYkM1allXeHNLSFJvYVhNc2JpbDlPM1poY2lCV1pUMW1kVzVqZEdsdmJpaDBMR1VzYVNsN2RtRnlJSE1zY2l4dUxHRTdhV1lvZEM1emJHbGpaU2xtYjNJb2NqMTBMbXhsYm1kMGFEc3RMWEkrTFRFN0tWWmxLSFJiY2wwc1pTeHBLVHRsYkhObElHWnZjaWh6UFhRdVkyaHBiR1JPYjJSbGN5eHlQWE11YkdWdVozUm9PeTB0Y2o0dE1Uc3BiajF6VzNKZExHRTliaTUwZVhCbExHNHVjM1I1YkdVbUppaGxMbkIxYzJnb1N5aHVLU2tzYVNZbWFTNXdkWE5vS0c0cEtTd3hJVDA5WVNZbU9TRTlQV0VtSmpFeElUMDlZWHg4SVc0dVkyaHBiR1JPYjJSbGN5NXNaVzVuZEdoOGZGWmxLRzRzWlN4cEtYMDdjbVYwZFhKdUlHRXVZMkZ6WTJGa1pWUnZQV1oxYm1OMGFXOXVLSFFzYVN4ektYdDJZWElnY2l4dUxHRXNieXhzUFdVdWRHOG9kQ3hwTEhNcExHZzlXMnhkTEY4OVcxMHNkVDFiWFN4alBWdGRMR1k5WlM1ZmFXNTBaWEp1WVd4ekxuSmxjMlZ5ZG1Wa1VISnZjSE03Wm05eUtIUTliQzVmZEdGeVoyVjBjM3g4YkM1MFlYSm5aWFFzVm1Vb2RDeGZMR01wTEd3dWNtVnVaR1Z5S0drc0lUQXNJVEFwTEZabEtIUXNkU2tzYkM1eVpXNWtaWElvTUN3aE1Dd2hNQ2tzYkM1ZlpXNWhZbXhsWkNnaE1Da3NjajFqTG14bGJtZDBhRHN0TFhJK0xURTdLV2xtS0c0OVNpaGpXM0pkTEY5YmNsMHNkVnR5WFNrc2JpNW1hWEp6ZEUxUVZDbDdiajF1TG1ScFpuTTdabTl5S0dFZ2FXNGdjeWxtVzJGZEppWW9ibHRoWFQxelcyRmRLVHR2UFh0OU8yWnZjaWhoSUdsdUlHNHBiMXRoWFQxZlczSmRXMkZkTzJndWNIVnphQ2hsTG1aeWIyMVVieWhqVzNKZExHa3NieXh1S1NsOWNtVjBkWEp1SUdoOUxIUXVZV04wYVhaaGRHVW9XMkZkS1N4aGZTd2hNQ2tzWm5WdVkzUnBiMjRvS1h0MllYSWdkRDFmWjNOVFkyOXdaUzVmWjNORVpXWnBibVV1Y0d4MVoybHVLSHR3Y205d1RtRnRaVHBjSW5KdmRXNWtVSEp2Y0hOY0lpeDJaWEp6YVc5dU9sd2lNUzQxWENJc2NISnBiM0pwZEhrNkxURXNRVkJKT2pJc2FXNXBkRHBtZFc1amRHbHZiaWgwTEdVc2FTbDdjbVYwZFhKdUlIUm9hWE11WDNSM1pXVnVQV2tzSVRCOWZTa3NaVDFtZFc1amRHbHZiaWgwS1h0bWIzSW9PM1E3S1hRdVpueDhkQzVpYkc5aWZId29kQzV5UFRFcExIUTlkQzVmYm1WNGRIMHNhVDEwTG5CeWIzUnZkSGx3WlR0cExsOXZia2x1YVhSQmJHeFFjbTl3Y3oxbWRXNWpkR2x2YmlncGUyWnZjaWgyWVhJZ2RDeHBMSE1zY2oxMGFHbHpMbDkwZDJWbGJpeHVQWEl1ZG1GeWN5NXliM1Z1WkZCeWIzQnpMbXB2YVc0L2NpNTJZWEp6TG5KdmRXNWtVSEp2Y0hNNmNpNTJZWEp6TG5KdmRXNWtVSEp2Y0hNdWMzQnNhWFFvWENJc1hDSXBMR0U5Ymk1c1pXNW5kR2dzYnoxN2ZTeHNQWEl1WDNCeWIzQk1iMjlyZFhBdWNtOTFibVJRY205d2N6c3RMV0UrTFRFN0tXOWJibHRoWFYwOU1UdG1iM0lvWVQxdUxteGxibWQwYURzdExXRStMVEU3S1dadmNpaDBQVzViWVYwc2FUMXlMbDltYVhKemRGQlVPMms3S1hNOWFTNWZibVY0ZEN4cExuQm5QMmt1ZEM1ZmNtOTFibVJRY205d2N5aHZMQ0V3S1RwcExtNDlQVDEwSmlZb01qMDlQV2t1WmlZbWFTNTBQMlVvYVM1MExsOW1hWEp6ZEZCVUtUb29kR2hwY3k1ZllXUmtLR2t1ZEN4MExHa3VjeXhwTG1NcExITW1KaWh6TGw5d2NtVjJQV2t1WDNCeVpYWXBMR2t1WDNCeVpYWS9hUzVmY0hKbGRpNWZibVY0ZEQxek9uSXVYMlpwY25OMFVGUTlQVDFwSmlZb2NpNWZabWx5YzNSUVZEMXpLU3hwTGw5dVpYaDBQV2t1WDNCeVpYWTliblZzYkN4eUxsOXdjbTl3VEc5dmEzVndXM1JkUFd3cEtTeHBQWE03Y21WMGRYSnVJVEY5TEdrdVgyRmtaRDFtZFc1amRHbHZiaWgwTEdVc2FTeHpLWHQwYUdsekxsOWhaR1JVZDJWbGJpaDBMR1VzYVN4cEszTXNaU3doTUNrc2RHaHBjeTVmYjNabGNuZHlhWFJsVUhKdmNITXVjSFZ6YUNobEtYMTlLQ2tzWm5WdVkzUnBiMjRvS1h0ZlozTlRZMjl3WlM1ZlozTkVaV1pwYm1VdWNHeDFaMmx1S0h0d2NtOXdUbUZ0WlRwY0ltRjBkSEpjSWl4QlVFazZNaXgyWlhKemFXOXVPbHdpTUM0MUxqQmNJaXhwYm1sME9tWjFibU4wYVc5dUtIUXNaU2w3ZG1GeUlHazdhV1lvWENKbWRXNWpkR2x2Ymx3aUlUMTBlWEJsYjJZZ2RDNXpaWFJCZEhSeWFXSjFkR1VwY21WMGRYSnVJVEU3Wm05eUtHa2dhVzRnWlNsMGFHbHpMbDloWkdSVWQyVmxiaWgwTEZ3aWMyVjBRWFIwY21saWRYUmxYQ0lzZEM1blpYUkJkSFJ5YVdKMWRHVW9hU2tyWENKY0lpeGxXMmxkSzF3aVhDSXNhU3doTVN4cEtTeDBhR2x6TGw5dmRtVnlkM0pwZEdWUWNtOXdjeTV3ZFhOb0tHa3BPM0psZEhWeWJpRXdmWDBwZlNncExGOW5jMU5qYjNCbExsOW5jMFJsWm1sdVpTNXdiSFZuYVc0b2UzQnliM0JPWVcxbE9sd2laR2x5WldOMGFXOXVZV3hTYjNSaGRHbHZibHdpTEhabGNuTnBiMjQ2WENJd0xqSXVNVndpTEVGUVNUb3lMR2x1YVhRNlpuVnVZM1JwYjI0b2RDeGxLWHRjSW05aWFtVmpkRndpSVQxMGVYQmxiMllnWlNZbUtHVTllM0p2ZEdGMGFXOXVPbVY5S1N4MGFHbHpMbVpwYm1Gc2N6MTdmVHQyWVhJZ2FTeHpMSElzYml4aExHOHNiRDFsTG5WelpWSmhaR2xoYm5NOVBUMGhNRDh5S2sxaGRHZ3VVRWs2TXpZd0xHZzlNV1V0Tmp0bWIzSW9hU0JwYmlCbEtWd2lkWE5sVW1Ga2FXRnVjMXdpSVQwOWFTWW1LRzg5S0dWYmFWMHJYQ0pjSWlrdWMzQnNhWFFvWENKZlhDSXBMSE05YjFzd1hTeHlQWEJoY25ObFJteHZZWFFvWENKbWRXNWpkR2x2Ymx3aUlUMTBlWEJsYjJZZ2RGdHBYVDkwVzJsZE9uUmJhUzVwYm1SbGVFOW1LRndpYzJWMFhDSXBmSHhjSW1aMWJtTjBhVzl1WENJaFBYUjVjR1Z2WmlCMFcxd2laMlYwWENJcmFTNXpkV0p6ZEhJb015bGRQMms2WENKblpYUmNJaXRwTG5OMVluTjBjaWd6S1Ywb0tTa3NiajEwYUdsekxtWnBibUZzYzF0cFhUMWNJbk4wY21sdVoxd2lQVDEwZVhCbGIyWWdjeVltWENJOVhDSTlQVDF6TG1Ob1lYSkJkQ2d4S1Q5eUszQmhjbk5sU1c1MEtITXVZMmhoY2tGMEtEQXBLMXdpTVZ3aUxERXdLU3BPZFcxaVpYSW9jeTV6ZFdKemRISW9NaWtwT2s1MWJXSmxjaWh6S1h4OE1DeGhQVzR0Y2l4dkxteGxibWQwYUNZbUtITTlieTVxYjJsdUtGd2lYMXdpS1N3dE1TRTlQWE11YVc1a1pYaFBaaWhjSW5Ob2IzSjBYQ0lwSmlZb1lTVTliQ3hoSVQwOVlTVW9iQzh5S1NZbUtHRTlNRDVoUDJFcmJEcGhMV3dwS1N3dE1TRTlQWE11YVc1a1pYaFBaaWhjSWw5amQxd2lLU1ltTUQ1aFAyRTlLR0VyT1RrNU9UazVPVGs1T1Nwc0tTVnNMU2d3ZkdFdmJDa3FiRG90TVNFOVBYTXVhVzVrWlhoUFppaGNJbU5qZDF3aUtTWW1ZVDR3SmlZb1lUMG9ZUzA1T1RrNU9UazVPVGs1S213cEpXd3RLREI4WVM5c0tTcHNLU2tzS0dFK2FIeDhMV2crWVNrbUppaDBhR2x6TGw5aFpHUlVkMlZsYmloMExHa3NjaXh5SzJFc2FTa3NkR2hwY3k1ZmIzWmxjbmR5YVhSbFVISnZjSE11Y0hWemFDaHBLU2twTzNKbGRIVnliaUV3ZlN4elpYUTZablZ1WTNScGIyNG9kQ2w3ZG1GeUlHVTdhV1lvTVNFOVBYUXBkR2hwY3k1ZmMzVndaWEl1YzJWMFVtRjBhVzh1WTJGc2JDaDBhR2x6TEhRcE8yVnNjMlVnWm05eUtHVTlkR2hwY3k1ZlptbHljM1JRVkR0bE95bGxMbVkvWlM1MFcyVXVjRjBvZEdocGN5NW1hVzVoYkhOYlpTNXdYU2s2WlM1MFcyVXVjRjA5ZEdocGN5NW1hVzVoYkhOYlpTNXdYU3hsUFdVdVgyNWxlSFI5ZlNrdVgyRjFkRzlEVTFNOUlUQXNYMmR6VTJOdmNHVXVYMmR6UkdWbWFXNWxLRndpWldGemFXNW5Ma0poWTJ0Y0lpeGJYQ0psWVhOcGJtY3VSV0Z6WlZ3aVhTeG1kVzVqZEdsdmJpaDBLWHQyWVhJZ1pTeHBMSE1zY2oxZlozTlRZMjl3WlM1SGNtVmxibE52WTJ0SGJHOWlZV3h6Zkh4ZlozTlRZMjl3WlN4dVBYSXVZMjl0TG1keVpXVnVjMjlqYXl4aFBUSXFUV0YwYUM1UVNTeHZQVTFoZEdndVVFa3ZNaXhzUFc0dVgyTnNZWE56TEdnOVpuVnVZM1JwYjI0b1pTeHBLWHQyWVhJZ2N6MXNLRndpWldGemFXNW5MbHdpSzJVc1puVnVZM1JwYjI0b0tYdDlMQ0V3S1N4eVBYTXVjSEp2ZEc5MGVYQmxQVzVsZHlCME8zSmxkSFZ5YmlCeUxtTnZibk4wY25WamRHOXlQWE1zY2k1blpYUlNZWFJwYnoxcExITjlMRjg5ZEM1eVpXZHBjM1JsY254OFpuVnVZM1JwYjI0b0tYdDlMSFU5Wm5WdVkzUnBiMjRvZEN4bExHa3NjeWw3ZG1GeUlISTliQ2hjSW1WaGMybHVaeTVjSWl0MExIdGxZWE5sVDNWME9tNWxkeUJsTEdWaGMyVkpianB1WlhjZ2FTeGxZWE5sU1c1UGRYUTZibVYzSUhOOUxDRXdLVHR5WlhSMWNtNGdYeWh5TEhRcExISjlMR005Wm5WdVkzUnBiMjRvZEN4bExHa3BlM1JvYVhNdWREMTBMSFJvYVhNdWRqMWxMR2ttSmloMGFHbHpMbTVsZUhROWFTeHBMbkJ5WlhZOWRHaHBjeXgwYUdsekxtTTlhUzUyTFdVc2RHaHBjeTVuWVhBOWFTNTBMWFFwZlN4bVBXWjFibU4wYVc5dUtHVXNhU2w3ZG1GeUlITTliQ2hjSW1WaGMybHVaeTVjSWl0bExHWjFibU4wYVc5dUtIUXBlM1JvYVhNdVgzQXhQWFI4ZkRBOVBUMTBQM1E2TVM0M01ERTFPQ3gwYUdsekxsOXdNajB4TGpVeU5TcDBhR2x6TGw5d01YMHNJVEFwTEhJOWN5NXdjbTkwYjNSNWNHVTlibVYzSUhRN2NtVjBkWEp1SUhJdVkyOXVjM1J5ZFdOMGIzSTljeXh5TG1kbGRGSmhkR2x2UFdrc2NpNWpiMjVtYVdjOVpuVnVZM1JwYjI0b2RDbDdjbVYwZFhKdUlHNWxkeUJ6S0hRcGZTeHpmU3h3UFhVb1hDSkNZV05yWENJc1ppaGNJa0poWTJ0UGRYUmNJaXhtZFc1amRHbHZiaWgwS1h0eVpYUjFjbTRvZEMwOU1Ta3FkQ29vS0hSb2FYTXVYM0F4S3pFcEtuUXJkR2hwY3k1ZmNERXBLekY5S1N4bUtGd2lRbUZqYTBsdVhDSXNablZ1WTNScGIyNG9kQ2w3Y21WMGRYSnVJSFFxZENvb0tIUm9hWE11WDNBeEt6RXBLblF0ZEdocGN5NWZjREVwZlNrc1ppaGNJa0poWTJ0SmJrOTFkRndpTEdaMWJtTjBhVzl1S0hRcGUzSmxkSFZ5YmlBeFBpaDBLajB5S1Q4dU5TcDBLblFxS0NoMGFHbHpMbDl3TWlzeEtTcDBMWFJvYVhNdVgzQXlLVG91TlNvb0tIUXRQVElwS25RcUtDaDBhR2x6TGw5d01pc3hLU3AwSzNSb2FYTXVYM0F5S1NzeUtYMHBLU3h0UFd3b1hDSmxZWE5wYm1jdVUyeHZkMDF2WENJc1puVnVZM1JwYjI0b2RDeGxMR2twZTJVOVpYeDhNRDA5UFdVL1pUb3VOeXh1ZFd4c1BUMTBQM1E5TGpjNmRENHhKaVlvZEQweEtTeDBhR2x6TGw5d1BURWhQVDEwUDJVNk1DeDBhR2x6TGw5d01UMG9NUzEwS1M4eUxIUm9hWE11WDNBeVBYUXNkR2hwY3k1ZmNETTlkR2hwY3k1ZmNERXJkR2hwY3k1ZmNESXNkR2hwY3k1ZlkyRnNZMFZ1WkQxcFBUMDlJVEI5TENFd0tTeGtQVzB1Y0hKdmRHOTBlWEJsUFc1bGR5QjBPM0psZEhWeWJpQmtMbU52Ym5OMGNuVmpkRzl5UFcwc1pDNW5aWFJTWVhScGJ6MW1kVzVqZEdsdmJpaDBLWHQyWVhJZ1pUMTBLeWd1TlMxMEtTcDBhR2x6TGw5d08zSmxkSFZ5YmlCMGFHbHpMbDl3TVQ1MFAzUm9hWE11WDJOaGJHTkZibVEvTVMwb2REMHhMWFF2ZEdocGN5NWZjREVwS25RNlpTMG9kRDB4TFhRdmRHaHBjeTVmY0RFcEtuUXFkQ3AwS21VNmRENTBhR2x6TGw5d016OTBhR2x6TGw5allXeGpSVzVrUHpFdEtIUTlLSFF0ZEdocGN5NWZjRE1wTDNSb2FYTXVYM0F4S1NwME9tVXJLSFF0WlNrcUtIUTlLSFF0ZEdocGN5NWZjRE1wTDNSb2FYTXVYM0F4S1NwMEtuUXFkRHAwYUdsekxsOWpZV3hqUlc1a1B6RTZaWDBzYlM1bFlYTmxQVzVsZHlCdEtDNDNMQzQzS1N4a0xtTnZibVpwWnoxdExtTnZibVpwWnoxbWRXNWpkR2x2YmloMExHVXNhU2w3Y21WMGRYSnVJRzVsZHlCdEtIUXNaU3hwS1gwc1pUMXNLRndpWldGemFXNW5MbE4wWlhCd1pXUkZZWE5sWENJc1puVnVZM1JwYjI0b2RDbDdkRDEwZkh3eExIUm9hWE11WDNBeFBURXZkQ3gwYUdsekxsOXdNajEwS3pGOUxDRXdLU3hrUFdVdWNISnZkRzkwZVhCbFBXNWxkeUIwTEdRdVkyOXVjM1J5ZFdOMGIzSTlaU3hrTG1kbGRGSmhkR2x2UFdaMWJtTjBhVzl1S0hRcGUzSmxkSFZ5YmlBd1BuUS9kRDB3T25RK1BURW1KaWgwUFM0NU9UazVPVGs1T1RrcExDaDBhR2x6TGw5d01pcDBQajR3S1NwMGFHbHpMbDl3TVgwc1pDNWpiMjVtYVdjOVpTNWpiMjVtYVdjOVpuVnVZM1JwYjI0b2RDbDdjbVYwZFhKdUlHNWxkeUJsS0hRcGZTeHBQV3dvWENKbFlYTnBibWN1VW05MVoyaEZZWE5sWENJc1puVnVZM1JwYjI0b1pTbDdaVDFsZkh4N2ZUdG1iM0lvZG1GeUlHa3NjeXh5TEc0c1lTeHZMR3c5WlM1MFlYQmxjbng4WENKdWIyNWxYQ0lzYUQxYlhTeGZQVEFzZFQwd2ZDaGxMbkJ2YVc1MGMzeDhNakFwTEdZOWRTeHdQV1V1Y21GdVpHOXRhWHBsSVQwOUlURXNiVDFsTG1Oc1lXMXdQVDA5SVRBc1pEMWxMblJsYlhCc1lYUmxJR2x1YzNSaGJtTmxiMllnZEQ5bExuUmxiWEJzWVhSbE9tNTFiR3dzWnoxY0ltNTFiV0psY2x3aVBUMTBlWEJsYjJZZ1pTNXpkSEpsYm1kMGFEOHVOQ3BsTG5OMGNtVnVaM1JvT2k0ME95MHRaajR0TVRzcGFUMXdQMDFoZEdndWNtRnVaRzl0S0NrNk1TOTFLbVlzY3oxa1AyUXVaMlYwVW1GMGFXOG9hU2s2YVN4Y0ltNXZibVZjSWowOVBXdy9jajFuT2x3aWIzVjBYQ0k5UFQxc1B5aHVQVEV0YVN4eVBXNHFiaXBuS1RwY0ltbHVYQ0k5UFQxc1AzSTlhU3BwS21jNkxqVSthVDhvYmoweUtta3NjajB1TlNwdUttNHFaeWs2S0c0OU1pb29NUzFwS1N4eVBTNDFLbTRxYmlwbktTeHdQM01yUFUxaGRHZ3VjbUZ1Wkc5dEtDa3FjaTB1TlNweU9tWWxNajl6S3owdU5TcHlPbk10UFM0MUtuSXNiU1ltS0hNK01UOXpQVEU2TUQ1ekppWW9jejB3S1Nrc2FGdGZLeXRkUFh0NE9ta3NlVHB6ZlR0bWIzSW9hQzV6YjNKMEtHWjFibU4wYVc5dUtIUXNaU2w3Y21WMGRYSnVJSFF1ZUMxbExuaDlLU3h2UFc1bGR5QmpLREVzTVN4dWRXeHNLU3htUFhVN0xTMW1QaTB4T3lsaFBXaGJabDBzYnoxdVpYY2dZeWhoTG5nc1lTNTVMRzhwTzNSb2FYTXVYM0J5WlhZOWJtVjNJR01vTUN3d0xEQWhQVDF2TG5RL2J6cHZMbTVsZUhRcGZTd2hNQ2tzWkQxcExuQnliM1J2ZEhsd1pUMXVaWGNnZEN4a0xtTnZibk4wY25WamRHOXlQV2tzWkM1blpYUlNZWFJwYnoxbWRXNWpkR2x2YmloMEtYdDJZWElnWlQxMGFHbHpMbDl3Y21WMk8ybG1LSFErWlM1MEtYdG1iM0lvTzJVdWJtVjRkQ1ltZEQ0OVpTNTBPeWxsUFdVdWJtVjRkRHRsUFdVdWNISmxkbjFsYkhObElHWnZjaWc3WlM1d2NtVjJKaVpsTG5RK1BYUTdLV1U5WlM1d2NtVjJPM0psZEhWeWJpQjBhR2x6TGw5d2NtVjJQV1VzWlM1Mkt5aDBMV1V1ZENrdlpTNW5ZWEFxWlM1amZTeGtMbU52Ym1acFp6MW1kVzVqZEdsdmJpaDBLWHR5WlhSMWNtNGdibVYzSUdrb2RDbDlMR2t1WldGelpUMXVaWGNnYVN4MUtGd2lRbTkxYm1ObFhDSXNhQ2hjSWtKdmRXNWpaVTkxZEZ3aUxHWjFibU4wYVc5dUtIUXBlM0psZEhWeWJpQXhMekl1TnpVK2REODNMalUyTWpVcWRDcDBPakl2TWk0M05UNTBQemN1TlRZeU5Tb29kQzA5TVM0MUx6SXVOelVwS25RckxqYzFPakl1TlM4eUxqYzFQblEvTnk0MU5qSTFLaWgwTFQweUxqSTFMekl1TnpVcEtuUXJMamt6TnpVNk55NDFOakkxS2loMExUMHlMall5TlM4eUxqYzFLU3AwS3k0NU9EUXpOelY5S1N4b0tGd2lRbTkxYm1ObFNXNWNJaXhtZFc1amRHbHZiaWgwS1h0eVpYUjFjbTRnTVM4eUxqYzFQaWgwUFRFdGRDay9NUzAzTGpVMk1qVXFkQ3AwT2pJdk1pNDNOVDUwUHpFdEtEY3VOVFl5TlNvb2RDMDlNUzQxTHpJdU56VXBLblFyTGpjMUtUb3lMalV2TWk0M05UNTBQekV0S0RjdU5UWXlOU29vZEMwOU1pNHlOUzh5TGpjMUtTcDBLeTQ1TXpjMUtUb3hMU2czTGpVMk1qVXFLSFF0UFRJdU5qSTFMekl1TnpVcEtuUXJMams0TkRNM05TbDlLU3hvS0Z3aVFtOTFibU5sU1c1UGRYUmNJaXhtZFc1amRHbHZiaWgwS1h0MllYSWdaVDB1TlQ1ME8zSmxkSFZ5YmlCMFBXVS9NUzB5S25RNk1pcDBMVEVzZEQweEx6SXVOelUrZEQ4M0xqVTJNalVxZENwME9qSXZNaTQzTlQ1MFB6Y3VOVFl5TlNvb2RDMDlNUzQxTHpJdU56VXBLblFyTGpjMU9qSXVOUzh5TGpjMVBuUS9OeTQxTmpJMUtpaDBMVDB5TGpJMUx6SXVOelVwS25Rckxqa3pOelU2Tnk0MU5qSTFLaWgwTFQweUxqWXlOUzh5TGpjMUtTcDBLeTQ1T0RRek56VXNaVDh1TlNvb01TMTBLVG91TlNwMEt5NDFmU2twTEhVb1hDSkRhWEpqWENJc2FDaGNJa05wY21OUGRYUmNJaXhtZFc1amRHbHZiaWgwS1h0eVpYUjFjbTRnVFdGMGFDNXpjWEowS0RFdEtIUXRQVEVwS25RcGZTa3NhQ2hjSWtOcGNtTkpibHdpTEdaMWJtTjBhVzl1S0hRcGUzSmxkSFZ5Ymkwb1RXRjBhQzV6Y1hKMEtERXRkQ3AwS1MweEtYMHBMR2dvWENKRGFYSmpTVzVQZFhSY0lpeG1kVzVqZEdsdmJpaDBLWHR5WlhSMWNtNGdNVDRvZENvOU1pay9MUzQxS2loTllYUm9Mbk54Y25Rb01TMTBLblFwTFRFcE9pNDFLaWhOWVhSb0xuTnhjblFvTVMwb2RDMDlNaWtxZENrck1TbDlLU2tzY3oxbWRXNWpkR2x2YmlobExHa3NjeWw3ZG1GeUlISTliQ2hjSW1WaGMybHVaeTVjSWl0bExHWjFibU4wYVc5dUtIUXNaU2w3ZEdocGN5NWZjREU5ZEQ0OU1UOTBPakVzZEdocGN5NWZjREk5S0dWOGZITXBMeWd4UG5RL2REb3hLU3gwYUdsekxsOXdNejEwYUdsekxsOXdNaTloS2loTllYUm9MbUZ6YVc0b01TOTBhR2x6TGw5d01TbDhmREFwTEhSb2FYTXVYM0F5UFdFdmRHaHBjeTVmY0RKOUxDRXdLU3h1UFhJdWNISnZkRzkwZVhCbFBXNWxkeUIwTzNKbGRIVnliaUJ1TG1OdmJuTjBjblZqZEc5eVBYSXNiaTVuWlhSU1lYUnBiejFwTEc0dVkyOXVabWxuUFdaMWJtTjBhVzl1S0hRc1pTbDdjbVYwZFhKdUlHNWxkeUJ5S0hRc1pTbDlMSEo5TEhVb1hDSkZiR0Z6ZEdsalhDSXNjeWhjSWtWc1lYTjBhV05QZFhSY0lpeG1kVzVqZEdsdmJpaDBLWHR5WlhSMWNtNGdkR2hwY3k1ZmNERXFUV0YwYUM1d2IzY29NaXd0TVRBcWRDa3FUV0YwYUM1emFXNG9LSFF0ZEdocGN5NWZjRE1wS25Sb2FYTXVYM0F5S1NzeGZTd3VNeWtzY3loY0lrVnNZWE4wYVdOSmJsd2lMR1oxYm1OMGFXOXVLSFFwZTNKbGRIVnliaTBvZEdocGN5NWZjREVxVFdGMGFDNXdiM2NvTWl3eE1Db29kQzA5TVNrcEtrMWhkR2d1YzJsdUtDaDBMWFJvYVhNdVgzQXpLU3AwYUdsekxsOXdNaWtwZlN3dU15a3NjeWhjSWtWc1lYTjBhV05KYms5MWRGd2lMR1oxYm1OMGFXOXVLSFFwZTNKbGRIVnliaUF4UGloMEtqMHlLVDh0TGpVcWRHaHBjeTVmY0RFcVRXRjBhQzV3YjNjb01pd3hNQ29vZEMwOU1Ta3BLazFoZEdndWMybHVLQ2gwTFhSb2FYTXVYM0F6S1NwMGFHbHpMbDl3TWlrNkxqVXFkR2hwY3k1ZmNERXFUV0YwYUM1d2IzY29NaXd0TVRBcUtIUXRQVEVwS1NwTllYUm9Mbk5wYmlnb2RDMTBhR2x6TGw5d015a3FkR2hwY3k1ZmNESXBLekY5TEM0ME5Ta3BMSFVvWENKRmVIQnZYQ0lzYUNoY0lrVjRjRzlQZFhSY0lpeG1kVzVqZEdsdmJpaDBLWHR5WlhSMWNtNGdNUzFOWVhSb0xuQnZkeWd5TEMweE1DcDBLWDBwTEdnb1hDSkZlSEJ2U1c1Y0lpeG1kVzVqZEdsdmJpaDBLWHR5WlhSMWNtNGdUV0YwYUM1d2IzY29NaXd4TUNvb2RDMHhLU2t0TGpBd01YMHBMR2dvWENKRmVIQnZTVzVQZFhSY0lpeG1kVzVqZEdsdmJpaDBLWHR5WlhSMWNtNGdNVDRvZENvOU1pay9MalVxVFdGMGFDNXdiM2NvTWl3eE1Db29kQzB4S1NrNkxqVXFLREl0VFdGMGFDNXdiM2NvTWl3dE1UQXFLSFF0TVNrcEtYMHBLU3gxS0Z3aVUybHVaVndpTEdnb1hDSlRhVzVsVDNWMFhDSXNablZ1WTNScGIyNG9kQ2w3Y21WMGRYSnVJRTFoZEdndWMybHVLSFFxYnlsOUtTeG9LRndpVTJsdVpVbHVYQ0lzWm5WdVkzUnBiMjRvZENsN2NtVjBkWEp1TFUxaGRHZ3VZMjl6S0hRcWJ5a3JNWDBwTEdnb1hDSlRhVzVsU1c1UGRYUmNJaXhtZFc1amRHbHZiaWgwS1h0eVpYUjFjbTR0TGpVcUtFMWhkR2d1WTI5ektFMWhkR2d1VUVrcWRDa3RNU2w5S1Nrc2JDaGNJbVZoYzJsdVp5NUZZWE5sVEc5dmEzVndYQ0lzZTJacGJtUTZablZ1WTNScGIyNG9aU2w3Y21WMGRYSnVJSFF1YldGd1cyVmRmWDBzSVRBcExGOG9jaTVUYkc5M1RXOHNYQ0pUYkc5M1RXOWNJaXhjSW1WaGMyVXNYQ0lwTEY4b2FTeGNJbEp2ZFdkb1JXRnpaVndpTEZ3aVpXRnpaU3hjSWlrc1h5aGxMRndpVTNSbGNIQmxaRVZoYzJWY0lpeGNJbVZoYzJVc1hDSXBMSEI5TENFd0tYMHBMRjluYzFOamIzQmxMbDluYzBSbFptbHVaU1ltWDJkelUyTnZjR1V1WDJkelVYVmxkV1V1Y0c5d0tDa29LU3htZFc1amRHbHZiaWgwTEdVcGUxd2lkWE5sSUhOMGNtbGpkRndpTzNaaGNpQnBQWFF1UjNKbFpXNVRiMk5yUjJ4dlltRnNjejEwTGtkeVpXVnVVMjlqYTBkc2IySmhiSE44ZkhRN2FXWW9JV2t1VkhkbFpXNU1hWFJsS1h0MllYSWdjeXh5TEc0c1lTeHZMR3c5Wm5WdVkzUnBiMjRvZENsN2RtRnlJR1VzY3oxMExuTndiR2wwS0Z3aUxsd2lLU3h5UFdrN1ptOXlLR1U5TUR0ekxteGxibWQwYUQ1bE8yVXJLeWx5VzNOYlpWMWRQWEk5Y2x0elcyVmRYWHg4ZTMwN2NtVjBkWEp1SUhKOUxHZzliQ2hjSW1OdmJTNW5jbVZsYm5OdlkydGNJaWtzWHoweFpTMHhNQ3gxUFdaMWJtTjBhVzl1S0hRcGUzWmhjaUJsTEdrOVcxMHNjejEwTG14bGJtZDBhRHRtYjNJb1pUMHdPMlVoUFQxek8ya3VjSFZ6YUNoMFcyVXJLMTBwS1R0eVpYUjFjbTRnYVgwc1l6MW1kVzVqZEdsdmJpZ3BlMzBzWmoxbWRXNWpkR2x2YmlncGUzWmhjaUIwUFU5aWFtVmpkQzV3Y205MGIzUjVjR1V1ZEc5VGRISnBibWNzWlQxMExtTmhiR3dvVzEwcE8zSmxkSFZ5YmlCbWRXNWpkR2x2YmlocEtYdHlaWFIxY200Z2JuVnNiQ0U5YVNZbUtHa2dhVzV6ZEdGdVkyVnZaaUJCY25KaGVYeDhYQ0p2WW1wbFkzUmNJajA5ZEhsd1pXOW1JR2ttSmlFaGFTNXdkWE5vSmlaMExtTmhiR3dvYVNrOVBUMWxLWDE5S0Nrc2NEMTdmU3h0UFdaMWJtTjBhVzl1S0hNc2NpeHVMR0VwZTNSb2FYTXVjMk05Y0Z0elhUOXdXM05kTG5Oak9sdGRMSEJiYzEwOWRHaHBjeXgwYUdsekxtZHpRMnhoYzNNOWJuVnNiQ3gwYUdsekxtWjFibU05Ymp0MllYSWdiejFiWFR0MGFHbHpMbU5vWldOclBXWjFibU4wYVc5dUtHZ3BlMlp2Y2loMllYSWdYeXgxTEdNc1ppeGtMR2M5Y2k1c1pXNW5kR2dzZGoxbk95MHRaejR0TVRzcEtGODljRnR5VzJkZFhYeDhibVYzSUcwb2NsdG5YU3hiWFNrcExtZHpRMnhoYzNNL0tHOWJaMTA5WHk1bmMwTnNZWE56TEhZdExTazZhQ1ltWHk1ell5NXdkWE5vS0hSb2FYTXBPMmxtS0RBOVBUMTJKaVp1S1dadmNpaDFQU2hjSW1OdmJTNW5jbVZsYm5Odlkyc3VYQ0lyY3lrdWMzQnNhWFFvWENJdVhDSXBMR005ZFM1d2IzQW9LU3htUFd3b2RTNXFiMmx1S0Z3aUxsd2lLU2xiWTEwOWRHaHBjeTVuYzBOc1lYTnpQVzR1WVhCd2JIa29iaXh2S1N4aEppWW9hVnRqWFQxbUxHUTlYQ0oxYm1SbFptbHVaV1JjSWlFOWRIbHdaVzltSUcxdlpIVnNaU1ltYlc5a2RXeGxMbVY0Y0c5eWRITXNJV1FtSmx3aVpuVnVZM1JwYjI1Y0lqMDlkSGx3Wlc5bUlHUmxabWx1WlNZbVpHVm1hVzVsTG1GdFpEOWtaV1pwYm1Vb0tIUXVSM0psWlc1VGIyTnJRVTFFVUdGMGFEOTBMa2R5WldWdVUyOWphMEZOUkZCaGRHZ3JYQ0l2WENJNlhDSmNJaWtyY3k1emNHeHBkQ2hjSWk1Y0lpa3VjRzl3S0Nrc1cxMHNablZ1WTNScGIyNG9LWHR5WlhSMWNtNGdabjBwT25NOVBUMWxKaVprSmlZb2JXOWtkV3hsTG1WNGNHOXlkSE05WmlrcExHYzlNRHQwYUdsekxuTmpMbXhsYm1kMGFENW5PMmNyS3lsMGFHbHpMbk5qVzJkZExtTm9aV05yS0NsOUxIUm9hWE11WTJobFkyc29JVEFwZlN4a1BYUXVYMmR6UkdWbWFXNWxQV1oxYm1OMGFXOXVLSFFzWlN4cExITXBlM0psZEhWeWJpQnVaWGNnYlNoMExHVXNhU3h6S1gwc1p6MW9MbDlqYkdGemN6MW1kVzVqZEdsdmJpaDBMR1VzYVNsN2NtVjBkWEp1SUdVOVpYeDhablZ1WTNScGIyNG9LWHQ5TEdRb2RDeGJYU3htZFc1amRHbHZiaWdwZTNKbGRIVnliaUJsZlN4cEtTeGxmVHRrTG1kc2IySmhiSE05YVR0MllYSWdkajFiTUN3d0xERXNNVjBzZVQxYlhTeFVQV2NvWENKbFlYTnBibWN1UldGelpWd2lMR1oxYm1OMGFXOXVLSFFzWlN4cExITXBlM1JvYVhNdVgyWjFibU05ZEN4MGFHbHpMbDkwZVhCbFBXbDhmREFzZEdocGN5NWZjRzkzWlhJOWMzeDhNQ3gwYUdsekxsOXdZWEpoYlhNOVpUOTJMbU52Ym1OaGRDaGxLVHAyZlN3aE1Da3NlRDFVTG0xaGNEMTdmU3gzUFZRdWNtVm5hWE4wWlhJOVpuVnVZM1JwYjI0b2RDeGxMR2tzY3lsN1ptOXlLSFpoY2lCeUxHNHNZU3h2TEd3OVpTNXpjR3hwZENoY0lpeGNJaWtzWHoxc0xteGxibWQwYUN4MVBTaHBmSHhjSW1WaGMyVkpiaXhsWVhObFQzVjBMR1ZoYzJWSmJrOTFkRndpS1M1emNHeHBkQ2hjSWl4Y0lpazdMUzFmUGkweE95bG1iM0lvYmoxc1cxOWRMSEk5Y3o5bktGd2laV0Z6YVc1bkxsd2lLMjRzYm5Wc2JDd2hNQ2s2YUM1bFlYTnBibWRiYmwxOGZIdDlMR0U5ZFM1c1pXNW5kR2c3TFMxaFBpMHhPeWx2UFhWYllWMHNlRnR1SzF3aUxsd2lLMjlkUFhoYmJ5dHVYVDF5VzI5ZFBYUXVaMlYwVW1GMGFXOC9kRHAwVzI5ZGZIeHVaWGNnZEgwN1ptOXlLRzQ5VkM1d2NtOTBiM1I1Y0dVc2JpNWZZMkZzWTBWdVpEMGhNU3h1TG1kbGRGSmhkR2x2UFdaMWJtTjBhVzl1S0hRcGUybG1LSFJvYVhNdVgyWjFibU1wY21WMGRYSnVJSFJvYVhNdVgzQmhjbUZ0YzFzd1hUMTBMSFJvYVhNdVgyWjFibU11WVhCd2JIa29iblZzYkN4MGFHbHpMbDl3WVhKaGJYTXBPM1poY2lCbFBYUm9hWE11WDNSNWNHVXNhVDEwYUdsekxsOXdiM2RsY2l4elBURTlQVDFsUHpFdGREb3lQVDA5WlQ5ME9pNDFQblEvTWlwME9qSXFLREV0ZENrN2NtVjBkWEp1SURFOVBUMXBQM01xUFhNNk1qMDlQV2svY3lvOWN5cHpPak05UFQxcFAzTXFQWE1xY3lwek9qUTlQVDFwSmlZb2N5bzljeXB6S25NcWN5a3NNVDA5UFdVL01TMXpPakk5UFQxbFAzTTZMalUrZEQ5ekx6STZNUzF6THpKOUxITTlXMXdpVEdsdVpXRnlYQ0lzWENKUmRXRmtYQ0lzWENKRGRXSnBZMXdpTEZ3aVVYVmhjblJjSWl4Y0lsRjFhVzUwTEZOMGNtOXVaMXdpWFN4eVBYTXViR1Z1WjNSb095MHRjajR0TVRzcGJqMXpXM0pkSzF3aUxGQnZkMlZ5WENJcmNpeDNLRzVsZHlCVUtHNTFiR3dzYm5Wc2JDd3hMSElwTEc0c1hDSmxZWE5sVDNWMFhDSXNJVEFwTEhjb2JtVjNJRlFvYm5Wc2JDeHVkV3hzTERJc2Npa3NiaXhjSW1WaGMyVkpibHdpS3lnd1BUMDljajljSWl4bFlYTmxUbTl1WlZ3aU9sd2lYQ0lwS1N4M0tHNWxkeUJVS0c1MWJHd3NiblZzYkN3ekxISXBMRzRzWENKbFlYTmxTVzVQZFhSY0lpazdlQzVzYVc1bFlYSTlhQzVsWVhOcGJtY3VUR2x1WldGeUxtVmhjMlZKYml4NExuTjNhVzVuUFdndVpXRnphVzVuTGxGMVlXUXVaV0Z6WlVsdVQzVjBPM1poY2lCaVBXY29YQ0psZG1WdWRITXVSWFpsYm5SRWFYTndZWFJqYUdWeVhDSXNablZ1WTNScGIyNG9kQ2w3ZEdocGN5NWZiR2x6ZEdWdVpYSnpQWHQ5TEhSb2FYTXVYMlYyWlc1MFZHRnlaMlYwUFhSOGZIUm9hWE45S1R0dVBXSXVjSEp2ZEc5MGVYQmxMRzR1WVdSa1JYWmxiblJNYVhOMFpXNWxjajFtZFc1amRHbHZiaWgwTEdVc2FTeHpMSElwZTNJOWNueDhNRHQyWVhJZ2JpeHNMR2c5ZEdocGN5NWZiR2x6ZEdWdVpYSnpXM1JkTEY4OU1EdG1iM0lvYm5Wc2JEMDlhQ1ltS0hSb2FYTXVYMnhwYzNSbGJtVnljMXQwWFQxb1BWdGRLU3hzUFdndWJHVnVaM1JvT3kwdGJENHRNVHNwYmoxb1cyeGRMRzR1WXowOVBXVW1KbTR1Y3owOVBXay9hQzV6Y0d4cFkyVW9iQ3d4S1Rvd1BUMDlYeVltY2o1dUxuQnlKaVlvWHoxc0t6RXBPMmd1YzNCc2FXTmxLRjhzTUN4N1l6cGxMSE02YVN4MWNEcHpMSEJ5T25KOUtTeDBhR2x6SVQwOVlYeDhiM3g4WVM1M1lXdGxLQ2w5TEc0dWNtVnRiM1psUlhabGJuUk1hWE4wWlc1bGNqMW1kVzVqZEdsdmJpaDBMR1VwZTNaaGNpQnBMSE05ZEdocGN5NWZiR2x6ZEdWdVpYSnpXM1JkTzJsbUtITXBabTl5S0drOWN5NXNaVzVuZEdnN0xTMXBQaTB4T3lscFppaHpXMmxkTG1NOVBUMWxLWEpsZEhWeWJpQnpMbk53YkdsalpTaHBMREVwTEhadmFXUWdNSDBzYmk1a2FYTndZWFJqYUVWMlpXNTBQV1oxYm1OMGFXOXVLSFFwZTNaaGNpQmxMR2tzY3l4eVBYUm9hWE11WDJ4cGMzUmxibVZ5YzF0MFhUdHBaaWh5S1dadmNpaGxQWEl1YkdWdVozUm9MR2s5ZEdocGN5NWZaWFpsYm5SVVlYSm5aWFE3TFMxbFBpMHhPeWx6UFhKYlpWMHNjeVltS0hNdWRYQS9jeTVqTG1OaGJHd29jeTV6Zkh4cExIdDBlWEJsT25Rc2RHRnlaMlYwT21sOUtUcHpMbU11WTJGc2JDaHpMbk44ZkdrcEtYMDdkbUZ5SUZBOWRDNXlaWEYxWlhOMFFXNXBiV0YwYVc5dVJuSmhiV1VzYXoxMExtTmhibU5sYkVGdWFXMWhkR2x2YmtaeVlXMWxMRk05UkdGMFpTNXViM2Q4ZkdaMWJtTjBhVzl1S0NsN2NtVjBkWEp1S0c1bGR5QkVZWFJsS1M1blpYUlVhVzFsS0NsOUxGSTlVeWdwTzJadmNpaHpQVnRjSW0xelhDSXNYQ0p0YjNwY0lpeGNJbmRsWW10cGRGd2lMRndpYjF3aVhTeHlQWE11YkdWdVozUm9PeTB0Y2o0dE1TWW1JVkE3S1ZBOWRGdHpXM0pkSzF3aVVtVnhkV1Z6ZEVGdWFXMWhkR2x2YmtaeVlXMWxYQ0pkTEdzOWRGdHpXM0pkSzF3aVEyRnVZMlZzUVc1cGJXRjBhVzl1Um5KaGJXVmNJbDE4ZkhSYmMxdHlYU3RjSWtOaGJtTmxiRkpsY1hWbGMzUkJibWx0WVhScGIyNUdjbUZ0WlZ3aVhUdG5LRndpVkdsamEyVnlYQ0lzWm5WdVkzUnBiMjRvZEN4bEtYdDJZWElnYVN4ekxISXNiaXhzTEdnOWRHaHBjeXgxUFZNb0tTeG1QV1VoUFQwaE1TWW1VQ3h3UFRVd01DeHRQVE16TEdROVhDSjBhV05yWENJc1p6MW1kVzVqZEdsdmJpaDBLWHQyWVhJZ1pTeGhMRzg5VXlncExWSTdiejV3SmlZb2RTczlieTF0S1N4U0t6MXZMR2d1ZEdsdFpUMG9VaTExS1M4eFpUTXNaVDFvTG5ScGJXVXRiQ3dvSVdsOGZHVStNSHg4ZEQwOVBTRXdLU1ltS0dndVpuSmhiV1VyS3l4c0t6MWxLeWhsUGoxdVB5NHdNRFE2YmkxbEtTeGhQU0V3S1N4MElUMDlJVEFtSmloeVBYTW9aeWtwTEdFbUptZ3VaR2x6Y0dGMFkyaEZkbVZ1ZENoa0tYMDdZaTVqWVd4c0tHZ3BMR2d1ZEdsdFpUMW9MbVp5WVcxbFBUQXNhQzUwYVdOclBXWjFibU4wYVc5dUtDbDdaeWdoTUNsOUxHZ3ViR0ZuVTIxdmIzUm9hVzVuUFdaMWJtTjBhVzl1S0hRc1pTbDdjRDEwZkh3eEwxOHNiVDFOWVhSb0xtMXBiaWhsTEhBc01DbDlMR2d1YzJ4bFpYQTlablZ1WTNScGIyNG9LWHR1ZFd4c0lUMXlKaVlvWmlZbWF6OXJLSElwT21Oc1pXRnlWR2x0Wlc5MWRDaHlLU3h6UFdNc2NqMXVkV3hzTEdnOVBUMWhKaVlvYnowaE1Ta3BmU3hvTG5kaGEyVTlablZ1WTNScGIyNG9LWHR1ZFd4c0lUMDljajlvTG5Oc1pXVndLQ2s2YUM1bWNtRnRaVDR4TUNZbUtGSTlVeWdwTFhBck5Ta3NjejB3UFQwOWFUOWpPbVltSmxBL1VEcG1kVzVqZEdsdmJpaDBLWHR5WlhSMWNtNGdjMlYwVkdsdFpXOTFkQ2gwTERCOE1XVXpLaWhzTFdndWRHbHRaU2tyTVNsOUxHZzlQVDFoSmlZb2J6MGhNQ2tzWnlneUtYMHNhQzVtY0hNOVpuVnVZM1JwYjI0b2RDbDdjbVYwZFhKdUlHRnlaM1Z0Wlc1MGN5NXNaVzVuZEdnL0tHazlkQ3h1UFRFdktHbDhmRFl3S1N4c1BYUm9hWE11ZEdsdFpTdHVMR2d1ZDJGclpTZ3BMSFp2YVdRZ01DazZhWDBzYUM1MWMyVlNRVVk5Wm5WdVkzUnBiMjRvZENsN2NtVjBkWEp1SUdGeVozVnRaVzUwY3k1c1pXNW5kR2cvS0dndWMyeGxaWEFvS1N4bVBYUXNhQzVtY0hNb2FTa3NkbTlwWkNBd0tUcG1mU3hvTG1ad2N5aDBLU3h6WlhSVWFXMWxiM1YwS0daMWJtTjBhVzl1S0NsN1ppWW1OVDVvTG1aeVlXMWxKaVpvTG5WelpWSkJSaWdoTVNsOUxERTFNREFwZlNrc2JqMW9MbFJwWTJ0bGNpNXdjbTkwYjNSNWNHVTlibVYzSUdndVpYWmxiblJ6TGtWMlpXNTBSR2x6Y0dGMFkyaGxjaXh1TG1OdmJuTjBjblZqZEc5eVBXZ3VWR2xqYTJWeU8zWmhjaUJQUFdjb1hDSmpiM0psTGtGdWFXMWhkR2x2Ymx3aUxHWjFibU4wYVc5dUtIUXNaU2w3YVdZb2RHaHBjeTUyWVhKelBXVTlaWHg4ZTMwc2RHaHBjeTVmWkhWeVlYUnBiMjQ5ZEdocGN5NWZkRzkwWVd4RWRYSmhkR2x2YmoxMGZId3dMSFJvYVhNdVgyUmxiR0Y1UFU1MWJXSmxjaWhsTG1SbGJHRjVLWHg4TUN4MGFHbHpMbDkwYVcxbFUyTmhiR1U5TVN4MGFHbHpMbDloWTNScGRtVTlaUzVwYlcxbFpHbGhkR1ZTWlc1a1pYSTlQVDBoTUN4MGFHbHpMbVJoZEdFOVpTNWtZWFJoTEhSb2FYTXVYM0psZG1WeWMyVmtQV1V1Y21WMlpYSnpaV1E5UFQwaE1DeFhLWHR2Zkh4aExuZGhhMlVvS1R0MllYSWdhVDEwYUdsekxuWmhjbk11ZFhObFJuSmhiV1Z6UDBjNlZ6dHBMbUZrWkNoMGFHbHpMR2t1WDNScGJXVXBMSFJvYVhNdWRtRnljeTV3WVhWelpXUW1KblJvYVhNdWNHRjFjMlZrS0NFd0tYMTlLVHRoUFU4dWRHbGphMlZ5UFc1bGR5Qm9MbFJwWTJ0bGNpeHVQVTh1Y0hKdmRHOTBlWEJsTEc0dVgyUnBjblI1UFc0dVgyZGpQVzR1WDJsdWFYUjBaV1E5Ymk1ZmNHRjFjMlZrUFNFeExHNHVYM1J2ZEdGc1ZHbHRaVDF1TGw5MGFXMWxQVEFzYmk1ZmNtRjNVSEpsZGxScGJXVTlMVEVzYmk1ZmJtVjRkRDF1TGw5c1lYTjBQVzR1WDI5dVZYQmtZWFJsUFc0dVgzUnBiV1ZzYVc1bFBXNHVkR2x0Wld4cGJtVTliblZzYkN4dUxsOXdZWFZ6WldROUlURTdkbUZ5SUVFOVpuVnVZM1JwYjI0b0tYdHZKaVpUS0NrdFVqNHlaVE1tSm1FdWQyRnJaU2dwTEhObGRGUnBiV1Z2ZFhRb1FTd3laVE1wZlR0QktDa3NiaTV3YkdGNVBXWjFibU4wYVc5dUtIUXNaU2w3Y21WMGRYSnVJRzUxYkd3aFBYUW1KblJvYVhNdWMyVmxheWgwTEdVcExIUm9hWE11Y21WMlpYSnpaV1FvSVRFcExuQmhkWE5sWkNnaE1TbDlMRzR1Y0dGMWMyVTlablZ1WTNScGIyNG9kQ3hsS1h0eVpYUjFjbTRnYm5Wc2JDRTlkQ1ltZEdocGN5NXpaV1ZyS0hRc1pTa3NkR2hwY3k1d1lYVnpaV1FvSVRBcGZTeHVMbkpsYzNWdFpUMW1kVzVqZEdsdmJpaDBMR1VwZTNKbGRIVnliaUJ1ZFd4c0lUMTBKaVowYUdsekxuTmxaV3NvZEN4bEtTeDBhR2x6TG5CaGRYTmxaQ2doTVNsOUxHNHVjMlZsYXoxbWRXNWpkR2x2YmloMExHVXBlM0psZEhWeWJpQjBhR2x6TG5SdmRHRnNWR2x0WlNoT2RXMWlaWElvZENrc1pTRTlQU0V4S1gwc2JpNXlaWE4wWVhKMFBXWjFibU4wYVc5dUtIUXNaU2w3Y21WMGRYSnVJSFJvYVhNdWNtVjJaWEp6WldRb0lURXBMbkJoZFhObFpDZ2hNU2t1ZEc5MFlXeFVhVzFsS0hRL0xYUm9hWE11WDJSbGJHRjVPakFzWlNFOVBTRXhMQ0V3S1gwc2JpNXlaWFpsY25ObFBXWjFibU4wYVc5dUtIUXNaU2w3Y21WMGRYSnVJRzUxYkd3aFBYUW1KblJvYVhNdWMyVmxheWgwZkh4MGFHbHpMblJ2ZEdGc1JIVnlZWFJwYjI0b0tTeGxLU3gwYUdsekxuSmxkbVZ5YzJWa0tDRXdLUzV3WVhWelpXUW9JVEVwZlN4dUxuSmxibVJsY2oxbWRXNWpkR2x2YmlncGUzMHNiaTVwYm5aaGJHbGtZWFJsUFdaMWJtTjBhVzl1S0NsN2NtVjBkWEp1SUhSb2FYTXVYM1JwYldVOWRHaHBjeTVmZEc5MFlXeFVhVzFsUFRBc2RHaHBjeTVmYVc1cGRIUmxaRDEwYUdsekxsOW5ZejBoTVN4MGFHbHpMbDl5WVhkUWNtVjJWR2x0WlQwdE1Td29kR2hwY3k1ZloyTjhmQ0YwYUdsekxuUnBiV1ZzYVc1bEtTWW1kR2hwY3k1ZlpXNWhZbXhsWkNnaE1Da3NkR2hwYzMwc2JpNXBjMEZqZEdsMlpUMW1kVzVqZEdsdmJpZ3BlM1poY2lCMExHVTlkR2hwY3k1ZmRHbHRaV3hwYm1Vc2FUMTBhR2x6TGw5emRHRnlkRlJwYldVN2NtVjBkWEp1SVdWOGZDRjBhR2x6TGw5bll5WW1JWFJvYVhNdVgzQmhkWE5sWkNZbVpTNXBjMEZqZEdsMlpTZ3BKaVlvZEQxbExuSmhkMVJwYldVb0tTaytQV2ttSm1rcmRHaHBjeTUwYjNSaGJFUjFjbUYwYVc5dUtDa3ZkR2hwY3k1ZmRHbHRaVk5qWVd4bFBuUjlMRzR1WDJWdVlXSnNaV1E5Wm5WdVkzUnBiMjRvZEN4bEtYdHlaWFIxY200Z2IzeDhZUzUzWVd0bEtDa3NkR2hwY3k1ZloyTTlJWFFzZEdocGN5NWZZV04wYVhabFBYUm9hWE11YVhOQlkzUnBkbVVvS1N4bElUMDlJVEFtSmloMEppWWhkR2hwY3k1MGFXMWxiR2x1WlQ5MGFHbHpMbDkwYVcxbGJHbHVaUzVoWkdRb2RHaHBjeXgwYUdsekxsOXpkR0Z5ZEZScGJXVXRkR2hwY3k1ZlpHVnNZWGtwT2lGMEppWjBhR2x6TG5ScGJXVnNhVzVsSmlaMGFHbHpMbDkwYVcxbGJHbHVaUzVmY21WdGIzWmxLSFJvYVhNc0lUQXBLU3doTVgwc2JpNWZhMmxzYkQxbWRXNWpkR2x2YmlncGUzSmxkSFZ5YmlCMGFHbHpMbDlsYm1GaWJHVmtLQ0V4TENFeEtYMHNiaTVyYVd4c1BXWjFibU4wYVc5dUtIUXNaU2w3Y21WMGRYSnVJSFJvYVhNdVgydHBiR3dvZEN4bEtTeDBhR2x6ZlN4dUxsOTFibU5oWTJobFBXWjFibU4wYVc5dUtIUXBlMlp2Y2loMllYSWdaVDEwUDNSb2FYTTZkR2hwY3k1MGFXMWxiR2x1WlR0bE95bGxMbDlrYVhKMGVUMGhNQ3hsUFdVdWRHbHRaV3hwYm1VN2NtVjBkWEp1SUhSb2FYTjlMRzR1WDNOM1lYQlRaV3htU1c1UVlYSmhiWE05Wm5WdVkzUnBiMjRvZENsN1ptOXlLSFpoY2lCbFBYUXViR1Z1WjNSb0xHazlkQzVqYjI1allYUW9LVHN0TFdVK0xURTdLVndpZTNObGJHWjlYQ0k5UFQxMFcyVmRKaVlvYVZ0bFhUMTBhR2x6S1R0eVpYUjFjbTRnYVgwc2JpNWZZMkZzYkdKaFkyczlablZ1WTNScGIyNG9kQ2w3ZG1GeUlHVTlkR2hwY3k1MllYSnpPMlZiZEYwdVlYQndiSGtvWlZ0MEsxd2lVMk52Y0dWY0lsMThmR1V1WTJGc2JHSmhZMnRUWTI5d1pYeDhkR2hwY3l4bFczUXJYQ0pRWVhKaGJYTmNJbDE4ZkhrcGZTeHVMbVYyWlc1MFEyRnNiR0poWTJzOVpuVnVZM1JwYjI0b2RDeGxMR2tzY3lsN2FXWW9YQ0p2Ymx3aVBUMDlLSFI4ZkZ3aVhDSXBMbk4xWW5OMGNpZ3dMRElwS1h0MllYSWdjajEwYUdsekxuWmhjbk03YVdZb01UMDlQV0Z5WjNWdFpXNTBjeTVzWlc1bmRHZ3BjbVYwZFhKdUlISmJkRjA3Ym5Wc2JEMDlaVDlrWld4bGRHVWdjbHQwWFRvb2NsdDBYVDFsTEhKYmRDdGNJbEJoY21GdGMxd2lYVDFtS0drcEppWXRNU0U5UFdrdWFtOXBiaWhjSWx3aUtTNXBibVJsZUU5bUtGd2llM05sYkdaOVhDSXBQM1JvYVhNdVgzTjNZWEJUWld4bVNXNVFZWEpoYlhNb2FTazZhU3h5VzNRclhDSlRZMjl3WlZ3aVhUMXpLU3hjSW05dVZYQmtZWFJsWENJOVBUMTBKaVlvZEdocGN5NWZiMjVWY0dSaGRHVTlaU2w5Y21WMGRYSnVJSFJvYVhOOUxHNHVaR1ZzWVhrOVpuVnVZM1JwYjI0b2RDbDdjbVYwZFhKdUlHRnlaM1Z0Wlc1MGN5NXNaVzVuZEdnL0tIUm9hWE11WDNScGJXVnNhVzVsTG5OdGIyOTBhRU5vYVd4a1ZHbHRhVzVuSmlaMGFHbHpMbk4wWVhKMFZHbHRaU2gwYUdsekxsOXpkR0Z5ZEZScGJXVXJkQzEwYUdsekxsOWtaV3hoZVNrc2RHaHBjeTVmWkdWc1lYazlkQ3gwYUdsektUcDBhR2x6TGw5a1pXeGhlWDBzYmk1a2RYSmhkR2x2YmoxbWRXNWpkR2x2YmloMEtYdHlaWFIxY200Z1lYSm5kVzFsYm5SekxteGxibWQwYUQ4b2RHaHBjeTVmWkhWeVlYUnBiMjQ5ZEdocGN5NWZkRzkwWVd4RWRYSmhkR2x2YmoxMExIUm9hWE11WDNWdVkyRmphR1VvSVRBcExIUm9hWE11WDNScGJXVnNhVzVsTG5OdGIyOTBhRU5vYVd4a1ZHbHRhVzVuSmlaMGFHbHpMbDkwYVcxbFBqQW1KblJvYVhNdVgzUnBiV1U4ZEdocGN5NWZaSFZ5WVhScGIyNG1KakFoUFQxMEppWjBhR2x6TG5SdmRHRnNWR2x0WlNoMGFHbHpMbDkwYjNSaGJGUnBiV1VxS0hRdmRHaHBjeTVmWkhWeVlYUnBiMjRwTENFd0tTeDBhR2x6S1Rvb2RHaHBjeTVmWkdseWRIazlJVEVzZEdocGN5NWZaSFZ5WVhScGIyNHBmU3h1TG5SdmRHRnNSSFZ5WVhScGIyNDlablZ1WTNScGIyNG9kQ2w3Y21WMGRYSnVJSFJvYVhNdVgyUnBjblI1UFNFeExHRnlaM1Z0Wlc1MGN5NXNaVzVuZEdnL2RHaHBjeTVrZFhKaGRHbHZiaWgwS1RwMGFHbHpMbDkwYjNSaGJFUjFjbUYwYVc5dWZTeHVMblJwYldVOVpuVnVZM1JwYjI0b2RDeGxLWHR5WlhSMWNtNGdZWEpuZFcxbGJuUnpMbXhsYm1kMGFEOG9kR2hwY3k1ZlpHbHlkSGttSm5Sb2FYTXVkRzkwWVd4RWRYSmhkR2x2YmlncExIUm9hWE11ZEc5MFlXeFVhVzFsS0hRK2RHaHBjeTVmWkhWeVlYUnBiMjQvZEdocGN5NWZaSFZ5WVhScGIyNDZkQ3hsS1NrNmRHaHBjeTVmZEdsdFpYMHNiaTUwYjNSaGJGUnBiV1U5Wm5WdVkzUnBiMjRvZEN4bExHa3BlMmxtS0c5OGZHRXVkMkZyWlNncExDRmhjbWQxYldWdWRITXViR1Z1WjNSb0tYSmxkSFZ5YmlCMGFHbHpMbDkwYjNSaGJGUnBiV1U3YVdZb2RHaHBjeTVmZEdsdFpXeHBibVVwZTJsbUtEQStkQ1ltSVdrbUppaDBLejEwYUdsekxuUnZkR0ZzUkhWeVlYUnBiMjRvS1Nrc2RHaHBjeTVmZEdsdFpXeHBibVV1YzIxdmIzUm9RMmhwYkdSVWFXMXBibWNwZTNSb2FYTXVYMlJwY25SNUppWjBhR2x6TG5SdmRHRnNSSFZ5WVhScGIyNG9LVHQyWVhJZ2N6MTBhR2x6TGw5MGIzUmhiRVIxY21GMGFXOXVMSEk5ZEdocGN5NWZkR2x0Wld4cGJtVTdhV1lvZEQ1ekppWWhhU1ltS0hROWN5a3NkR2hwY3k1ZmMzUmhjblJVYVcxbFBTaDBhR2x6TGw5d1lYVnpaV1EvZEdocGN5NWZjR0YxYzJWVWFXMWxPbkl1WDNScGJXVXBMU2gwYUdsekxsOXlaWFpsY25ObFpEOXpMWFE2ZENrdmRHaHBjeTVmZEdsdFpWTmpZV3hsTEhJdVgyUnBjblI1Zkh4MGFHbHpMbDkxYm1OaFkyaGxLQ0V4S1N4eUxsOTBhVzFsYkdsdVpTbG1iM0lvTzNJdVgzUnBiV1ZzYVc1bE95bHlMbDkwYVcxbGJHbHVaUzVmZEdsdFpTRTlQU2h5TGw5emRHRnlkRlJwYldVcmNpNWZkRzkwWVd4VWFXMWxLUzl5TGw5MGFXMWxVMk5oYkdVbUpuSXVkRzkwWVd4VWFXMWxLSEl1WDNSdmRHRnNWR2x0WlN3aE1Da3NjajF5TGw5MGFXMWxiR2x1WlgxMGFHbHpMbDluWXlZbWRHaHBjeTVmWlc1aFlteGxaQ2doTUN3aE1Ta3NLSFJvYVhNdVgzUnZkR0ZzVkdsdFpTRTlQWFI4ZkRBOVBUMTBhR2x6TGw5a2RYSmhkR2x2YmlrbUppaEdMbXhsYm1kMGFDWW1VU2dwTEhSb2FYTXVjbVZ1WkdWeUtIUXNaU3doTVNrc1JpNXNaVzVuZEdnbUpsRW9LU2w5Y21WMGRYSnVJSFJvYVhOOUxHNHVjSEp2WjNKbGMzTTliaTUwYjNSaGJGQnliMmR5WlhOelBXWjFibU4wYVc5dUtIUXNaU2w3ZG1GeUlHazlkR2hwY3k1a2RYSmhkR2x2YmlncE8zSmxkSFZ5YmlCaGNtZDFiV1Z1ZEhNdWJHVnVaM1JvUDNSb2FYTXVkRzkwWVd4VWFXMWxLR2txZEN4bEtUcHBQM1JvYVhNdVgzUnBiV1V2YVRwMGFHbHpMbkpoZEdsdmZTeHVMbk4wWVhKMFZHbHRaVDFtZFc1amRHbHZiaWgwS1h0eVpYUjFjbTRnWVhKbmRXMWxiblJ6TG14bGJtZDBhRDhvZENFOVBYUm9hWE11WDNOMFlYSjBWR2x0WlNZbUtIUm9hWE11WDNOMFlYSjBWR2x0WlQxMExIUm9hWE11ZEdsdFpXeHBibVVtSm5Sb2FYTXVkR2x0Wld4cGJtVXVYM052Y25SRGFHbHNaSEpsYmlZbWRHaHBjeTUwYVcxbGJHbHVaUzVoWkdRb2RHaHBjeXgwTFhSb2FYTXVYMlJsYkdGNUtTa3NkR2hwY3lrNmRHaHBjeTVmYzNSaGNuUlVhVzFsZlN4dUxtVnVaRlJwYldVOVpuVnVZM1JwYjI0b2RDbDdjbVYwZFhKdUlIUm9hWE11WDNOMFlYSjBWR2x0WlNzb01DRTlkRDkwYUdsekxuUnZkR0ZzUkhWeVlYUnBiMjRvS1RwMGFHbHpMbVIxY21GMGFXOXVLQ2twTDNSb2FYTXVYM1JwYldWVFkyRnNaWDBzYmk1MGFXMWxVMk5oYkdVOVpuVnVZM1JwYjI0b2RDbDdhV1lvSVdGeVozVnRaVzUwY3k1c1pXNW5kR2dwY21WMGRYSnVJSFJvYVhNdVgzUnBiV1ZUWTJGc1pUdHBaaWgwUFhSOGZGOHNkR2hwY3k1ZmRHbHRaV3hwYm1VbUpuUm9hWE11WDNScGJXVnNhVzVsTG5OdGIyOTBhRU5vYVd4a1ZHbHRhVzVuS1h0MllYSWdaVDEwYUdsekxsOXdZWFZ6WlZScGJXVXNhVDFsZkh3d1BUMDlaVDlsT25Sb2FYTXVYM1JwYldWc2FXNWxMblJ2ZEdGc1ZHbHRaU2dwTzNSb2FYTXVYM04wWVhKMFZHbHRaVDFwTFNocExYUm9hWE11WDNOMFlYSjBWR2x0WlNrcWRHaHBjeTVmZEdsdFpWTmpZV3hsTDNSOWNtVjBkWEp1SUhSb2FYTXVYM1JwYldWVFkyRnNaVDEwTEhSb2FYTXVYM1Z1WTJGamFHVW9JVEVwZlN4dUxuSmxkbVZ5YzJWa1BXWjFibU4wYVc5dUtIUXBlM0psZEhWeWJpQmhjbWQxYldWdWRITXViR1Z1WjNSb1B5aDBJVDEwYUdsekxsOXlaWFpsY25ObFpDWW1LSFJvYVhNdVgzSmxkbVZ5YzJWa1BYUXNkR2hwY3k1MGIzUmhiRlJwYldVb2RHaHBjeTVmZEdsdFpXeHBibVVtSmlGMGFHbHpMbDkwYVcxbGJHbHVaUzV6Ylc5dmRHaERhR2xzWkZScGJXbHVaejkwYUdsekxuUnZkR0ZzUkhWeVlYUnBiMjRvS1MxMGFHbHpMbDkwYjNSaGJGUnBiV1U2ZEdocGN5NWZkRzkwWVd4VWFXMWxMQ0V3S1Nrc2RHaHBjeWs2ZEdocGN5NWZjbVYyWlhKelpXUjlMRzR1Y0dGMWMyVmtQV1oxYm1OMGFXOXVLSFFwZTJsbUtDRmhjbWQxYldWdWRITXViR1Z1WjNSb0tYSmxkSFZ5YmlCMGFHbHpMbDl3WVhWelpXUTdkbUZ5SUdVc2FTeHpQWFJvYVhNdVgzUnBiV1ZzYVc1bE8zSmxkSFZ5YmlCMElUMTBhR2x6TGw5d1lYVnpaV1FtSm5NbUppaHZmSHgwZkh4aExuZGhhMlVvS1N4bFBYTXVjbUYzVkdsdFpTZ3BMR2s5WlMxMGFHbHpMbDl3WVhWelpWUnBiV1VzSVhRbUpuTXVjMjF2YjNSb1EyaHBiR1JVYVcxcGJtY21KaWgwYUdsekxsOXpkR0Z5ZEZScGJXVXJQV2tzZEdocGN5NWZkVzVqWVdOb1pTZ2hNU2twTEhSb2FYTXVYM0JoZFhObFZHbHRaVDEwUDJVNmJuVnNiQ3gwYUdsekxsOXdZWFZ6WldROWRDeDBhR2x6TGw5aFkzUnBkbVU5ZEdocGN5NXBjMEZqZEdsMlpTZ3BMQ0YwSmlZd0lUMDlhU1ltZEdocGN5NWZhVzVwZEhSbFpDWW1kR2hwY3k1a2RYSmhkR2x2YmlncEppWW9aVDF6TG5OdGIyOTBhRU5vYVd4a1ZHbHRhVzVuUDNSb2FYTXVYM1J2ZEdGc1ZHbHRaVG9vWlMxMGFHbHpMbDl6ZEdGeWRGUnBiV1VwTDNSb2FYTXVYM1JwYldWVFkyRnNaU3gwYUdsekxuSmxibVJsY2lobExHVTlQVDEwYUdsekxsOTBiM1JoYkZScGJXVXNJVEFwS1Nrc2RHaHBjeTVmWjJNbUppRjBKaVowYUdsekxsOWxibUZpYkdWa0tDRXdMQ0V4S1N4MGFHbHpmVHQyWVhJZ1F6MW5LRndpWTI5eVpTNVRhVzF3YkdWVWFXMWxiR2x1WlZ3aUxHWjFibU4wYVc5dUtIUXBlMDh1WTJGc2JDaDBhR2x6TERBc2RDa3NkR2hwY3k1aGRYUnZVbVZ0YjNabFEyaHBiR1J5Wlc0OWRHaHBjeTV6Ylc5dmRHaERhR2xzWkZScGJXbHVaejBoTUgwcE8yNDlReTV3Y205MGIzUjVjR1U5Ym1WM0lFOHNiaTVqYjI1emRISjFZM1J2Y2oxRExHNHVhMmxzYkNncExsOW5ZejBoTVN4dUxsOW1hWEp6ZEQxdUxsOXNZWE4wUFc0dVgzSmxZMlZ1ZEQxdWRXeHNMRzR1WDNOdmNuUkRhR2xzWkhKbGJqMGhNU3h1TG1Ga1pEMXVMbWx1YzJWeWREMW1kVzVqZEdsdmJpaDBMR1VwZTNaaGNpQnBMSE03YVdZb2RDNWZjM1JoY25SVWFXMWxQVTUxYldKbGNpaGxmSHd3S1N0MExsOWtaV3hoZVN4MExsOXdZWFZ6WldRbUpuUm9hWE1oUFQxMExsOTBhVzFsYkdsdVpTWW1LSFF1WDNCaGRYTmxWR2x0WlQxMExsOXpkR0Z5ZEZScGJXVXJLSFJvYVhNdWNtRjNWR2x0WlNncExYUXVYM04wWVhKMFZHbHRaU2t2ZEM1ZmRHbHRaVk5qWVd4bEtTeDBMblJwYldWc2FXNWxKaVowTG5ScGJXVnNhVzVsTGw5eVpXMXZkbVVvZEN3aE1Da3NkQzUwYVcxbGJHbHVaVDEwTGw5MGFXMWxiR2x1WlQxMGFHbHpMSFF1WDJkakppWjBMbDlsYm1GaWJHVmtLQ0V3TENFd0tTeHBQWFJvYVhNdVgyeGhjM1FzZEdocGN5NWZjMjl5ZEVOb2FXeGtjbVZ1S1dadmNpaHpQWFF1WDNOMFlYSjBWR2x0WlR0cEppWnBMbDl6ZEdGeWRGUnBiV1UrY3pzcGFUMXBMbDl3Y21WMk8zSmxkSFZ5YmlCcFB5aDBMbDl1WlhoMFBXa3VYMjVsZUhRc2FTNWZibVY0ZEQxMEtUb29kQzVmYm1WNGREMTBhR2x6TGw5bWFYSnpkQ3gwYUdsekxsOW1hWEp6ZEQxMEtTeDBMbDl1WlhoMFAzUXVYMjVsZUhRdVgzQnlaWFk5ZERwMGFHbHpMbDlzWVhOMFBYUXNkQzVmY0hKbGRqMXBMSFJvYVhNdVgzSmxZMlZ1ZEQxMExIUm9hWE11WDNScGJXVnNhVzVsSmlaMGFHbHpMbDkxYm1OaFkyaGxLQ0V3S1N4MGFHbHpmU3h1TGw5eVpXMXZkbVU5Wm5WdVkzUnBiMjRvZEN4bEtYdHlaWFIxY200Z2RDNTBhVzFsYkdsdVpUMDlQWFJvYVhNbUppaGxmSHgwTGw5bGJtRmliR1ZrS0NFeExDRXdLU3gwTGw5d2NtVjJQM1F1WDNCeVpYWXVYMjVsZUhROWRDNWZibVY0ZERwMGFHbHpMbDltYVhKemREMDlQWFFtSmloMGFHbHpMbDltYVhKemREMTBMbDl1WlhoMEtTeDBMbDl1WlhoMFAzUXVYMjVsZUhRdVgzQnlaWFk5ZEM1ZmNISmxkanAwYUdsekxsOXNZWE4wUFQwOWRDWW1LSFJvYVhNdVgyeGhjM1E5ZEM1ZmNISmxkaWtzZEM1ZmJtVjRkRDEwTGw5d2NtVjJQWFF1ZEdsdFpXeHBibVU5Ym5Wc2JDeDBQVDA5ZEdocGN5NWZjbVZqWlc1MEppWW9kR2hwY3k1ZmNtVmpaVzUwUFhSb2FYTXVYMnhoYzNRcExIUm9hWE11WDNScGJXVnNhVzVsSmlaMGFHbHpMbDkxYm1OaFkyaGxLQ0V3S1Nrc2RHaHBjMzBzYmk1eVpXNWtaWEk5Wm5WdVkzUnBiMjRvZEN4bExHa3BlM1poY2lCekxISTlkR2hwY3k1ZlptbHljM1E3Wm05eUtIUm9hWE11WDNSdmRHRnNWR2x0WlQxMGFHbHpMbDkwYVcxbFBYUm9hWE11WDNKaGQxQnlaWFpVYVcxbFBYUTdjanNwY3oxeUxsOXVaWGgwTENoeUxsOWhZM1JwZG1WOGZIUStQWEl1WDNOMFlYSjBWR2x0WlNZbUlYSXVYM0JoZFhObFpDa21KaWh5TGw5eVpYWmxjbk5sWkQ5eUxuSmxibVJsY2lnb2NpNWZaR2x5ZEhrL2NpNTBiM1JoYkVSMWNtRjBhVzl1S0NrNmNpNWZkRzkwWVd4RWRYSmhkR2x2YmlrdEtIUXRjaTVmYzNSaGNuUlVhVzFsS1NweUxsOTBhVzFsVTJOaGJHVXNaU3hwS1RweUxuSmxibVJsY2lnb2RDMXlMbDl6ZEdGeWRGUnBiV1VwS25JdVgzUnBiV1ZUWTJGc1pTeGxMR2twS1N4eVBYTjlMRzR1Y21GM1ZHbHRaVDFtZFc1amRHbHZiaWdwZTNKbGRIVnliaUJ2Zkh4aExuZGhhMlVvS1N4MGFHbHpMbDkwYjNSaGJGUnBiV1Y5TzNaaGNpQkVQV2NvWENKVWQyVmxia3hwZEdWY0lpeG1kVzVqZEdsdmJpaGxMR2tzY3lsN2FXWW9UeTVqWVd4c0tIUm9hWE1zYVN4ektTeDBhR2x6TG5KbGJtUmxjajFFTG5CeWIzUnZkSGx3WlM1eVpXNWtaWElzYm5Wc2JEMDlaU2wwYUhKdmQxd2lRMkZ1Ym05MElIUjNaV1Z1SUdFZ2JuVnNiQ0IwWVhKblpYUXVYQ0k3ZEdocGN5NTBZWEpuWlhROVpUMWNJbk4wY21sdVoxd2lJVDEwZVhCbGIyWWdaVDlsT2tRdWMyVnNaV04wYjNJb1pTbDhmR1U3ZG1GeUlISXNiaXhoTEc4OVpTNXFjWFZsY25sOGZHVXViR1Z1WjNSb0ppWmxJVDA5ZENZbVpWc3dYU1ltS0dWYk1GMDlQVDEwZkh4bFd6QmRMbTV2WkdWVWVYQmxKaVpsV3pCZExuTjBlV3hsSmlZaFpTNXViMlJsVkhsd1pTa3NiRDEwYUdsekxuWmhjbk11YjNabGNuZHlhWFJsTzJsbUtIUm9hWE11WDI5MlpYSjNjbWwwWlQxc1BXNTFiR3c5UFd3L1ZsdEVMbVJsWm1GMWJIUlBkbVZ5ZDNKcGRHVmRPbHdpYm5WdFltVnlYQ0k5UFhSNWNHVnZaaUJzUDJ3K1BqQTZWbHRzWFN3b2IzeDhaU0JwYm5OMFlXNWpaVzltSUVGeWNtRjVmSHhsTG5CMWMyZ21KbVlvWlNrcEppWmNJbTUxYldKbGNsd2lJVDEwZVhCbGIyWWdaVnN3WFNsbWIzSW9kR2hwY3k1ZmRHRnlaMlYwY3oxaFBYVW9aU2tzZEdocGN5NWZjSEp2Y0V4dmIydDFjRDFiWFN4MGFHbHpMbDl6YVdKc2FXNW5jejFiWFN4eVBUQTdZUzVzWlc1bmRHZytjanR5S3lzcGJqMWhXM0pkTEc0L1hDSnpkSEpwYm1kY0lpRTlkSGx3Wlc5bUlHNC9iaTVzWlc1bmRHZ21KbTRoUFQxMEppWnVXekJkSmlZb2Jsc3dYVDA5UFhSOGZHNWJNRjB1Ym05a1pWUjVjR1VtSm01Yk1GMHVjM1I1YkdVbUppRnVMbTV2WkdWVWVYQmxLVDhvWVM1emNHeHBZMlVvY2kwdExERXBMSFJvYVhNdVgzUmhjbWRsZEhNOVlUMWhMbU52Ym1OaGRDaDFLRzRwS1NrNktIUm9hWE11WDNOcFlteHBibWR6VzNKZFBTUW9iaXgwYUdsekxDRXhLU3d4UFQwOWJDWW1kR2hwY3k1ZmMybGliR2x1WjNOYmNsMHViR1Z1WjNSb1BqRW1Ka3NvYml4MGFHbHpMRzUxYkd3c01TeDBhR2x6TGw5emFXSnNhVzVuYzF0eVhTa3BPaWh1UFdGYmNpMHRYVDFFTG5ObGJHVmpkRzl5S0c0cExGd2ljM1J5YVc1blhDSTlQWFI1Y0dWdlppQnVKaVpoTG5Od2JHbGpaU2h5S3pFc01Ta3BPbUV1YzNCc2FXTmxLSEl0TFN3eEtUdGxiSE5sSUhSb2FYTXVYM0J5YjNCTWIyOXJkWEE5ZTMwc2RHaHBjeTVmYzJsaWJHbHVaM005SkNobExIUm9hWE1zSVRFcExERTlQVDFzSmlaMGFHbHpMbDl6YVdKc2FXNW5jeTVzWlc1bmRHZytNU1ltU3lobExIUm9hWE1zYm5Wc2JDd3hMSFJvYVhNdVgzTnBZbXhwYm1kektUc29kR2hwY3k1MllYSnpMbWx0YldWa2FXRjBaVkpsYm1SbGNueDhNRDA5UFdrbUpqQTlQVDEwYUdsekxsOWtaV3hoZVNZbWRHaHBjeTUyWVhKekxtbHRiV1ZrYVdGMFpWSmxibVJsY2lFOVBTRXhLU1ltS0hSb2FYTXVYM1JwYldVOUxWOHNkR2hwY3k1eVpXNWtaWElvTFhSb2FYTXVYMlJsYkdGNUtTbDlMQ0V3S1N4TlBXWjFibU4wYVc5dUtHVXBlM0psZEhWeWJpQmxKaVpsTG14bGJtZDBhQ1ltWlNFOVBYUW1KbVZiTUYwbUppaGxXekJkUFQwOWRIeDhaVnN3WFM1dWIyUmxWSGx3WlNZbVpWc3dYUzV6ZEhsc1pTWW1JV1V1Ym05a1pWUjVjR1VwZlN4NlBXWjFibU4wYVc5dUtIUXNaU2w3ZG1GeUlHa3NjejE3ZlR0bWIzSW9hU0JwYmlCMEtYRmJhVjE4ZkdrZ2FXNGdaU1ltWENKMGNtRnVjMlp2Y20xY0lpRTlQV2ttSmx3aWVGd2lJVDA5YVNZbVhDSjVYQ0loUFQxcEppWmNJbmRwWkhSb1hDSWhQVDFwSmlaY0ltaGxhV2RvZEZ3aUlUMDlhU1ltWENKamJHRnpjMDVoYldWY0lpRTlQV2ttSmx3aVltOXlaR1Z5WENJaFBUMXBmSHdoS0NGcVcybGRmSHhxVzJsZEppWnFXMmxkTGw5aGRYUnZRMU5US1h4OEtITmJhVjA5ZEZ0cFhTeGtaV3hsZEdVZ2RGdHBYU2s3ZEM1amMzTTljMzA3YmoxRUxuQnliM1J2ZEhsd1pUMXVaWGNnVHl4dUxtTnZibk4wY25WamRHOXlQVVFzYmk1cmFXeHNLQ2t1WDJkalBTRXhMRzR1Y21GMGFXODlNQ3h1TGw5bWFYSnpkRkJVUFc0dVgzUmhjbWRsZEhNOWJpNWZiM1psY25keWFYUjBaVzVRY205d2N6MXVMbDl6ZEdGeWRFRjBQVzUxYkd3c2JpNWZibTkwYVdaNVVHeDFaMmx1YzA5bVJXNWhZbXhsWkQxdUxsOXNZWHA1UFNFeExFUXVkbVZ5YzJsdmJqMWNJakV1TVRndU1Gd2lMRVF1WkdWbVlYVnNkRVZoYzJVOWJpNWZaV0Z6WlQxdVpYY2dWQ2h1ZFd4c0xHNTFiR3dzTVN3eEtTeEVMbVJsWm1GMWJIUlBkbVZ5ZDNKcGRHVTlYQ0poZFhSdlhDSXNSQzUwYVdOclpYSTlZU3hFTG1GMWRHOVRiR1ZsY0QweE1qQXNSQzVzWVdkVGJXOXZkR2hwYm1jOVpuVnVZM1JwYjI0b2RDeGxLWHRoTG14aFoxTnRiMjkwYUdsdVp5aDBMR1VwZlN4RUxuTmxiR1ZqZEc5eVBYUXVKSHg4ZEM1cVVYVmxjbmw4ZkdaMWJtTjBhVzl1S0dVcGUzWmhjaUJwUFhRdUpIeDhkQzVxVVhWbGNuazdjbVYwZFhKdUlHay9LRVF1YzJWc1pXTjBiM0k5YVN4cEtHVXBLVHBjSW5WdVpHVm1hVzVsWkZ3aVBUMTBlWEJsYjJZZ1pHOWpkVzFsYm5RL1pUcGtiMk4xYldWdWRDNXhkV1Z5ZVZObGJHVmpkRzl5UVd4c1AyUnZZM1Z0Wlc1MExuRjFaWEo1VTJWc1pXTjBiM0pCYkd3b1pTazZaRzlqZFcxbGJuUXVaMlYwUld4bGJXVnVkRUo1U1dRb1hDSWpYQ0k5UFQxbExtTm9ZWEpCZENnd0tUOWxMbk4xWW5OMGNpZ3hLVHBsS1gwN2RtRnlJRVk5VzEwc1NUMTdmU3hGUFM4b1B6b29MWHd0UFh4Y1hDczlLVDljWEdRcVhGd3VQMXhjWkNvb1B6cGxXMXhjTFN0ZFAxeGNaQ3NwUHlsYk1DMDVYUzluYVN4T1BXWjFibU4wYVc5dUtIUXBlMlp2Y2loMllYSWdaU3hwUFhSb2FYTXVYMlpwY25OMFVGUXNjejB4WlMwMk8yazdLV1U5YVM1aWJHOWlQM1EvZEdocGN5NXFiMmx1S0Z3aVhDSXBPblJvYVhNdWMzUmhjblE2YVM1aktuUXJhUzV6TEdrdWNqOWxQVTFoZEdndWNtOTFibVFvWlNrNmN6NWxKaVpsUGkxekppWW9aVDB3S1N4cExtWS9hUzVtY0Q5cExuUmJhUzV3WFNocExtWndMR1VwT21rdWRGdHBMbkJkS0dVcE9ta3VkRnRwTG5CZFBXVXNhVDFwTGw5dVpYaDBmU3hNUFdaMWJtTjBhVzl1S0hRc1pTeHBMSE1wZTNaaGNpQnlMRzRzWVN4dkxHd3NhQ3hmTEhVOVczUXNaVjBzWXowd0xHWTlYQ0pjSWl4d1BUQTdabTl5S0hVdWMzUmhjblE5ZEN4cEppWW9hU2gxS1N4MFBYVmJNRjBzWlQxMVd6RmRLU3gxTG14bGJtZDBhRDB3TEhJOWRDNXRZWFJqYUNoRktYeDhXMTBzYmoxbExtMWhkR05vS0VVcGZIeGJYU3h6SmlZb2N5NWZibVY0ZEQxdWRXeHNMSE11WW14dllqMHhMSFV1WDJacGNuTjBVRlE5Y3lrc2JEMXVMbXhsYm1kMGFDeHZQVEE3YkQ1dk8yOHJLeWxmUFc1YmIxMHNhRDFsTG5OMVluTjBjaWhqTEdVdWFXNWtaWGhQWmloZkxHTXBMV01wTEdZclBXaDhmQ0Z2UDJnNlhDSXNYQ0lzWXlzOWFDNXNaVzVuZEdnc2NEOXdQU2h3S3pFcEpUVTZYQ0p5WjJKaEtGd2lQVDA5YUM1emRXSnpkSElvTFRVcEppWW9jRDB4S1N4ZlBUMDljbHR2WFh4OGJ6NDljaTVzWlc1bmRHZy9aaXM5WHpvb1ppWW1LSFV1Y0hWemFDaG1LU3htUFZ3aVhDSXBMR0U5Y0dGeWMyVkdiRzloZENoeVcyOWRLU3gxTG5CMWMyZ29ZU2tzZFM1ZlptbHljM1JRVkQxN1gyNWxlSFE2ZFM1ZlptbHljM1JRVkN4ME9uVXNjRHAxTG14bGJtZDBhQzB4TEhNNllTeGpPaWhjSWoxY0lqMDlQVjh1WTJoaGNrRjBLREVwUDNCaGNuTmxTVzUwS0Y4dVkyaGhja0YwS0RBcEsxd2lNVndpTERFd0tTcHdZWEp6WlVac2IyRjBLRjh1YzNWaWMzUnlLRElwS1Rwd1lYSnpaVVpzYjJGMEtGOHBMV0VwZkh3d0xHWTZNQ3h5T25BbUpqUStjSDBwTEdNclBWOHViR1Z1WjNSb08zSmxkSFZ5YmlCbUt6MWxMbk4xWW5OMGNpaGpLU3htSmlaMUxuQjFjMmdvWmlrc2RTNXpaWFJTWVhScGJ6MU9MSFY5TEZnOVpuVnVZM1JwYjI0b2RDeGxMR2tzY3l4eUxHNHNZU3h2S1h0MllYSWdiQ3hvTEY4OVhDSm5aWFJjSWowOVBXay9kRnRsWFRwcExIVTlkSGx3Wlc5bUlIUmJaVjBzWXoxY0luTjBjbWx1WjF3aVBUMTBlWEJsYjJZZ2N5WW1YQ0k5WENJOVBUMXpMbU5vWVhKQmRDZ3hLU3htUFh0ME9uUXNjRHBsTEhNNlh5eG1PbHdpWm5WdVkzUnBiMjVjSWowOVBYVXNjR2M2TUN4dU9uSjhmR1VzY2pwdUxIQnlPakFzWXpwalAzQmhjbk5sU1c1MEtITXVZMmhoY2tGMEtEQXBLMXdpTVZ3aUxERXdLU3B3WVhKelpVWnNiMkYwS0hNdWMzVmljM1J5S0RJcEtUcHdZWEp6WlVac2IyRjBLSE1wTFY5OGZEQjlPM0psZEhWeWJsd2liblZ0WW1WeVhDSWhQVDExSmlZb1hDSm1kVzVqZEdsdmJsd2lQVDA5ZFNZbVhDSm5aWFJjSWowOVBXa21KaWhvUFdVdWFXNWtaWGhQWmloY0luTmxkRndpS1h4OFhDSm1kVzVqZEdsdmJsd2lJVDEwZVhCbGIyWWdkRnRjSW1kbGRGd2lLMlV1YzNWaWMzUnlLRE1wWFQ5bE9sd2laMlYwWENJclpTNXpkV0p6ZEhJb015a3NaaTV6UFY4OVlUOTBXMmhkS0dFcE9uUmJhRjBvS1Nrc1hDSnpkSEpwYm1kY0lqMDlkSGx3Wlc5bUlGOG1KaWhoZkh4cGMwNWhUaWhmS1NrL0tHWXVabkE5WVN4c1BVd29YeXh6TEc5OGZFUXVaR1ZtWVhWc2RGTjBjbWx1WjBacGJIUmxjaXhtS1N4bVBYdDBPbXdzY0RwY0luTmxkRkpoZEdsdlhDSXNjem93TEdNNk1TeG1PaklzY0djNk1DeHVPbko4ZkdVc2NISTZNSDBwT21OOGZDaG1MbU05Y0dGeWMyVkdiRzloZENoektTMXdZWEp6WlVac2IyRjBLRjhwZkh3d0tTa3NaaTVqUHlnb1ppNWZibVY0ZEQxMGFHbHpMbDltYVhKemRGQlVLU1ltS0dZdVgyNWxlSFF1WDNCeVpYWTlaaWtzZEdocGN5NWZabWx5YzNSUVZEMW1MR1lwT25admFXUWdNSDBzUWoxRUxsOXBiblJsY201aGJITTllMmx6UVhKeVlYazZaaXhwYzFObGJHVmpkRzl5T2swc2JHRjZlVlIzWldWdWN6cEdMR0pzYjJKRWFXWTZUSDBzYWoxRUxsOXdiSFZuYVc1elBYdDlMRms5UWk1MGQyVmxia3h2YjJ0MWNEMTdmU3hWUFRBc2NUMUNMbkpsYzJWeWRtVmtVSEp2Y0hNOWUyVmhjMlU2TVN4a1pXeGhlVG94TEc5MlpYSjNjbWwwWlRveExHOXVRMjl0Y0d4bGRHVTZNU3h2YmtOdmJYQnNaWFJsVUdGeVlXMXpPakVzYjI1RGIyMXdiR1YwWlZOamIzQmxPakVzZFhObFJuSmhiV1Z6T2pFc2NuVnVRbUZqYTNkaGNtUnpPakVzYzNSaGNuUkJkRG94TEc5dVZYQmtZWFJsT2pFc2IyNVZjR1JoZEdWUVlYSmhiWE02TVN4dmJsVndaR0YwWlZOamIzQmxPakVzYjI1VGRHRnlkRG94TEc5dVUzUmhjblJRWVhKaGJYTTZNU3h2YmxOMFlYSjBVMk52Y0dVNk1TeHZibEpsZG1WeWMyVkRiMjF3YkdWMFpUb3hMRzl1VW1WMlpYSnpaVU52YlhCc1pYUmxVR0Z5WVcxek9qRXNiMjVTWlhabGNuTmxRMjl0Y0d4bGRHVlRZMjl3WlRveExHOXVVbVZ3WldGME9qRXNiMjVTWlhCbFlYUlFZWEpoYlhNNk1TeHZibEpsY0dWaGRGTmpiM0JsT2pFc1pXRnpaVkJoY21GdGN6b3hMSGx2ZVc4Nk1TeHBiVzFsWkdsaGRHVlNaVzVrWlhJNk1TeHlaWEJsWVhRNk1TeHlaWEJsWVhSRVpXeGhlVG94TEdSaGRHRTZNU3h3WVhWelpXUTZNU3h5WlhabGNuTmxaRG94TEdGMWRHOURVMU02TVN4c1lYcDVPakVzYjI1UGRtVnlkM0pwZEdVNk1TeGpZV3hzWW1GamExTmpiM0JsT2pFc2MzUnlhVzVuUm1sc2RHVnlPakY5TEZZOWUyNXZibVU2TUN4aGJHdzZNU3hoZFhSdk9qSXNZMjl1WTNWeWNtVnVkRG96TEdGc2JFOXVVM1JoY25RNk5DeHdjbVZsZUdsemRHbHVaem8xTEZ3aWRISjFaVndpT2pFc1hDSm1ZV3h6WlZ3aU9qQjlMRWM5VHk1ZmNtOXZkRVp5WVcxbGMxUnBiV1ZzYVc1bFBXNWxkeUJETEZjOVR5NWZjbTl2ZEZScGJXVnNhVzVsUFc1bGR5QkRMRm85TXpBc1VUMUNMbXhoZW5sU1pXNWtaWEk5Wm5WdVkzUnBiMjRvS1h0MllYSWdkQ3hsUFVZdWJHVnVaM1JvTzJadmNpaEpQWHQ5T3kwdFpUNHRNVHNwZEQxR1cyVmRMSFFtSm5RdVgyeGhlbmtoUFQwaE1TWW1LSFF1Y21WdVpHVnlLSFF1WDJ4aGVubGJNRjBzZEM1ZmJHRjZlVnN4WFN3aE1Da3NkQzVmYkdGNmVUMGhNU2s3Umk1c1pXNW5kR2c5TUgwN1Z5NWZjM1JoY25SVWFXMWxQV0V1ZEdsdFpTeEhMbDl6ZEdGeWRGUnBiV1U5WVM1bWNtRnRaU3hYTGw5aFkzUnBkbVU5Unk1ZllXTjBhWFpsUFNFd0xITmxkRlJwYldWdmRYUW9VU3d4S1N4UExsOTFjR1JoZEdWU2IyOTBQVVF1Y21WdVpHVnlQV1oxYm1OMGFXOXVLQ2w3ZG1GeUlIUXNaU3hwTzJsbUtFWXViR1Z1WjNSb0ppWlJLQ2tzVnk1eVpXNWtaWElvS0dFdWRHbHRaUzFYTGw5emRHRnlkRlJwYldVcEtsY3VYM1JwYldWVFkyRnNaU3doTVN3aE1Ta3NSeTV5Wlc1a1pYSW9LR0V1Wm5KaGJXVXRSeTVmYzNSaGNuUlVhVzFsS1NwSExsOTBhVzFsVTJOaGJHVXNJVEVzSVRFcExFWXViR1Z1WjNSb0ppWlJLQ2tzWVM1bWNtRnRaVDQ5V2lsN1dqMWhMbVp5WVcxbEt5aHdZWEp6WlVsdWRDaEVMbUYxZEc5VGJHVmxjQ3d4TUNsOGZERXlNQ2s3WEc1bWIzSW9hU0JwYmlCWktYdG1iM0lvWlQxWlcybGRMblIzWldWdWN5eDBQV1V1YkdWdVozUm9PeTB0ZEQ0dE1Uc3BaVnQwWFM1ZloyTW1KbVV1YzNCc2FXTmxLSFFzTVNrN01EMDlQV1V1YkdWdVozUm9KaVprWld4bGRHVWdXVnRwWFgxcFppaHBQVmN1WDJacGNuTjBMQ2doYVh4OGFTNWZjR0YxYzJWa0tTWW1SQzVoZFhSdlUyeGxaWEFtSmlGSExsOW1hWEp6ZENZbU1UMDlQV0V1WDJ4cGMzUmxibVZ5Y3k1MGFXTnJMbXhsYm1kMGFDbDdabTl5S0R0cEppWnBMbDl3WVhWelpXUTdLV2s5YVM1ZmJtVjRkRHRwZkh4aExuTnNaV1Z3S0NsOWZYMHNZUzVoWkdSRmRtVnVkRXhwYzNSbGJtVnlLRndpZEdsamExd2lMRTh1WDNWd1pHRjBaVkp2YjNRcE8zWmhjaUFrUFdaMWJtTjBhVzl1S0hRc1pTeHBLWHQyWVhJZ2N5eHlMRzQ5ZEM1ZlozTlVkMlZsYmtsRU8ybG1LRmxiYm54OEtIUXVYMmR6VkhkbFpXNUpSRDF1UFZ3aWRGd2lLMVVyS3lsZGZId29XVnR1WFQxN2RHRnlaMlYwT25Rc2RIZGxaVzV6T2x0ZGZTa3NaU1ltS0hNOVdWdHVYUzUwZDJWbGJuTXNjMXR5UFhNdWJHVnVaM1JvWFQxbExHa3BLV1p2Y2lnN0xTMXlQaTB4T3lselczSmRQVDA5WlNZbWN5NXpjR3hwWTJVb2Npd3hLVHR5WlhSMWNtNGdXVnR1WFM1MGQyVmxibk45TEVnOVpuVnVZM1JwYjI0b2RDeGxMR2tzY3lsN2RtRnlJSElzYml4aFBYUXVkbUZ5Y3k1dmJrOTJaWEozY21sMFpUdHlaWFIxY200Z1lTWW1LSEk5WVNoMExHVXNhU3h6S1Nrc1lUMUVMbTl1VDNabGNuZHlhWFJsTEdFbUppaHVQV0VvZEN4bExHa3NjeWtwTEhJaFBUMGhNU1ltYmlFOVBTRXhmU3hMUFdaMWJtTjBhVzl1S0hRc1pTeHBMSE1zY2lsN2RtRnlJRzRzWVN4dkxHdzdhV1lvTVQwOVBYTjhmSE0rUFRRcGUyWnZjaWhzUFhJdWJHVnVaM1JvTEc0OU1EdHNQbTQ3YmlzcktXbG1LQ2h2UFhKYmJsMHBJVDA5WlNsdkxsOW5ZM3g4Ynk1ZmEybHNiQ2h1ZFd4c0xIUXNaU2ttSmloaFBTRXdLVHRsYkhObElHbG1LRFU5UFQxektXSnlaV0ZyTzNKbGRIVnliaUJoZlhaaGNpQm9MSFU5WlM1ZmMzUmhjblJVYVcxbEsxOHNZejFiWFN4bVBUQXNjRDB3UFQwOVpTNWZaSFZ5WVhScGIyNDdabTl5S0c0OWNpNXNaVzVuZEdnN0xTMXVQaTB4T3lrb2J6MXlXMjVkS1QwOVBXVjhmRzh1WDJkamZIeHZMbDl3WVhWelpXUjhmQ2h2TGw5MGFXMWxiR2x1WlNFOVBXVXVYM1JwYldWc2FXNWxQeWhvUFdoOGZFb29aU3d3TEhBcExEQTlQVDFLS0c4c2FDeHdLU1ltS0dOYlppc3JYVDF2S1NrNmRUNDlieTVmYzNSaGNuUlVhVzFsSmladkxsOXpkR0Z5ZEZScGJXVXJieTUwYjNSaGJFUjFjbUYwYVc5dUtDa3ZieTVmZEdsdFpWTmpZV3hsUG5VbUppZ29jSHg4SVc4dVgybHVhWFIwWldRcEppWXlaUzB4TUQ0OWRTMXZMbDl6ZEdGeWRGUnBiV1Y4ZkNoalcyWXJLMTA5YnlrcEtUdG1iM0lvYmoxbU95MHRiajR0TVRzcGFXWW9iejFqVzI1ZExESTlQVDF6SmladkxsOXJhV3hzS0drc2RDeGxLU1ltS0dFOUlUQXBMREloUFQxemZId2hieTVmWm1seWMzUlFWQ1ltYnk1ZmFXNXBkSFJsWkNsN2FXWW9NaUU5UFhNbUppRklLRzhzWlNrcFkyOXVkR2x1ZFdVN2J5NWZaVzVoWW14bFpDZ2hNU3doTVNrbUppaGhQU0V3S1gxeVpYUjFjbTRnWVgwc1NqMW1kVzVqZEdsdmJpaDBMR1VzYVNsN1ptOXlLSFpoY2lCelBYUXVYM1JwYldWc2FXNWxMSEk5Y3k1ZmRHbHRaVk5qWVd4bExHNDlkQzVmYzNSaGNuUlVhVzFsTzNNdVgzUnBiV1ZzYVc1bE95bDdhV1lvYmlzOWN5NWZjM1JoY25SVWFXMWxMSElxUFhNdVgzUnBiV1ZUWTJGc1pTeHpMbDl3WVhWelpXUXBjbVYwZFhKdUxURXdNRHR6UFhNdVgzUnBiV1ZzYVc1bGZYSmxkSFZ5YmlCdUx6MXlMRzQrWlQ5dUxXVTZhU1ltYmowOVBXVjhmQ0YwTGw5cGJtbDBkR1ZrSmlZeUtsOCtiaTFsUDE4NktHNHJQWFF1ZEc5MFlXeEVkWEpoZEdsdmJpZ3BMM1F1WDNScGJXVlRZMkZzWlM5eUtUNWxLMTgvTURwdUxXVXRYMzA3Ymk1ZmFXNXBkRDFtZFc1amRHbHZiaWdwZTNaaGNpQjBMR1VzYVN4ekxISXNiajEwYUdsekxuWmhjbk1zWVQxMGFHbHpMbDl2ZG1WeWQzSnBkSFJsYmxCeWIzQnpMRzg5ZEdocGN5NWZaSFZ5WVhScGIyNHNiRDBoSVc0dWFXMXRaV1JwWVhSbFVtVnVaR1Z5TEdnOWJpNWxZWE5sTzJsbUtHNHVjM1JoY25SQmRDbDdkR2hwY3k1ZmMzUmhjblJCZENZbUtIUm9hWE11WDNOMFlYSjBRWFF1Y21WdVpHVnlLQzB4TENFd0tTeDBhR2x6TGw5emRHRnlkRUYwTG10cGJHd29LU2tzY2oxN2ZUdG1iM0lvY3lCcGJpQnVMbk4wWVhKMFFYUXBjbHR6WFQxdUxuTjBZWEowUVhSYmMxMDdhV1lvY2k1dmRtVnlkM0pwZEdVOUlURXNjaTVwYlcxbFpHbGhkR1ZTWlc1a1pYSTlJVEFzY2k1c1lYcDVQV3dtSm00dWJHRjZlU0U5UFNFeExISXVjM1JoY25SQmREMXlMbVJsYkdGNVBXNTFiR3dzZEdocGN5NWZjM1JoY25SQmREMUVMblJ2S0hSb2FYTXVkR0Z5WjJWMExEQXNjaWtzYkNscFppaDBhR2x6TGw5MGFXMWxQakFwZEdocGN5NWZjM1JoY25SQmREMXVkV3hzTzJWc2MyVWdhV1lvTUNFOVBXOHBjbVYwZFhKdWZXVnNjMlVnYVdZb2JpNXlkVzVDWVdOcmQyRnlaSE1tSmpBaFBUMXZLV2xtS0hSb2FYTXVYM04wWVhKMFFYUXBkR2hwY3k1ZmMzUmhjblJCZEM1eVpXNWtaWElvTFRFc0lUQXBMSFJvYVhNdVgzTjBZWEowUVhRdWEybHNiQ2dwTEhSb2FYTXVYM04wWVhKMFFYUTliblZzYkR0bGJITmxlekFoUFQxMGFHbHpMbDkwYVcxbEppWW9iRDBoTVNrc2FUMTdmVHRtYjNJb2N5QnBiaUJ1S1hGYmMxMG1KbHdpWVhWMGIwTlRVMXdpSVQwOWMzeDhLR2xiYzEwOWJsdHpYU2s3YVdZb2FTNXZkbVZ5ZDNKcGRHVTlNQ3hwTG1SaGRHRTlYQ0pwYzBaeWIyMVRkR0Z5ZEZ3aUxHa3ViR0Y2ZVQxc0ppWnVMbXhoZW5raFBUMGhNU3hwTG1sdGJXVmthV0YwWlZKbGJtUmxjajFzTEhSb2FYTXVYM04wWVhKMFFYUTlSQzUwYnloMGFHbHpMblJoY21kbGRDd3dMR2twTEd3cGUybG1LREE5UFQxMGFHbHpMbDkwYVcxbEtYSmxkSFZ5Ym4xbGJITmxJSFJvYVhNdVgzTjBZWEowUVhRdVgybHVhWFFvS1N4MGFHbHpMbDl6ZEdGeWRFRjBMbDlsYm1GaWJHVmtLQ0V4S1N4MGFHbHpMblpoY25NdWFXMXRaV1JwWVhSbFVtVnVaR1Z5SmlZb2RHaHBjeTVmYzNSaGNuUkJkRDF1ZFd4c0tYMXBaaWgwYUdsekxsOWxZWE5sUFdnOWFEOW9JR2x1YzNSaGJtTmxiMllnVkQ5b09sd2lablZ1WTNScGIyNWNJajA5ZEhsd1pXOW1JR2cvYm1WM0lGUW9hQ3h1TG1WaGMyVlFZWEpoYlhNcE9uaGJhRjE4ZkVRdVpHVm1ZWFZzZEVWaGMyVTZSQzVrWldaaGRXeDBSV0Z6WlN4dUxtVmhjMlZRWVhKaGJYTWdhVzV6ZEdGdVkyVnZaaUJCY25KaGVTWW1hQzVqYjI1bWFXY21KaWgwYUdsekxsOWxZWE5sUFdndVkyOXVabWxuTG1Gd2NHeDVLR2dzYmk1bFlYTmxVR0Z5WVcxektTa3NkR2hwY3k1ZlpXRnpaVlI1Y0dVOWRHaHBjeTVmWldGelpTNWZkSGx3WlN4MGFHbHpMbDlsWVhObFVHOTNaWEk5ZEdocGN5NWZaV0Z6WlM1ZmNHOTNaWElzZEdocGN5NWZabWx5YzNSUVZEMXVkV3hzTEhSb2FYTXVYM1JoY21kbGRITXBabTl5S0hROWRHaHBjeTVmZEdGeVoyVjBjeTVzWlc1bmRHZzdMUzEwUGkweE95bDBhR2x6TGw5cGJtbDBVSEp2Y0hNb2RHaHBjeTVmZEdGeVoyVjBjMXQwWFN4MGFHbHpMbDl3Y205d1RHOXZhM1Z3VzNSZFBYdDlMSFJvYVhNdVgzTnBZbXhwYm1kelczUmRMR0UvWVZ0MFhUcHVkV3hzS1NZbUtHVTlJVEFwTzJWc2MyVWdaVDEwYUdsekxsOXBibWwwVUhKdmNITW9kR2hwY3k1MFlYSm5aWFFzZEdocGN5NWZjSEp2Y0V4dmIydDFjQ3gwYUdsekxsOXphV0pzYVc1bmN5eGhLVHRwWmlobEppWkVMbDl2YmxCc2RXZHBia1YyWlc1MEtGd2lYMjl1U1c1cGRFRnNiRkJ5YjNCelhDSXNkR2hwY3lrc1lTWW1LSFJvYVhNdVgyWnBjbk4wVUZSOGZGd2lablZ1WTNScGIyNWNJaUU5ZEhsd1pXOW1JSFJvYVhNdWRHRnlaMlYwSmlaMGFHbHpMbDlsYm1GaWJHVmtLQ0V4TENFeEtTa3NiaTV5ZFc1Q1lXTnJkMkZ5WkhNcFptOXlLR2s5ZEdocGN5NWZabWx5YzNSUVZEdHBPeWxwTG5NclBXa3VZeXhwTG1NOUxXa3VZeXhwUFdrdVgyNWxlSFE3ZEdocGN5NWZiMjVWY0dSaGRHVTliaTV2YmxWd1pHRjBaU3gwYUdsekxsOXBibWwwZEdWa1BTRXdmU3h1TGw5cGJtbDBVSEp2Y0hNOVpuVnVZM1JwYjI0b1pTeHBMSE1zY2lsN2RtRnlJRzRzWVN4dkxHd3NhQ3hmTzJsbUtHNTFiR3c5UFdVcGNtVjBkWEp1SVRFN1NWdGxMbDluYzFSM1pXVnVTVVJkSmlaUktDa3NkR2hwY3k1MllYSnpMbU56YzN4OFpTNXpkSGxzWlNZbVpTRTlQWFFtSm1VdWJtOWtaVlI1Y0dVbUptb3VZM056SmlaMGFHbHpMblpoY25NdVlYVjBiME5UVXlFOVBTRXhKaVo2S0hSb2FYTXVkbUZ5Y3l4bEtUdG1iM0lvYmlCcGJpQjBhR2x6TG5aaGNuTXBhV1lvWHoxMGFHbHpMblpoY25OYmJsMHNjVnR1WFNsZkppWW9YeUJwYm5OMFlXNWpaVzltSUVGeWNtRjVmSHhmTG5CMWMyZ21KbVlvWHlrcEppWXRNU0U5UFY4dWFtOXBiaWhjSWx3aUtTNXBibVJsZUU5bUtGd2llM05sYkdaOVhDSXBKaVlvZEdocGN5NTJZWEp6VzI1ZFBWODlkR2hwY3k1ZmMzZGhjRk5sYkdaSmJsQmhjbUZ0Y3loZkxIUm9hWE1wS1R0bGJITmxJR2xtS0dwYmJsMG1KaWhzUFc1bGR5QnFXMjVkS1M1ZmIyNUpibWwwVkhkbFpXNG9aU3gwYUdsekxuWmhjbk5iYmwwc2RHaHBjeWtwZTJadmNpaDBhR2x6TGw5bWFYSnpkRkJVUFdnOWUxOXVaWGgwT25Sb2FYTXVYMlpwY25OMFVGUXNkRHBzTEhBNlhDSnpaWFJTWVhScGIxd2lMSE02TUN4ak9qRXNaam94TEc0NmJpeHdaem94TEhCeU9td3VYM0J5YVc5eWFYUjVmU3hoUFd3dVgyOTJaWEozY21sMFpWQnliM0J6TG14bGJtZDBhRHN0TFdFK0xURTdLV2xiYkM1ZmIzWmxjbmR5YVhSbFVISnZjSE5iWVYxZFBYUm9hWE11WDJacGNuTjBVRlE3S0d3dVgzQnlhVzl5YVhSNWZIeHNMbDl2YmtsdWFYUkJiR3hRY205d2N5a21KaWh2UFNFd0tTd29iQzVmYjI1RWFYTmhZbXhsZkh4c0xsOXZia1Z1WVdKc1pTa21KaWgwYUdsekxsOXViM1JwWm5sUWJIVm5hVzV6VDJaRmJtRmliR1ZrUFNFd0tTeG9MbDl1WlhoMEppWW9hQzVmYm1WNGRDNWZjSEpsZGoxb0tYMWxiSE5sSUdsYmJsMDlXQzVqWVd4c0tIUm9hWE1zWlN4dUxGd2laMlYwWENJc1h5eHVMREFzYm5Wc2JDeDBhR2x6TG5aaGNuTXVjM1J5YVc1blJtbHNkR1Z5S1R0eVpYUjFjbTRnY2lZbWRHaHBjeTVmYTJsc2JDaHlMR1VwUDNSb2FYTXVYMmx1YVhSUWNtOXdjeWhsTEdrc2N5eHlLVHAwYUdsekxsOXZkbVZ5ZDNKcGRHVStNU1ltZEdocGN5NWZabWx5YzNSUVZDWW1jeTVzWlc1bmRHZytNU1ltU3lobExIUm9hWE1zYVN4MGFHbHpMbDl2ZG1WeWQzSnBkR1VzY3lrL0tIUm9hWE11WDJ0cGJHd29hU3hsS1N4MGFHbHpMbDlwYm1sMFVISnZjSE1vWlN4cExITXNjaWtwT2loMGFHbHpMbDltYVhKemRGQlVKaVlvZEdocGN5NTJZWEp6TG14aGVua2hQVDBoTVNZbWRHaHBjeTVmWkhWeVlYUnBiMjU4ZkhSb2FYTXVkbUZ5Y3k1c1lYcDVKaVloZEdocGN5NWZaSFZ5WVhScGIyNHBKaVlvU1Z0bExsOW5jMVIzWldWdVNVUmRQU0V3S1N4dktYMHNiaTV5Wlc1a1pYSTlablZ1WTNScGIyNG9kQ3hsTEdrcGUzWmhjaUJ6TEhJc2JpeGhMRzg5ZEdocGN5NWZkR2x0WlN4c1BYUm9hWE11WDJSMWNtRjBhVzl1TEdnOWRHaHBjeTVmY21GM1VISmxkbFJwYldVN2FXWW9kRDQ5YkNsMGFHbHpMbDkwYjNSaGJGUnBiV1U5ZEdocGN5NWZkR2x0WlQxc0xIUm9hWE11Y21GMGFXODlkR2hwY3k1ZlpXRnpaUzVmWTJGc1kwVnVaRDkwYUdsekxsOWxZWE5sTG1kbGRGSmhkR2x2S0RFcE9qRXNkR2hwY3k1ZmNtVjJaWEp6WldSOGZDaHpQU0V3TEhJOVhDSnZia052YlhCc1pYUmxYQ0lzYVQxcGZIeDBhR2x6TGw5MGFXMWxiR2x1WlM1aGRYUnZVbVZ0YjNabFEyaHBiR1J5Wlc0cExEQTlQVDFzSmlZb2RHaHBjeTVmYVc1cGRIUmxaSHg4SVhSb2FYTXVkbUZ5Y3k1c1lYcDVmSHhwS1NZbUtIUm9hWE11WDNOMFlYSjBWR2x0WlQwOVBYUm9hWE11WDNScGJXVnNhVzVsTGw5a2RYSmhkR2x2YmlZbUtIUTlNQ2tzS0RBOVBUMTBmSHd3UG1oOGZHZzlQVDFmSmlaY0ltbHpVR0YxYzJWY0lpRTlQWFJvYVhNdVpHRjBZU2ttSm1naFBUMTBKaVlvYVQwaE1DeG9QbDhtSmloeVBWd2liMjVTWlhabGNuTmxRMjl0Y0d4bGRHVmNJaWtwTEhSb2FYTXVYM0poZDFCeVpYWlVhVzFsUFdFOUlXVjhmSFI4ZkdnOVBUMTBQM1E2WHlrN1pXeHpaU0JwWmlneFpTMDNQblFwZEdocGN5NWZkRzkwWVd4VWFXMWxQWFJvYVhNdVgzUnBiV1U5TUN4MGFHbHpMbkpoZEdsdlBYUm9hWE11WDJWaGMyVXVYMk5oYkdORmJtUS9kR2hwY3k1ZlpXRnpaUzVuWlhSU1lYUnBieWd3S1Rvd0xDZ3dJVDA5YjN4OE1EMDlQV3dtSm1nK01Da21KaWh5UFZ3aWIyNVNaWFpsY25ObFEyOXRjR3hsZEdWY0lpeHpQWFJvYVhNdVgzSmxkbVZ5YzJWa0tTd3dQblFtSmloMGFHbHpMbDloWTNScGRtVTlJVEVzTUQwOVBXd21KaWgwYUdsekxsOXBibWwwZEdWa2ZId2hkR2hwY3k1MllYSnpMbXhoZW5sOGZHa3BKaVlvYUQ0OU1DWW1LR2doUFQxZmZIeGNJbWx6VUdGMWMyVmNJaUU5UFhSb2FYTXVaR0YwWVNrbUppaHBQU0V3S1N4MGFHbHpMbDl5WVhkUWNtVjJWR2x0WlQxaFBTRmxmSHgwZkh4b1BUMDlkRDkwT2w4cEtTeDBhR2x6TGw5cGJtbDBkR1ZrZkh3b2FUMGhNQ2s3Wld4elpTQnBaaWgwYUdsekxsOTBiM1JoYkZScGJXVTlkR2hwY3k1ZmRHbHRaVDEwTEhSb2FYTXVYMlZoYzJWVWVYQmxLWHQyWVhJZ2RUMTBMMndzWXoxMGFHbHpMbDlsWVhObFZIbHdaU3htUFhSb2FYTXVYMlZoYzJWUWIzZGxjanNvTVQwOVBXTjhmRE05UFQxakppWjFQajB1TlNrbUppaDFQVEV0ZFNrc016MDlQV01tSmloMUtqMHlLU3d4UFQwOVpqOTFLajExT2pJOVBUMW1QM1VxUFhVcWRUb3pQVDA5Wmo5MUtqMTFLblVxZFRvMFBUMDlaaVltS0hVcVBYVXFkU3AxS25VcExIUm9hWE11Y21GMGFXODlNVDA5UFdNL01TMTFPakk5UFQxalAzVTZMalUrZEM5c1AzVXZNam94TFhVdk1uMWxiSE5sSUhSb2FYTXVjbUYwYVc4OWRHaHBjeTVmWldGelpTNW5aWFJTWVhScGJ5aDBMMndwTzJsbUtIUm9hWE11WDNScGJXVWhQVDF2Zkh4cEtYdHBaaWdoZEdocGN5NWZhVzVwZEhSbFpDbDdhV1lvZEdocGN5NWZhVzVwZENncExDRjBhR2x6TGw5cGJtbDBkR1ZrZkh4MGFHbHpMbDluWXlseVpYUjFjbTQ3YVdZb0lXa21KblJvYVhNdVgyWnBjbk4wVUZRbUppaDBhR2x6TG5aaGNuTXViR0Y2ZVNFOVBTRXhKaVowYUdsekxsOWtkWEpoZEdsdmJueDhkR2hwY3k1MllYSnpMbXhoZW5rbUppRjBhR2x6TGw5a2RYSmhkR2x2YmlrcGNtVjBkWEp1SUhSb2FYTXVYM1JwYldVOWRHaHBjeTVmZEc5MFlXeFVhVzFsUFc4c2RHaHBjeTVmY21GM1VISmxkbFJwYldVOWFDeEdMbkIxYzJnb2RHaHBjeWtzZEdocGN5NWZiR0Y2ZVQxYmRDeGxYU3gyYjJsa0lEQTdkR2hwY3k1ZmRHbHRaU1ltSVhNL2RHaHBjeTV5WVhScGJ6MTBhR2x6TGw5bFlYTmxMbWRsZEZKaGRHbHZLSFJvYVhNdVgzUnBiV1V2YkNrNmN5WW1kR2hwY3k1ZlpXRnpaUzVmWTJGc1kwVnVaQ1ltS0hSb2FYTXVjbUYwYVc4OWRHaHBjeTVmWldGelpTNW5aWFJTWVhScGJ5Z3dQVDA5ZEdocGN5NWZkR2x0WlQ4d09qRXBLWDFtYjNJb2RHaHBjeTVmYkdGNmVTRTlQU0V4SmlZb2RHaHBjeTVmYkdGNmVUMGhNU2tzZEdocGN5NWZZV04wYVhabGZId2hkR2hwY3k1ZmNHRjFjMlZrSmlaMGFHbHpMbDkwYVcxbElUMDlieVltZEQ0OU1DWW1LSFJvYVhNdVgyRmpkR2wyWlQwaE1Da3NNRDA5UFc4bUppaDBhR2x6TGw5emRHRnlkRUYwSmlZb2RENDlNRDkwYUdsekxsOXpkR0Z5ZEVGMExuSmxibVJsY2loMExHVXNhU2s2Y254OEtISTlYQ0pmWkhWdGJYbEhVMXdpS1Nrc2RHaHBjeTUyWVhKekxtOXVVM1JoY25RbUppZ3dJVDA5ZEdocGN5NWZkR2x0Wlh4OE1EMDlQV3dwSmlZb1pYeDhkR2hwY3k1ZlkyRnNiR0poWTJzb1hDSnZibE4wWVhKMFhDSXBLU2tzYmoxMGFHbHpMbDltYVhKemRGQlVPMjQ3S1c0dVpqOXVMblJiYmk1d1hTaHVMbU1xZEdocGN5NXlZWFJwYnl0dUxuTXBPbTR1ZEZ0dUxuQmRQVzR1WXlwMGFHbHpMbkpoZEdsdksyNHVjeXh1UFc0dVgyNWxlSFE3ZEdocGN5NWZiMjVWY0dSaGRHVW1KaWd3UG5RbUpuUm9hWE11WDNOMFlYSjBRWFFtSm5RaFBUMHRNV1V0TkNZbWRHaHBjeTVmYzNSaGNuUkJkQzV5Wlc1a1pYSW9kQ3hsTEdrcExHVjhmQ2gwYUdsekxsOTBhVzFsSVQwOWIzeDhjeWttSm5Sb2FYTXVYMk5oYkd4aVlXTnJLRndpYjI1VmNHUmhkR1ZjSWlrcExISW1KaWdoZEdocGN5NWZaMk44ZkdrcEppWW9NRDUwSmlaMGFHbHpMbDl6ZEdGeWRFRjBKaVloZEdocGN5NWZiMjVWY0dSaGRHVW1KblFoUFQwdE1XVXROQ1ltZEdocGN5NWZjM1JoY25SQmRDNXlaVzVrWlhJb2RDeGxMR2twTEhNbUppaDBhR2x6TGw5MGFXMWxiR2x1WlM1aGRYUnZVbVZ0YjNabFEyaHBiR1J5Wlc0bUpuUm9hWE11WDJWdVlXSnNaV1FvSVRFc0lURXBMSFJvYVhNdVgyRmpkR2wyWlQwaE1Ta3NJV1VtSm5Sb2FYTXVkbUZ5YzF0eVhTWW1kR2hwY3k1ZlkyRnNiR0poWTJzb2Npa3NNRDA5UFd3bUpuUm9hWE11WDNKaGQxQnlaWFpVYVcxbFBUMDlYeVltWVNFOVBWOG1KaWgwYUdsekxsOXlZWGRRY21WMlZHbHRaVDB3S1NsOWZTeHVMbDlyYVd4c1BXWjFibU4wYVc5dUtIUXNaU3hwS1h0cFppaGNJbUZzYkZ3aVBUMDlkQ1ltS0hROWJuVnNiQ2tzYm5Wc2JEMDlkQ1ltS0c1MWJHdzlQV1Y4ZkdVOVBUMTBhR2x6TG5SaGNtZGxkQ2twY21WMGRYSnVJSFJvYVhNdVgyeGhlbms5SVRFc2RHaHBjeTVmWlc1aFlteGxaQ2doTVN3aE1TazdaVDFjSW5OMGNtbHVaMXdpSVQxMGVYQmxiMllnWlQ5bGZIeDBhR2x6TGw5MFlYSm5aWFJ6Zkh4MGFHbHpMblJoY21kbGREcEVMbk5sYkdWamRHOXlLR1VwZkh4bE8zWmhjaUJ6TEhJc2JpeGhMRzhzYkN4b0xGOHNkU3hqUFdrbUpuUm9hWE11WDNScGJXVW1KbWt1WDNOMFlYSjBWR2x0WlQwOVBYUm9hWE11WDNOMFlYSjBWR2x0WlNZbWRHaHBjeTVmZEdsdFpXeHBibVU5UFQxcExsOTBhVzFsYkdsdVpUdHBaaWdvWmlobEtYeDhUU2hsS1NrbUpsd2liblZ0WW1WeVhDSWhQWFI1Y0dWdlppQmxXekJkS1dadmNpaHpQV1V1YkdWdVozUm9PeTB0Y3o0dE1Uc3BkR2hwY3k1ZmEybHNiQ2gwTEdWYmMxMHNhU2ttSmloc1BTRXdLVHRsYkhObGUybG1LSFJvYVhNdVgzUmhjbWRsZEhNcGUyWnZjaWh6UFhSb2FYTXVYM1JoY21kbGRITXViR1Z1WjNSb095MHRjejR0TVRzcGFXWW9aVDA5UFhSb2FYTXVYM1JoY21kbGRITmJjMTBwZTI4OWRHaHBjeTVmY0hKdmNFeHZiMnQxY0Z0elhYeDhlMzBzZEdocGN5NWZiM1psY25keWFYUjBaVzVRY205d2N6MTBhR2x6TGw5dmRtVnlkM0pwZEhSbGJsQnliM0J6Zkh4YlhTeHlQWFJvYVhNdVgyOTJaWEozY21sMGRHVnVVSEp2Y0hOYmMxMDlkRDkwYUdsekxsOXZkbVZ5ZDNKcGRIUmxibEJ5YjNCelczTmRmSHg3ZlRwY0ltRnNiRndpTzJKeVpXRnJmWDFsYkhObGUybG1LR1VoUFQxMGFHbHpMblJoY21kbGRDbHlaWFIxY200aE1UdHZQWFJvYVhNdVgzQnliM0JNYjI5cmRYQXNjajEwYUdsekxsOXZkbVZ5ZDNKcGRIUmxibEJ5YjNCelBYUS9kR2hwY3k1ZmIzWmxjbmR5YVhSMFpXNVFjbTl3YzN4OGUzMDZYQ0poYkd4Y0luMXBaaWh2S1h0cFppaG9QWFI4Zkc4c1h6MTBJVDA5Y2lZbVhDSmhiR3hjSWlFOVBYSW1KblFoUFQxdkppWW9YQ0p2WW1wbFkzUmNJaUU5ZEhsd1pXOW1JSFI4ZkNGMExsOTBaVzF3UzJsc2JDa3NhU1ltS0VRdWIyNVBkbVZ5ZDNKcGRHVjhmSFJvYVhNdWRtRnljeTV2Yms5MlpYSjNjbWwwWlNrcGUyWnZjaWh1SUdsdUlHZ3BiMXR1WFNZbUtIVjhmQ2gxUFZ0ZEtTeDFMbkIxYzJnb2Jpa3BPMmxtS0NoMWZId2hkQ2ttSmlGSUtIUm9hWE1zYVN4bExIVXBLWEpsZEhWeWJpRXhmV1p2Y2lodUlHbHVJR2dwS0dFOWIxdHVYU2ttSmloakppWW9ZUzVtUDJFdWRGdGhMbkJkS0dFdWN5azZZUzUwVzJFdWNGMDlZUzV6TEd3OUlUQXBMR0V1Y0djbUptRXVkQzVmYTJsc2JDaG9LU1ltS0d3OUlUQXBMR0V1Y0djbUpqQWhQVDFoTG5RdVgyOTJaWEozY21sMFpWQnliM0J6TG14bGJtZDBhSHg4S0dFdVgzQnlaWFkvWVM1ZmNISmxkaTVmYm1WNGREMWhMbDl1WlhoME9tRTlQVDEwYUdsekxsOW1hWEp6ZEZCVUppWW9kR2hwY3k1ZlptbHljM1JRVkQxaExsOXVaWGgwS1N4aExsOXVaWGgwSmlZb1lTNWZibVY0ZEM1ZmNISmxkajFoTGw5d2NtVjJLU3hoTGw5dVpYaDBQV0V1WDNCeVpYWTliblZzYkNrc1pHVnNaWFJsSUc5YmJsMHBMRjhtSmloeVcyNWRQVEVwT3lGMGFHbHpMbDltYVhKemRGQlVKaVowYUdsekxsOXBibWwwZEdWa0ppWjBhR2x6TGw5bGJtRmliR1ZrS0NFeExDRXhLWDE5Y21WMGRYSnVJR3g5TEc0dWFXNTJZV3hwWkdGMFpUMW1kVzVqZEdsdmJpZ3BlM0psZEhWeWJpQjBhR2x6TGw5dWIzUnBabmxRYkhWbmFXNXpUMlpGYm1GaWJHVmtKaVpFTGw5dmJsQnNkV2RwYmtWMlpXNTBLRndpWDI5dVJHbHpZV0pzWlZ3aUxIUm9hWE1wTEhSb2FYTXVYMlpwY25OMFVGUTlkR2hwY3k1ZmIzWmxjbmR5YVhSMFpXNVFjbTl3Y3oxMGFHbHpMbDl6ZEdGeWRFRjBQWFJvYVhNdVgyOXVWWEJrWVhSbFBXNTFiR3dzZEdocGN5NWZibTkwYVdaNVVHeDFaMmx1YzA5bVJXNWhZbXhsWkQxMGFHbHpMbDloWTNScGRtVTlkR2hwY3k1ZmJHRjZlVDBoTVN4MGFHbHpMbDl3Y205d1RHOXZhM1Z3UFhSb2FYTXVYM1JoY21kbGRITS9lMzA2VzEwc1R5NXdjbTkwYjNSNWNHVXVhVzUyWVd4cFpHRjBaUzVqWVd4c0tIUm9hWE1wTEhSb2FYTXVkbUZ5Y3k1cGJXMWxaR2xoZEdWU1pXNWtaWEltSmloMGFHbHpMbDkwYVcxbFBTMWZMSFJvYVhNdWNtVnVaR1Z5S0MxMGFHbHpMbDlrWld4aGVTa3BMSFJvYVhOOUxHNHVYMlZ1WVdKc1pXUTlablZ1WTNScGIyNG9kQ3hsS1h0cFppaHZmSHhoTG5kaGEyVW9LU3gwSmlaMGFHbHpMbDluWXlsN2RtRnlJR2tzY3oxMGFHbHpMbDkwWVhKblpYUnpPMmxtS0hNcFptOXlLR2s5Y3k1c1pXNW5kR2c3TFMxcFBpMHhPeWwwYUdsekxsOXphV0pzYVc1bmMxdHBYVDBrS0hOYmFWMHNkR2hwY3l3aE1DazdaV3h6WlNCMGFHbHpMbDl6YVdKc2FXNW5jejBrS0hSb2FYTXVkR0Z5WjJWMExIUm9hWE1zSVRBcGZYSmxkSFZ5YmlCUExuQnliM1J2ZEhsd1pTNWZaVzVoWW14bFpDNWpZV3hzS0hSb2FYTXNkQ3hsS1N4MGFHbHpMbDl1YjNScFpubFFiSFZuYVc1elQyWkZibUZpYkdWa0ppWjBhR2x6TGw5bWFYSnpkRkJVUDBRdVgyOXVVR3gxWjJsdVJYWmxiblFvZEQ5Y0lsOXZia1Z1WVdKc1pWd2lPbHdpWDI5dVJHbHpZV0pzWlZ3aUxIUm9hWE1wT2lFeGZTeEVMblJ2UFdaMWJtTjBhVzl1S0hRc1pTeHBLWHR5WlhSMWNtNGdibVYzSUVRb2RDeGxMR2twZlN4RUxtWnliMjA5Wm5WdVkzUnBiMjRvZEN4bExHa3BlM0psZEhWeWJpQnBMbkoxYmtKaFkydDNZWEprY3owaE1DeHBMbWx0YldWa2FXRjBaVkpsYm1SbGNqMHdJVDFwTG1sdGJXVmthV0YwWlZKbGJtUmxjaXh1WlhjZ1JDaDBMR1VzYVNsOUxFUXVabkp2YlZSdlBXWjFibU4wYVc5dUtIUXNaU3hwTEhNcGUzSmxkSFZ5YmlCekxuTjBZWEowUVhROWFTeHpMbWx0YldWa2FXRjBaVkpsYm1SbGNqMHdJVDF6TG1sdGJXVmthV0YwWlZKbGJtUmxjaVltTUNFOWFTNXBiVzFsWkdsaGRHVlNaVzVrWlhJc2JtVjNJRVFvZEN4bExITXBmU3hFTG1SbGJHRjVaV1JEWVd4c1BXWjFibU4wYVc5dUtIUXNaU3hwTEhNc2NpbDdjbVYwZFhKdUlHNWxkeUJFS0dVc01DeDdaR1ZzWVhrNmRDeHZia052YlhCc1pYUmxPbVVzYjI1RGIyMXdiR1YwWlZCaGNtRnRjenBwTEdOaGJHeGlZV05yVTJOdmNHVTZjeXh2YmxKbGRtVnljMlZEYjIxd2JHVjBaVHBsTEc5dVVtVjJaWEp6WlVOdmJYQnNaWFJsVUdGeVlXMXpPbWtzYVcxdFpXUnBZWFJsVW1WdVpHVnlPaUV4TEd4aGVuazZJVEVzZFhObFJuSmhiV1Z6T25Jc2IzWmxjbmR5YVhSbE9qQjlLWDBzUkM1elpYUTlablZ1WTNScGIyNG9kQ3hsS1h0eVpYUjFjbTRnYm1WM0lFUW9kQ3d3TEdVcGZTeEVMbWRsZEZSM1pXVnVjMDltUFdaMWJtTjBhVzl1S0hRc1pTbDdhV1lvYm5Wc2JEMDlkQ2x5WlhSMWNtNWJYVHQwUFZ3aWMzUnlhVzVuWENJaFBYUjVjR1Z2WmlCMFAzUTZSQzV6Wld4bFkzUnZjaWgwS1h4OGREdDJZWElnYVN4ekxISXNianRwWmlnb1ppaDBLWHg4VFNoMEtTa21KbHdpYm5WdFltVnlYQ0loUFhSNWNHVnZaaUIwV3pCZEtYdG1iM0lvYVQxMExteGxibWQwYUN4elBWdGRPeTB0YVQ0dE1Uc3BjejF6TG1OdmJtTmhkQ2hFTG1kbGRGUjNaV1Z1YzA5bUtIUmJhVjBzWlNrcE8yWnZjaWhwUFhNdWJHVnVaM1JvT3kwdGFUNHRNVHNwWm05eUtHNDljMXRwWFN4eVBXazdMUzF5UGkweE95bHVQVDA5YzF0eVhTWW1jeTV6Y0d4cFkyVW9hU3d4S1gxbGJITmxJR1p2Y2loelBTUW9kQ2t1WTI5dVkyRjBLQ2tzYVQxekxteGxibWQwYURzdExXaytMVEU3S1NoelcybGRMbDluWTN4OFpTWW1JWE5iYVYwdWFYTkJZM1JwZG1Vb0tTa21Kbk11YzNCc2FXTmxLR2tzTVNrN2NtVjBkWEp1SUhOOUxFUXVhMmxzYkZSM1pXVnVjMDltUFVRdWEybHNiRVJsYkdGNVpXUkRZV3hzYzFSdlBXWjFibU4wYVc5dUtIUXNaU3hwS1h0Y0ltOWlhbVZqZEZ3aVBUMTBlWEJsYjJZZ1pTWW1LR2s5WlN4bFBTRXhLVHRtYjNJb2RtRnlJSE05UkM1blpYUlVkMlZsYm5OUFppaDBMR1VwTEhJOWN5NXNaVzVuZEdnN0xTMXlQaTB4T3lselczSmRMbDlyYVd4c0tHa3NkQ2w5TzNaaGNpQjBaVDFuS0Z3aWNHeDFaMmx1Y3k1VWQyVmxibEJzZFdkcGJsd2lMR1oxYm1OMGFXOXVLSFFzWlNsN2RHaHBjeTVmYjNabGNuZHlhWFJsVUhKdmNITTlLSFI4ZkZ3aVhDSXBMbk53YkdsMEtGd2lMRndpS1N4MGFHbHpMbDl3Y205d1RtRnRaVDEwYUdsekxsOXZkbVZ5ZDNKcGRHVlFjbTl3YzFzd1hTeDBhR2x6TGw5d2NtbHZjbWwwZVQxbGZId3dMSFJvYVhNdVgzTjFjR1Z5UFhSbExuQnliM1J2ZEhsd1pYMHNJVEFwTzJsbUtHNDlkR1V1Y0hKdmRHOTBlWEJsTEhSbExuWmxjbk5wYjI0OVhDSXhMakU0TGpCY0lpeDBaUzVCVUVrOU1peHVMbDltYVhKemRGQlVQVzUxYkd3c2JpNWZZV1JrVkhkbFpXNDlXQ3h1TG5ObGRGSmhkR2x2UFU0c2JpNWZhMmxzYkQxbWRXNWpkR2x2YmloMEtYdDJZWElnWlN4cFBYUm9hWE11WDI5MlpYSjNjbWwwWlZCeWIzQnpMSE05ZEdocGN5NWZabWx5YzNSUVZEdHBaaWh1ZFd4c0lUMTBXM1JvYVhNdVgzQnliM0JPWVcxbFhTbDBhR2x6TGw5dmRtVnlkM0pwZEdWUWNtOXdjejFiWFR0bGJITmxJR1p2Y2lobFBXa3ViR1Z1WjNSb095MHRaVDR0TVRzcGJuVnNiQ0U5ZEZ0cFcyVmRYU1ltYVM1emNHeHBZMlVvWlN3eEtUdG1iM0lvTzNNN0tXNTFiR3doUFhSYmN5NXVYU1ltS0hNdVgyNWxlSFFtSmloekxsOXVaWGgwTGw5d2NtVjJQWE11WDNCeVpYWXBMSE11WDNCeVpYWS9LSE11WDNCeVpYWXVYMjVsZUhROWN5NWZibVY0ZEN4ekxsOXdjbVYyUFc1MWJHd3BPblJvYVhNdVgyWnBjbk4wVUZROVBUMXpKaVlvZEdocGN5NWZabWx5YzNSUVZEMXpMbDl1WlhoMEtTa3NjejF6TGw5dVpYaDBPM0psZEhWeWJpRXhmU3h1TGw5eWIzVnVaRkJ5YjNCelBXWjFibU4wYVc5dUtIUXNaU2w3Wm05eUtIWmhjaUJwUFhSb2FYTXVYMlpwY25OMFVGUTdhVHNwS0hSYmRHaHBjeTVmY0hKdmNFNWhiV1ZkZkh4dWRXeHNJVDFwTG00bUpuUmJhUzV1TG5Od2JHbDBLSFJvYVhNdVgzQnliM0JPWVcxbEsxd2lYMXdpS1M1cWIybHVLRndpWENJcFhTa21KaWhwTG5JOVpTa3NhVDFwTGw5dVpYaDBmU3hFTGw5dmJsQnNkV2RwYmtWMlpXNTBQV1oxYm1OMGFXOXVLSFFzWlNsN2RtRnlJR2tzY3l4eUxHNHNZU3h2UFdVdVgyWnBjbk4wVUZRN2FXWW9YQ0pmYjI1SmJtbDBRV3hzVUhKdmNITmNJajA5UFhRcGUyWnZjaWc3YnpzcGUyWnZjaWhoUFc4dVgyNWxlSFFzY3oxeU8zTW1Kbk11Y0hJK2J5NXdjanNwY3oxekxsOXVaWGgwT3lodkxsOXdjbVYyUFhNL2N5NWZjSEpsZGpwdUtUOXZMbDl3Y21WMkxsOXVaWGgwUFc4NmNqMXZMQ2h2TGw5dVpYaDBQWE1wUDNNdVgzQnlaWFk5YnpwdVBXOHNiejFoZlc4OVpTNWZabWx5YzNSUVZEMXlmV1p2Y2lnN2J6c3BieTV3WnlZbVhDSm1kVzVqZEdsdmJsd2lQVDEwZVhCbGIyWWdieTUwVzNSZEppWnZMblJiZEYwb0tTWW1LR2s5SVRBcExHODlieTVmYm1WNGREdHlaWFIxY200Z2FYMHNkR1V1WVdOMGFYWmhkR1U5Wm5WdVkzUnBiMjRvZENsN1ptOXlLSFpoY2lCbFBYUXViR1Z1WjNSb095MHRaVDR0TVRzcGRGdGxYUzVCVUVrOVBUMTBaUzVCVUVrbUppaHFXeWh1WlhjZ2RGdGxYU2t1WDNCeWIzQk9ZVzFsWFQxMFcyVmRLVHR5WlhSMWNtNGhNSDBzWkM1d2JIVm5hVzQ5Wm5WdVkzUnBiMjRvZENsN2FXWW9JU2gwSmlaMExuQnliM0JPWVcxbEppWjBMbWx1YVhRbUpuUXVRVkJKS1NsMGFISnZkMXdpYVd4c1pXZGhiQ0J3YkhWbmFXNGdaR1ZtYVc1cGRHbHZiaTVjSWp0MllYSWdaU3hwUFhRdWNISnZjRTVoYldVc2N6MTBMbkJ5YVc5eWFYUjVmSHd3TEhJOWRDNXZkbVZ5ZDNKcGRHVlFjbTl3Y3l4dVBYdHBibWwwT2x3aVgyOXVTVzVwZEZSM1pXVnVYQ0lzYzJWME9sd2ljMlYwVW1GMGFXOWNJaXhyYVd4c09sd2lYMnRwYkd4Y0lpeHliM1Z1WkRwY0lsOXliM1Z1WkZCeWIzQnpYQ0lzYVc1cGRFRnNiRHBjSWw5dmJrbHVhWFJCYkd4UWNtOXdjMXdpZlN4aFBXY29YQ0p3YkhWbmFXNXpMbHdpSzJrdVkyaGhja0YwS0RBcExuUnZWWEJ3WlhKRFlYTmxLQ2tyYVM1emRXSnpkSElvTVNrclhDSlFiSFZuYVc1Y0lpeG1kVzVqZEdsdmJpZ3BlM1JsTG1OaGJHd29kR2hwY3l4cExITXBMSFJvYVhNdVgyOTJaWEozY21sMFpWQnliM0J6UFhKOGZGdGRmU3gwTG1kc2IySmhiRDA5UFNFd0tTeHZQV0V1Y0hKdmRHOTBlWEJsUFc1bGR5QjBaU2hwS1R0dkxtTnZibk4wY25WamRHOXlQV0VzWVM1QlVFazlkQzVCVUVrN1ptOXlLR1VnYVc0Z2JpbGNJbVoxYm1OMGFXOXVYQ0k5UFhSNWNHVnZaaUIwVzJWZEppWW9iMXR1VzJWZFhUMTBXMlZkS1R0eVpYUjFjbTRnWVM1MlpYSnphVzl1UFhRdWRtVnljMmx2Yml4MFpTNWhZM1JwZG1GMFpTaGJZVjBwTEdGOUxITTlkQzVmWjNOUmRXVjFaU2w3Wm05eUtISTlNRHR6TG14bGJtZDBhRDV5TzNJckt5bHpXM0pkS0NrN1ptOXlLRzRnYVc0Z2NDbHdXMjVkTG1aMWJtTjhmSFF1WTI5dWMyOXNaUzVzYjJjb1hDSkhVMEZRSUdWdVkyOTFiblJsY21Wa0lHMXBjM05wYm1jZ1pHVndaVzVrWlc1amVUb2dZMjl0TG1keVpXVnVjMjlqYXk1Y0lpdHVLWDF2UFNFeGZYMG9YQ0oxYm1SbFptbHVaV1JjSWlFOWRIbHdaVzltSUcxdlpIVnNaU1ltYlc5a2RXeGxMbVY0Y0c5eWRITW1KbHdpZFc1a1pXWnBibVZrWENJaFBYUjVjR1Z2WmlCbmJHOWlZV3cvWjJ4dlltRnNPblJvYVhOOGZIZHBibVJ2ZHl4Y0lsUjNaV1Z1VFdGNFhDSXBPeUpkZlE9PSIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZSh7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxLCBoZWxwZXIsIGFsaWFzMT1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGFsaWFzMj1cImZ1bmN0aW9uXCI7XG5cbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwiaW5kZXgtaXRlbS1jb250ZW50XFxcIj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC1jb3Zlci1jb250YWluZXJcXFwiIHN0eWxlPVxcXCJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ1wiXG4gICAgKyAoKHN0YWNrMSA9ICgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuY292ZXIgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmNvdmVyIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGFsaWFzMSksKHR5cGVvZiBoZWxwZXIgPT09IGFsaWFzMiA/IGhlbHBlci5jYWxsKGRlcHRoMCx7XCJuYW1lXCI6XCJjb3ZlclwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIilcbiAgICArIFwiJyk7XFxcIj5cXG4gICAgICAgIFxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicHJvamVjdC1pbmZvcy1jb250YWluZXJcXFwiPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInByb2plY3QteWVhclxcXCI+MjAxNjwvc3Bhbj5cXG4gICAgICAgIDxoMyBjbGFzcz1cXFwicHJvamVjdC1uYW1lXFxcIj5cIlxuICAgICsgKChzdGFjazEgPSAoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnRpdGxlIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC50aXRsZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBhbGlhczEpLCh0eXBlb2YgaGVscGVyID09PSBhbGlhczIgPyBoZWxwZXIuY2FsbChkZXB0aDAse1wibmFtZVwiOlwidGl0bGVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSkgIT0gbnVsbCA/IHN0YWNrMSA6IFwiXCIpXG4gICAgKyBcIjwvaDM+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwcm9qY2V0LWRlc2NyaXB0aW9uLWNvbnRhaW5lclxcXCI+XFxuICAgICAgICAgICAgPHAgY2xhc3M9XFxcInByb2plY3QtZGVzY3JpcHRpb25cXFwiPkxvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0LCBjb25zZWN0ZXR1ciBhZGlwaXNpY2luZyBlbGl0LCBzZWQgZG8gZWl1c21vZFxcbiAgICAgICAgICAgIHRlbXBvciBpbmNpZGlkdW50IHV0IGxhYm9yZSBldCBkb2xvcmUgbWFnbmEgYWxpcXVhLiBVdCBlbmltIGFkIG1pbmltIHZlbmlhbS48L3A+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XCI7XG59LFwidXNlRGF0YVwiOnRydWV9KTtcbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZSh7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICByZXR1cm4gXCI8c3BhbiBjbGFzcz1cXFwicHJldi1hcnJvdyBpbmRleC1hcnJvdyBpbmRleC1hcnJvdy1qc1xcXCI+PC9zcGFuPlxcbjxzcGFuIGNsYXNzPVxcXCJuZXh0LWFycm93IGluZGV4LWFycm93IGluZGV4LWFycm93LWpzXFxcIj48L3NwYW4+XFxuPHVsIGNsYXNzPVxcXCJpbmRleC1saXN0IGluZGV4LWxpc3QtanNcXFwiPjwvdWw+XCI7XG59LFwidXNlRGF0YVwiOnRydWV9KTtcbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZSh7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICByZXR1cm4gXCI8ZGl2IGNsYXNzPVxcXCJyZWdpb24tbmF2XFxcIj48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJyZWdpb24tY29udGVudFxcXCI+PC9kaXY+XCI7XG59LFwidXNlRGF0YVwiOnRydWV9KTtcbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZSh7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICByZXR1cm4gXCI8aDEgY2xhc3M9XFxcIm5hbWUgdGl0bGVcXFwiPk1hcmluZSBBbW9yb3M8L2gxPlxcblxcbjx1bCBjbGFzcz1cXFwibmF2LWxpc3QgbmF2LWxpc3QtanNcXFwiPlxcbiAgICA8bGkgY2xhc3M9XFxcIm5hdi1pdGVtXFxcIj5cXG4gICAgICAgIDxoMiBjbGFzcz1cXFwicGFydC10aXRsZSB0aXRsZVxcXCI+V29yazwvaDI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzdWItbmF2LWxpc3QtY29udGFpbmVyIHdvcmstbGlzdC1qc1xcXCI+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9saT5cXG4gICAgPGxpIGNsYXNzPVxcXCJuYXYtaXRlbVxcXCI+XFxuICAgICAgICA8aDIgY2xhc3M9XFxcInBhcnQtdGl0bGUgdGl0bGVcXFwiPkFib3V0PC9oMj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInN1Yi1uYXYtbGlzdC1jb250YWluZXIgYWJvdXQtbGlzdC1qc1xcXCI+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9saT5cXG48L3VsPlwiO1xufSxcInVzZURhdGFcIjp0cnVlfSk7XG4iLCIvLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoe1wiMVwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgICB2YXIgc3RhY2sxO1xuXG4gIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcImlubmVyLXByb2plY3QtbmF2LWxpc3QtY29udGFpbmVyXFxcIj5cXG4gICAgPHVsIGNsYXNzPVxcXCJpbm5lci1wcm9qZWN0LW5hdi1saXN0XFxcIj5cXG5cIlxuICAgICsgKChzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChkZXB0aDAsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnN1YnBhcnQgOiBkZXB0aDApLHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDIsIGRhdGEsIDApLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCIgICAgPC91bD5cXG48L2Rpdj5cXG5cIjtcbn0sXCIyXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICAgIHZhciBoZWxwZXIsIGFsaWFzMT10aGlzLmVzY2FwZUV4cHJlc3Npb247XG5cbiAgcmV0dXJuIFwiICAgICAgICA8bGkgY2xhc3M9XFxcImlubmVyLXByb2plY3QtbmF2LWl0ZW1cXFwiIGRhdGEtc2x1Zz1cXFwiXCJcbiAgICArIGFsaWFzMSgoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLmtleSB8fCAoZGF0YSAmJiBkYXRhLmtleSkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJzLmhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBcImZ1bmN0aW9uXCIgPyBoZWxwZXIuY2FsbChkZXB0aDAse1wibmFtZVwiOlwia2V5XCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXG4gICAgKyBcIlxcXCI+XCJcbiAgICArIGFsaWFzMSh0aGlzLmxhbWJkYShkZXB0aDAsIGRlcHRoMCkpXG4gICAgKyBcIjwvbGk+XFxuXCI7XG59LFwiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgdmFyIHN0YWNrMSwgaGVscGVyO1xuXG4gIHJldHVybiBcIjxoMyBjbGFzcz1cXFwicHJvamVjdC1uYW1lIHN1Yi1wYXJ0LW5hbWUgc3ViLXBhcnQtbmFtZS1qc1xcXCI+XCJcbiAgICArICgoc3RhY2sxID0gKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy50aXRsZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudGl0bGUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVycy5oZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gXCJmdW5jdGlvblwiID8gaGVscGVyLmNhbGwoZGVwdGgwLHtcIm5hbWVcIjpcInRpdGxlXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpICE9IG51bGwgPyBzdGFjazEgOiBcIlwiKVxuICAgICsgXCI8L2gzPlxcblwiXG4gICAgKyAoKHN0YWNrMSA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnN1YnBhcnQgOiBkZXB0aDApLHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgxLCBkYXRhLCAwKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKSAhPSBudWxsID8gc3RhY2sxIDogXCJcIik7XG59LFwidXNlRGF0YVwiOnRydWV9KTtcbiJdfQ==
